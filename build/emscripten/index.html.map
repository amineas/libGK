{"version":3,"file":"index.html","sources":["../../src/event.c","../../src/fonts.c","../../src/gkApplication.c","../../src/gkAudio.c","../../src/gkAudioStream.c","../../src/gkAudioSystemOpenAL.c","../../src/gkDrawToImage.c","../../src/gkGeometry.c","../../src/gkGraphics.c","../../src/gkImage.c","../../src/gkImageDecoder.c","../../src/gkImageType.c","../../src/gkPlatformWeb.c","../../src/gkUtf8.c","../../src/panel.c","../../src/timer.c","../../src/tween.c","../../src/gkStream.c","../../src/gkFileStream.c","../../external/jpeg/lib/android/jcomapi.c","../../external/jpeg/lib/android/jdapimin.c","../../external/jpeg/lib/android/jdapistd.c","../../external/jpeg/lib/android/jdarith.c","../../external/jpeg/lib/android/jdatasrc.c","../../external/jpeg/lib/android/jdcoefct.c","../../external/jpeg/lib/android/jdcolor.c","../../external/jpeg/lib/android/jddctmgr.c","../../external/jpeg/lib/android/jdhuff.c","../../external/jpeg/lib/android/jdinput.c","../../external/jpeg/lib/android/jdmainct.c","../../external/jpeg/lib/android/jdmarker.c","../../external/jpeg/lib/android/jdmaster.c","../../external/jpeg/lib/android/jdmerge.c","../../external/jpeg/lib/android/jdpostct.c","../../external/jpeg/lib/android/jdsample.c","../../external/jpeg/lib/android/jerror.c","../../external/jpeg/lib/android/jidctflt.c","../../external/jpeg/lib/android/jidctfst.c","../../external/jpeg/lib/android/jidctint.c","../../external/jpeg/lib/android/jquant1.c","../../external/jpeg/lib/android/jquant2.c","../../external/jpeg/lib/android/jutils.c","../../external/jpeg/lib/android/jmemmgr.c","../../external/jpeg/lib/android/jmemansi.c","../../external/png/lib/android/png.c","../../external/png/lib/android/pngerror.c","../../external/png/lib/android/pngget.c","../../external/png/lib/android/pngmem.c","../../external/png/lib/android/pngread.c","../../external/png/lib/android/pngrio.c","../../external/png/lib/android/pngrtran.c","../../external/png/lib/android/pngrutil.c","../../external/png/lib/android/pngset.c","../../external/png/lib/android/pngtrans.c","../../external/zlib/lib/emscripten/adler32.c","../../external/zlib/lib/emscripten/crc32.c","../../external/zlib/lib/emscripten/inflate.c","../../external/zlib/lib/emscripten/inftrees.c","../../external/zlib/lib/emscripten/inffast.c","../../external/zlib/lib/emscripten/zutil.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;AAvOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAWA;AAAA;;;AAPA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;AAGA;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAFA;AAEA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAIA;AAAA;;AACA;AAIA;;AAHA;AAAA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8PA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAGA;AAAA;;AAgHA;AAAA;;AA/GA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;AAEA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;AAEA;;AAEA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;AAcA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;AAOA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA3BA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AA8BA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;AArBA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;;;;;;;AA9DA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AA9KA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuBA;AAAA;AAAA;AAAA;AACA;;AAtBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AA2NA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAkBA;AAAA;;AAfA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAoGA;;;AAlGA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;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AA;AAAA;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAMA;;;;;;;;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAYA;;AATA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAKA;AAAA;;AAHA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;;;AAGA;;;;;AAGA;AACA;AACA;;;;;;AAGA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;;;;;AC1GA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;;;;;;;;;;AAyEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BA;;AAzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;AA6EA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAEA;AAA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AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAaA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;;AAIA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAjGA;AAAA;AAAA;;;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAyEA;AAAA;;;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAiCA;AAAA;;;AAlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAgBA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA1bA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAVA;AAAA;AAAA;;AAeA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAlHA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;;AACA;;AAQA;AAAA;AAAA;AAAA;AACA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAYA;AAAA;AAAA;;AAVA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;;;;;;;;AAjHA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ACoFA;AAAA;AAAA;AAAA;AAMA;AAAA;;AAWA;;;AAVA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;AAyBA;;;;;;;;;;;;;;AAsDA;AAAA;;;;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAvNA;;;;;;;;AAwEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;ACgiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAsBA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;AAvnBA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;;AAPA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAkHA;AAAA;AAAA;AAAA;AASA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAaA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAdA;AAAA;AAAA;;AAsBA;AAAA;AAAA;AAxBA;AAAA;AAAA;;;AAkBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAaA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAIA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAwCA;AAAA;;AApCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;;;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;AA/IA;;;;;;;;;;;;;;;;;;;;AAlFA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAWA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAjBA;AAAA;AAAA;;AA+CA;AAAA;AAAA;AAjDA;AAAA;AAAA;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAgDA;AAAA;;AAPA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAIA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;AA1IA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAqTA;AAAA;AAAA;AAAA;AACA;AAOA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAuBA;AAAA;;;AAfA;AAeA;AAAA;;;AAXA;AAWA;AAAA;;;AADA;AAAA;AACA;AAAA;;;;AArCA;AAqCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AA0KA;AAAA;;AAtKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;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5HA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAQA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;AAEA;AAAA;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;A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AA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;;;;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;AAEA;AAAA;AAAA;;AAnBA;AAAA;AAAA;;;;;;;;;;;;AAuBA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;;;AAMA;AAAA;AAAA;;;;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;AAEA;AAAA;AAAA;;AAbA;AAAA;AAAA;;;;;;AA7DA;AAAA;AAAA;;;AAUA;AA+EA;AAAA;;;AA/EA;AA+EA;AAAA;;;AAvEA;AAuEA;AAAA;;;AA1DA;AA0DA;AAAA;;;AA1DA;AA0DA;AAAA;;;AAnDA;AAmDA;AAAA;;;AAnCA;AAmCA;AAAA;;;AA3BA;AA2BA;AAAA;;;AA3BA;AA2BA;AAAA;;;AApBA;AAoBA;AAAA;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAuGA;AAAA;;;;AAjGA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;;;;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;AAEA;AAAA;AAAA;;AAnBA;AAAA;AAAA;;;;;;;;;;;;AAuBA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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A;AAAA;AACA;AAAA;AAAA;;;AAFA;AAiBA;AAAA;;AAXA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1jBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA;;;;;;;;;AA4bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AApGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AA8CA;AAAA;;;AA3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;;;AARA;AAAA;AAAA;;;AAUA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAOA;AAAA;;;AALA;AAAA;AAKA;AAAA;;;AAHA;AAAA;AAGA;AAAA;;AApBA;AAAA;AAoBA;AAAA;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;;;;;;;;AA9GA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAnJA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AA2CA;;AAtCA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AA4DA;AAAA;;;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AA4DA;AAAA;;;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AA2DA;AAAA;;;AA3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AA0DA;AAAA;;;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AA0DA;AAAA;;;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;A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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuGA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;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AAA;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AApFA;AAAA;AAAA;;AAyFA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AApDA;AAAA;AAAA;;AAsDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAUA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AApFA;AAAA;AAAA;;AA2FA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAlFA;AAAA;AAAA;;AAoFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtLA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAUA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AArGA;AAAA;AAAA;;AA6GA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AA/GA;AAAA;AAAA;;AAiHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmDA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA/DA;AAAA;AAAA;;AAiEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAhDA;AAAA;AAAA;;AAkDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoCA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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A;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4DA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA5EA;AAAA;AAAA;;AA8EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAxFA;AAAA;AAAA;;AA0FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAhEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAzFA;AAAA;AAAA;;AA2FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+EA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AArGA;AAAA;AAAA;;AAuGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoFA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA5GA;AAAA;AAAA;;AA8GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmFA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA3GA;AAAA;AAAA;;AA6GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AApFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyFA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AArHA;AAAA;AAAA;;AAuHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkGA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAhIA;AAAA;AAAA;;AAkIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAUA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AArGA;AAAA;AAAA;;AA4GA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAhIA;AAAA;AAAA;;AAkIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqDA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA3GA;AAAA;AAAA;;AA6GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwCA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AArGA;AAAA;AAAA;;AAuGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAxFA;AAAA;AAAA;;AA0FA;;;;;;;;;;;;;;;;;;;;;;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A;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsGA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAnFA;AAAA;AAAA;;AAqFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqFA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA/DA;AAAA;AAAA;;AAiEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiFA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAhDA;AAAA;AAAA;;AAkDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AA5CA;AAAA;AAAA;;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAUA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;A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AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;AAAA;AAAA;AACA;AA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AA;;AADA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA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;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAqBA;;AAAA;;;;;;;;;;;;;;;;;AAzDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAnBA;AAAA;AAAA;AAAA;AAAA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;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAQA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA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AAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAoXA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkKA;AAAA;;AA/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;A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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAhBA;AAAA;AAAA;;AAqBA;AAAA;AAAA;AAAA;AAAA;;;;;;AAxSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;;AAcA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAZA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AACA;;AAIA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAA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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAxCA;AAAA;AAAA;;;;;;;;;AA+CA;AAAA;AACA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA2CA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAlBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA2BA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAhEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAwEA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAtCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAkDA;;AA1U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AAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAtCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA8CA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;ACkGA;AAAA;;;AAAA;;AAWA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAYA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ACpOA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAnBA;AAmBA;AAAA;;;;;;;;;;;;;AAWA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;;;AAKA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;AAUA;AAAA;;;AATA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AA5BA;AA4BA;AAAA;;;;;;;;;;;;;;;;;AAWA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAmBA;AAAA;;AAlBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAUA;AAAA;;AARA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;;;AApBA;AAoBA;AAAA;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsZA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;;;;;;;;;;;;;AAgLA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAjLA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAGA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAtBA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAyBA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAiKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;AAqBA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;;;;;AAPA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsQA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5eA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;AA6GA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAsDA;AAAA;;;;;;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;;;;;;;AAyQA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;AA3eA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;AA2GA;AAAA;;;;;AAAA;AAAA;;;;;;;;;AAsDA;AAAA;AAAA;AAAA;AACA;AAAA;;AAaA;AAAA;;;AAZA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AA8CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AA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AAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AA1TA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;;;;AAySA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AA/SA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;;AAgSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AAtTA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AA0SA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;A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A;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;AA0BA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AA4BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AApHA;AAAA;AAAA;AAEA;AAAA;;;AA+FA;AAAA;AAAA;AACA;AAAA;;;AAQA;AAAA;AAAA;;AAEA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AClBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAQA;AAAA;AACA;AAAA;;;AAAA","sourcesContent":["/* Copyright (c) 2012 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include <stdlib.h>\r\n#include \"gk.h\"\r\n\r\ntypedef struct gkEventListener listenerNode;\r\nstruct gkEventListener\r\n{\r\n    int type;\r\n    short priority;\r\n    gkEventListenerFunc func;\r\n    void* param;\r\n    struct gkEventListener* next;\r\n};\r\n\r\n\r\nvoid gkInitDispatcher(gkDispatcher* dispatcher)\r\n{\r\n    dispatcher->listeners = 0;\r\n}\r\n\r\nvoid gkCleanupDispatcher(gkDispatcher* dispatcher)\r\n{\r\n    if(dispatcher->listeners)\r\n    {\r\n        listenerNode* node = dispatcher->listeners, *p;\r\n        while(node)\r\n        {\r\n            node = (p = node)->next;\r\n            free(p);\r\n        }\r\n    }\r\n}\r\n\r\nvoid gkAddListener(gkDispatcherHandle pDispatcher, int type, short priority, gkEventListenerFunc func, void* param)\r\n{\r\n    gkDispatcher* dispatcher = (gkDispatcher*) pDispatcher;\r\n    listenerNode* listener = (listenerNode*)malloc(sizeof(listenerNode));\r\n    listener->type = type;\r\n    listener->priority = priority;\r\n    listener->func = func;\r\n    listener->param = param;\r\n    listener->next = 0;\r\n    gkRemoveListener(dispatcher, type, func, param);\r\n    if(dispatcher->listeners)\r\n    {\r\n        listenerNode* node, *prev = 0;\r\n        for(node = dispatcher->listeners; node; node = (prev = node)->next)\r\n        {\r\n            if(listener->priority > node->priority)\r\n            {\r\n                if(prev)\r\n                {\r\n                    prev->next = listener;\r\n                    listener->next = node;\r\n                }\r\n                else\r\n                {\r\n                    dispatcher->listeners = listener;\r\n                    listener->next = node;\r\n                }\r\n                break;\r\n            }\r\n            if(node->next == 0)\r\n            {\r\n                node->next = listener;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        dispatcher->listeners = listener;\r\n    }\r\n}\r\n\r\nvoid gkRemoveListener(gkDispatcherHandle pDispatcher, int type, gkEventListenerFunc func, void* param)\r\n{\r\n    gkDispatcher* dispatcher = (gkDispatcher*) pDispatcher;\r\n    if(dispatcher->listeners)\r\n    {\r\n        listenerNode* node, *prev = 0;\r\n        for(node = dispatcher->listeners; node; node = (prev = node)->next)\r\n        {\r\n            if(node->type == type && node->func == func && node->param == param)\r\n            {\r\n                if(prev)\r\n                {\r\n                    prev->next = node->next;\r\n                    free(node);\r\n                }\r\n                else\r\n                {\r\n                    dispatcher->listeners = node->next;\r\n                    free(node);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint gkHasListeners(gkDispatcherHandle pDispatcher, int type)\r\n{\r\n    gkDispatcher* dispatcher = (gkDispatcher*) pDispatcher;\r\n    if(dispatcher->listeners)\r\n    {\r\n        listenerNode* listener;\r\n        for(listener = (listenerNode*)dispatcher->listeners; listener; listener = listener->next)\r\n        {\r\n            if(listener->type == type) return 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nGK_BOOL gkDispatch(gkDispatcherHandle pDispatcher, gkEventHandle eventPtr)\r\n{\r\n    gkDispatcher* dispatcher = (gkDispatcher*) pDispatcher;\r\n    GK_BOOL result = GK_TRUE;\r\n    gkEvent* eventData = (gkEvent*)eventPtr;\r\n    if(dispatcher->listeners)\r\n    {\r\n        struct callNode\r\n        {\r\n            gkEventListenerFunc func;\r\n            void* param;\r\n            struct callNode* next;\r\n        };\r\n        struct callNode* callList = 0, *pnode = 0, *cnode;\r\n        listenerNode* listener;\r\n        for(listener = (listenerNode*)dispatcher->listeners; listener; listener = listener->next)\r\n        {\r\n            if(listener->type == eventData->type)\r\n            {\r\n                cnode = (struct callNode*)malloc(sizeof(struct callNode));\r\n                cnode->func = listener->func;\r\n                cnode->param = listener->param;\r\n                cnode->next = 0;\r\n                if(callList == 0)\r\n                {\r\n                    callList = cnode;\r\n                }\r\n                else\r\n                {\r\n                    pnode->next = cnode;\r\n                }\r\n                pnode = cnode;\r\n            }\r\n        }\r\n        for(cnode = callList; cnode; cnode = cnode->next)\r\n        {\r\n            if(!cnode->func(eventData, cnode->param))\r\n            {\r\n                result = GK_FALSE;\r\n                break;\r\n            }\r\n        }\r\n        while(callList)\r\n        {\r\n            callList = (cnode = callList)->next;\r\n            free(cnode);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#define GK_INTERNAL\r\n\r\n#include \"gk.h\"\r\n#include \"gk_internal.h\"\r\n\r\n#ifdef GK_USE_FONTS\r\n\r\n#include \"gkGL.h\"\r\n\r\n#include <ft2build.h>\r\n#include FT_FREETYPE_H\r\n#include FT_GLYPH_H\r\n#include FT_STROKER_H\r\n\r\nFT_Library ftlib;\r\n\r\n#define GK_FONT_TOTAL_STYLES 4\r\n\r\n#define CHAR(x)\t((uint32_t)x)\r\n\r\ngkTextFormat gkDefaultTextFormat = {\r\n\tGK_TEXT_ALIGN_LEFT,\t\t/*\talign */\r\n\tGK_TEXT_VALIGN_TOP,\t\t/*\tvalign */\r\n\tGK_FALSE,\t\t\t/*\twordWrap */\r\n\t4,\t\t\t\t/*\ttab space */\r\n\tGK_FALSE,\t\t\t/*\tunderline */\r\n\t0,\t\t\t\t/*\twidth */\r\n\t0,\t\t\t\t/*\theight\t*/\r\n\t0,\t\t\t\t/*\tstroke size\t*/\r\n\t0,\t\t\t\t/*\tline spacing */\r\n\t{1,1,1,1},\t\t\t/*\ttext color\t*/\r\n\t{0,0,0,1},\t\t\t/*\tstroke color */\r\n\tGK_FALSE\t\t\t/*\tvertical */\r\n};\r\n\r\ntypedef struct gkBBoxStruct gkBBox;\r\nstruct gkBBoxStruct{\r\n\tfloat minX;\r\n\tfloat minY;\r\n\tfloat maxX;\r\n\tfloat maxY;\r\n};\r\n\r\ngkBBox gkCreateBBox(float minx, float miny, float maxx, float maxy)\r\n{\r\n\tgkBBox r = {minx, miny, maxx, maxy};\r\n\treturn r;\r\n}\r\n\r\nvoid gkBBoxAdd(gkBBox* dst, gkBBox *src)\r\n{\r\n\tif(dst->minX > src->minX) dst->minX = src->minX;\r\n\tif(dst->minY > src->minY) dst->minY = src->minY;\r\n\tif(dst->maxX < src->maxX) dst->maxX = src->maxX;\r\n\tif(dst->maxY < src->maxY) dst->maxY = src->maxY;\r\n}\r\n\r\nvoid gkBBoxTranslate(gkBBox* dst, float tx, float ty)\r\n{\r\n\tdst->minX += tx;\r\n\tdst->maxX += tx;\r\n\tdst->minY += ty;\r\n\tdst->maxY += ty;\r\n}\r\n\r\ntypedef struct gkGlyphStruct gkGlyph;\r\nstruct gkGlyphStruct{\r\n\tint index;\r\n\tgkSize size;\r\n\tgkPoint offset;\r\n\tgkPoint advance;\r\n\tgkBBox bbox;\r\n\tuint32_t texId;\r\n\tgkRect texCoords;\r\n};\r\n\r\ntypedef struct gkGlyphSetStruct gkGlyphSet;\r\nstruct gkGlyphSetStruct{\r\n\tuint32_t texId;\r\n\tgkGlyph** glyphs;\r\n};\r\n\r\ntypedef struct gkGlyphCollectionStruct gkGlyphCollection;\r\nstruct gkGlyphCollectionStruct{\r\n\tuint16_t size;\r\n\tfloat strokeSize;\r\n\tuint16_t setBits;\r\n\tuint16_t texWidth;\r\n\tuint16_t texHeight;\r\n\tuint16_t cellWidth;\r\n\tuint16_t cellHeight;\r\n\tuint16_t glyphSetCount;\r\n\tgkGlyphSet** glyphSets;\r\n\tgkGlyphCollection* next;\r\n};\r\n\r\nstruct gkFontFaceStructEx{\r\n\tchar* fontFamily;\r\n\tuint8_t style;\r\n\t/*Extended info*/\r\n\tFT_Face ftface;\r\n\tgkGlyphCollection* collections;\r\n};\r\ntypedef struct gkFontFaceStructEx gkFontFaceEx;\r\n\r\ntypedef struct gkFontRcRefStruct gkFontRcRef;\r\nstruct gkFontRcRefStruct{\r\n\tgkFontResource* resource;\r\n\tgkFontRcRef* next;\r\n};\r\ngkFontRcRef* gkFontResources, *gkFontResourcesTop;\r\n\r\nvoid gkInitFont(gkFont* font);\r\nvoid gkDestroyFace(gkFontFaceEx* face);\r\n\r\ngkGlyphCollection* gkGetGlyphCollection(gkFont* font, float strokeSize);\r\ngkGlyphSet* gkGetGlyphSet(gkGlyphCollection* collection, int index);\r\ngkGlyph* gkGetGlyph(FT_Face face, gkGlyphCollection* collection, gkGlyphSet* set, uint32_t index);\r\n\r\nvoid gkDestroyGlyphCollection(gkGlyphCollection* collection);\r\nvoid gkDestroyGlyphSet(gkGlyphSet* set, int setSize);\r\nvoid gkDestroyGlyph(gkGlyph* glyph);\r\n\r\n/* functions */\r\n\r\nvoid gkInitFonts()\r\n{\r\n\tFT_Error err = FT_Init_FreeType(&ftlib);\r\n\tif (err) {\r\n\t\tprintf(\"GK [ERROR]: FreeType2 could not be initializeed.\\n\");\r\n\t\tgkExit();\r\n\t}\r\n\tgkFontResources = 0;\r\n\tgkFontResourcesTop = 0;\r\n}\r\n\r\nstatic void printFontResourceError(FT_Error error, char* filename)\r\n{\r\n\tif (error == FT_Err_Unknown_File_Format) {\r\n\t\tprintf(\"GK [ERROR]: Unknown File Format %s\\n\", filename);\r\n\t} else if (error == FT_Err_Cannot_Open_Resource) {\r\n\t\tprintf(\"GK [ERROR]: Cannot Open Resource %s\\n\", filename);\r\n\t} else if (error == FT_Err_Invalid_File_Format) {\r\n\t\tprintf(\"GK [ERROR]: Invalid File Format %s\\n\", filename);\r\n\t} else if (error == FT_Err_Unimplemented_Feature) {\r\n\t\tprintf(\"GK [ERROR]: Unimplemented Feature %s\\n\", filename);\r\n\t} else if (error == FT_Err_Missing_Module) {\r\n\t\tprintf(\"GK [ERROR]: Missing Module %s\\n\", filename);\r\n\t} else if (error) {\r\n\t\tprintf(\"GK [ERROR]: Could not load font resource %s\\n\", filename);\r\n\t}\r\n}\r\n\r\ngkFontResource* gkAddFontResource(char* filename)\r\n{\r\n\tFT_Face face;\r\n\tgkFontResource *resource = 0;\r\n\tgkFontRcRef* ref;\r\n\tgkFontFaceEx* f;\r\n\tint i = 0;\r\n\tFT_Error error;\r\n\tdo {\r\n\t\terror = FT_New_Face(ftlib, filename, i, &face);\r\n\t\tif (error) {\r\n\t\t\tprintFontResourceError(error, filename);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (resource == 0) {\r\n\t\t\tresource = (gkFontResource*)malloc(sizeof(gkFontResource));\r\n\t\t\tresource->numFaces = (uint8_t)face->num_faces;\r\n\t\t\tresource->faces = (gkFontFace**)calloc(face->num_faces, sizeof(gkFontFaceEx*));\r\n\t\t\tref = (gkFontRcRef*)malloc(sizeof(gkFontRcRef));\r\n\t\t\tref->resource = resource;\r\n\t\t\tref->next = 0;\r\n\t\t\tif (gkFontResources) {\r\n\t\t\t\tgkFontResourcesTop->next = ref;\r\n\t\t\t\tgkFontResourcesTop = ref;\r\n\t\t\t} else {\r\n\t\t\t\tgkFontResources = gkFontResourcesTop = ref;\r\n\t\t\t}\r\n\t\t}\r\n\t\tf = (gkFontFaceEx*)(resource->faces[i] = (gkFontFace*)malloc(sizeof(gkFontFaceEx)));\r\n\t\tf->fontFamily = face->family_name;\r\n\t\tf->style = (uint8_t)face->style_flags;\r\n\t\tf->ftface = face;\r\n\t\tf->collections = 0;\r\n\t\ti++;\r\n\t} while (i < resource->numFaces);\r\n\treturn resource;\r\n}\r\n\r\nvoid gkRemoveFontResource(gkFontResource* rc)\r\n{\r\n\tgkFontRcRef* ref = gkFontResources, *prev = 0, *p;\r\n\tgkFontFaceEx* face;\r\n\tint i;\r\n\twhile (ref) {\r\n\t\tif (ref->resource == rc) {\r\n\t\t\tp = ref;\r\n\t\t\tfor (i = 0; i < rc->numFaces; i++) {\r\n\t\t\t\tface = (gkFontFaceEx*)rc->faces[i];\r\n\t\t\t\tgkDestroyFace(face);\r\n\t\t\t}\r\n\t\t\tfree(rc->faces);\r\n\t\t\tfree(p->resource);\r\n\t\t\tif (prev) {\r\n\t\t\t\tprev->next = p->next;\r\n\t\t\t} else {\r\n\t\t\t\tgkFontResources = p->next;\r\n\t\t\t}\r\n\t\t\tref = ref->next;\r\n\t\t\tfree(p);\r\n\t\t} else {\r\n\t\t\tprev = ref;\r\n\t\t\tref = ref->next;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ngkFont* gkCreateFont(char* family, uint16_t size, uint8_t style)\r\n{\r\n\tgkFont* font;\r\n\tgkFontRcRef* p = gkFontResources;\r\n\tgkFontResource* resource;\r\n\tgkFontFaceEx* face;\r\n\tint i;\r\n\twhile (p) {\r\n\t\tresource = p->resource;\r\n\t\tfor (i = 0; i < resource->numFaces; i++) {\r\n\t\t\tface = (gkFontFaceEx*)resource->faces[i];\r\n\t\t\tif (stricmp(face->fontFamily, family) == 0 && face->style == style) {\r\n\t\t\t\tfont = (gkFont*)malloc(sizeof(gkFont));\r\n\t\t\t\tfont->face = (gkFontFace*)face;\r\n\t\t\t\tfont->size = size;\r\n\t\t\t\tgkInitFont(font);\r\n\t\t\t\treturn font;\r\n\t\t\t}\r\n\t\t}\r\n\t\tp = p->next;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid gkDestroyFont(gkFont* font)\r\n{\r\n\tfree(font);\r\n}\r\n\r\nvoid gkCleanupFonts()\r\n{\r\n\tgkFontRcRef* ref = gkFontResources, *p;\r\n\tgkFontFaceEx* face;\r\n\tint i;\r\n\twhile (ref) {\r\n\t\tp = ref;\r\n\t\tfor (i = 0; i < p->resource->numFaces; i++) {\r\n\t\t\tface = (gkFontFaceEx*)p->resource->faces[i];\r\n\t\t\tFT_Done_Face(face->ftface);\r\n\t\t\tfree(face);\r\n\t\t}\r\n\t\tfree(p->resource->faces);\r\n\t\tfree(p->resource);\r\n\t\tref = ref->next;\r\n\t\tfree(p);\r\n\t}\r\n\tgkFontResources = gkFontResourcesTop = 0;\r\n\tFT_Done_FreeType(ftlib);\r\n\tftlib = 0;\r\n}\r\n\r\nvoid gkInitFont(gkFont* font)\r\n{\r\n}\r\n\r\n\r\n/*\r\n\tGlyph caching\r\n*/\r\n\r\n#define GK_MIN_FONT_TEX_SIZE\t64\r\n#define GK_MAX_FONT_TEX_SIZE\t1024\r\n\r\nvoid gkInitGlyphCollection(gkGlyphCollection* collection, gkFont* font, float strokeSize);\r\nGK_BOOL gkTestCollection(gkGlyphCollection* collection, int glyphW, int glyphH);\r\ngkGlyph* gkMakeGlyph(FT_Face face, gkGlyphCollection* collection, gkGlyphSet* glyphSet, int index);\r\nvoid gkGetCellPos(gkGlyphCollection* collection, int index, int *x, int *y);\r\n\r\ngkGlyph* gkGetGlyph(FT_Face face, gkGlyphCollection* collection, gkGlyphSet* glyphSet, uint32_t index){\r\n\tint glyphIndex = index&(0xFF>>(8 - collection->setBits));\r\n\tgkGlyph* glyph = glyphSet->glyphs[glyphIndex];\r\n\tif(!glyph){\r\n\t\tglyph = glyphSet->glyphs[glyphIndex] = gkMakeGlyph(face, collection, glyphSet, index);\r\n\t}\r\n\treturn glyph;\r\n}\r\n\r\n\r\ngkGlyphCollection* gkGetGlyphCollection(gkFont* font, float strokeSize){\r\n\tgkFontFaceEx* face = (gkFontFaceEx*)font->face;\r\n\tgkGlyphCollection* p = face->collections;\r\n\tif(p){\r\n\t\twhile(p){\r\n\t\t\tif(p->size == font->size && p->strokeSize == strokeSize) return p;\r\n\t\t\tp = p->next;\r\n\t\t}\r\n\t}\r\n\tp = (gkGlyphCollection*)malloc(sizeof(gkGlyphCollection));\r\n\tgkInitGlyphCollection(p, (gkFont*)font, strokeSize);\r\n\tif(face->collections){\r\n\t\tp->next = face->collections;\r\n\t}\r\n\tface->collections = p;\r\n\treturn p;\r\n}\r\n\r\nvoid gkInitGlyphCollection(gkGlyphCollection* collection, gkFont* font, float strokeSize){\r\n\tint Gw, Gh;\r\n\tFT_Face face = ((gkFontFaceEx*)font->face)->ftface;\r\n\tGw = FT_MulFix(face->bbox.xMax - face->bbox.xMin, face->size->metrics.x_scale)/64 + (int)strokeSize;\r\n\tGh = FT_MulFix(face->bbox.yMax - face->bbox.yMin, face->size->metrics.y_scale)/64 + (int)strokeSize;\r\n\tcollection->glyphSets = 0;\r\n\tcollection->glyphSetCount = 0;\r\n\tcollection->size = font->size;\r\n\tcollection->strokeSize = strokeSize;\r\n\tcollection->next = 0;\r\n\tcollection->setBits = 8;\r\n\tcollection->texWidth = GK_MIN_FONT_TEX_SIZE;\r\n\tcollection->texHeight = GK_MIN_FONT_TEX_SIZE;\r\n\tcollection->cellWidth = Gw;\r\n\tcollection->cellHeight = Gh;\r\n\twhile(!gkTestCollection(collection, Gw, Gh)){\r\n\t\tif(collection->texWidth<GK_MAX_FONT_TEX_SIZE){\r\n\t\t\tcollection->texWidth <<=1;\r\n\t\t}else if(collection->texHeight<GK_MAX_FONT_TEX_SIZE){\r\n\t\t\tcollection->texWidth = GK_MIN_FONT_TEX_SIZE;\r\n\t\t\tcollection->texHeight <<=1;\r\n\t\t}else if(collection->setBits>1){\r\n\t\t\tcollection->setBits--;\r\n\t\t\tcollection->texWidth = collection->texHeight = GK_MIN_FONT_TEX_SIZE;\r\n\t\t}else{\r\n\t\t\tprintf(\"GK [ERROR]: font error\\n\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nGK_BOOL gkTestCollection(gkGlyphCollection* collection, int glyphW, int glyphH){\r\n\tint setSize = 0xFF>>(8 - collection->setBits);\r\n\tint glyphsPerRow = collection->texWidth / glyphW;\r\n\tif(glyphsPerRow>0){\r\n\t\tint rows = setSize / glyphsPerRow;\r\n\t\treturn rows * glyphH <= collection->texHeight;\r\n\t}else{\r\n\t\treturn GK_FALSE;\r\n\t}\r\n}\r\n\r\ngkGlyphSet* gkGetGlyphSet(gkGlyphCollection* collection, int index){\r\n\tgkGlyphSet* glyphSet;\r\n\tint setIndex = index>>collection->setBits;\r\n\tif(setIndex >= collection->glyphSetCount){\r\n\t\tint newSetCount = setIndex + 1;\r\n\t\tcollection->glyphSets = (gkGlyphSet**)realloc(collection->glyphSets, newSetCount*sizeof(gkGlyphSet*));\r\n\t\tmemset(collection->glyphSets + collection->glyphSetCount, 0, (newSetCount - collection->glyphSetCount)*sizeof(gkGlyphSet*));\r\n\t\tcollection->glyphSetCount = newSetCount;\r\n\t}\r\n\tif(collection->glyphSets[setIndex] == 0){\r\n\t\tint setSize = (0xFF>>(8 - collection->setBits)) + 1;\r\n\t\tint w = collection->texWidth, h = collection->texHeight;\r\n\t\tsize_t tmpSize = (w*h)*4;\r\n\t\tchar* tmp = (char*)malloc(tmpSize); // nasty, can't put 0 in WebGL's glTexImage2D\r\n\t\tmemset(tmp, 0, tmpSize);\r\n\t\tglyphSet = (gkGlyphSet*)malloc(sizeof(gkGlyphSet));\r\n\t\tglGenTextures(1, &glyphSet->texId);\r\n\t\tglBindTexture(GL_TEXTURE_2D, glyphSet->texId);\r\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, tmp);\r\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\r\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\r\n\t\tfree(tmp);\r\n\t\tglyphSet->glyphs = (gkGlyph**)calloc(setSize, sizeof(gkGlyph*));\r\n\t\tmemset(glyphSet->glyphs, 0, setSize*sizeof(gkGlyph*));\r\n\t\tcollection->glyphSets[setIndex] = glyphSet;\r\n\t}else{\r\n\t\tglyphSet = collection->glyphSets[setIndex];\r\n\t}\r\n\treturn glyphSet;\r\n}\r\n\r\nvoid gkGetCellPos(gkGlyphCollection* collection, int index, int *x, int *y){\r\n\tint glyphIndex = index&(0xFF>>(8 - collection->setBits));\r\n\tint cols = (collection->texWidth/collection->cellWidth);\r\n\tint column = glyphIndex % cols;\r\n\tint row = glyphIndex / cols;\r\n\t*x = column*collection->cellWidth;\r\n\t*y = row*collection->cellHeight;\r\n}\r\n\r\nstatic void printGlyphError(FT_Error error)\r\n{\r\n\tif (error == FT_Err_Invalid_Glyph_Index) {\r\n\t\tprintf(\"GK [ERROR]: Invalid Glyph Index\\n\");\r\n\t} else if(error == FT_Err_Cannot_Render_Glyph) {\r\n\t\tprintf(\"GK [ERROR]: Cannot Render Glyph\\n\");\r\n\t}\r\n}\r\n\r\ngkGlyph* gkMakeGlyph(FT_Face face, gkGlyphCollection* collection, gkGlyphSet* glyphSet, int index){\r\n\tgkGlyph* glyph;\r\n\tFT_GlyphSlot slot = face->glyph;\r\n\tFT_BBox cbox;\r\n\tFT_Glyph ftglyph;\r\n\tFT_Stroker stroker;\r\n\tFT_BitmapGlyph bglyph;\r\n\tFT_Error error;\r\n\tuint8_t *buf, *pbuf;\r\n\tint r, tr, tx, ty;\r\n\tfloat texWidth = (float)collection->texWidth, texHeight = (float)collection->texHeight;\r\n\r\n\tif(collection->strokeSize == 0){\r\n\r\n\t\terror = FT_Load_Glyph(face, index, FT_LOAD_DEFAULT);\r\n\t\tif (error) {\r\n\t\t\tprintGlyphError(error);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\terror = FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);;\r\n\t\tif (error) {\r\n\t\t\tprintGlyphError(error);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tglyph = (gkGlyph*)malloc(sizeof(gkGlyph));\r\n\r\n\t\tpbuf = buf = (uint8_t*)malloc(slot->bitmap.width*slot->bitmap.rows*4*sizeof(uint8_t));\r\n\t\tfor(r = 0; r<slot->bitmap.rows; r++){\r\n\t\t\tuint8_t *bmp = slot->bitmap.buffer + r*slot->bitmap.pitch;\r\n\t\t\tpbuf = buf + r*slot->bitmap.width*4;\r\n\t\t\tfor(tr = 0; tr<slot->bitmap.width; tr++){\r\n\t\t\t\t*pbuf++ = 0xFF;\r\n\t\t\t\t*pbuf++ = 0xFF;\r\n\t\t\t\t*pbuf++ = 0xFF;\r\n\t\t\t\t*pbuf++ = *bmp++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tglyph->size.width = (float)slot->bitmap.width;\r\n\t\tglyph->size.height = (float)slot->bitmap.rows;\r\n\r\n\t\tglyph->offset.x = (float)slot->bitmap_left;\r\n\t\tglyph->offset.y = (float)slot->bitmap_top;\r\n\r\n\t\tglyph->advance.x = ((float)slot->metrics.horiAdvance)/64.0f;\r\n\t\tglyph->advance.y = ((float)slot->metrics.vertAdvance)/64.0f;\r\n\r\n\t\tFT_Get_Glyph(slot, &ftglyph);\r\n\t\tFT_Glyph_Get_CBox(ftglyph, ft_glyph_bbox_pixels, &cbox);\r\n\t\tFT_Done_Glyph(ftglyph);\r\n\r\n\t\tglyph->bbox = gkCreateBBox((float)(cbox.xMin), (float)(-cbox.yMax), (float)(cbox.xMax), (float)(-cbox.yMin));\r\n\r\n\t\tglyph->texId = glyphSet->texId;\r\n\r\n\t\tgkGetCellPos(collection, index, &tx, &ty);\r\n\r\n\t\tglBindTexture(GL_TEXTURE_2D, glyphSet->texId);\r\n\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, tx, ty, slot->bitmap.width, slot->bitmap.rows, GL_RGBA, GL_UNSIGNED_BYTE, buf);\r\n\r\n\t\tglyph->texCoords.x = (float)tx/texWidth;\r\n\t\tglyph->texCoords.y = (float)ty/texHeight;\r\n\t\tglyph->texCoords.width = (float)(tx + slot->bitmap.width)/texWidth - glyph->texCoords.x;\r\n\t\tglyph->texCoords.height = (float)(ty + slot->bitmap.rows)/texHeight - glyph->texCoords.y;\r\n\t\tfree(buf);\r\n\r\n\t}else{\r\n\t\tif(FT_Load_Glyph(face, index, FT_LOAD_DEFAULT)) return 0;\r\n\r\n\t\tFT_Stroker_New(ftlib, &stroker);\r\n\t\tFT_Stroker_Set(stroker, (FT_Fixed)(collection->strokeSize*16.0f), FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);\r\n\r\n\t\tFT_Get_Glyph(slot, &ftglyph);\r\n\t\tif(FT_Glyph_Stroke(&ftglyph, stroker, GK_TRUE) != 0){\r\n\t\t\tFT_Done_Glyph(ftglyph);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tFT_Glyph_To_Bitmap(&ftglyph, FT_RENDER_MODE_NORMAL, 0, 1);\r\n\t\tbglyph = (FT_BitmapGlyph)ftglyph;\r\n\r\n\t\tglyph = (gkGlyph*)malloc(sizeof(gkGlyph));\r\n\r\n\t\tpbuf = buf = (uint8_t*)malloc(bglyph->bitmap.width*bglyph->bitmap.rows*4*sizeof(uint8_t));\r\n\t\tfor(r = 0; r<bglyph->bitmap.rows; r++){\r\n\t\t\tuint8_t *bmp = bglyph->bitmap.buffer + r*bglyph->bitmap.pitch;\r\n\t\t\tpbuf = buf + r*bglyph->bitmap.width*4;\r\n\t\t\tfor(tr = 0; tr<bglyph->bitmap.width; tr++){\r\n\t\t\t\t*pbuf++ = 0xFF;\r\n\t\t\t\t*pbuf++ = 0xFF;\r\n\t\t\t\t*pbuf++ = 0xFF;\r\n\t\t\t\t*pbuf++ = *bmp++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tglyph->size.width = (float)bglyph->bitmap.width;\r\n\t\tglyph->size.height = (float)bglyph->bitmap.rows;\r\n\r\n\t\tglyph->offset.x = (float)bglyph->left;\r\n\t\tglyph->offset.y = (float)bglyph->top;\r\n\r\n\t\tglyph->advance.x = ((float)slot->metrics.horiAdvance)/64.0f;\r\n\t\tglyph->advance.y = ((float)slot->metrics.vertAdvance)/64.0f;\r\n\r\n\t\tglyph->texId = glyphSet->texId;\r\n\r\n\t\tgkGetCellPos(collection, index, &tx, &ty);\r\n\r\n\t\tglBindTexture(GL_TEXTURE_2D, glyphSet->texId);\r\n\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, tx, ty, bglyph->bitmap.width, bglyph->bitmap.rows, GL_RGBA, GL_UNSIGNED_BYTE, buf);\r\n\r\n\t\tglyph->texCoords.x = (float)tx/texWidth;\r\n\t\tglyph->texCoords.y = (float)ty/texHeight;\r\n\t\tglyph->texCoords.width = (float)(tx + bglyph->bitmap.width)/texWidth - glyph->texCoords.x;\r\n\t\tglyph->texCoords.height = (float)(ty + bglyph->bitmap.rows)/texHeight - glyph->texCoords.y;\r\n\r\n\t\tfree(buf);\r\n\t}\r\n\tglyph->index = index;\r\n\treturn glyph;\r\n}\r\n\r\nvoid gkDestroyFace(gkFontFaceEx* face){\r\n\tgkGlyphCollection* p = face->collections, *r;\r\n\twhile(p){\r\n\t\tp = (r = p)->next;\r\n\t\tgkDestroyGlyphCollection(r);\r\n\t}\r\n\tFT_Done_Face(face->ftface);\r\n\tfree(face);\r\n}\r\n\r\nvoid gkDestroyGlyphCollection(gkGlyphCollection* collection){\r\n\tint i;\r\n\tint setSize = 0xFF>>(8 - collection->setBits);\r\n\tfor(i = 0; i<collection->glyphSetCount; i++){\r\n\t\tgkGlyphSet* set = collection->glyphSets[i];\r\n\t\tif(set) gkDestroyGlyphSet(set, setSize);\r\n\t}\r\n\tfree(collection->glyphSets);\r\n\tfree(collection);\r\n}\r\n\r\nvoid gkDestroyGlyphSet(gkGlyphSet* set, int setSize){\r\n\tint i;\r\n\tfor(i = 0; i<setSize; i++){\r\n\t\tif(set->glyphs[i]) free(set->glyphs[i]);\r\n\t}\r\n\tfree(set->glyphs);\r\n\tglDeleteTextures(1, &set->texId);\r\n\tfree(set);\r\n}\r\n\r\n/*\r\n\tDrawing and measuring\r\n*/\r\n\r\ntypedef struct gkSentenceElementStruct gkSentenceElement;\r\nstruct gkSentenceElementStruct{\r\n\tuint8_t type;\r\n\tgkPoint advance;\r\n\tgkBBox bbox;\r\n\tgkGlyph** glyphStart;\r\n\tgkGlyph** glyphEnd;\r\n\tgkGlyph** strokeStart;\r\n\tgkGlyph** strokeEnd;\r\n\tgkSentenceElement* next;\r\n};\r\ntypedef struct gkSentenceLineStruct gkSentenceLine;\r\nstruct gkSentenceLineStruct{\r\n\tgkSentenceElement* first;\r\n\tgkSentenceElement* last;\r\n\tgkBBox bbox;\r\n\tgkSentenceLine* next;\r\n};\r\n\r\n#define GK_SE_WORD\t\t0\r\n#define GK_SE_TAB\t\t1\r\n#define GK_SE_SPACE\t\t2\r\n#define GK_SE_NEWLINE\t3\r\n\r\ngkSentenceElement* gkParseSentenceElements(gkFont* font, char* text, gkTextFormat* format);\r\nvoid gkFreeSentenceElements(gkSentenceElement* elements);\r\ngkSentenceLine* gkParseSentenceLines(gkSentenceElement* elements, gkTextFormat* format);\r\nvoid gkFreeSentenceLines(gkSentenceLine* lines);\r\ngkBBox gkGetTextBBox(gkSentenceLine* lines, gkTextFormat* format, float leading);\r\ngkPoint gkAlignLine(gkSentenceLine* line, gkTextFormat* format, gkBBox* textBBox);\r\ngkPoint gkDrawSentenceLine(FT_Face face, gkSentenceLine* line, gkTextFormat* format);\r\n\r\ngkSize gkMeasureText(gkFont* font, char* text, gkTextFormat* format)\r\n{\r\n\tFT_Face face = ((gkFontFaceEx*)font->face)->ftface;\r\n\tgkSentenceElement* elements;\r\n\tgkSentenceLine* lines;\r\n\tfloat oldTextFormatWidth;\r\n\tgkBBox textBBox;\r\n\r\n\tif(format == 0)\r\n        format = &gkDefaultTextFormat;\r\n\r\n\toldTextFormatWidth = format->width;\r\n\tif(elements = gkParseSentenceElements(font, text, format))\r\n    {\r\n\t\tfloat leading = ((float)face->size->metrics.height)/64.0f + format->lineSpacing;\r\n\t\tlines = gkParseSentenceLines(elements, format);\r\n\t\ttextBBox = gkGetTextBBox(lines, format, leading);\r\n\t\tgkFreeSentenceLines(lines);\r\n\t\tgkFreeSentenceElements(elements);\r\n\t}else{\r\n\t    textBBox.minX = textBBox.maxX = 0;\r\n\t    textBBox.minY = textBBox.maxY = 0;\r\n\t}\r\n\tformat->width = oldTextFormatWidth;\r\n\treturn GK_SIZE(textBBox.maxX - textBBox.minX, textBBox.maxY - textBBox.minY);\r\n}\r\n\r\nvoid gkDrawText(gkFont* font, char* text, float x, float y, gkTextFormat* format){\r\n\tFT_Face face = ((gkFontFaceEx*)font->face)->ftface;\r\n\tgkSentenceElement* elements;\r\n\tgkSentenceLine* lines, *currentLine;\r\n\tfloat oldTextFormatWidth;\r\n\tif(format == 0) format = &gkDefaultTextFormat;\r\n\toldTextFormatWidth = format->width;\r\n\tif(elements = gkParseSentenceElements(font, text, format)){\r\n\t\tgkPoint align;\r\n\t\tfloat tx = x, ty = y;\r\n\t\tfloat leading = ((float)face->size->metrics.height)/64.0f + format->lineSpacing;\r\n\t\tgkBBox textBBox;\r\n\t\tcurrentLine = lines = gkParseSentenceLines(elements, format);\r\n\t\ttextBBox = gkGetTextBBox(lines, format, leading);\r\n\t\twhile(currentLine){\r\n\t\t\tglPushMatrix();\r\n\t\t\talign = gkAlignLine(currentLine, format, &textBBox);\r\n\t\t\tglTranslatef(tx + align.x,ty + align.y,0);\r\n\t\t\tgkDrawSentenceLine(face, currentLine, format);\r\n\t\t\tglPopMatrix();\r\n\t\t\tcurrentLine = currentLine->next;\r\n\t\t\tif(format->vertical){\r\n\t\t\t\ttx -= leading;\r\n\t\t\t}else{\r\n\t\t\t\tty += leading;\r\n\t\t\t}\r\n\t\t}\r\n\t\tgkFreeSentenceLines(lines);\r\n\t\tgkFreeSentenceElements(elements);\r\n\t}\r\n\tformat->width = oldTextFormatWidth;\r\n}\r\n\r\ngkSentenceElement* gkParseSentenceElements(gkFont* font, char* text, gkTextFormat* format){\r\n\tFT_Face face = ((gkFontFaceEx*)font->face)->ftface;\r\n\tGK_BOOL hasKerning = FT_HAS_KERNING(face);\r\n\r\n\tsize_t totalGlyphs = 0, currentGlyph = 0;\r\n\tgkGlyph** glyphs, **strokes = 0;\r\n\tgkGlyphCollection* collection, *strokeCollection;\r\n\tgkSentenceElement* firstElement = 0, *lastElement = firstElement, *currentElement = 0;\r\n\r\n\tchar* str;\r\n\tuint32_t c, lastChar;\r\n\r\n\tstr = gkUtf8CharCode(text, &c);\r\n\twhile (c) {\r\n\t\tif(c != CHAR(' ') && c != CHAR('\\t') && c != CHAR('\\r') && c != CHAR('\\n')) \r\n\t\t\ttotalGlyphs++;\r\n\t\tstr = gkUtf8CharCode(str, &c);\r\n\t}\r\n\r\n\tif(totalGlyphs > 0){\r\n\t\tint index, prevIndex = 0;\r\n\t\tgkPoint spaceAdvance;\r\n\t\tgkGlyph* glyph = 0;\r\n\t\tglyphs = (gkGlyph**)calloc(totalGlyphs, sizeof(gkGlyph*));\r\n\t\tFT_Set_Char_Size(face, 0, font->size*64, 0, 96);\r\n\t\tcollection = gkGetGlyphCollection(font, 0);\r\n\t\tif(format->strokeSize>0.0f){\r\n\t\t\tstrokes = (gkGlyph**)calloc(totalGlyphs, sizeof(gkGlyph*));\r\n\t\t\tstrokeCollection = gkGetGlyphCollection(font, format->strokeSize);\r\n\t\t}\r\n\t\tFT_Load_Char(face, L' ', FT_LOAD_DEFAULT);\r\n\t\tspaceAdvance.x = ((float)face->glyph->advance.x)/64.0f;\r\n\t\tspaceAdvance.y = ((float)face->glyph->advance.y)/64.0f;\r\n\t\tif(spaceAdvance.y == 0) spaceAdvance.y = spaceAdvance.x;\r\n\r\n\t\tstr = gkUtf8CharCode(text, &c);\r\n\t\tlastChar = c;\r\n\t\twhile(c) {\r\n\t\t\tif(c != CHAR(' ') && c != CHAR('\\t') \r\n\t\t\t\t\t&& c != CHAR('\\r') && c != CHAR('\\n')) {\r\n\t\t\t\tindex = FT_Get_Char_Index(face, c);\r\n\t\t\t\tif(strokes) strokes[currentGlyph] = gkGetGlyph(face, strokeCollection, gkGetGlyphSet(strokeCollection, index), index);\r\n\t\t\t\tglyphs[currentGlyph] = glyph = gkGetGlyph(face, collection, gkGetGlyphSet(collection, index), index);\r\n\t\t\t\tif(currentElement && currentElement->type != GK_SE_WORD){\r\n\t\t\t\t\tlastElement->next = currentElement;\r\n\t\t\t\t\tlastElement = currentElement;\r\n\t\t\t\t\tcurrentElement = 0;\r\n\t\t\t\t}\r\n\t\t\t\tif(currentElement == 0){\r\n\t\t\t\t\tcurrentElement = (gkSentenceElement*)malloc(sizeof(gkSentenceElement));\r\n\t\t\t\t\tcurrentElement->type = GK_SE_WORD;\r\n\t\t\t\t\tcurrentElement->glyphStart = glyphs + currentGlyph;\r\n\t\t\t\t\tcurrentElement->glyphEnd = glyphs + currentGlyph;\r\n\t\t\t\t\tcurrentElement->strokeStart = strokes + currentGlyph;\r\n\t\t\t\t\tcurrentElement->strokeEnd = strokes + currentGlyph;\r\n\t\t\t\t\tcurrentElement->advance.x = glyph->advance.x;\r\n\t\t\t\t\tcurrentElement->advance.y = glyph->advance.y;\r\n\t\t\t\t\tcurrentElement->bbox = glyph->bbox;\r\n\t\t\t\t\tcurrentElement->next = 0;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tgkBBox tbbox = glyph->bbox;\r\n\t\t\t\t\tcurrentElement->glyphEnd = glyphs + currentGlyph;\r\n\t\t\t\t\tcurrentElement->strokeEnd = strokes + currentGlyph;\r\n\t\t\t\t\tif(format->vertical){\r\n\t\t\t\t\t\tgkBBoxTranslate(&tbbox, 0, currentElement->advance.y);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tgkBBoxTranslate(&tbbox, currentElement->advance.x, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgkBBoxAdd(&currentElement->bbox, &tbbox);\r\n\t\t\t\t\tcurrentElement->advance.x += glyph->advance.x;\r\n\t\t\t\t\tcurrentElement->advance.y += glyph->advance.y;\r\n\t\t\t\t\tif(hasKerning){\r\n\t\t\t\t\t\tFT_Vector delta;\r\n\t\t\t\t\t\tFT_Get_Kerning(face, prevIndex, index, FT_KERNING_DEFAULT, &delta);\r\n\t\t\t\t\t\tcurrentElement->advance.x += ((float)delta.x)/64.0f;\r\n\t\t\t\t\t\tcurrentElement->advance.y += ((float)delta.y)/64.0f;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprevIndex = index;\r\n\t\t\t\tcurrentGlyph++;\r\n\t\t\t}else{\r\n\t\t\t\tif(currentElement && currentElement->type == GK_SE_WORD){\r\n\t\t\t\t\tlastElement->next = currentElement;\r\n\t\t\t\t\tlastElement = currentElement;\r\n\t\t\t\t}\r\n\t\t\t\tcurrentElement = 0;\r\n\t\t\t\tif(c == CHAR('\\t')){\r\n\t\t\t\t\tcurrentElement = (gkSentenceElement*)malloc(sizeof(gkSentenceElement));\r\n\t\t\t\t\tcurrentElement->type = GK_SE_TAB;\r\n\t\t\t\t\tcurrentElement->advance = spaceAdvance;\r\n\t\t\t\t\tif(format->vertical){\r\n\t\t\t\t\t\tcurrentElement->bbox = gkCreateBBox(0, 0, 0, spaceAdvance.y);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tcurrentElement->bbox = gkCreateBBox(0, 0, spaceAdvance.x, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrentElement->next = 0;\r\n\t\t\t\t}else if(c == CHAR(' ')) {\r\n\t\t\t\t\tcurrentElement = (gkSentenceElement*)malloc(sizeof(gkSentenceElement));\r\n\t\t\t\t\tcurrentElement->type = GK_SE_SPACE;\r\n\t\t\t\t\tcurrentElement->advance = spaceAdvance;\r\n\t\t\t\t\tif(format->vertical){\r\n\t\t\t\t\t\tcurrentElement->bbox = gkCreateBBox(0, 0, 0, spaceAdvance.y);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tcurrentElement->bbox = gkCreateBBox(0, 0, spaceAdvance.x, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrentElement->next = 0;\r\n\t\t\t\t}else if((c == CHAR('\\n') && lastChar != CHAR('\\r')) || c == CHAR('\\r')) {\r\n\t\t\t\t\tcurrentElement = (gkSentenceElement*)malloc(sizeof(gkSentenceElement));\r\n\t\t\t\t\tcurrentElement->type = GK_SE_NEWLINE;\r\n\t\t\t\t\tcurrentElement->bbox = gkCreateBBox(0,0,0,0);\r\n\t\t\t\t\tcurrentElement->next = 0;\r\n\t\t\t\t}\r\n\t\t\t\tif(currentElement && lastElement){\r\n\t\t\t\t\tlastElement->next = currentElement;\r\n\t\t\t\t\tlastElement = currentElement;\r\n\t\t\t\t\tcurrentElement = 0;\r\n\t\t\t\t}\r\n\t\t\t\tprevIndex  = 0;\r\n\t\t\t}\r\n\t\t\tif(firstElement == 0 && currentElement){\r\n\t\t\t\tfirstElement = lastElement = currentElement;\r\n\t\t\t}\r\n\t\t\tlastChar = c;\r\n\t\t\tstr = gkUtf8CharCode(str, &c);\r\n\t\t}\r\n\t\tif(currentElement && currentElement != lastElement){\r\n\t\t\tlastElement->next = currentElement;\r\n\t\t\tlastElement = currentElement;\r\n\t\t\tcurrentElement = 0;\r\n\t\t}\r\n\t}\r\n\treturn firstElement;\r\n}\r\n\r\nvoid gkFreeSentenceElements(gkSentenceElement* elements){\r\n\tgkSentenceElement* p = elements, *r;\r\n\tfree(p->strokeStart);\r\n\tfree(p->glyphStart);\r\n\twhile(p){\r\n\t\tp = (r = p)->next;\r\n\t\tfree(r);\r\n\t}\r\n}\r\n\r\ngkSentenceLine* gkParseSentenceLines(gkSentenceElement* elements, gkTextFormat* format){\r\n\tgkSentenceElement* currentElement = elements;\r\n\tgkSentenceLine *firstLine = (gkSentenceLine*)malloc(sizeof(gkSentenceLine)), *current = firstLine, *newLine;\r\n\tgkPoint advance = {0,0};\r\n\tGK_BOOL wordWrap = format->wordWrap && format->width>0;\r\n\tmemset(firstLine, 0, sizeof(gkSentenceLine));\r\n\twhile(currentElement){\r\n\t\tif(currentElement->type == GK_SE_NEWLINE){\r\nwordWrap:\r\n\t\t\tnewLine = (gkSentenceLine*)malloc(sizeof(gkSentenceLine));\r\n\t\t\tmemset(newLine, 0, sizeof(gkSentenceLine));\r\n\t\t\tcurrent->next = newLine;\r\n\t\t\tcurrent = newLine;\r\n\t\t}else{\r\n\t\t\tif(current->first == 0){\r\n\t\t\t\tcurrent->first = current->last = currentElement;\r\n\t\t\t\tcurrent->bbox = currentElement->bbox;\r\n\t\t\t\tadvance = currentElement->advance;\r\n\t\t\t}else{\r\n\t\t\t\tgkBBox tbbox = currentElement->bbox;\r\n\t\t\t\tif(format->vertical){\r\n\t\t\t\t\tgkBBoxTranslate(&tbbox, 0, advance.y);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tgkBBoxTranslate(&tbbox, advance.x, 0);\r\n\t\t\t\t}\r\n\t\t\t\tgkBBoxAdd(&current->bbox, &tbbox);\r\n\t\t\t\tcurrent->last = currentElement;\r\n\t\t\t\tadvance.x += currentElement->advance.x;\r\n\t\t\t\tadvance.y += currentElement->advance.y;\r\n\t\t\t\tif(wordWrap && currentElement->next)\r\n\t\t\t\t{\r\n\t\t\t\t\tgkBBox* nextBox = &currentElement->next->bbox;\r\n\t\t\t\t\tfloat nextW = (nextBox->maxX - nextBox->minX) + (current->bbox.maxX - current->bbox.minX);\r\n\t\t\t\t\tif(nextW > format->width)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(currentElement->next->type != GK_SE_WORD)\r\n\t\t\t\t\t\t\tcurrentElement = currentElement->next;\r\n\t\t\t\t\t\tgoto wordWrap;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcurrentElement = currentElement->next;\r\n\t}\r\n\treturn firstLine;\r\n}\r\n\r\nvoid gkFreeSentenceLines(gkSentenceLine* lines){\r\n\tgkSentenceLine* p;\r\n\twhile(lines){\r\n\t\tlines = (p = lines)->next;\r\n\t\tfree(p);\r\n\t}\r\n}\r\n\r\ngkBBox gkGetTextBBox(gkSentenceLine* lines, gkTextFormat* format, float leading){\r\n\tgkBBox res = lines->bbox;\r\n\tgkSentenceLine* currentLine = lines;\r\n\tfloat tx = 0, ty = 0;\r\n\twhile(currentLine){\r\n\t\tgkBBox b = currentLine->bbox;\r\n\t\tgkBBoxTranslate(&b, tx, ty);\r\n\t\tgkBBoxAdd(&res, &b);\r\n\t\tif(format->vertical){\r\n\t\t\ttx -= leading;\r\n\t\t}else{\r\n\t\t\tty += leading;\r\n\t\t}\r\n\t\tcurrentLine = currentLine->next;\r\n\t}\r\n\treturn res;\r\n}\r\ngkPoint gkAlignLine(gkSentenceLine* line, gkTextFormat* format, gkBBox* textBBox){\r\n\tgkPoint result = {0,0};\r\n\tfloat width;\r\n\tfloat height;\r\n\tif(format->width == 0){\r\n\t\twidth = textBBox->maxX - textBBox->minX;\r\n\t}else{\r\n\t\twidth = format->width;\r\n\t}\r\n\tif(format->height == 0){\r\n\t\theight = textBBox->maxY - textBBox->minY;\r\n\t}else{\r\n\t\theight = format->height;\r\n\t}\r\n\tif(format->vertical){\r\n\t\tif(format->align == GK_TEXT_ALIGN_LEFT){\r\n\t\t\tresult.x = -textBBox->minX;\r\n\t\t}else if(format->align == GK_TEXT_ALIGN_CENTER){\r\n\t\t\tresult.x = (width - (textBBox->maxX - textBBox->minX))/2 - textBBox->minX;\r\n\t\t}else if(format->align == GK_TEXT_ALIGN_RIGHT){\r\n\t\t\tresult.x = (width - (textBBox->maxX - textBBox->minX)) - textBBox->minX;\r\n\t\t}\r\n\t\tif(format->valign == GK_TEXT_VALIGN_TOP){\r\n\t\t\tresult.y = -line->bbox.minY;\r\n\t\t}else if(format->valign == GK_TEXT_VALIGN_MIDDLE){\r\n\t\t\tresult.y = (height - (line->bbox.maxY - line->bbox.minY))/2 - line->bbox.minY;\r\n\t\t}else if(format->valign == GK_TEXT_VALIGN_BOTTOM){\r\n\t\t\tresult.y = (height - (line->bbox.maxY - line->bbox.minY)) - line->bbox.minY;\r\n\t\t}\r\n\t}else{\r\n\t\tif(format->align == GK_TEXT_ALIGN_LEFT){\r\n\t\t\tresult.x = -line->bbox.minX;\r\n\t\t}else if(format->align == GK_TEXT_ALIGN_CENTER){\r\n\t\t\tresult.x = (width - (line->bbox.maxX - line->bbox.minX))/2 - line->bbox.minX;\r\n\t\t}else if(format->align == GK_TEXT_ALIGN_RIGHT){\r\n\t\t\tresult.x = (width - (line->bbox.maxX - line->bbox.minX)) - line->bbox.minX;\r\n\t\t}\r\n\t\tif(format->valign == GK_TEXT_VALIGN_TOP){\r\n\t\t\tresult.y = -textBBox->minY;\r\n\t\t}else if(format->valign == GK_TEXT_VALIGN_MIDDLE){\r\n\t\t\tresult.y = (height - (textBBox->maxY - textBBox->minY))/2 - textBBox->minY;\r\n\t\t}else if(format->valign == GK_TEXT_VALIGN_BOTTOM){\r\n\t\t\tresult.y = (height - (textBBox->maxY - textBBox->minY)) - textBBox->minY;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\ngkPoint gkDrawSentenceLine(FT_Face face, gkSentenceLine* line, gkTextFormat* format){\r\n\tgkGlyph *g, **c, **firstGlyph, **lastGlyph;\r\n\tgkPoint b = GK_POINT(0,0), p;\r\n\tGLuint texImage = 0;\r\n\tint prevIndex = 0;\r\n\tGK_BOOL stroke = format->strokeSize>0;\r\n\tGK_BOOL hasKerning = FT_HAS_KERNING(face);\r\n\tgkSentenceElement* currentElement;\r\n\tgkColor tmpColor;\r\n\tif(line->first == 0) return GK_POINT(0,0);\r\ndraw:\r\n\tif(stroke){\r\n\t\ttmpColor = gkGetFilteredColor(format->strokeColor);\r\n\t}else{\r\n\t\ttmpColor = gkGetFilteredColor(format->textColor);\r\n\t}\r\n\tif(format->underline && format->vertical == GK_FALSE){\r\n\t\tfloat underlinePos = ((float)FT_MulFix(face->underline_position, face->size->metrics.y_scale))/64.0f;\r\n\t\tfloat underlineThickness = ((float)FT_MulFix(face->underline_thickness, face->size->metrics.y_scale))/64.0f;\r\n\t\tif(stroke){\r\n\t\t\tfloat lw = format->strokeSize/3.0f;\r\n\t\t\tunderlineThickness += lw;\r\n\t\t\tgkSetLineWidth(lw);\r\n\t\t\tgkSetLineColor(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);\r\n\t\t\tgkSetFillColor(0,0,0,0);\r\n\t\t}else{\r\n\t\t\tgkSetLineWidth(0);\r\n\t\t\tgkSetFillColor(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);\r\n\t\t}\r\n\t\tgkDrawRect(-underlineThickness*0.5f + line->bbox.minX, -underlinePos - underlineThickness*0.5f, underlineThickness + (line->bbox.maxX - line->bbox.minX), underlineThickness);\r\n\t}\r\n\tglColor4f(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);\r\n\tglEnable(GL_TEXTURE_2D);\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglEnableClientState(GL_TEXTURE_COORD_ARRAY);\r\n\tcurrentElement = line->first;\r\n\twhile(1){\r\n\t\tif(currentElement->type == GK_SE_WORD){\r\n\t\t\tif(stroke){\r\n\t\t\t\tfirstGlyph = currentElement->strokeStart;\r\n\t\t\t\tlastGlyph = currentElement->strokeEnd;\r\n\t\t\t}else{\r\n\t\t\t\tfirstGlyph = currentElement->glyphStart;\r\n\t\t\t\tlastGlyph = currentElement->glyphEnd;\r\n\t\t\t}\r\n\t\t\tfor(c = firstGlyph; c <= lastGlyph; c++){\r\n\t\t\t\tg = *c;\r\n\t\t\t\tif(hasKerning){\r\n\t\t\t\t\tFT_Vector delta;\r\n\t\t\t\t\tFT_Get_Kerning(face, prevIndex, g->index, FT_KERNING_DEFAULT, &delta);\r\n\t\t\t\t\tif(format->vertical){\r\n\t\t\t\t\t\tb.y += ((float)delta.y)/64.0f;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tb.x += ((float)delta.x)/64.0f;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tp.x = b.x + g->offset.x;\r\n\t\t\t\tp.y = b.y - g->offset.y;\r\n\t\t\t\tif(texImage == 0 || texImage != g->texId){\r\n\t\t\t\t\ttexImage = g->texId;\r\n\t\t\t\t\tglBindTexture(GL_TEXTURE_2D, texImage);\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat v[] = {\r\n\t\t\t\t\t\tp.x, p.y,\r\n\t\t\t\t\t\tp.x + g->size.width, p.y,\r\n\t\t\t\t\t\tp.x + g->size.width, p.y + g->size.height,\r\n\t\t\t\t\t\tp.x, p.y + g->size.height\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfloat c[] = {\r\n\t\t\t\t\t\tg->texCoords.x, g->texCoords.y,\r\n\t\t\t\t\t\tg->texCoords.x + g->texCoords.width, g->texCoords.y,\r\n\t\t\t\t\t\tg->texCoords.x + g->texCoords.width, g->texCoords.y + g->texCoords.height,\r\n\t\t\t\t\t\tg->texCoords.x, g->texCoords.y + g->texCoords.height,\r\n\t\t\t\t\t};\r\n\t\t\t\t\tglVertexPointer(2, GL_FLOAT, 0, v);\r\n\t\t\t\t\tglTexCoordPointer(2, GL_FLOAT, 0, c);\r\n\t\t\t\t\tglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\r\n\t\t\t\t}\r\n\t\t\t\tif(format->vertical){\r\n\t\t\t\t\tb.y += g->advance.y;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tb.x += g->advance.x;\r\n\t\t\t\t}\r\n\t\t\t\tprevIndex = g->index;\r\n\t\t\t}\r\n\t\t}else if(currentElement->type == GK_SE_SPACE){\r\n\t\t\tif(format->vertical){\r\n\t\t\t\tb.y += currentElement->advance.y;\r\n\t\t\t}else{\r\n\t\t\t\tb.x += currentElement->advance.x;\r\n\t\t\t}\r\n\t\t}else if(currentElement->type == GK_SE_TAB){\r\n\t\t\t//make tabulations\r\n\t\t}\r\n\t\tif(currentElement == line->last) break;\r\n\t\tcurrentElement = currentElement->next;\r\n\t}\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n\tglDisableClientState(GL_TEXTURE_COORD_ARRAY);\r\n\tglDisable(GL_TEXTURE_2D);\r\n\r\n\tif(stroke){\r\n\t\tb = GK_POINT(0,0);\r\n\t\tprevIndex = 0;\r\n\t\tstroke = GK_FALSE;\r\n\t\tgoto draw;\r\n\t}\r\n\treturn GK_POINT(0,0);\r\n}\r\n\r\n#endif\t//GK_USE_FONTS","﻿/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#define GK_INTERNAL\r\n\r\n#include \"gk.h\"\r\n#include \"gk_internal.h\"\r\n\r\n#include \"gkPlatform.h\"\r\n\r\n#include \"gkGL.h\"\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <locale.h>\r\n\r\nstatic gkPlatform Platform;\r\n\r\nGK_BOOL gkFullscreen;\r\nGK_BOOL gkWindowResizable = GK_FALSE;\r\nGK_BOOL gkInFrame;\r\nint gkFps = 0;\r\nint gkTargetFps = 60;\r\ngkSize\tgkScreenSize = {800,600};\r\n\r\ngkPanel* gkMainPanel = 0;\r\n\r\nGK_BOOL gkUpdateSize;\r\nGK_BOOL gkFpsLimitEnabled;\r\n\r\nchar gkAppDirBuffer[GK_MAX_APPDIR_SIZE];\r\nchar windowNameBuffer[GK_MAX_TITLE_SIZE];\r\n\r\ngkInitFunc initFunc;\r\ngkCleanupFunc cleanupFunc;\r\n\r\nGK_BOOL gkInit();\r\nvoid loop();\r\nvoid gkCleanup();\r\n\r\nvoid updateGLSize(gkSize sz);\r\n\r\nvoid onPlatformInit()\r\n{\r\n\tif (!gkInit()) {\r\n\t\tgkExit();\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!initFunc()) {\r\n\t\tcleanupFunc = 0;\r\n\t\tgkCleanup();\r\n\t\tgkExit();\r\n\t\treturn;\r\n\t}\r\n\r\n\tPlatform.Run(loop, gkCleanup);\r\n}\r\n\r\nvoid gkMain(gkInitFunc init, gkCleanupFunc cleanup)\r\n{\r\n\tinitFunc = init;\r\n\tcleanupFunc = cleanup;\r\n\r\n\tsetlocale(LC_CTYPE, \"\");\r\n\r\n\tPlatform = gkGetPlatform();\r\n\tPlatform.Init(onPlatformInit);\r\n}\r\n\r\nvoid gkExit()\r\n{\r\n\tPlatform.Exit();\r\n}\r\n\r\n\r\nchar* gkGetAppDir()\r\n{\r\n\tPlatform.GetAppDir(gkAppDirBuffer, GK_MAX_APPDIR_SIZE);\r\n\treturn gkAppDirBuffer;\r\n}\r\n\r\nvoid gkSetTargetFps(int targetFps)\r\n{\r\n\tgkTargetFps = targetFps;\r\n\tgkFpsLimitEnabled = (gkTargetFps >= 1);\r\n\tPlatform.SetVSync(targetFps == -1);\r\n}\r\n\r\nint gkGetTargetFps()\r\n{\r\n\treturn gkTargetFps;\r\n}\r\n\r\nint gkGetFps()\r\n{\r\n\treturn gkFps;\r\n}\r\n\r\nvoid gkSetScreenSize(gkSize size)\r\n{\r\n\tif (!gkInFrame) {\r\n\t\tPlatform.ResizeScreen(size);\r\n\t\tgkProcessLayoutMainPanel(gkMainPanel, size.width, size.height);\r\n\t\tupdateGLSize(size);\r\n\t\tgkUpdateSize = GK_FALSE;\r\n\t} else {\r\n\t    gkUpdateSize = GK_TRUE;\r\n\t}\r\n\tgkScreenSize = size;\r\n\tgkSetFullscreen(gkFullscreen);\r\n}\r\n\r\ngkSize gkGetScreenSize()\r\n{\r\n\treturn gkScreenSize;\r\n}\r\n\r\nstatic GK_BOOL gkCanSwitchFullscreen()\r\n{\r\n\tsize_t i, resolutionCount = 0;\r\n\tgkSize* resolutions;\r\n\tGK_BOOL resolutionSupported = GK_FALSE;\r\n\tresolutionCount = gkGetSupportedScreenSizes(0);\r\n\tresolutions = (gkSize*)calloc(resolutionCount, sizeof(gkSize));\r\n\tgkGetSupportedScreenSizes(resolutions);\r\n\tfor (i = 0; i < resolutionCount; i++) {\r\n\t\tif (resolutions[i].width == gkScreenSize.width && resolutions[i].height == gkScreenSize.height) {\r\n\t\t\tresolutionSupported = GK_TRUE;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tfree(resolutions);\r\n\treturn resolutionSupported;\r\n}\r\n\r\nvoid gkSetFullscreen(GK_BOOL fullscreen)\r\n{\r\n\tgkFullscreen = Platform.SetFullscreen(fullscreen && gkCanSwitchFullscreen());\r\n}\r\n\r\nGK_BOOL gkIsFullscreen()\r\n{\r\n\treturn gkFullscreen;\r\n}\r\n\r\nsize_t gkGetSupportedScreenSizes(gkSize* sizes)\r\n{\r\n\treturn Platform.GetSupportedSizes(sizes);\r\n}\r\n\r\nvoid gkSetWindowTitle(char* title)\r\n{\r\n\tPlatform.SetWindowTitle(title);\r\n}\r\n\r\nchar* gkGetWindowTitle()\r\n{\r\n\tPlatform.GetWindowTitle(windowNameBuffer, GK_MAX_TITLE_SIZE);\r\n\treturn windowNameBuffer;\r\n}\r\n\r\nvoid gkSetWindowResizable(GK_BOOL resizable)\r\n{\r\n\tgkWindowResizable = resizable;\r\n\tPlatform.SetWindowResizable(resizable);\r\n}\r\n\r\nGK_BOOL gkIsWindowResizable()\r\n{\r\n\treturn gkWindowResizable;\r\n}\r\n\r\n\r\n///////////////////////////////\r\n\r\nvoid onWindowClose()\r\n{\r\n\tgkExit();\r\n}\r\n\r\nvoid onWindowMouseMove(int x, int y)\r\n{\r\n\tgkMouseEvent evt;\r\n\tevt.type = GK_ON_MOUSE_MOVE;\r\n\tevt.target = evt.currentTarget = gkMouse;\r\n\tevt.position = GK_POINT(x,y);\r\n\tgkGlobalMouseState.position.x = (float)x;\r\n\tgkGlobalMouseState.position.y = (float)y;\r\n\tgkDispatch(gkMouse, &evt);\r\n\tgkProcessMouseEvent(&evt);\r\n}\r\n\r\nvoid onWindowMouseWheel(int x, int y, int w)\r\n{\r\n\tgkMouseEvent evt;\r\n\tevt.type = GK_ON_MOUSE_WHEEL;\r\n\tevt.target = evt.currentTarget = gkMouse;\r\n\tevt.position = GK_POINT(gkGlobalMouseState.position.x,gkGlobalMouseState.position.y);\r\n\tevt.delta = w;\r\n\tgkGlobalMouseState.wheel += w;\r\n\tgkDispatch(gkMouse, &evt);\r\n\tgkProcessMouseEvent(&evt);\r\n}\r\n\r\nvoid onWindowMouseDown(int x, int y, int mb)\r\n{\r\n\tgkMouseEvent evt;\r\n\tevt.type = GK_ON_MOUSE_DOWN;\r\n\tevt.target = evt.currentTarget = gkMouse;\r\n\tevt.button = mb;\r\n\tevt.position = GK_POINT(x,y);\r\n\tgkGlobalMouseState.position.x = (float)x;\r\n\tgkGlobalMouseState.position.y = (float)y;\r\n\tif(mb<GK_MAX_MOUSE_BUTTONS)\r\n\t\tgkGlobalMouseState.buttons[mb] = GK_TRUE;\r\n\tgkDispatch(gkMouse, &evt);\r\n\tgkProcessMouseEvent(&evt);\r\n}\r\n\r\nvoid onWindowMouseUp(int x, int y, int mb)\r\n{\r\n\tgkMouseEvent evt;\r\n\tevt.type = GK_ON_MOUSE_UP;\r\n\tevt.target = evt.currentTarget = gkMouse;\r\n\tevt.button = mb;\r\n\tevt.position = GK_POINT(x,y);\r\n\tgkGlobalMouseState.position.x = (float)x;\r\n\tgkGlobalMouseState.position.y = (float)y;\r\n\tif(mb<GK_MAX_MOUSE_BUTTONS)\r\n\t\tgkGlobalMouseState.buttons[mb] = GK_FALSE;\r\n\tgkDispatch(gkMouse, &evt);\r\n\tgkProcessMouseEvent(&evt);\r\n}\r\n\r\nvoid onWindowSizeChanged(gkSize nsize)\r\n{\r\n\tgkSetScreenSize(nsize);\r\n}\r\n\r\nuint16_t gkLastKeyCode = 0;\r\nuint16_t gkLastScanCode = 0;\r\n\r\nvoid prepareKey(gkKey* key, uint16_t keyCode, uint16_t scanCode, GK_BOOL keyDown)\r\n{\r\n\tkeyCode = Platform.PrepareKey(keyCode, scanCode, keyDown);\r\n\r\n\tgkGlobalKeyboardState.keys[keyCode] = keyDown;\r\n\tkey->code = keyCode;\r\n\tkey->modifiers = 0;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_NUMLOCK])\tkey->modifiers |= GK_KEY_MOD_NUM;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_CAPSLOCK]) key->modifiers |= GK_KEY_MOD_CAPS;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_LCTRL])\tkey->modifiers |= GK_KEY_MOD_LCTRL;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_RCTRL])\tkey->modifiers |= GK_KEY_MOD_RCTRL;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_LALT])\tkey->modifiers |= GK_KEY_MOD_LALT;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_RALT])\tkey->modifiers |= GK_KEY_MOD_RALT;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_LSHIFT])\tkey->modifiers |= GK_KEY_MOD_LSHIFT;\r\n\tif(gkGlobalKeyboardState.keys[GK_KEY_RSHIFT])\tkey->modifiers |= GK_KEY_MOD_RSHIFT;\r\n}\r\n\r\nvoid onWindowKeyDown(uint16_t keyCode, uint16_t scanCode)\r\n{\r\n\tgkKeyboardEvent evt;\r\n\tgkKey key;\r\n\tprepareKey(&key, keyCode, scanCode, GK_TRUE);\r\n\r\n\tif (gkLastKeyCode == key.code && gkLastScanCode == scanCode)\r\n\t\tevt.type = GK_ON_KEY_REPEAT;\r\n\telse \r\n\t\tevt.type = GK_ON_KEY_DOWN;\r\n\r\n\tevt.currentTarget = evt.target = gkKeyboard;\r\n\tevt.key = key;\r\n\tgkDispatch(gkKeyboard, &evt);\r\n\tgkProcessKeyboardEvent(&evt);\r\n\tgkLastKeyCode = key.code;\r\n\tgkLastScanCode = scanCode;\r\n}\r\n\r\nvoid onWindowKeyUp(uint16_t keyCode, uint16_t scanCode)\r\n{\r\n\tgkKeyboardEvent evt;\r\n\tgkKey key;\r\n\r\n\tprepareKey(&key, keyCode, scanCode, GK_FALSE);\r\n\r\n\tevt.type = GK_ON_KEY_UP;\r\n\tevt.currentTarget = evt.target = gkKeyboard;\r\n\tevt.key = key;\r\n\tgkDispatch(gkKeyboard, &evt);\r\n\tgkProcessKeyboardEvent(&evt);\r\n\tif (gkLastKeyCode == key.code && gkLastScanCode == scanCode) {\r\n\t\tgkLastKeyCode = 0;\r\n\t\tgkLastScanCode = 0;\r\n\t}\r\n}\r\nvoid onWindowCharacter(uint32_t character)\r\n{\r\n\tgkKeyboardEvent evt;\r\n\tevt.type = GK_ON_CHARACTER;\r\n\tevt.currentTarget = evt.target = gkKeyboard;\r\n\tevt.charCode = character;\r\n\tgkDispatch(gkKeyboard, &evt);\r\n\tgkProcessKeyboardEvent(&evt);\r\n}\r\n//\r\n\r\nGK_BOOL gkInit()\r\n{\r\n\tgkFullscreen = GK_FALSE;\r\n\r\n\tgkMouse = (gkDispatcher*)malloc(sizeof(gkDispatcher));\r\n\tgkKeyboard = (gkDispatcher*)malloc(sizeof(gkDispatcher));\r\n\tgkInitDispatcher(gkMouse);\r\n\tgkInitDispatcher(gkKeyboard);\r\n\r\n\tgkMainPanel = gkCreatePanel();\r\n\r\n\tupdateGLSize(gkScreenSize);\r\n\r\n\tgkSetWindowResizable(GK_FALSE);\r\n\r\n\tgkAppStartTime = gkMilliseconds();\r\n\tgkSetTargetFps(0);\r\n\r\n\tgkGlobalMouseState.wheel = 0;\r\n\tgkInitImages();\r\n#ifdef GK_USE_FONTS\r\n   \tgkInitFonts();\r\n#endif\r\n\tgkInitTimers();\r\n\tgkInitTweens();\r\n#ifdef GK_USE_JOYSTICK\r\n\tgkInitJoystick();\r\n#endif\r\n\tgkInitAudio();\r\n\r\n\treturn GK_TRUE;\r\n}\r\n\r\nvoid updateGLSize(gkSize sz)\r\n{\r\n    \tglViewport(0,0, (GLsizei)sz.width, (GLsizei)sz.height);\r\n    \tglMatrixMode(GL_PROJECTION);\r\n    \tglLoadIdentity();\r\n    \tglOrtho(0,sz.width,sz.height,0, -1, 1);\r\n\r\n    \tglMatrixMode(GL_MODELVIEW);\r\n    \tglLoadIdentity();\r\n    \tglClearColor(0,0,0,1.0f);\r\n    \tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n    \tglEnable(GL_BLEND);\r\n\r\n    \tgkCleanupDrawToImageBuffer();\r\n    \tgkInitDrawToImageBuffer(sz);\r\n}\r\n\r\n\r\nvoid processEvents()\r\n{\r\n\tgkUpdateMouseTarget(gkMainPanel);\r\n\tgkCheckFocusedPanel();\r\n\tPlatform.ProcessEvents();\r\n}\r\n\r\nuint64_t gkTimeSinceLastFrame = 0;\r\nuint64_t gkFpsFrames = 0;\r\nuint64_t gkFpsFreq = 250;\r\nuint64_t gkFpsAccum = 0;\r\n\r\nvoid drawFrame()\r\n{\r\n\tuint64_t td;\r\n\r\n\tglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\r\n\tgkResetTransform();\r\n\tgkResetColorFilter();\r\n\r\n\tgkInFrame = GK_TRUE;\r\n\ttd = (gkMilliseconds() - gkTimeSinceLastFrame);\r\n\tgkTimeSinceLastFrame = gkMilliseconds();\r\n\r\n\tgkProcessLayoutMainPanel(gkMainPanel, gkScreenSize.width, gkScreenSize.height);\r\n\tgkProcessUpdatePanel(gkMainPanel);\r\n\tgkProcessDrawPanel(gkMainPanel);\r\n\r\n\tgkFpsAccum += td;\r\n\tgkFpsFrames++;\r\n\tif (gkFpsAccum >= gkFpsFreq) {\r\n\t\tgkFps = (int)(1000.0f/((float)gkFpsAccum/(float)gkFpsFrames));\r\n\t\tgkFpsAccum = 0;\r\n\t\tgkFpsFrames = 0;\r\n\t}\r\n\tgkInFrame = GK_FALSE;\r\n\r\n\tPlatform.SwapBuffers();\r\n}\r\n\r\nvoid loop()\r\n{\r\n\tuint64_t sleepTime = gkTargetFps?(1000/gkTargetFps):0;\r\n\tuint64_t elapsedTime = gkMilliseconds();\r\n\tint rest;\r\n\r\n\tgkUpdateTweens();\r\n\tgkUpdateTimers();\r\n\tprocessEvents();\r\n\tdrawFrame();\r\n\r\n\tif (gkUpdateSize)\r\n\t\tgkSetScreenSize(gkScreenSize);\r\n\r\n\telapsedTime = gkMilliseconds() - elapsedTime;\r\n\trest = (int)(sleepTime - elapsedTime);\r\n\telapsedTime = gkMilliseconds();\r\n\r\n\tif (rest>0 && gkFpsLimitEnabled)\r\n\t\tPlatform.Sleep(rest);\r\n}\r\n\r\nvoid gkCleanup()\r\n{\r\n\tif (cleanupFunc)\r\n\t\tcleanupFunc();\r\n\r\n\tgkCleanupAudio();\r\n\tgkCleanupImages();\r\n#ifdef GK_USE_FONTS\r\n   \tgkCleanupFonts();\r\n#endif\r\n\tgkCleanupTimers();\r\n\tgkCleanupTweens();\r\n#ifdef GK_USE_JOYSTICK\r\n\tgkCleanupJoystick();\r\n#endif\r\n\r\n\tgkDestroyPanel(gkMainPanel);\r\n\tgkCleanupDispatcher(gkKeyboard);\r\n\tgkCleanupDispatcher(gkMouse);\r\n\tfree(gkKeyboard);\r\n\tfree(gkMouse);\r\n\r\n\tPlatform.Cleanup();\r\n}\r\n\r\n#ifdef GK_PLATFORM_TEST\r\n\r\nfloat r = 0;\r\ngkImage* bg;\r\ngkImage* img;\r\ngkFont* font = 0;\r\ngkTextFormat fpsTf;\r\nuint64_t frameTime;\r\ngkSound* snd;\r\nGK_BOOL playing = 0;\r\n\r\nstatic void testDraw(gkPanel* p)\r\n{\r\n\tchar fps[10];\r\n\tuint64_t diff = gkMilliseconds() - frameTime;\r\n\tfloat ts = (float)diff * 0.001f;\r\n\tframeTime += diff;\r\n\t\r\n\tgkMatrix mat = gkMatrixCreateTranslation(-img->width*0.5f, -img->height*0.5f);\r\n\tgkMatrixMult(&mat, gkMatrixCreateRotation(r));\r\n\tgkMatrixMult(&mat, gkMatrixCreateTranslation(p->mouseX, p->mouseY));\r\n\t\r\n\tgkDrawImage(bg,0,0);\r\n\r\n\tgkSetFillColor(1.0f,0.0f,0.0f,0.5f);\r\n\tgkSetLineWidth(1.0f);\r\n\tgkSetLineColor(1.0f,1.0f,1.0f,1.0f);\r\n\tgkDrawCircle(p->width*0.5f, p->height*0.5f, p->width*0.5f);\r\n\t\r\n\tgkPushTransform(&mat);\r\n\tgkDrawImage(img, 0,0);\r\n\tgkPopTransform();\r\n\t\r\n\tr += ts*5.0f;\r\n\r\n#ifdef GK_USE_FONTS\r\n\tsprintf(fps, \"FPS: %d\", gkGetFps());\r\n\tgkDrawText(font, fps, 5, 5, &fpsTf);\r\n#endif\r\n}\r\n\r\nGK_BOOL onSoundStopped(gkEvent* e, void *p)\r\n{\r\n\tplaying = GK_FALSE;\r\n\treturn GK_TRUE;\r\n}\r\n\r\nvoid playSnd()\r\n{\r\n\tif (!playing) {\r\n\t\tgkSoundSource* src = gkPlaySound(snd, 0);\r\n\t\tgkAddListener(src, GK_ON_SOUND_STOPPED, 0, onSoundStopped, 0);\r\n\t\tplaying = GK_TRUE;\r\n\t}\r\n}\r\n\r\nGK_BOOL onMouseDown(gkEvent* e, void*p){\r\n\tplaySnd();\r\n\treturn GK_TRUE;\r\n}\r\n\r\nstatic GK_BOOL testInit()\r\n{\r\n\tif( !(bg = gkLoadImage(\"assets/testOut.jpg\"))) {\r\n\t\tprintf(\"Couldn't load assets/testOut.jpg\\n\");\r\n\t}\r\n\tif( !(img = gkLoadImage(\"assets/test.png\"))) {\r\n\t\tprintf(\"Couldn't load assets/test.png\\n\");\r\n\t}\r\n\t\r\n#ifdef GK_USE_FONTS\r\n\tgkAddFontResource(\"assets/chiller.TTF\");\r\n\tfont = gkCreateFont(\"Chiller\", 30, GK_FONT_NORMAL);\r\n\tprintf(font?\"font created\\n\":\"font failed\\n\");\r\n\tfpsTf = gkDefaultTextFormat;\r\n\tfpsTf.textColor = GK_COLOR(1,1,1,1);\r\n\tfpsTf.strokeColor = GK_COLOR(0,0,0,1);\r\n\tfpsTf.strokeSize = 6.0f;\r\n#endif\r\n\r\n\tsnd = gkLoadSound(\"assets/music.wav\", GK_SOUND_STATIC);\r\n\tif (snd == 0) {\r\n\t\tprintf(\"Couldn't load sound assets/music.wav\");\r\n\t}\r\n\tplaySnd();\r\n\t\r\n\tgkAddListener(gkMouse, GK_ON_MOUSE_DOWN, 0, onMouseDown, 0);\r\n\r\n\tframeTime = gkMilliseconds();\r\n\t\r\n\tgkMainPanel->drawFunc = testDraw;\r\n\treturn GK_TRUE;\r\n}\r\nstatic void testCleanup()\r\n{\r\n\tgkDestroySound(snd);\r\n#ifdef GK_USE_FONTS\r\n\tgkDestroyFont(font);\r\n#endif\r\n\tgkDestroyImage(img);\r\n\tgkDestroyImage(bg);\r\n}\r\n\r\nGK_APP(testInit, testCleanup);\r\n\r\n#endif\r\n","/* Copyright (c) 2012 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#define GK_INTERNAL\r\n\r\n#include \"gk.h\"\r\n#include \"gk_internal.h\"\r\n\r\n#include \"gkAudioSystem.h\"\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\nstatic gkAudioSystem Audio;\r\n\r\n/***\r\n    Utilities\r\n*/\r\n\r\n/* Those were good for OpenAL only */\r\n//#define VOLUME(x) ((expf(5.757f*(x))*3.1623e-3f)*(x<0.1f?x*10.0f:1.0f))\t//For 50dB range\r\n//#define VOLUME(x) ((expf(6.908f*(x))/1000.0f)*(x<0.1f?x*10.0f:1.0f))\t\t//For 60dB range\r\n//#define VOLUME(x) ((expf(8.059f*(x))*3.1623e-4f)*(x<0.1f?x*10.0f:1.0f))\t//For 70dB range\r\n\r\nstatic int volToDb(float vol)\r\n{\r\n\tint db = (int)((Audio.minVolume + vol*(Audio.maxVolume - Audio.minVolume)));\r\n\tif (vol<0.05f)\r\n\t\tdb = db - (int)(((0.05f - vol)/0.05f)*4000.0f);\r\n\treturn db;\r\n}\r\n\r\nstatic float dbToVol(int db)\r\n{\r\n\tif (db > Audio.minVolume) \r\n\t\treturn ((float)db - Audio.minVolume)/(Audio.maxVolume - Audio.minVolume);\r\n\treturn 0.0f;\r\n}\r\n\r\nstruct gkSoundNode\r\n{\r\n    gkSoundSource* source;\r\n    struct gkSoundNode* prev, *next;\r\n};\r\n\r\nstatic struct gkSoundNode* soundNodes = 0, *lastSoundNode = 0;\r\n\r\nstatic void addSoundNode(gkSoundSource* source)\r\n{\r\n\tstruct gkSoundNode* node = (struct gkSoundNode*)malloc(sizeof(struct gkSoundNode));\r\n\tnode->source = source;\r\n\tnode->prev = lastSoundNode;\r\n\tnode->next = 0;\r\n\r\n\tif(lastSoundNode != 0)\r\n\t\tlastSoundNode->next = node;\r\n\telse \r\n\t\tsoundNodes = node;\r\n\r\n\tlastSoundNode = node;\r\n}\r\n\r\nstatic struct gkSoundNode* findSoundNode(gkSoundSource* source)\r\n{\r\n\tstruct gkSoundNode* node;\r\n\tfor (node = soundNodes; node; node = node->next) {\r\n\t\tif(node->source == source)\r\n\t\t\treturn node;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nstatic void removeSoundNode(struct gkSoundNode* node)\r\n{\r\n\tif (node->next == 0) \r\n\t\tlastSoundNode = node->prev;\r\n\tif (node->prev) {\r\n\t\tnode->prev->next = node->next;\r\n\t\tif (node->next)\r\n\t\t\tnode->next->prev = node->prev;\r\n\t} else {\r\n\t\tsoundNodes = node->next;\r\n\t\tif (node->next)\r\n\t\t\tnode->next->prev = 0;\r\n\t}\r\n\tfree(node);\r\n}\r\n\r\nstatic int fillBuffer(gkAudioBuffer buffer, gkSound* sound)\r\n{\r\n\tchar buf[GK_STREAM_BUFFER_SIZE];\r\n\tgkAudioStream* stream = sound->internal.stream;\r\n\tgkAudioStreamInfo* info = &sound->internal.streamInfo;\r\n\tsize_t readBytes = stream->read(stream, buf, GK_STREAM_BUFFER_SIZE);\r\n\r\n\tif (readBytes > 0) {\r\n\t\tAudio.Buffer.SetData(buffer, buf, readBytes);\r\n\t}\r\n\r\n\treturn readBytes;\r\n}\r\n\r\nstatic int fillBuffers(gkAudioBuffer* buffers, int numToFill, gkSound* sound)\r\n{\r\n\tint i = 0;\r\n\r\n\twhile ((i < numToFill) && (fillBuffer(buffers[i], sound) > 0))\r\n\t\ti++;\r\n\r\n\treturn i;\r\n}\r\n\r\nstatic void fillQueue(gkSoundSource* source, int numBuffers, gkAudioBuffer* buffers)\r\n{\r\n\tgkSound* sound = source->sound;\r\n\tgkAudioStream* stream = sound->internal.stream;\r\n\r\n\tint filled = fillBuffers(buffers, numBuffers, sound);\r\n\r\n\tif (filled == 0 && stream->eof(stream) && source->internal.looping) {\r\n\t\tstream->seek(stream, 0, SEEK_SET);\r\n\t\tfilled = fillBuffers(buffers, numBuffers, sound);\r\n\t}\r\n\r\n\tAudio.Player.QueueBuffers(source->internal.player, filled, buffers);\r\n}\r\n\r\nstatic void updateTimeOffset(gkSoundSource* source, uint64_t currentTime)\r\n{\r\n\tif (source->sound == 0)\r\n\t\treturn;\r\n\tif (source->sound->internal.flags & GK_SOUND_STREAM) {\r\n\t\tfloat pitch;\r\n\t\tuint64_t elapsed = currentTime - source->internal.lastOffset;\r\n\t\tuint64_t total = (uint64_t)(source->sound->length*1000.0f);\r\n\r\n\t\tpitch = Audio.Player.GetPitch(source->internal.player);\r\n\t\tsource->internal.currentOffset += (uint64_t)((float)elapsed*pitch);\r\n\r\n\t\tif (total != 0)\r\n\t\t\tsource->internal.currentOffset %= total;\r\n\r\n\t\tsource->internal.lastOffset += elapsed;\r\n\t}\r\n}\r\n\r\nstatic gkTimer* updateAudioTimer;\r\n\r\nstatic GK_BOOL updateAudio(gkEvent* event, void* param);\r\nstatic void soundSourceStopped(struct gkSoundNode* node, GK_BOOL dispatchStopEvent);\r\n\r\n/***\r\n    Sound system initialization and cleanup\r\n*/\r\n\r\nvoid gkInitAudio()\r\n{\r\n\tAudio = gkGetAudioSystem();\r\n\tAudio.Init();\r\n\r\n\tgkInitAudioStream();\r\n\r\n\tupdateAudioTimer = gkCreateTimer();\r\n\tupdateAudioTimer->interval = 100;\r\n\tgkAddListener(updateAudioTimer, GK_ON_TIMER, 0, updateAudio, 0);\r\n\tgkStartTimer(updateAudioTimer, 0);\r\n}\r\n\r\nvoid gkCleanupAudio()\r\n{\r\n    struct gkSoundNode *c, *p = soundNodes;\r\n\r\n    gkCleanupAudioStream();\r\n\r\n    gkStopTimer(updateAudioTimer);\r\n    gkDestroyTimer(updateAudioTimer);\r\n\r\n    /* free all SoundSources and SoundNodes */\r\n    while(p)\r\n    {\r\n        c = p;\r\n        p = p->next;\r\n\tc->source->state = GK_SOUND_STATE_IDLE;\t//Workaround-ish !\r\n        if(c->source->internal.autoDestroy)\r\n            gkDestroySoundSource(c->source);\r\n        removeSoundNode(c);\r\n    }\r\n\r\n    Audio.Cleanup();\r\n}\r\n\r\n\r\n/***\r\n    Sound creation and destruction\r\n*/\r\n\r\ngkSound* gkLoadSound(char* filename, int flags)\r\n{\r\n\tgkSound* sound = 0;\r\n\tgkAudioStream* stream = gkAudioStreamOpen(filename);\r\n\r\n\tif (stream) {\r\n\t\tgkAudioStreamInfo* info;\r\n\r\n\t\tsound = (gkSound*)malloc(sizeof(gkSound));\r\n\t\tsound->internal.flags = flags;\r\n\r\n\t\tinfo = &sound->internal.streamInfo;\r\n\r\n\t\tstream->getInfo(stream, info);\r\n\r\n\t\tsound->length = info->length;\r\n\r\n\t\tif ( flags & GK_SOUND_STATIC ) {\r\n\t\t\tchar* buf;\r\n\t\t\tbuf = (char*)malloc(info->streamSize);\r\n\t\t\tstream->read(stream, buf, info->streamSize);\r\n\r\n\t\t\tsound->internal.buffers[0] = \r\n\t\t\t\tAudio.CreateBuffer(info->format, info->sampleRate, GK_FALSE);\r\n\r\n\t\t\tAudio.Buffer.SetData(sound->internal.buffers[0], \r\n\t\t\t\tbuf, info->streamSize);\r\n\r\n\t\t\tsound->seekable = GK_TRUE;\r\n\r\n\t\t\tfree(buf);\r\n\t\t\tgkAudioStreamClose(stream);\r\n\t\t} else if( flags & GK_SOUND_STREAM ) {\r\n\t\t\tint i;\r\n\t\t\tsound->internal.stream = stream;\r\n\t\t\tsound->seekable = stream->seek != 0;\r\n\r\n\t\t\tfor (i = 0; i < GK_NUM_STREAM_BUFFERS; i++) {\r\n\t\t\t\tsound->internal.buffers[i] = \r\n\t\t\t\t\tAudio.CreateBuffer(info->format, info->sampleRate, GK_TRUE);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn sound;\r\n}\r\n\r\nvoid gkDestroySound(gkSound* sound)\r\n{\r\n\tint i, delBufferCount = 1;\r\n\r\n\tif (sound->internal.flags & GK_SOUND_STREAM )\r\n\t\tdelBufferCount = GK_NUM_STREAM_BUFFERS;\r\n\r\n\tfor (i = 0; i<delBufferCount; i++)\r\n\t\tAudio.DestroyBuffer(sound->internal.buffers[i]);\r\n\r\n\tfree(sound);\r\n}\r\n\r\ngkSoundSource* gkCreateSoundSource()\r\n{\r\n    gkSoundSource* source = (gkSoundSource*)malloc(sizeof(gkSoundSource));\r\n\r\n    gkInitDispatcher(&source->dispatcher);\r\n\r\n    source->internal.player = Audio.CreatePlayer();\r\n\r\n    source->internal.autoDestroy = GK_FALSE;\r\n\r\n    source->state = GK_SOUND_STATE_IDLE;\r\n    source->sound = 0;\r\n    source->internal.looping = GK_FALSE;\r\n\r\n    return source;\r\n}\r\n\r\nvoid gkDestroySoundSource(gkSoundSource* source)\r\n{\r\n\tif (source->state != GK_SOUND_STATE_IDLE) {\r\n\t\tstruct gkSoundNode* node = findSoundNode(source);\r\n\t\tif (node)\r\n\t\t\tremoveSoundNode(node);\r\n\t}\r\n\tgkCleanupDispatcher(&source->dispatcher);\r\n\tAudio.DestroyPlayer(source->internal.player);\r\n\tfree(source);\r\n}\r\n\r\n/***\r\n    Sound properties\r\n*/\r\n\r\nvoid gkSetSoundGain(gkSoundSource* source, float gain)\r\n{\r\n\tAudio.Player.SetVolume(source->internal.player, volToDb(gain));\r\n}\r\n\r\nfloat gkGetSoundGain(gkSoundSource* source)\r\n{\r\n\treturn dbToVol(Audio.Player.GetVolume(source->internal.player));\r\n}\r\n\r\nvoid gkSetSoundPitch(gkSoundSource* source, float pitch)\r\n{\r\n\tupdateTimeOffset(source, gkMilliseconds());\r\n\tAudio.Player.SetPitch(source->internal.player, pitch);\r\n}\r\n\r\nfloat gkGetSoundPitch(gkSoundSource* source)\r\n{\r\n\treturn Audio.Player.GetPitch(source->internal.player);\r\n}\r\n\r\nvoid gkSetSoundLooping(gkSoundSource* source, GK_BOOL looping)\r\n{\r\n    source->internal.looping = looping;\r\n    if(source->state != GK_SOUND_STATE_IDLE)\r\n\t    Audio.Player.SetLooping(source->internal.player, looping);\r\n}\r\n\r\nGK_BOOL gkIsSoundLooping(gkSoundSource* source)\r\n{\r\n    return source->internal.looping;\r\n}\r\n\r\nvoid gkSetSoundOffset(gkSoundSource* source, float seconds)\r\n{\r\n    if(source->sound == 0 || !source->sound->seekable) return;\r\n    if(source->sound->internal.flags & GK_SOUND_STATIC)\r\n    {\r\n\t    Audio.Player.SetOffset(source->internal.player, seconds);\r\n    }else\r\n    {\r\n        gkAudioStream* stream = source->sound->internal.stream;\r\n        gkAudioStreamInfo* info = &source->sound->internal.streamInfo;\r\n        int pos = (int)((float)info->sampleRate*seconds);\r\n\r\n        stream->seek(stream, pos, SEEK_SET);\r\n\r\n\tAudio.Player.Stop(source->internal.player);\r\n        fillQueue(source, GK_NUM_STREAM_BUFFERS, source->sound->internal.buffers);\r\n\tAudio.Player.Play(source->internal.player);\r\n\r\n\tif (source->state == GK_SOUND_STATE_PAUSED) \r\n\t\tAudio.Player.Pause(source->internal.player);\r\n\r\n        source->internal.currentOffset = (int)(seconds*1000.0f);\r\n        source->internal.lastOffset = gkMilliseconds();\r\n    }\r\n}\r\n\r\nfloat gkGetSoundOffset(gkSoundSource* source)\r\n{\r\n    if(source->sound == 0) \r\n\t    return 0;\r\n\r\n    if(source->sound->internal.flags & GK_SOUND_STATIC)\r\n\t    return Audio.Player.GetOffset(source->internal.player);\r\n\r\n    return (float)source->internal.currentOffset*0.001f;\r\n}\r\n\r\n/***\r\n    Listener properties\r\n*/\r\n\r\nvoid gkSetMasterGain(float gain)\r\n{\r\n\tAudio.SetVolume(volToDb(gain));\r\n}\r\n\r\nfloat gkGetMasterGain()\r\n{\r\n\treturn dbToVol(Audio.GetVolume());\r\n}\r\n\r\n/***\r\n    Playback control\r\n*/\r\n\r\ngkSoundSource* gkPlaySound(gkSound* sound, gkSoundSource* source)\r\n{\r\n\tif (source == 0) {\r\n\t\tsource = gkCreateSoundSource();\r\n\t\tsource->internal.autoDestroy = GK_TRUE;\r\n\t}\r\n\r\n\tsource->sound = sound;\r\n\tsource->internal.currentOffset = 0;\r\n\tsource->internal.lastOffset = gkMilliseconds();\r\n\r\n\tif (sound->internal.flags & GK_SOUND_STREAM) {\r\n\t\tgkAudioStream* stream = sound->internal.stream;\r\n\t\tstream->seek(stream, 0, SEEK_SET);\r\n\t\tAudio.Player.SetLooping(source->internal.player, GK_FALSE);\r\n\t\tfillQueue(source, GK_NUM_STREAM_BUFFERS, sound->internal.buffers);\r\n\t} else {\r\n\t\tAudio.Player.SetLooping(source->internal.player, source->internal.looping);\r\n\t\tAudio.Player.SetBuffer(source->internal.player, sound->internal.buffers[0]);\r\n\t}\r\n\tAudio.Player.Play(source->internal.player);\r\n\r\n\tsource->state = GK_SOUND_STATE_PLAYING;\r\n\r\n\taddSoundNode(source);\r\n\r\n\treturn source;\r\n}\r\n\r\nvoid gkPauseSound(gkSoundSource* source)\r\n{\r\n    updateTimeOffset(source, gkMilliseconds());\r\n    source->state = GK_SOUND_STATE_PAUSED;\r\n    Audio.Player.Pause(source->internal.player);\r\n}\r\n\r\nvoid gkResumeSound(gkSoundSource* source)\r\n{\r\n    source->state = GK_SOUND_STATE_PLAYING;\r\n    source->internal.lastOffset = gkMilliseconds();\r\n    Audio.Player.Play(source->internal.player);\r\n}\r\n\r\nvoid gkStopSound(gkSoundSource* source, GK_BOOL dispatchStopEvent)\r\n{\r\n\tstruct gkSoundNode* node = soundNodes;\r\n\tgkAudioPlayerState state = Audio.Player.GetState(source->internal.player);\r\n\r\n\tif(state != GK_AUDIOPLAYER_STOPPED)\r\n\t\tAudio.Player.Stop(source->internal.player);\r\n\telse\r\n\t\treturn;\r\n\r\n\twhile (node) {\r\n\t\tif(node->source == source) break;\r\n\t\tnode = node->next;\r\n\t}\r\n\r\n\tsoundSourceStopped(node, dispatchStopEvent);\r\n}\r\n\r\n/***\r\n    Sound system heartbeat\r\n*/\r\n\r\nstatic void updateStream(gkSoundSource* source)\r\n{\r\n\tgkSound* sound = source->sound;\r\n\tint processed, queued;\r\n\r\n\tAudio.Player.GetQueueState(source->internal.player, &processed, &queued);\r\n\r\n\tif (queued<GK_NUM_STREAM_BUFFERS)\r\n\t\tfillQueue(source, (GK_NUM_STREAM_BUFFERS - queued), sound->internal.buffers + queued);\r\n\r\n\tif (processed > 0) {\r\n\t\tint i, u;\r\n\t\tgkAudioBuffer *buffers = sound->internal.buffers;\r\n\r\n\t\tAudio.Player.UnqueueBuffers(source->internal.player, \r\n\t\t\tprocessed, buffers);\r\n\r\n\t\t/* refill */\r\n\t\tfillQueue(source, processed, buffers);\r\n\r\n\t\t/* rotate buffer */\r\n\t\tfor (i = 0; i<processed; i++) {\r\n\t\t\tgkAudioBuffer tmp = buffers[0];\r\n\t\t\tfor (u = 1; u < GK_NUM_STREAM_BUFFERS; u++) \r\n\t\t\t\tbuffers[u-1] = buffers[u];\r\n\t\t\tbuffers[GK_NUM_STREAM_BUFFERS-1] = tmp;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void soundSourceStopped(struct gkSoundNode* node, GK_BOOL dispatchStopEvent)\r\n{\r\n\tgkSoundSource* source = node->source;\r\n\r\n\tsource->state = GK_SOUND_STATE_IDLE;\r\n\r\n\tAudio.Player.SetBuffer(source->internal.player, 0);\r\n\r\n\tif (dispatchStopEvent) {\r\n\t\tgkEvent evt;\r\n\t\tevt.type = GK_ON_SOUND_STOPPED;\r\n\t\tevt.target = source;\r\n\t\tgkDispatch(source, &evt);\r\n\t}\r\n\tsource->sound = 0;\r\n\r\n\tif(source->internal.autoDestroy)\r\n\t\tgkDestroySoundSource(source);\r\n\r\n\tremoveSoundNode(node);\r\n}\r\n\r\nstatic GK_BOOL updateAudio(gkEvent* event, void* param)\r\n{\r\n    struct gkSoundNode* p, *curNode;\r\n    gkAudioPlayerState state;\r\n    uint64_t millis = gkMilliseconds();\r\n\r\n    if(soundNodes != 0)\r\n    {\r\n        p = soundNodes;\r\n        while(p)\r\n        {\r\n            gkSoundSource* source = p->source;\r\n            curNode = p;\r\n            p = p->next;\r\n\r\n            if( (source->state == GK_SOUND_STATE_PLAYING) &&\r\n               (source->sound->internal.flags & GK_SOUND_STREAM) )\r\n            {\r\n                updateTimeOffset(source, millis);\r\n                updateStream(source);\r\n            }\r\n\r\n\t    state = Audio.Player.GetState(source->internal.player);\r\n\r\n\t    if (state == GK_AUDIOPLAYER_STOPPED)\r\n                soundSourceStopped(curNode, GK_TRUE);\r\n        }\r\n    }\r\n    return GK_TRUE;\r\n}","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n\r\n#include <gk.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#include \"gkStream.h\"\r\n#include \"gkConfig.h\"\r\n#include \"gkAudioInternal.h\"\r\n\r\nstatic int getAudioFormat(int channels, int bitsPerSample)\r\n{\r\n    if(channels == 1)\r\n    {\r\n        switch(bitsPerSample)\r\n        {\r\n            case 8: return GK_AUDIO_FORMAT_MONO8;\r\n            case 16: return GK_AUDIO_FORMAT_MONO16;\r\n            case 32: return GK_AUDIO_FORMAT_MONO32;\r\n        }\r\n    }else if(channels == 2)\r\n    {\r\n        switch(bitsPerSample)\r\n        {\r\n            case 8: return GK_AUDIO_FORMAT_STEREO8;\r\n            case 16: return GK_AUDIO_FORMAT_STEREO16;\r\n            case 32: return GK_AUDIO_FORMAT_STEREO32;\r\n        }\r\n    }\r\n    return GK_AUDIO_FORMAT_UNSUPPORTED;\r\n}\r\n\r\n/* WAV stream */\r\n\r\nstruct wavHeader{\r\n    char riff[4];\r\n    uint32_t chunkSize;\r\n    char wave[4];\r\n    char fmt[4];\r\n    uint32_t subchunkSize;\r\n    uint16_t audioFormat;\r\n    uint16_t numChannels;\r\n    uint32_t sampleRate;\r\n    uint32_t byteRate;\r\n    uint16_t blockAlign;\r\n    uint16_t bitsPerSample;\r\n    char data[4];\r\n    uint32_t dataSize;\r\n};\r\n\r\ntypedef struct _gkWavAudioStream gkWavAudioStream;\r\nstruct _gkWavAudioStream{\r\n    gkAudioStream base;\r\n    gkStream* handle;\r\n    size_t startOffset;\r\n    gkAudioStreamInfo info;\r\n};\r\n\r\nstatic int readWavStream(gkAudioStream* stream, void* buffer, size_t bytes);\r\nstatic int seekWavStream(gkAudioStream* stream, size_t offset, int origin);\r\nstatic void getWavStreamInfo(gkAudioStream* stream, gkAudioStreamInfo* info);\r\nstatic int eofWavStream(gkAudioStream* stream);\r\nstatic void destroyWavAudioStream(gkAudioStream* stream);\r\n\r\nstatic gkAudioStream* createWavAudioStream(char* location)\r\n{\r\n    gkWavAudioStream* stream = (gkWavAudioStream*)malloc(sizeof(gkWavAudioStream));\r\n    struct wavHeader header;\r\n    stream->handle = gkOpenFile(location, \"rb\");\r\n    if(stream->handle)\r\n    {\r\n\t\tgkStreamRead(stream->handle, &header, sizeof(header));\r\n\t\r\n\t\tchar* subchunk = header.data;\r\n\t\twhile (strncmp(subchunk, \"data\", 4) != 0) {\r\n\t\t\tgkStreamSeek(stream->handle, header.dataSize, GK_SEEK_CUR);\r\n\t\t\tgkStreamRead(stream->handle, subchunk, sizeof(uint32_t)*2);\r\n\t\t}\r\n\t\r\n\t\tstream->startOffset = gkStreamTell(stream->handle);\r\n\t\r\n        if(header.audioFormat == 1)\r\n        {\r\n            stream->info.sampleRate = header.sampleRate;\r\n            stream->info.streamSize = header.dataSize;\r\n            stream->info.length = (float)header.dataSize/(float)header.byteRate;\r\n            stream->info.format = getAudioFormat(header.numChannels, header.bitsPerSample);\r\n            stream->info.channels = header.numChannels;\r\n            stream->info.bitsPerSample = header.bitsPerSample;\r\n            stream->base.read = readWavStream;\r\n            stream->base.seek = seekWavStream;\r\n            stream->base.getInfo = getWavStreamInfo;\r\n            stream->base.eof = eofWavStream;\r\n            stream->base.destroy = destroyWavAudioStream;\r\n            return (gkAudioStream*)stream;\r\n        }\r\n\tgkStreamClose(stream->handle);\r\n    }\r\n    free(stream);\r\n    return 0;\r\n}\r\n\r\nstatic void destroyWavAudioStream(gkAudioStream* s)\r\n{\r\n    gkWavAudioStream* stream = (gkWavAudioStream*)s;\r\n    gkStreamClose(stream->handle);\r\n    free(stream);\r\n}\r\n\r\nstatic void getWavStreamInfo(gkAudioStream* s, gkAudioStreamInfo* info)\r\n{\r\n    memcpy(info, &((gkWavAudioStream*)s)->info, sizeof(gkAudioStreamInfo));\r\n}\r\n\r\nstatic int readWavStream(gkAudioStream* s, void* buffer, size_t bytes)\r\n{\r\n    gkWavAudioStream* stream = (gkWavAudioStream*)s;\r\n    return gkStreamRead(stream->handle, buffer, sizeof(char) * bytes);\r\n}\r\n\r\nstatic int seekWavStream(gkAudioStream* s, size_t sampleOffset, int origin)\r\n{\r\n    gkWavAudioStream* stream = (gkWavAudioStream*)s;\r\n    sampleOffset *= (stream->info.bitsPerSample/8)*stream->info.channels;\r\n    if(origin == GK_SEEK_SET)\r\n    {\r\n        sampleOffset = sampleOffset + stream->startOffset;\r\n    }\r\n    return gkStreamSeek(stream->handle, sampleOffset, origin);\r\n}\r\n\r\nstatic int eofWavStream(gkAudioStream* s)\r\n{\r\n    gkWavAudioStream* stream = (gkWavAudioStream*)s;\r\n    return gkStreamEnd(stream->handle);\r\n}\r\n\r\n\r\n/* MP3 stream through libmpg123 */\r\n\r\n#ifdef GK_USE_MPG123\r\n\r\n#define GK_MP3_SUPPORT\r\n\r\n#include <mpg123.h>\r\n\r\ntypedef struct _gkMp3AudioStream gkMp3AudioStream;\r\nstruct _gkMp3AudioStream{\r\n    gkAudioStream base;\r\n    mpg123_handle* handle;\r\n    GK_BOOL eof;\r\n};\r\n\r\nstatic int readMp3Stream(gkAudioStream* stream, void* buffer, size_t bytes);\r\nstatic int seekMp3Stream(gkAudioStream* stream, size_t offset, int origin);\r\nstatic void getMp3StreamInfo(gkAudioStream* stream, gkAudioStreamInfo* info);\r\nstatic int eofMp3Stream(gkAudioStream* stream);\r\nstatic void destroyMp3AudioStream(gkAudioStream* stream);\r\n\r\nstatic gkAudioStream* createMp3AudioStream(char* location)\r\n{\r\n    gkMp3AudioStream* stream = (gkMp3AudioStream*)malloc(sizeof(gkMp3AudioStream));\r\n    stream->handle = mpg123_new(0, 0);\r\n    stream->eof = GK_FALSE;\r\n    mpg123_open(stream->handle, location);\r\n    stream->base.read = readMp3Stream;\r\n    stream->base.seek = seekMp3Stream;\r\n    stream->base.getInfo = getMp3StreamInfo;\r\n    stream->base.eof = eofMp3Stream;\r\n    stream->base.destroy = destroyMp3AudioStream;\r\n    return (gkAudioStream*)stream;\r\n}\r\n\r\nstatic void destroyMp3AudioStream(gkAudioStream* s)\r\n{\r\n    gkMp3AudioStream* stream = (gkMp3AudioStream*)s;\r\n    mpg123_close(stream->handle);\r\n    mpg123_delete(stream->handle);\r\n    free(stream);\r\n}\r\n\r\nstatic void getMp3StreamInfo(gkAudioStream* s, gkAudioStreamInfo* info)\r\n{\r\n    gkMp3AudioStream* stream = (gkMp3AudioStream*)s;\r\n\tint channels, encoding, bitsPerSample;\r\n\tlong sampleRate, totalSamples;\r\n\r\n\tmpg123_getformat(stream->handle, &sampleRate, &channels, &encoding);\r\n\r\n\tif(( encoding&MPG123_ENC_32) == MPG123_ENC_32)\r\n\t\tbitsPerSample = 32;\r\n\telse if( (encoding&MPG123_ENC_16) == MPG123_ENC_16)\r\n\t\tbitsPerSample = 16;\r\n\telse if( (encoding&MPG123_ENC_8) == MPG123_ENC_8)\r\n\t\tbitsPerSample = 8;\r\n\r\n    totalSamples = mpg123_length(stream->handle);\r\n    info->format = getAudioFormat(channels, bitsPerSample);\r\n    info->channels = channels;\r\n    info->bitsPerSample = bitsPerSample;\r\n    info->sampleRate = sampleRate;\r\n    info->length = (float)totalSamples/(float)sampleRate;\r\n    info->streamSize = totalSamples*(bitsPerSample*channels)/8;\r\n}\r\n\r\nstatic int readMp3Stream(gkAudioStream* s, void* buffer, size_t bytes)\r\n{\r\n    gkMp3AudioStream* stream = (gkMp3AudioStream*)s;\r\n    size_t bytesRead;\r\n    int res = mpg123_read(stream->handle, buffer, bytes, &bytesRead);\r\n    if(res == MPG123_DONE) stream->eof = GK_TRUE;\r\n    return bytesRead;\r\n}\r\n\r\nstatic int seekMp3Stream(gkAudioStream* s, size_t sampleOffset, int origin)\r\n{\r\n    gkMp3AudioStream* stream = (gkMp3AudioStream*)s;\r\n    off_t streamOffset = mpg123_seek(stream->handle, sampleOffset, origin);\r\n    stream->eof = GK_FALSE;\r\n    if(streamOffset>=0) return 0;\r\n    return streamOffset;\r\n}\r\n\r\nstatic int eofMp3Stream(gkAudioStream* s)\r\n{\r\n    gkMp3AudioStream* stream = (gkMp3AudioStream*)s;\r\n    return stream->eof;\r\n}\r\n\r\n#endif\r\n\r\n/**/\r\n/* OGG stream through libvorbisfile */\r\n\r\n#ifdef GK_USE_OGGVORBIS\r\n\r\n#define GK_OGG_SUPPORT\r\n\r\n#include <vorbis/vorbisfile.h>\r\n\r\ntypedef struct _gkOggAudioStream gkOggAudioStream;\r\nstruct _gkOggAudioStream{\r\n    gkAudioStream base;\r\n    OggVorbis_File handle;\r\n    GK_BOOL eof;\r\n};\r\n\r\nstatic int readOggStream(gkAudioStream* stream, void* buffer, size_t bytes);\r\nstatic int seekOggStream(gkAudioStream* stream, size_t offset, int origin);\r\nstatic void getOggStreamInfo(gkAudioStream* stream, gkAudioStreamInfo* info);\r\nstatic int eofOggStream(gkAudioStream* stream);\r\nstatic void destroyOggAudioStream(gkAudioStream* stream);\r\n\r\nstatic gkAudioStream* createOggAudioStream(char* location)\r\n{\r\n    gkOggAudioStream* stream = (gkOggAudioStream*)malloc(sizeof(gkOggAudioStream));\r\n    if(ov_fopen(location, &stream->handle) != 0)\r\n    {\r\n        free(stream);\r\n        return 0;\r\n    }\r\n    stream->eof = GK_FALSE;\r\n    stream->base.read = readOggStream;\r\n\r\n    if(ov_seekable(&stream->handle) != 0)\r\n        stream->base.seek = seekOggStream;\r\n    else stream->base.seek = 0;\r\n\r\n    stream->base.getInfo = getOggStreamInfo;\r\n    stream->base.eof = eofOggStream;\r\n    stream->base.destroy = destroyOggAudioStream;\r\n    return (gkAudioStream*)stream;\r\n}\r\n\r\nstatic void destroyOggAudioStream(gkAudioStream* s)\r\n{\r\n    gkOggAudioStream* stream = (gkOggAudioStream*)s;\r\n    ov_clear(&stream->handle);\r\n    free(stream);\r\n}\r\n\r\nstatic void getOggStreamInfo(gkAudioStream* s, gkAudioStreamInfo* info)\r\n{\r\n    gkOggAudioStream* stream = (gkOggAudioStream*)s;\r\n    vorbis_info* vinfo = ov_info(&stream->handle, -1);\r\n\r\n\tuint64_t totalSamples = ov_pcm_total(&stream->handle, -1);\r\n    info->channels = vinfo->channels;\r\n    info->bitsPerSample = 16;\r\n    info->format = getAudioFormat(info->channels, info->bitsPerSample);\r\n    info->sampleRate = vinfo->rate;\r\n    info->length = ov_time_total(&stream->handle, -1);\r\n    info->streamSize = totalSamples*(info->bitsPerSample*info->channels)/8;\r\n}\r\n\r\nstatic int readOggStream(gkAudioStream* s, void* buffer, size_t bytes)\r\n{\r\n    gkOggAudioStream* stream = (gkOggAudioStream*)s;\r\n    int currentSection;\r\n    size_t offset = 0;\r\n    while(offset<bytes)\r\n    {\r\n        size_t bytesRead = ov_read(&stream->handle, (char*)buffer + offset, bytes - offset, 0, 2, 1, &currentSection);\r\n        if(bytesRead == 0)\r\n        {\r\n            stream->eof = GK_TRUE;\r\n            break;\r\n        }\r\n        if(bytesRead<0)\r\n        {\r\n            break;\r\n        }\r\n        offset += bytesRead;\r\n    }\r\n    return offset;\r\n}\r\n\r\nstatic int seekOggStream(gkAudioStream* s, size_t sampleOffset, int origin)\r\n{\r\n    gkOggAudioStream* stream = (gkOggAudioStream*)s;\r\n    if(origin == SEEK_CUR)\r\n        sampleOffset += ov_pcm_tell(&stream->handle);\r\n    else if(origin == SEEK_END)\r\n        sampleOffset = ov_pcm_total(&stream->handle, -1) - sampleOffset;\r\n    if(ov_pcm_seek(&stream->handle, sampleOffset) == 0)\r\n    {\r\n        stream->eof = GK_FALSE;\r\n        return sampleOffset;\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic int eofOggStream(gkAudioStream* s)\r\n{\r\n    gkOggAudioStream* stream = (gkOggAudioStream*)s;\r\n    return stream->eof;\r\n}\r\n\r\n#endif\r\n\r\n/* End of stream types */\r\n\r\n\r\nvoid gkInitAudioStream()\r\n{\r\n#ifdef GK_USE_MPG123\r\n    mpg123_init();\r\n#endif\r\n}\r\n\r\nvoid gkCleanupAudioStream()\r\n{\r\n#ifdef GK_USE_MPG123\r\n    mpg123_exit();\r\n#endif\r\n}\r\n\r\ngkAudioStream* gkAudioStreamOpen(char* location)\r\n{\r\n\tchar* ext = location + (strlen(location) - 3);\r\n\tif(stricmp(ext,\"wav\") == 0)\r\n\t\treturn createWavAudioStream(location);\r\n#ifdef GK_MP3_SUPPORT\r\n\telse if(stricmp(ext, \"mp3\") == 0)\r\n\t\treturn createMp3AudioStream(location);\r\n#endif\r\n#ifdef GK_OGG_SUPPORT\r\n\telse if(stricmp(ext, \"ogg\") == 0)\r\n\t\treturn createOggAudioStream(location);\r\n#endif\r\n\treturn 0;\r\n}\r\n\r\nvoid gkAudioStreamClose(gkAudioStream* stream)\r\n{\r\n    stream->destroy(stream);\r\n}\r\n","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include \"gkAudioSystem.h\"\r\n\r\n#ifdef GK_USE_OPENAL\r\n\r\n#pragma comment(lib,\"OpenAL32.lib\")\r\n\r\n#include <AL/al.h>\r\n#include <AL/alc.h>\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#include <math.h>\r\n\r\n/* Amplitude Ratio (volume) to Decibel */\r\nstatic float VolumeToDb(float v)\r\n{\r\n\tif (v == 0)\r\n\t\treturn -100.0f;\r\n\treturn 20.0f*log10f(v);\r\n}\r\n\r\n/* Decibel to Amplitude Ratio (volume)*/\r\nstatic float DbToVolume(float db)\r\n{\r\n\tif (db <= -100.0f)\r\n\t\treturn 0.0f;\r\n\treturn powf(10.0f, db/20.0f);\r\n}\r\n\r\n#define STR(x)\t#x\r\n#define TOSTRING(x)\tSTR(x)\r\n#define CHECK_ERROR(fun)\tcheckError(STR(fun)\" at \"TOSTRING(__LINE__))\r\n\r\nstatic uint32_t checkError(char* func)\r\n{\r\n\tint err; \r\n\tif((err = alGetError()) != AL_NO_ERROR) \r\n\t\tprintf(\"GK [ERROR]: in %s -  AL Error: %X\\n\", func, err);\r\n\treturn err;\r\n}\r\n\r\nstatic uint32_t checkErrorNoArg()\r\n{\r\n\treturn checkError(\"out\");\r\n}\r\n\r\n\r\nstatic ALCdevice* device;\r\nstatic ALCcontext* ctx;\r\n\r\nstatic void initOpenAL()\r\n{\r\n\tint major, minor;\r\n\talcGetIntegerv(NULL, ALC_MAJOR_VERSION, 1, &major);\r\n\talcGetIntegerv(NULL, ALC_MAJOR_VERSION, 1, &minor);\r\n\t\r\n\tprintf(\"GK [INFO]: ALC version: %i.%i\\n\", major, minor);\r\n\r\n\tif (device = alcOpenDevice(0)) {\r\n\t\tctx = alcCreateContext(device, NULL);\r\n\t\tif (ctx) {\r\n\t\t\talcMakeContextCurrent(ctx);\r\n\t\t} else {\r\n\t\t\talcCloseDevice(device);\r\n\t\t\tdevice = 0;\r\n\t\t\tprintf(\"GK [ERROR]: Failed to create audio context\");\r\n\t\t}\r\n\t} else {\r\n\t\tctx = 0;\r\n\t\tprintf(\"GK [ERROR]: OpenAL: Failed to open device\\n\");\r\n\t}\r\n}\r\n\r\nstatic void cleanupOpenAL()\r\n{\r\n\tif (ctx)\r\n\t\talcDestroyContext(ctx);\r\n\tif (device)\r\n\t\talcCloseDevice(device);\r\n}\r\n\r\ntypedef struct gkAudioBufferData{\r\n\tALuint alBuffer;\r\n\tint format;\r\n\tint sampleRate;\r\n}gkAudioBufferData;\r\n\r\nstatic gkAudioBuffer CreateBuffer(int format, int sampleRate, GK_BOOL streaming)\r\n{\r\n\tgkAudioBufferData* data = (gkAudioBufferData*)malloc(sizeof(gkAudioBufferData));\r\n\tdata->format = format;\r\n\tdata->sampleRate = sampleRate;\r\n\talGenBuffers(1, &data->alBuffer);\r\n\treturn data;\r\n}\r\n\r\nstatic void DestroyBuffer(gkAudioBuffer buffer)\r\n{\r\n\talDeleteBuffers(1, &buffer->alBuffer);\r\n\tfree(buffer);\r\n}\r\n\r\nstatic uint32_t SetBufferData(gkAudioBuffer buffer, const void* data, size_t dataSize)\r\n{\r\n\talBufferData(buffer->alBuffer, buffer->format, data, dataSize, buffer->sampleRate);\r\n\tprintf(\"SetBufferData format: %X  size: %d  sampleRate: %d\\n\", buffer->format, dataSize, buffer->sampleRate);\r\n\treturn CHECK_ERROR(alBufferData);\r\n}\r\n\r\ntypedef struct gkAudioPlayerData{\r\n\tALuint alSource;\r\n}gkAudioPlayerData;\r\n\r\nstatic gkAudioPlayer CreatePlayer()\r\n{\r\n\tgkAudioPlayerData* data = (gkAudioPlayerData*)malloc(sizeof(gkAudioPlayerData));\r\n\talGenSources(1, &data->alSource);\r\n\talSourcei(data->alSource, AL_SOURCE_RELATIVE, 1);\r\n\talSource3f(data->alSource, AL_POSITION, 0,0,0);\r\n\tCHECK_ERROR(CreatePlayer);\r\n\treturn data;\r\n}\r\n\r\nstatic void DestroyPlayer(gkAudioPlayer player)\r\n{\r\n\talDeleteSources(1, &player->alSource);\r\n\tfree(player);\r\n}\r\n\r\nstatic void SetPlayerPitch(gkAudioPlayer player, float pitch)\r\n{\r\n\talSourcef(player->alSource, AL_PITCH, pitch);\r\n}\r\nstatic float GetPlayerPitch(gkAudioPlayer player)\r\n{\r\n\tfloat pitch;\r\n\talGetSourcef(player->alSource, AL_PITCH, &pitch);\r\n\treturn pitch;\r\n}\r\nstatic void SetPlayerVolume(gkAudioPlayer player, int vol)\r\n{\r\n\talSourcef(player->alSource, AL_GAIN, DbToVolume(((float)vol)/100.0f));\r\n\tCHECK_ERROR(alSourcef);\r\n}\r\nstatic int GetPlayerVolume(gkAudioPlayer player)\r\n{\r\n\tfloat vol;\r\n\talGetSourcef(player->alSource, AL_GAIN, &vol);\r\n\treturn (int)(VolumeToDb(vol)*100.0f);\r\n}\r\nstatic void SetPlayerLooping(gkAudioPlayer player, GK_BOOL looping)\r\n{\r\n    int type;\r\n\talGetSourcei(player->alSource, AL_SOURCE_TYPE, &type);\r\n    alSourcei(player->alSource, AL_LOOPING, (type == AL_STATIC) && looping);\r\n\tCHECK_ERROR(alGetSourcei);\r\n}\r\nstatic GK_BOOL IsPlayerLooping(gkAudioPlayer player)\r\n{\r\n\tALint looping;\r\n\talGetSourcei(player->alSource, AL_LOOPING, &looping);\r\n\treturn looping;\r\n}\r\nstatic void SetPlayerOffset(gkAudioPlayer player, float sec)\r\n{\r\n\talSourcef(player->alSource, AL_SEC_OFFSET, sec);\r\n}\r\nstatic float GetPlayerOffset(gkAudioPlayer player)\r\n{\r\n\tfloat sec;\r\n\talGetSourcef(player->alSource, AL_SEC_OFFSET, &sec);\r\n\treturn sec;\r\n}\r\nstatic void PlayerSetBufer(gkAudioPlayer player, gkAudioBuffer buffer)\r\n{\r\n\talSourcei(player->alSource, AL_BUFFER, buffer ? buffer->alBuffer : 0);\r\n}\r\nstatic uint32_t PlayerQueueBuffers(gkAudioPlayer player, int numBuffers, gkAudioBuffer* buffers)\r\n{\r\n\tint i;\r\n\tALint srcId = player->alSource;\r\n\tfor (i = 0; i < numBuffers; i++) \r\n\t\talSourceQueueBuffers(srcId, 1, &(buffers[i]->alBuffer));\r\n\treturn CHECK_ERROR(alSourceQueueBuffers);\r\n}\r\n\r\nstatic uint32_t PlayerUnqueueBuffers(gkAudioPlayer player, int numBuffers, gkAudioBuffer* buffers)\r\n{\r\n\tint i;\r\n\tALint srcId = player->alSource;\r\n\tfor (i = 0; i < numBuffers; i++) \r\n\t\talSourceUnqueueBuffers(srcId, 1, &(buffers[i]->alBuffer));\r\n\treturn CHECK_ERROR(alSourceUnqueueBuffers);\r\n}\r\nstatic uint32_t PlayerPlay(gkAudioPlayer player)\r\n{\r\n\talSourcePlay(player->alSource);\r\n\treturn CHECK_ERROR(alSourcePlay);\r\n}\r\nstatic uint32_t PlayerPause(gkAudioPlayer player)\r\n{\r\n\talSourcePause(player->alSource);\r\n\treturn CHECK_ERROR(alSourcePause);\r\n}\r\nstatic uint32_t PlayerStop(gkAudioPlayer player)\r\n{\r\n\talSourceStop(player->alSource);\r\n\talSourcei(player->alSource, AL_BUFFER, 0);\r\n\treturn CHECK_ERROR(alSourcei);\r\n}\r\nstatic gkAudioPlayerState PlayerGetState(gkAudioPlayer player)\r\n{\r\n\tALint alState;\r\n\talGetSourcei(player->alSource, AL_SOURCE_STATE, &alState);\r\n\r\n\tswitch (alState) {\r\n\tcase AL_PAUSED:\r\n\t\treturn GK_AUDIOPLAYER_PAUSED;\r\n\tcase AL_PLAYING:\r\n\t\treturn GK_AUDIOPLAYER_PLAYING;\r\n\tcase AL_STOPPED:\r\n\t\treturn GK_AUDIOPLAYER_STOPPED;\r\n\t}\r\n\treturn GK_AUDIOPLAYER_STOPPED;\r\n}\r\nstatic void PlayerGetQueueState(gkAudioPlayer player, int* processed, int* queued)\r\n{\r\n\talGetSourcei(player->alSource, AL_BUFFERS_PROCESSED, processed);\r\n\talGetSourcei(player->alSource, AL_BUFFERS_QUEUED, queued);\r\n}\r\n\r\nstatic void SetMasterVolume(int db)\r\n{\r\n\tfloat r = DbToVolume(((float)db)/100.0f);\r\n\talListenerf(AL_GAIN, r);\r\n}\r\nstatic int GetMasterVolume()\r\n{\r\n\tfloat vol;\r\n\talGetListenerf(AL_GAIN, &vol);\r\n\treturn (int)(VolumeToDb(vol)*100.0f);\r\n}\r\n\r\ngkAudioSystem gkGetAudioSystem()\r\n{\r\n\tgkAudioSystem audioSys;\r\n\r\n\taudioSys.minVolume = -6000.0f;\r\n\taudioSys.maxVolume = 0.0f;\r\n\r\n\taudioSys.Init = initOpenAL;\r\n\taudioSys.Cleanup = cleanupOpenAL;\r\n\taudioSys.CheckError = checkErrorNoArg;\r\n\taudioSys.CreateBuffer = CreateBuffer;\r\n\taudioSys.DestroyBuffer = DestroyBuffer;\r\n\taudioSys.Buffer.SetData = SetBufferData;\r\n\r\n\taudioSys.CreatePlayer = CreatePlayer;\r\n\taudioSys.DestroyPlayer = DestroyPlayer;\r\n\r\n\taudioSys.Player.SetPitch = SetPlayerPitch;\r\n\taudioSys.Player.GetPitch = GetPlayerPitch;\r\n\taudioSys.Player.SetVolume = SetPlayerVolume;\r\n\taudioSys.Player.GetVolume = GetPlayerVolume;\r\n\taudioSys.Player.SetLooping = SetPlayerLooping;\r\n\taudioSys.Player.IsLooping = IsPlayerLooping;\r\n\taudioSys.Player.SetOffset = SetPlayerOffset;\r\n\taudioSys.Player.GetOffset = GetPlayerOffset;\r\n\taudioSys.Player.SetBuffer = PlayerSetBufer;\r\n\taudioSys.Player.QueueBuffers = PlayerQueueBuffers;\r\n\taudioSys.Player.UnqueueBuffers = PlayerUnqueueBuffers;\r\n\taudioSys.Player.Play = PlayerPlay;\r\n\taudioSys.Player.Pause = PlayerPause;\r\n\taudioSys.Player.Stop = PlayerStop;\r\n\taudioSys.Player.GetState = PlayerGetState;\r\n\taudioSys.Player.GetQueueState = PlayerGetQueueState;\r\n\r\n\taudioSys.SetVolume = SetMasterVolume;\r\n\taudioSys.GetVolume = GetMasterVolume;\r\n\treturn audioSys;\r\n}\r\n\r\n#endif","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include <gk.h>\r\n\r\n#include <gkImage.h>\r\n#include <gkGraphics.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#include \"gk_internal.h\"\r\n#include \"gkGL.h\"\r\n\r\n/* \r\n\tThe idea behind this code is to draw anything to\r\n\ta 'buffer' and then copy the buffer content to the\r\n\ttexture. \r\n\r\n\tDifferent implementations using FBO, Aux buffers and Plain\r\n\ttextures are available. \r\n\r\n\tA much faster Draw To Texture is possible if using FBOs\r\n\tthe \"right\" way (attaching target texture as color attachment) but\r\n\tthat requires the FBO to be initialized specifically for the texture.\r\n*/\r\n\r\ngkImage* gkImageToDraw = 0;\r\ngkColorNode* gkOldColorFilterTop;\r\ngkTransformNode* gkOldTransformTop;\r\nGLint gkOldViewport[4];\r\n\r\nstruct gkDrawToImageImplementation\r\n{\r\n\tvoid (*initBuffer)(gkSize size);\r\n\tvoid (*cleanBuffer)();\r\n\tvoid (*beginDraw)();\r\n\tvoid (*endDraw)();\r\n}*gkDTI = 0;\r\n\r\nvoid gkInitDTI();\r\n\r\nvoid gkInitDrawToImageBuffer(gkSize size)\r\n{\r\n\tif (gkDTI == 0)\r\n\t\tgkInitDTI();\r\n\r\n\tgkDTI->initBuffer(size);\r\n}\r\n\r\nvoid gkCleanupDrawToImageBuffer()\r\n{\r\n\tif (gkDTI != 0)\r\n\t\tgkDTI->cleanBuffer();\r\n}\r\n\r\nGK_BOOL gkBeginDrawToImage(gkImage* img, GK_BOOL clear)\r\n{\r\n\tif(gkImageToDraw != 0) \r\n\t\treturn GK_FALSE;\r\n\r\n\tgkImageToDraw = img;\r\n\r\n\t/* Save the current graphics state before drawing begins */\r\n\r\n\tglGetIntegerv(GL_VIEWPORT, gkOldViewport);\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglPushMatrix();\r\n\tglMatrixMode(GL_MODELVIEW);\r\n\tglPushMatrix();\r\n\r\n\t/* Set render target to preallocated buffer */\r\n\tgkDTI->beginDraw();\r\n\r\n\tglViewport(0,0, (GLsizei)img->width, (GLsizei)img->height);\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglLoadIdentity();\r\n\tglOrtho(0,(int)img->width,0,(int)img->height, -1, 1);\r\n\tglMatrixMode(GL_MODELVIEW);\r\n\tglLoadIdentity();\r\n\r\n\tglClearColor(0,0,0,0);\r\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\tglEnable(GL_BLEND);\r\n\r\n\r\n\tgkOldColorFilterTop = gkColorFilterTop;\r\n\tgkColorFilterTop = (gkColorNode*)malloc(sizeof(gkColorNode));\r\n\tgkColorFilterTop->parent = 0;\r\n\tgkColorFilterTop->color = GK_COLOR(1,1,1,1);\r\n\r\n\tgkOldTransformTop = gkTransformTop;\r\n\tgkTransformTop = (gkTransformNode*)malloc(sizeof(gkTransformNode));\r\n\tgkTransformTop->parent = 0;\r\n\tgkTransformTop->transform = gkMatrixCreateIdentity();\r\n\r\n\tglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\r\n\r\n\tif(!clear)\t\r\n\t\tgkDrawImage(gkImageToDraw, 0.0f, 0.0f);\r\n\r\n\treturn GK_TRUE;\r\n}\r\n\r\nvoid gkEndDrawToImage()\r\n{\r\n\tgkColorNode *colorNode;\r\n\tgkTransformNode *transformNode;\r\n\r\n\tif (gkImageToDraw == 0) {\r\n\t\tprintf(\"GK [ERROR]: No target image to draw to\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tglDisable(GL_BLEND);\r\n\r\n\tglBindTexture(GL_TEXTURE_2D, gkImageToDraw->id);\r\n\tglCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, (int)gkImageToDraw->width, (int)gkImageToDraw->height);\r\n\r\n\t/* Restore graphics state */\r\n\tglViewport(gkOldViewport[0], gkOldViewport[1], gkOldViewport[2], gkOldViewport[3]);\r\n\tglEnable(GL_BLEND);\r\n\tglMatrixMode(GL_MODELVIEW);\r\n\tglPopMatrix();\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglPopMatrix();\r\n\r\n\t/* Reset render target to default frame buffer */\r\n\tgkDTI->endDraw();\r\n\r\n\twhile (gkColorFilterTop->parent) {\r\n\t\tgkColorFilterTop = (colorNode = gkColorFilterTop)->parent;\r\n\t\tfree(colorNode);\r\n\t}\r\n\tfree(gkColorFilterTop);\r\n\tgkColorFilterTop = gkOldColorFilterTop;\r\n\r\n\twhile (gkTransformTop->parent) {\r\n\t\tgkTransformTop = (transformNode = gkTransformTop)->parent;\r\n\t\tfree(transformNode);\r\n\t}\r\n\tfree(gkTransformTop);\r\n\tgkTransformTop = gkOldTransformTop;\r\n\r\n\tglMatrixMode(GL_MODELVIEW);\r\n\r\n\tgkImageToDraw = 0;\r\n}\r\n\r\n/* Begin implementations */\r\n\r\n/*\r\n\tFBO Draw to image implementation \r\n*/\r\n\r\nGLuint imgFramebufferId = 0;\r\nGLuint imgRenderbuffers[2];\r\n\r\nvoid gkDTIInitBufferFBO(gkSize size)\r\n{\r\n\tGLuint status;\r\n\tglGenFramebuffers(1, &imgFramebufferId);\r\n\tglBindFramebuffer(GL_FRAMEBUFFER, imgFramebufferId);\r\n\r\n\tglGenRenderbuffers(2, imgRenderbuffers);\r\n\tglBindRenderbuffer(GL_RENDERBUFFER, imgRenderbuffers[0]);\r\n\tglRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA, (int)size.width, (int)size.height);\r\n\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, imgRenderbuffers[0]);\r\n\r\n\tglBindRenderbuffer(GL_RENDERBUFFER, imgRenderbuffers[1]);\r\n\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, (int)size.width, (int)size.height);\r\n\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, imgRenderbuffers[1]);\r\n\t\t\r\n\tstatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\r\n\tif(status != GL_FRAMEBUFFER_COMPLETE){\r\n\t\tswitch(status){\r\n\t\t\tcase GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\r\n\t\t\t\tprintf(\"GK [ERROR]: InitDrawToImageBuffer GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\r\n\t\t\t\tprintf(\"GK [ERROR]: InitDrawToImageBuffer GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase GL_FRAMEBUFFER_UNSUPPORTED:\r\n\t\t\t\tprintf(\"GK [ERROR]: InitDrawToImageBuffer GL_FRAMEBUFFER_UNSUPPORTED_EXT\\n\");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\r\n\t\tglDeleteRenderbuffers(2, imgRenderbuffers);\r\n\t\tglDeleteFramebuffers(1, &imgFramebufferId);\r\n\t\timgFramebufferId = 0;\r\n\r\n\t\tprintf(\"GK [INFO]: FBO initialization failed\\n\");\r\n\t}\r\n\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\r\n}\r\n\r\nvoid gkDTICleanBufferFBO()\r\n{\r\n\tif(imgFramebufferId){\r\n\t\tglDeleteRenderbuffers(2, imgRenderbuffers);\r\n\t\tglDeleteFramebuffers(1, &imgFramebufferId);\r\n\t}\r\n}\r\n\r\nvoid gkDTIBeginDrawFBO()\r\n{\r\n\tif(imgFramebufferId)\r\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, imgFramebufferId);\r\n}\r\n\r\nvoid gkDTIEndDrawFBO()\r\n{\r\n\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\r\n}\r\n\r\nstruct gkDrawToImageImplementation gkDTIFBO = {\r\n\tgkDTIInitBufferFBO, gkDTICleanBufferFBO,\r\n\tgkDTIBeginDrawFBO, gkDTIEndDrawFBO\r\n};\r\n\r\n\r\n#ifdef GK_USE_GLAUXBUFFERS\r\n/*\r\n\tAUX Buffer Draw to image implementation\r\n*/\r\n\r\nvoid gkDTIInitBufferAUX(gkSize size)\r\n{\r\n\t/* do nothing for AUX */\r\n}\r\n\r\nvoid gkDTICleanBufferAUX()\r\n{\r\n\t/* do nothing for AUX */\r\n}\r\n\r\nvoid gkDTIBeginDrawAUX()\r\n{\r\n\tglReadBuffer(GL_AUX0);\r\n\tglDrawBuffer(GL_AUX0);\r\n}\r\n\r\nvoid gkDTIEndDrawAUX()\r\n{\r\n\tglReadBuffer(GL_BACK);\r\n\tglDrawBuffer(GL_BACK);\r\n}\r\n\r\nstruct gkDrawToImageImplementation gkDTIAUX = {\r\n\tgkDTIInitBufferAUX, gkDTICleanBufferAUX,\r\n\tgkDTIBeginDrawAUX, gkDTIEndDrawAUX\r\n};\r\n\r\n#endif\r\n\r\n/*\r\n\tTexCopy DTI implementation \r\n*/\r\n\r\ngkImage* screenBufferImg = 0;\r\ngkImage* screenDepthBufferImg = 0;\r\n\r\n\r\nvoid gkDTIInitBufferTex(gkSize size)\r\n{\r\n\tscreenBufferImg = gkCreateImage((int)size.width, (int)size.height);\r\n\tscreenDepthBufferImg = (gkImage*)malloc(sizeof(gkImage));\r\n\tglGenTextures(1, &screenDepthBufferImg->id);\r\n\tglBindTexture(GL_TEXTURE_2D, screenDepthBufferImg->id);\r\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, (int)size.width, (int)size.height, 0, GL_DEPTH_COMPONENT16, GL_FLOAT, 0);\r\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\r\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\r\n\tscreenDepthBufferImg->width = (uint16_t)size.width;\r\n\tscreenDepthBufferImg->height = (uint16_t)size.height;\r\n}\r\n\r\nvoid gkDTICleanBufferTex()\r\n{\r\n\tif (screenBufferImg) {\r\n\t\tgkDestroyImage(screenBufferImg);\r\n\t\tgkDestroyImage(screenDepthBufferImg);\r\n\t}\r\n}\r\n\r\nvoid gkDTIBeginDrawTex()\r\n{\r\n\tGLint viewportDimmension[4];\r\n\r\n\tglGetIntegerv(GL_VIEWPORT, viewportDimmension);\r\n\r\n\tglBindTexture(GL_TEXTURE_2D, screenBufferImg->id);\r\n\tglCopyTexSubImage2D(GL_TEXTURE_2D, 0,0,0,0,0, viewportDimmension[2], viewportDimmension[3]);\r\n\r\n\tglBindTexture(GL_TEXTURE_2D, screenDepthBufferImg->id);\r\n\tglCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, 0, 0, viewportDimmension[2], viewportDimmension[3], 0);\r\n}\r\n\r\nvoid gkDTIEndDrawTex()\r\n{\r\n\tGLboolean blendEnabled = glIsEnabled(GL_BLEND);\r\n\tGLboolean depthEnabled = glIsEnabled(GL_DEPTH_TEST);\r\n\tGLint viewportDimmension[4];\r\n\r\n\tglDisable(GL_BLEND);\r\n\tglDisable(GL_DEPTH_TEST);\r\n\r\n\tglGetIntegerv(GL_VIEWPORT, viewportDimmension);\r\n\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglPushMatrix();\r\n\tglLoadIdentity();\r\n\tglOrtho(0,viewportDimmension[2], 0, viewportDimmension[3], -1, 1);\r\n\tglMatrixMode(GL_MODELVIEW);\r\n\tglPushMatrix();\r\n\tglLoadIdentity();\r\n\r\n\tgkColorFilterTop->color = GK_COLOR(1,1,1,1);\r\n\r\n\tgkDrawImage(screenDepthBufferImg, 0.0f, 0.0f);\r\n\tgkDrawImage(screenBufferImg, 0.0f, 0.0f);\r\n\r\n\tglPopMatrix();\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglPopMatrix();\r\n\r\n\tif(depthEnabled == GL_TRUE) glEnable(GL_DEPTH_TEST);\r\n\tif(blendEnabled == GL_TRUE) glEnable(GL_BLEND);\r\n}\r\n\r\nstruct gkDrawToImageImplementation gkDTITex = {\r\n\tgkDTIInitBufferTex, gkDTICleanBufferTex,\r\n\tgkDTIBeginDrawTex, gkDTIEndDrawTex\r\n};\r\n\r\n/* End of implementations */\r\n\r\nvoid gkInitDTI()\r\n{\r\n\tif (GLEE_EXT_framebuffer_object) {\r\n\t\tgkDTI = &gkDTIFBO;\r\n\t\tprintf(\"GK [INFO]: Using FBO\\n\");\r\n\t} else {\r\n#ifdef GK_USE_GLAUXBUFFERS\r\n\t\tGLint auxBuffers = 0;\r\n\t\tglGetIntegerv(GL_AUX_BUFFERS, &auxBuffers);\r\n\t\tif (auxBuffers > 0) {\r\n\t\t\tgkDTI = &gkDTIAUX;\r\n\t\t\tprintf(\"GK [INFO]: Using aux buffer\\n\");\r\n\t\t} else {\r\n\t\t\tgkDTI = &gkDTITex;\r\n\t\t\tprintf(\"GK [INFO]: Using TexCopy\\n\");\r\n\t\t}\r\n#else\r\n\t\tgkDTI = &gkDTITex;\r\n\t\tprintf(\"GK [INFO]: Using TexCopy\\n\");\r\n#endif\r\n\t}\r\n}\r\n","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n\r\n#include \"gk.h\"\r\n\r\n#include <math.h>\r\n\r\nvoid sincosf(const float a, float* s, float* c);\r\n\r\ngkMatrix GK_IDENTIY_MATRIX = {1,0,0,\r\n\t\t\t\t\t\t\t  0,1,0,\r\n\t\t\t\t\t\t\t  0,0,1};\r\n\r\ngkPoint\tGK_POINT(float x, float y){ gkPoint p = {x,y}; return p;};\r\ngkSize GK_SIZE(float width, float height){ gkSize s = {width,height}; return s;};\r\ngkRect GK_RECT(float x, float y, float width, float height){ gkRect r = {x,y,width,height}; return r;};\r\n\r\ngkMatrix gkMatrixCreateIdentity(){\r\n\treturn GK_IDENTIY_MATRIX;\r\n}\r\n\r\ngkMatrix gkMatrixCreateTranslation(float x, float y){\r\n\tgkMatrix res = { 1, 0, 0,\r\n\t\t\t\t\t 0, 1, 0,\r\n\t\t\t\t\t x, y, 1\r\n\t\t\t\t   };\r\n\treturn res;\r\n}\r\n\r\ngkMatrix gkMatrixCreateScale(float sx, float sy){\r\n\tgkMatrix res = { sx, 0, 0,\r\n\t\t\t\t\t 0, sy, 0,\r\n\t\t\t\t\t 0, 0, 1\r\n\t\t\t\t   };\r\n\treturn res;\r\n}\r\n\r\nvoid sincosf(const float a, float* s, float* c){\r\n#ifdef GK_PLATFORM_WIN\r\n\t_asm{\r\n\t\tmov eax, c\r\n\t\tmov esi, s\r\n\t\tfld a\r\n\t\tfwait\r\n\t\tfsincos\r\n\t\tfwait\r\n\t\tfstp [eax]\r\n\t\tfstp [esi]\r\n\t}\r\n#else\r\n    *s = sinf(a);\r\n    *c = cosf(a);\r\n#endif\r\n}\r\n\r\ngkMatrix gkMatrixCreateRotation(float angle){\r\n\tfloat cosa, sina;\r\n\tsincosf(angle, &sina, &cosa);\r\n\t{\r\n\t\tgkMatrix res = { cosa, -sina, 0,\r\n\t\t\t\t\t\t sina, cosa, 0,\r\n\t\t\t\t\t\t 0, 0, 1\r\n\t\t\t\t\t   };\r\n\t\treturn res;\r\n\t}\r\n}\r\n\r\nvoid gkMatrixMult(gkMatrix* dst, gkMatrix mat){\r\n\tgkMatrixMultPtr(dst, &mat);\r\n}\r\nvoid gkMatrixMultPtr(gkMatrix* dst, gkMatrix *mat){\t\t// dst = dst * mat\r\n\tfloat *B = (float*)mat->data, *A;\r\n\tgkMatrix tmp = *dst;\r\n\tint c,r,r3;\r\n\tA = tmp.data;\r\n\tfor(r = 0; r<3; r++){\r\n\t\tr3 = r*3;\r\n\t\tfor(c = 0; c<3; c++){\r\n\t\t\tdst->data[r3 + c] = B[c]*A[r3] + B[c + 3]*A[r3 + 1] + B[c + 6]*A[r3 + 2];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfloat gkMatrixDeterminant(gkMatrix* mat){\r\n\tfloat* m = mat->data;\r\n\treturn m[0]*m[4]*m[8] + m[3]*m[7]*m[2] + m[6]*m[1]*m[5] -\r\n\t\t   m[6]*m[4]*m[2] - m[3]*m[1]*m[8] - m[0]*m[7]*m[5];\r\n}\r\n\r\nvoid gkMatrixInverse(gkMatrix* mat){\r\n\tfloat d = gkMatrixDeterminant(mat);\r\n\tif(d == 0) *mat = GK_IDENTIY_MATRIX;\r\n\telse{\r\n\t\tint i;\r\n\t\tfloat* m = mat->data;\r\n\t\tgkMatrix inv = {\r\n\t\t\t\t(m[4]*m[8] - m[7]*m[5]), -(m[1]*m[8] - m[7]*m[2]), (m[1]*m[5] - m[4]*m[2]),\r\n\t\t\t\t-(m[3]*m[8] - m[6]*m[5]), (m[0]*m[8] - m[6]*m[2]), -(m[0]*m[5] - m[3]*m[2]),\r\n\t\t\t\t(m[3]*m[7] - m[6]*m[4]), -(m[0]*m[7] - m[6]*m[1]), (m[0]*m[4] - m[3]*m[1])\r\n\t\t};\r\n\t\tfor(i = 0; i<9; i++) inv.data[i] /= d;\r\n\t\t*mat = inv;\r\n\t}\r\n}\r\n\r\nvoid gkMatrixTranspose(gkMatrix* mat){\r\n\tint i,j, i3, j3;\r\n\tfloat *m = mat->data, tmp;\r\n\tfor(i = 0; i<3; i++){\r\n\t\ti3 = i*3;\r\n\t\tfor(j = i; j<3; j++){\r\n\t\t\tj3 = j*3;\r\n\t\t\ttmp = m[i3 + j];\r\n\t\t\tm[i3 + j] = m[j3 + i];\r\n\t\t\tm[j3 + i] = tmp;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ngkPoint gkTransformPoint(gkPoint p, gkMatrix* mat){\r\n\tfloat *m = mat->data;\r\n\tgkPoint result;\r\n//\tz = p.x*m[6] + p.y*m[7] + m[8];\r\n\tresult.x = p.x*m[0] + p.y*m[3] + m[6];\r\n\tresult.y = p.x*m[1] + p.y*m[4] + m[7];\r\n\treturn result;\r\n}\r\n","/* Copyright (c) 2012 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n\r\n#include \"gk.h\"\r\n\r\n#include \"gkGL.h\"\r\n\r\n#include <stdlib.h>\r\n\r\n#define M_PI_OVER_180 0.017453292519943295769f\r\n#define M_180_OVER_PI 57.29577951308232087684f\r\n\r\nvoid sincosf(float a, float* s, float* c);  /*in geom.c*/\r\n\r\n/* Color filter stack */\r\n\r\ntypedef struct gkColorNodeStruct gkColorNode;\r\nstruct gkColorNodeStruct{\r\n\tgkColor color;\r\n\tgkColorNode* parent;\r\n}gkColorFilterRoot = {{1.0f,1.0f,1.0f,1.0f}, 0}, *gkColorFilterTop = &gkColorFilterRoot;\r\n\r\nvoid gkResetColorFilter(){\r\n\tgkColorNode *p;\r\n\twhile(gkColorFilterTop->parent){\r\n\t\tgkColorFilterTop = (p = gkColorFilterTop)->parent;\r\n\t\tfree(p);\r\n\t}\r\n}\r\n\r\nvoid gkPushColorFilter(float r, float g, float b, float a){\r\n\tgkColorNode* n = (gkColorNode*)malloc(sizeof(gkColorNode));\r\n\tn->color = GK_COLOR(gkColorFilterTop->color.r*r, gkColorFilterTop->color.g*g, gkColorFilterTop->color.b*b, gkColorFilterTop->color.a*a);\r\n\tn->parent = gkColorFilterTop;\r\n\tgkColorFilterTop = n;\r\n}\r\n\r\ngkColor gkGetFilteredColor(gkColor c){\r\n\tc.r *= gkColorFilterTop->color.r;\r\n\tc.g *= gkColorFilterTop->color.g;\r\n\tc.b *= gkColorFilterTop->color.b;\r\n\tc.a *= gkColorFilterTop->color.a;\r\n\treturn c;\r\n}\r\n\r\nvoid gkPopColorFilter(){\r\n\tif(gkColorFilterTop->parent){\r\n\t\tgkColorNode* p = gkColorFilterTop;\r\n\t\tgkColorFilterTop = gkColorFilterTop->parent;\r\n\t\tfree(p);\r\n\t}\r\n}\r\n\r\n/* Transform stack */\r\n\r\ntypedef struct gkTransformNodeStruct gkTransformNode;\r\nstruct gkTransformNodeStruct{\r\n\tgkMatrix transform;\r\n\tgkTransformNode *parent;\r\n}gkTransformRoot = {{1,0,0,0,1,0,0,0,1}, 0}, *gkTransformTop = &gkTransformRoot;\r\n\r\nvoid gkUpdateGLMatrix(){\r\n\tfloat *p = gkTransformTop->transform.data, m[16] = {\r\n\t\t\t\tp[0], p[1], 0, p[2],\r\n\t\t\t\tp[3], p[4], 0, p[5],\r\n\t\t\t\t0   , 0   , 1,    0,\r\n\t\t\t\tp[6], p[7], 0, p[8]\r\n\t};\r\n\tglLoadMatrixf(m);\r\n}\r\n\r\nvoid gkResetTransform(){\r\n\tgkTransformNode *p;\r\n\twhile(gkTransformTop->parent){\r\n\t\tgkTransformTop = (p = gkTransformTop)->parent;\r\n\t\tfree(p);\r\n\t}\r\n\tglLoadIdentity();\r\n}\r\n\r\nvoid gkPushTransform(gkMatrix* matrix){\r\n\tgkTransformNode* n = (gkTransformNode*)malloc(sizeof(gkTransformNode));\r\n\tn->transform = *matrix;\r\n\tgkMatrixMultPtr(&n->transform, &gkTransformTop->transform);\r\n\tn->parent = gkTransformTop;\r\n\tgkTransformTop = n;\r\n\tgkUpdateGLMatrix();\r\n}\r\n\r\nvoid gkPopTransform(){\r\n\tif(gkTransformTop->parent){\r\n\t\tgkTransformNode* p = gkTransformTop;\r\n\t\tgkTransformTop = gkTransformTop->parent;\r\n\t\tfree(p);\r\n\t}\r\n\tgkUpdateGLMatrix();\r\n}\r\n\r\n/***********************/\r\n\r\ngkColor gkFillColor = {0.0f,0.0f,0.0f,1.0f};\r\ngkColor gkLineColor = {1.0f,1.0f,1.0f,1.0f};\r\nfloat gkLineWidth = 0;\r\n\r\ngkColor GK_COLOR(float r, float g, float b, float a){\r\n\tgkColor c = {r,g,b,a};\r\n\treturn c;\r\n}\r\n\r\nvoid gkSetFillColor(float r, float g, float b, float a){\r\n\tgkFillColor.r = r;\r\n\tgkFillColor.g = g;\r\n\tgkFillColor.b = b;\r\n\tgkFillColor.a = a;\r\n}\r\n\r\nvoid gkSetLineColor(float r, float g, float b, float a){\r\n\tgkLineColor.r = r;\r\n\tgkLineColor.g = g;\r\n\tgkLineColor.b = b;\r\n\tgkLineColor.a = a;\r\n}\r\n\r\nvoid gkSetLineWidth(float w){\r\n\tgkLineWidth = w;\r\n}\r\n\r\nGK_BOOL gkCheckLineProperties(){\r\n\tif(gkLineWidth > 0){\r\n\t\tgkColor lineColor = gkGetFilteredColor(gkLineColor);\r\n\t\tglColor4f(lineColor.r, lineColor.g, lineColor.b, lineColor.a);\r\n\t\tglLineWidth(gkLineWidth);\r\n\t\treturn GK_TRUE;\r\n\t}\r\n\treturn GK_FALSE;\r\n}\r\n\r\nvoid gkSetClipRect(float x, float y, float w, float h){\r\n\tif(w != 0 && h != 0){\r\n\t\tglClipPlaneVarType tClip[] = {0, 1, 0, -y};\r\n\t\tglClipPlaneVarType bClip[] = {0, -1, 0, (y + h)};\r\n\t\tglClipPlaneVarType lClip[] = {1, 0, 0, -x};\r\n\t\tglClipPlaneVarType rClip[] = {-1, 0, 0, (x + w)};\r\n\t\tglClipPlanef(GL_CLIP_PLANE0, tClip);\r\n\t\tglClipPlanef(GL_CLIP_PLANE1, bClip);\r\n\t\tglClipPlanef(GL_CLIP_PLANE2, lClip);\r\n\t\tglClipPlanef(GL_CLIP_PLANE3, rClip);\r\n\t\tglEnable(GL_CLIP_PLANE0);\r\n\t\tglEnable(GL_CLIP_PLANE1);\r\n\t\tglEnable(GL_CLIP_PLANE2);\r\n\t\tglEnable(GL_CLIP_PLANE3);\r\n\t}else{\r\n\t\tglDisable(GL_CLIP_PLANE0);\r\n\t\tglDisable(GL_CLIP_PLANE1);\r\n\t\tglDisable(GL_CLIP_PLANE2);\r\n\t\tglDisable(GL_CLIP_PLANE3);\r\n\t}\r\n}\r\n\r\n\r\nvoid gkDrawPoint(float x, float y, float size){\r\n\tfloat v[] = {x,y};\r\n\tgkColor fillColor = gkGetFilteredColor(gkFillColor);\r\n\tglPointSize(size);\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglVertexPointer(2, GL_FLOAT, 0, v);\r\n\tglColor4f(fillColor.r, fillColor.g, fillColor.b, fillColor.a);\r\n\tglDrawArrays(GL_POINTS, 0,1);\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n}\r\n\r\nvoid gkDrawLine(float sx, float sy, float ex, float ey){\r\n\tfloat v[] = {sx, sy, ex, ey};\r\n\tif(gkCheckLineProperties()){\r\n\t\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\t\tglVertexPointer(2, GL_FLOAT, 0, v);\r\n\t\tglDrawArrays(GL_LINES, 0, 2);\r\n\t\tglDisableClientState(GL_VERTEX_ARRAY);\r\n\t}\r\n}\r\n\r\nvoid gkDrawRect(float x, float y, float w, float h){\r\n\tfloat v[] = {x,y,\r\n\t\t\t\t x + w, y,\r\n\t\t\t\t x + w, y + h,\r\n\t\t\t\t x, y + h};\r\n\tgkColor fillColor = gkGetFilteredColor(gkFillColor);\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglVertexPointer(2,GL_FLOAT, 0, v);\r\n\tglColor4f(fillColor.r, fillColor.g, fillColor.b, fillColor.a);\r\n\tglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\r\n\tif(gkCheckLineProperties()){\r\n\t\tglDrawArrays(GL_LINE_LOOP, 0, 4);\r\n\t}\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n}\r\n\r\n\r\nvoid gkDrawRoundRect(float x, float y, float w, float h, float a, float b){\r\n\tgkPoint roundRect[74], *current = roundRect + 1;\r\n\tfloat sina, cosa, angle = 0, step = M_PI_OVER_180*5;\r\n\tint i;\r\n\tgkColor fillColor = gkGetFilteredColor(gkFillColor);\r\n\r\n\troundRect[0].x = x + w/2;\r\n\troundRect[0].y = y + h/2;\r\n\tif(w<a*2) a = w/2;\r\n\tif(h<b*2) b = h/2;\r\n\r\n\tfor(i = 0; i<18; i++, current++){\r\n\t\tsincosf(angle, &sina, &cosa);\r\n\t\tcurrent->x = (x + w - a) + a*cosa;\r\n\t\tcurrent->y = (y + b)\t - b*sina;\r\n\t\tangle += step;\r\n\t}\r\n\tfor(i = 0; i<18; i++, current++){\r\n\t\tsincosf(angle, &sina, &cosa);\r\n\t\tcurrent->x = (x + a)\t+ a*cosa;\r\n\t\tcurrent->y = (y + b)\t- b*sina;\r\n\t\tangle += step;\r\n\t}\r\n\tfor(i = 0; i<18; i++, current++){\r\n\t\tsincosf(angle, &sina, &cosa);\r\n\t\tcurrent->x = (x + a)\t\t+ a*cosa;\r\n\t\tcurrent->y = (y + h - b)\t- b*sina;\r\n\t\tangle += step;\r\n\t}\r\n\tfor(i = 0; i<18; i++, current++){\r\n\t\tsincosf(angle, &sina, &cosa);\r\n\t\tcurrent->x = (x + w - a)\t+ a*cosa;\r\n\t\tcurrent->y = (y + h - b)\t- b*sina;\r\n\t\tangle += step;\r\n\t}\r\n\tcurrent->x = roundRect[1].x;\r\n\tcurrent->y = roundRect[1].y;\r\n\r\n\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglVertexPointer(2, GL_FLOAT, 0, roundRect);\r\n\tglColor4f(fillColor.r, fillColor.g, fillColor.b, fillColor.a);\r\n\tglDrawArrays(GL_TRIANGLE_FAN, 0, 74);\r\n\tif(gkCheckLineProperties()){\r\n\t\tglDrawArrays(GL_LINE_LOOP, 1, 73);\r\n\t}\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n}\r\n\r\nvoid gkDrawCircle(float x, float y, float r){\r\n\tstatic const float sincosTable[] = {\t/* pre-calculated 62 (cos, sin) pairs for angles from 0 to (M_PI_OVER_180 * 6) * 62   */\r\n\t\t1.000000f,0.000000f,0.994522f,0.104528f,0.978148f,0.207912f,0.951057f,0.309017f,0.913545f,\r\n\t\t0.406737f,0.866025f,0.500000f,0.809017f,0.587785f,0.743145f,0.669131f,0.669131f,0.743145f,\r\n\t\t0.587785f,0.809017f,0.500000f,0.866025f,0.406737f,0.913545f,0.309017f,0.951057f,0.207912f,\r\n\t\t0.978148f,0.104528f,0.994522f,-0.000000f,1.000000f,-0.104529f,0.994522f,-0.207912f,0.978148f,\r\n\t\t-0.309017f,0.951056f,-0.406737f,0.913545f,-0.500000f,0.866025f,-0.587785f,0.809017f,\r\n\t\t-0.669131f,0.743145f,-0.743145f,0.669131f,-0.809017f,0.587786f,-0.866025f,0.500000f,-0.913545f,\r\n\t\t0.406737f,-0.951056f,0.309018f,-0.978147f,0.207913f,-0.994522f,0.104529f,-1.000000f,\r\n\t\t0.000001f,-0.994522f,-0.104527f,-0.978148f,-0.207910f,-0.951057f,-0.309016f,-0.913546f,\r\n\t\t-0.406735f,-0.866026f,-0.499999f,-0.809018f,-0.587784f,-0.743146f,-0.669129f,-0.669132f,\r\n\t\t-0.743143f,-0.587787f,-0.809016f,-0.500002f,-0.866024f,-0.406739f,-0.913544f,-0.309019f,\r\n\t\t-0.951056f,-0.207914f,-0.978147f,-0.104531f,-0.994522f,-0.000003f,-1.000000f,0.104526f,\r\n\t\t-0.994522f,0.207909f,-0.978148f,0.309014f,-0.951057f,0.406734f,-0.913547f,0.499997f,-0.866027f,\r\n\t\t0.587782f,-0.809019f,0.669128f,-0.743147f,0.743142f,-0.669133f,0.809015f,-0.587788f,\r\n\t\t0.866023f,-0.500003f,0.913544f,-0.406740f,0.951055f,-0.309021f,0.978147f,-0.207916f,\r\n\t\t0.994521f,-0.104533f,1.000000f,-0.000005f\r\n\t};\r\n\tconst float *sincosPtr = sincosTable;\r\n//\r\n\tgkPoint circle[62], *current;\r\n\tgkColor fillColor = gkGetFilteredColor(gkFillColor);\r\n\tcircle[0].x = x;\r\n\tcircle[0].y = y;\r\n\tfor(current = circle + 1; current-circle<62; current++){\r\n\t\tcurrent->x = *(sincosPtr++)*r + x;\r\n\t\tcurrent->y = *(sincosPtr++)*r + y;\r\n\t}\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglVertexPointer(2, GL_FLOAT, 0, circle);\r\n\tglColor4f(fillColor.r, fillColor.g, fillColor.b, fillColor.a);\r\n\tglDrawArrays(GL_TRIANGLE_FAN, 0, 62);\r\n\tif(gkCheckLineProperties()){\r\n\t\tglDrawArrays(GL_LINE_LOOP, 1, 61);\r\n\t}\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n}\r\n\r\nstatic void drawPolyInternal(gkPoint* path, int length);\r\n\r\nvoid gkDrawPath(gkPoint* path, int length, int polygon){\r\n\tgkColor fillColor = gkGetFilteredColor(gkFillColor);\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglVertexPointer(2, GL_FLOAT, 0, path);\r\n\tif(polygon){\r\n\t\tglColor4f(fillColor.r, fillColor.g, fillColor.b, fillColor.a);\r\n\t\tdrawPolyInternal(path, length);\r\n\t}\r\n\tif(gkCheckLineProperties()){\r\n\t\tglDrawArrays(polygon?GL_LINE_LOOP:GL_LINE_STRIP, 0, length);\r\n\t}\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n}\r\n\r\n\r\n#ifdef GK_CONCAVE_POLYGONS\r\n/* \r\n *\tThis one works with many concave polygons as well\r\n */\r\n\r\n#define MAX_INDICES 1000\r\n\r\nstatic void drawPolyInternal(gkPoint* path, int length)\r\n{\r\n\tint r;\r\n\tint maxCount = 0;\r\n\tint minBrk = 1000;\r\n\tint ind[MAX_INDICES];\r\n\r\n\tif (length>256) {\r\n\t\tglDrawArrays(GL_TRIANGLE_FAN, 0, length);\r\n\t}\r\n\r\n\t//\trotate points order to find the best match. \r\n\t//\tThis algorithm has O(N*N) complexity. May be slow.\r\n\r\n\tfor (r = 0; r<length; r++) {\r\n\t\t//\tSimple triangulation \r\n\t\t//\tworks for a lot of polygons (even concave)\r\n\t\tint i, i2, p;\r\n\t\tint indices[MAX_INDICES];\r\n\t\tint pathStack[MAX_INDICES], cur, pathTop = length-1;\r\n\t\tfloat c;\r\n\t\tint center = r, brk = 0, count = 0;\r\n\t\tgkPoint v1, v2;\r\n\r\n\t\tfor (i = 0; i<pathTop; i++) {\r\n\t\t\tpathStack[i] = (i + 1 + r)%length;\r\n\t\t}\r\n\r\n\t\tfor (cur = 0; cur < pathTop-1; cur++) {\r\n\t\t\ti = pathStack[cur];\r\n\t\t\ti2 = pathStack[cur+1];\r\n\t\t\tv1.x = (path[i].x - path[center].x);\r\n\t\t\tv1.y = (path[i].y - path[center].y);\r\n\t\t\tv2.x = (path[i2].x - path[center].x);\r\n\t\t\tv2.y = (path[i2].y - path[center].y);\r\n\t\t\tc = v1.x*v2.y - v1.y*v2.x;\r\n\t\t\tif (c<0) {\r\n\t\t\t\tp = count*3;\r\n\t\t\t\tindices[p] = center;\r\n\t\t\t\tindices[p+1] = i;\r\n\t\t\t\tindices[p+2] = i2;\r\n\t\t\t\tcount++;\r\n\t\t\t} else {\r\n\t\t\t\tif (cur>length-1) \r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tbrk++;\r\n\t\t\t\tpathStack[pathTop] = center;\r\n\t\t\t\tpathTop++;\r\n\t\t\t\tcenter = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (brk < minBrk) {\r\n\t\t\tmaxCount = count;\r\n\t\t\tminBrk = brk;\r\n\t\t\tmemcpy(ind, indices, sizeof(int)*count*3);\r\n\t\t}\r\n\t\tif (length>16)\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tglDrawElements(GL_TRIANGLES, maxCount*3, GL_UNSIGNED_INT, ind);\r\n}\r\n#else\r\nstatic void drawPolyInternal(gkPoint* path, int length)\r\n{\r\n\tglDrawArrays(GL_TRIANGLE_FAN, 0, length);\r\n}\r\n#endif\r\n","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n\r\n#include <gk.h>\r\n#include \"gkImageInternal.h\"\r\n#include \"gkGL.h\"\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\n#include <locale.h>\r\n\r\ngkColor gkGetFilteredColor(gkColor c);\t//implemented in graphics.c\r\n\r\nvoid gkInitImages(){\r\n}\r\n\r\nvoid gkCleanupImages(){\r\n}\r\n\r\ngkImage* gkLoadImage(char* filename)\r\n{\r\n\tGLint oldTexId;\r\n\tgkImage* image;\r\n\tgkImageData* imageData = gkDecodeImage(filename);\r\n\r\n\tif (!imageData)\r\n\t\treturn 0;\r\n\r\n\timage = (gkImage*)malloc(sizeof(gkImage));\r\n\timage->width = imageData->width;\r\n\timage->height = imageData->height;\r\n\r\n\tglGenTextures(1, &image->id);\r\n\r\n\tglEnable(GL_TEXTURE_2D);\r\n\tglGetIntegerv(GL_TEXTURE_BINDING_2D, &oldTexId);\r\n\tglBindTexture(GL_TEXTURE_2D, image->id);\r\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\r\n\r\n\tif (imageData->pixelFormat == GK_PIXELFORMAT_RGBA) {\r\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image->width, image->height, \r\n\t\t\t0, GL_RGBA, GL_UNSIGNED_BYTE, imageData->data);\r\n\t} else if (imageData->pixelFormat == GK_PIXELFORMAT_RGB) {\r\n\t\t/* \r\n\t\tOn android there is a problem when the Texture internal format and\r\n\t\tdata format are different. \r\n\t\t*/\r\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB/*A*/, image->width, image->height, \r\n\t\t\t0, GL_RGB, GL_UNSIGNED_BYTE, imageData->data);\r\n\t}\r\n\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\r\n\tglBindTexture(GL_TEXTURE_2D, oldTexId);\r\n\tglDisable(GL_TEXTURE_2D);\r\n\r\n\treturn image;\r\n}\r\n\r\nGK_BOOL gkSaveImage(gkImage* image, char* filename)\r\n{\r\n\tGK_BOOL result;\r\n\tgkImageData *imageData = gkCreateImageData(image->width, image->height, GK_PIXELFORMAT_RGBA);\r\n\tgkGetImageData(image, GK_PIXELFORMAT_RGBA, imageData->data);\r\n\tresult = gkEncodeImage(filename, imageData);\r\n\tgkDestroyImageData(imageData);\r\n\treturn result;\r\n}\r\n\r\ngkImage* gkCreateImage(int width, int height){\r\n\tgkImage* image = (gkImage*)malloc(sizeof(gkImage));\r\n\tGLint oldTexId;\r\n\r\n\tglGenTextures(1, &image->id);\r\n\timage->width = width;\r\n\timage->height = height;\r\n\r\n\tglEnable(GL_TEXTURE_2D);\r\n\tglGetIntegerv(GL_TEXTURE_BINDING_2D, &oldTexId);\r\n\tglBindTexture(GL_TEXTURE_2D, image->id);\r\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image->width, image->height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\r\n\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\r\n\tglBindTexture(GL_TEXTURE_2D, oldTexId);\r\n\tglDisable(GL_TEXTURE_2D);\r\n\r\n\treturn image;\r\n}\r\n\r\nvoid gkSetImageData(gkImage* image, gkPixelFormat format, void* data)\r\n{\r\n\tGLint oldId;\r\n\tGLint oldUnPackAlignment;\r\n\tglGetIntegerv(GL_UNPACK_ALIGNMENT, &oldUnPackAlignment);\r\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\r\n\tglEnable(GL_TEXTURE_2D);\r\n\tglGetIntegerv(GL_TEXTURE_BINDING_2D, &oldId);\r\n\tglBindTexture(GL_TEXTURE_2D, image->id);\r\n\r\n\tif (format == GK_PIXELFORMAT_RGBA) {\r\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image->width, image->height,0, GL_RGBA, GL_UNSIGNED_BYTE, data);\r\n\t} else if (format == GK_PIXELFORMAT_RGB) {\r\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image->width, image->height,0, GL_RGB, GL_UNSIGNED_BYTE, data);\r\n\t}\r\n\r\n\tglBindTexture(GL_TEXTURE_2D, oldId);\r\n\tglDisable(GL_TEXTURE_2D);\r\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, oldUnPackAlignment);\r\n}\r\n\r\nvoid gkGetImageData(gkImage* image, gkPixelFormat format, void* data)\r\n{\r\n\tGLint oldId;\r\n\tGLint oldPackAlignment;\r\n\tGLuint fmt;\r\n\tglGetIntegerv(GL_PACK_ALIGNMENT, &oldPackAlignment);\r\n\tglPixelStorei(GL_PACK_ALIGNMENT, 1);\r\n\tglGetIntegerv(GL_TEXTURE_BINDING_2D, &oldId);\r\n\tglBindTexture(GL_TEXTURE_2D, image->id);\r\n\r\n\tif (format == GK_PIXELFORMAT_RGBA) {\r\n\t\tfmt = GL_RGBA;\r\n\t}else if (format == GK_PIXELFORMAT_RGB) {\r\n\t\tfmt = GL_RGB;\r\n\t}\r\n\r\n#if defined(GK_PLATFORM_WIN) || defined(GK_PLATFORM_LINUX)\r\n\t/* If glGetTexImage is available */\r\n\tglGetTexImage(GL_TEXTURE_2D, 0, fmt, GL_UNSIGNED_BYTE, data);\r\n#else \r\n\tif (gkBeginDrawToImage(image, GK_FALSE)) {\r\n\t\tglFlush();\r\n\t\tglReadPixels(0,0, image->width, image->height, \r\n\t\t\tfmt, GL_UNSIGNED_BYTE, data);\r\n\t\tgkEndDrawToImage();\r\n\t}\r\n#endif\r\n\r\n\tglBindTexture(GL_TEXTURE_2D, oldId);\r\n\tglPixelStorei(GL_PACK_ALIGNMENT, oldPackAlignment);\r\n}\r\n\r\nvoid gkDrawImageInternal(gkImage* img, float* v, float* c){\r\n\tgkColor color = gkGetFilteredColor(GK_COLOR(1,1,1,1));\r\n\tglColor4f(color.r, color.g, color.b, color.a);\r\n\tglEnable(GL_TEXTURE_2D);\r\n\tglBindTexture(GL_TEXTURE_2D, img->id);\r\n\tglEnableClientState(GL_VERTEX_ARRAY);\r\n\tglEnableClientState(GL_TEXTURE_COORD_ARRAY);\r\n\tglVertexPointer(2, GL_FLOAT, 0, v);\r\n\tglTexCoordPointer(2, GL_FLOAT, 0, c);\r\n\tglDrawArrays(GL_TRIANGLE_FAN, 0, 4);\r\n\tglDisableClientState(GL_VERTEX_ARRAY);\r\n\tglDisableClientState(GL_TEXTURE_COORD_ARRAY);\r\n\tglDisable(GL_TEXTURE_2D);\r\n}\r\n\r\nvoid gkDrawImage(gkImage* image, float x, float y){\r\n\tfloat v[]= {\r\n\t\t0,0,\r\n\t\timage->width, 0,\r\n\t\timage->width, image->height,\r\n\t\t0, image->height\r\n\t};\r\n\tfloat c[]= {\r\n\t\t0, 0,\r\n\t\t1, 0,\r\n\t\t1, 1,\r\n\t\t0, 1\r\n\t};\r\n\r\n\tglPushMatrix();\r\n\tglTranslatef(x,y,0);\r\n\tgkDrawImageInternal(image, v, c);\r\n\tglPopMatrix();\r\n}\r\n\r\nvoid gkDrawImageEx(gkImage* image, float x, float y, gkRect srcRect){\r\n\tfloat v[]= {\r\n\t\t0,0,\r\n\t\tsrcRect.width, 0,\r\n\t\tsrcRect.width, srcRect.height,\r\n\t\t0, srcRect.height\r\n\t};\r\n\tfloat left = (srcRect.x/image->width);\r\n\tfloat top = (srcRect.y/image->height);\r\n\tfloat right = left + (srcRect.width/image->width);\r\n\tfloat bottom = top + (srcRect.height/image->height);\r\n\r\n\tfloat c[]= {\r\n\t\tleft, top,\r\n\t\tright, top,\r\n\t\tright, bottom,\r\n\t\tleft, bottom\r\n\t};\r\n\r\n\tglPushMatrix();\r\n\tglTranslatef(x,y,0);\r\n\tgkDrawImageInternal(image, v, c);\r\n\tglPopMatrix();\r\n}\r\n\r\n\r\nvoid gkDestroyImage(gkImage* image){\r\n\tglDeleteTextures(1, &image->id);\r\n\tfree(image);\r\n}\r\n","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include \"gkConfig.h\"\r\n#include \"gkImageInternal.h\"\r\n#include \"gkStream.h\"\r\n#include <stdio.h>\r\n\r\nstatic gkImageData* gkDecodeImageBMP(void* buffer, size_t size);\r\nstatic gkImageData* gkDecodeImageJPEG(void* buffer, size_t size);\r\nstatic gkImageData* gkDecodeImagePNG(void* buffer, size_t size);\r\n\r\ngkImageData* gkDecodeImage(char* filename)\r\n{\r\n\tgkStream* f = gkOpenFile(filename, \"rb\");\r\n\tchar* buffer;\r\n\tsize_t fileSize;\r\n\tgkImageData* img;\r\n\r\n\tif (!f) \r\n\t\treturn 0;\r\n\tgkStreamSeek(f, 0, GK_SEEK_END);\r\n\tfileSize = gkStreamTell(f);\r\n\tgkStreamSeek(f, 0, GK_SEEK_SET);\r\n\t\r\n\tbuffer = (char*)malloc(fileSize);\r\n\tgkStreamRead(f, buffer, fileSize * sizeof(char));\r\n\r\n\timg = gkDecodeImageMem(buffer, fileSize);\r\n\r\n\tfree(buffer);\r\n\tgkStreamClose(f);\r\n\r\n\treturn img;\r\n}\r\n\r\ngkImageData* gkDecodeImageMem(void* buffer, size_t size)\r\n{\r\n\tgkImageType imgType = gkGetImageTypeMem(buffer, size);\r\n\r\n\tif(imgType == GK_IMAGE_BMP)\r\n\t\treturn gkDecodeImageBMP(buffer, size);\r\n\telse if(imgType == GK_IMAGE_JPEG)\r\n\t\treturn gkDecodeImageJPEG(buffer, size);\r\n\telse if(imgType == GK_IMAGE_PNG)\r\n\t\treturn gkDecodeImagePNG(buffer, size);\r\n\r\n\treturn 0;\r\n}\r\n\r\ngkImageData* gkCreateImageData(uint32_t width, uint32_t height, gkPixelFormat format)\r\n{\r\n\tsize_t pixelSize = (format == GK_PIXELFORMAT_RGBA ? 4 : 3);\r\n\tsize_t size = sizeof(gkImageData) + (width * height * pixelSize);\r\n\tgkImageData* dat = (gkImageData*)malloc(size);\r\n\tdat->width = width;\r\n\tdat->height = height;\r\n\tdat->pixelFormat = format;\r\n\tdat->data = dat + 1;\r\n\treturn dat;\r\n}\r\n\r\nvoid gkDestroyImageData(gkImageData* imgData)\r\n{\r\n\tfree(imgData);\r\n}\r\n\r\n\r\n/*\r\n * Decode JPEG images (libjpeg)\r\n */\r\n\r\n#ifdef GK_USE_LIBJPEG\r\n\r\n#define GK_JPEG_SUPPORT\r\n\r\n#include <jpeglib.h>\r\n\r\nstatic gkImageData* gkDecodeImageJPEG(void* inbuffer, size_t insize)\r\n{\r\n\tgkImageData* imgData;\r\n\r\n\tstruct jpeg_decompress_struct cinfo;\r\n\tstruct jpeg_error_mgr jerr;\r\n\r\n\tJSAMPARRAY buffer;\r\n\tchar *imgBufPtr;\r\n\tsize_t stride;\r\n\r\n\tcinfo.err = jpeg_std_error(&jerr);\r\n\tjpeg_create_decompress(&cinfo);\r\n\r\n\tjpeg_mem_src(&cinfo, (unsigned char*)inbuffer, insize);\r\n\tjpeg_read_header(&cinfo, TRUE);\r\n\r\n\timgData = gkCreateImageData(cinfo.image_width, cinfo.image_height, GK_PIXELFORMAT_RGB);\r\n\timgBufPtr = (char*)imgData->data;\r\n\r\n\tcinfo.out_color_space = JCS_RGB;\r\n\r\n\tjpeg_start_decompress(&cinfo);\r\n\t\t\r\n\tstride = cinfo.out_color_components*cinfo.output_width;\r\n\tbuffer = (cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, stride, 1);\r\n\r\n\twhile (cinfo.output_scanline<cinfo.output_height) {\r\n\t\tjpeg_read_scanlines(&cinfo, buffer, 1);\r\n\t\tmemcpy(imgBufPtr, buffer[0], stride);\r\n\t\timgBufPtr += stride;\r\n\t}\r\n\tjpeg_destroy((j_common_ptr)&cinfo);\r\n\r\n\treturn imgData;\r\n}\r\n\r\n#endif\r\n\r\n/*\r\n * Decode PNG images (libpng 1.6)\r\n */\r\n\r\n#ifdef GK_USE_LIBPNG\r\n\r\n#define GK_PNG_SUPPORT\r\n\r\n#include <png.h>\r\n\r\nstruct pngEncodedData{\r\n\tvoid* ptr;\r\n\tsize_t size;\r\n};\r\n\r\nstatic void readPngEncodedData(png_structp pread, png_bytep dst, png_size_t dstSize)\r\n{\r\n\tstruct pngEncodedData* data = (struct pngEncodedData*)png_get_io_ptr(pread);\r\n\tsize_t s = data->size < dstSize ? data->size : dstSize;\r\n\tmemcpy(dst, data->ptr, s);\r\n\tdata->ptr = (char*)data->ptr + s;\r\n\tdata->size -= s;\r\n}\r\n\r\nstatic void pngError(png_structp png_ptr, png_const_charp error_msg)\r\n{\r\n\tprintf(\"PNG Error: %s\\n\", error_msg);\r\n}\r\n\r\nstatic void pngWarning(png_structp png_ptr, png_const_charp warning_msg)\r\n{\r\n\tprintf(\"PNG Warning: %s\\n\", warning_msg);\r\n}\r\n\r\nstatic gkImageData* gkDecodeImagePNG(void* buffer, size_t size)\r\n{\r\n\tpng_structp pread;\r\n\tpng_infop pinfo;\r\n\tstruct pngEncodedData data = {buffer, size};\r\n\r\n\tpng_uint_32 width, height, channels, colorType;\r\n\tgkImageData* img = 0;\r\n\tchar* ptr;\r\n\tsize_t stride;\r\n\r\n\tpread = png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, pngError, pngWarning);\r\n\tif (!pread) {\r\n\t\tprintf(\"png_create_read_struct failed!\\n\");\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tpinfo = png_create_info_struct(pread);\r\n\tif (!pinfo) {\r\n\t\tprintf(\"png_create_info_struct failed!\\n\");\r\n\t\tpng_destroy_read_struct(&pread, 0, 0);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (setjmp(png_jmpbuf(pread))) {\r\n\t\tif (img)\r\n\t\t\tgkDestroyImageData(img);\r\n\t\tprintf(\"setjmp entered!\\n\");\r\n\t\tpng_destroy_read_struct(&pread, &pinfo, 0);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tpng_set_read_fn(pread, &data, readPngEncodedData);\r\n\r\n\tpng_read_info(pread, pinfo);\r\n\r\n\twidth = png_get_image_width(pread, pinfo);\r\n\theight = png_get_image_height(pread, pinfo);\r\n\tchannels = png_get_channels(pread, pinfo);\r\n\tcolorType = png_get_color_type(pread, pinfo);\r\n\r\n\tif (colorType == PNG_COLOR_TYPE_PALETTE) {\r\n\t\tpng_set_palette_to_rgb(pread);\r\n\t\tchannels = 3;\r\n\t}else if (colorType == PNG_COLOR_TYPE_GRAY) {\r\n\t\tpng_set_gray_to_rgb(pread);\r\n\t\tchannels = 3;\r\n\t}\r\n\r\n\tif (png_get_valid(pread, pinfo, PNG_INFO_tRNS)) {\r\n\t\tpng_set_tRNS_to_alpha(pread);\r\n\t\tchannels += 1;\r\n\t}\r\n\r\n\tif (png_get_bit_depth(pread, pinfo)  == 16)\r\n\t\tpng_set_strip_16(pread);\r\n\r\n\timg = gkCreateImageData(width, height, channels == 3 ? GK_PIXELFORMAT_RGB : GK_PIXELFORMAT_RGBA);\r\n\r\n\tstride = width * channels;\r\n\tptr = (char*)img->data;\r\n\r\n\twhile (height>0) {\r\n\t\tpng_read_row(pread, (png_bytep)ptr, 0);\r\n\t\theight--;\r\n\t\tptr += stride;\r\n\t}\r\n\r\n\tpng_destroy_read_struct(&pread, &pinfo, 0);\r\n\treturn img;\r\n}\r\n\r\n#endif\r\n\r\n\r\n#ifndef GK_BMP_SUPPORT\r\n\r\nstatic gkImageData* gkDecodeImageBMP(void* buffer, size_t size)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n#endif\r\n\r\n#ifndef GK_JPEG_SUPPORT\r\n\r\nstatic gkImageData* gkDecodeImageJPEG(void* buffer, size_t size)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n#endif\r\n\r\n#ifndef GK_PNG_SUPPORT\r\n\r\nstatic gkImageData* gkDecodeImagePNG(void* buffer, size_t size)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n#endif\r\n","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include \"gkImageInternal.h\"\r\n#include <stdio.h>\r\n#include <memory.h>\r\n\r\ngkImageType gkGetImageType(char* filename)\r\n{\r\n\tgkImageType res = GK_IMAGE_UNKNOWN;\r\n\tchar hdr[10];\r\n\tFILE* f = fopen(filename, \"rb\");\r\n\tif (f) {\r\n\t\tsize_t hdrSize = fread(hdr, sizeof(char), 10, f);\r\n\t\tres = gkGetImageTypeMem(hdr, hdrSize);\r\n\t\tfclose(f);\r\n\t}\r\n\treturn res;\r\n}\r\n\r\ngkImageType gkGetImageTypeMem(void* buffer, size_t size)\r\n{\r\n\tunsigned char* hdr = (unsigned char*)buffer;\r\n\tif(size<2)\r\n\t\treturn GK_IMAGE_UNKNOWN;\r\n\r\n\tif (hdr[0] == 0x42 && hdr[1] == 0x4d) \r\n\t\treturn GK_IMAGE_BMP;\r\n\r\n\r\n\tif(size>10) \r\n\t\tsize = 10;\r\n\r\n\tif (hdr[0] == 0xff && hdr[1] == 0xd8) {\r\n\t\tif (size>6) {\r\n\t\t\tif (memcmp(hdr + 6, \"JFIF\", size - 6) == 0 \r\n\t\t\t\t|| memcmp(hdr + 6, \"Exif\", size - 6) == 0)\r\n\t\t\t\treturn GK_IMAGE_JPEG;\r\n\t\t} else {\r\n\t\t\treturn GK_IMAGE_JPEG;\r\n\t\t}\r\n\t}\r\n\r\n\tif(size>8) size = 8;\r\n\r\n\tif(memcmp(hdr, \"\\211PNG\\r\\n\\032\\n\", size) == 0)\r\n\t\treturn GK_IMAGE_PNG;\r\n\r\n\treturn GK_IMAGE_UNKNOWN;\r\n}","#include \"gkPlatform.h\"\r\n\r\n#ifdef GK_PLATFORM_WEB\r\n\r\n#include <gk.h>\r\n#include \"gk_internal.h\"\r\n\r\n#include <stdio.h>\r\n#include <GL/glfw.h>\r\n#include <emscripten/emscripten.h>\r\n\r\nint main()\r\n{\r\n\tgkAppMain();\r\n\treturn 0;\r\n}\r\n\r\nstatic GK_BOOL gkActive;\r\n\r\nstatic onRunCallback onCleanup;\r\n\r\nstatic GK_BOOL initWeb(onInitCallback onInit)\r\n{\r\n\tint width = 800, height = 600;\r\n \r\n    if (glfwInit() != GL_TRUE) {\r\n        printf(\"glfwInit() failed\\n\");\r\n        return GL_FALSE;\r\n    }\r\n \r\n    if (glfwOpenWindow(width, height, 8, 8, 8, 8, 16, 0, GLFW_WINDOW) != GL_TRUE) {\r\n        printf(\"glfwOpenWindow() failed\\n\");\r\n        return GL_FALSE;\r\n    }\r\n\t\r\n\tgkScreenSize.width = (float)width;\r\n\tgkScreenSize.height = (float)height;\r\n\t\r\n\tgkActive = GK_TRUE;\r\n\r\n\tonInit();\r\n\r\n\treturn GK_TRUE;\r\n}\r\n\r\nstatic void runWeb(onRunCallback loop, onRunCallback cleanup)\r\n{\r\n\tonCleanup = cleanup;\r\n\temscripten_set_main_loop(loop, 0, 1);\r\n}\r\n\r\nstatic void cleanupWeb()\r\n{\r\n\tglfwTerminate();\r\n}\r\n\r\nstatic void ExitAppWeb()\r\n{\r\n\tgkActive = GK_FALSE;\r\n\temscripten_cancel_main_loop();\r\n\tonCleanup();\r\n}\r\n\r\nstatic void GetAppDirWeb(char* dst, size_t dstSize)\r\n{\r\n\tprintf(\"getAppDir\\n\");\r\n\tstrcpy(dst, \"\");\r\n}\r\n\r\nstatic void SetVSyncWeb(GK_BOOL enabled)\r\n{\r\n\tprintf(\"setVSync\\n\");\r\n}\r\n\r\nstatic void ResizeScreenWeb(gkSize size)\r\n{\r\n\tprintf(\"resizeScreen\\n\");\r\n}\r\n\r\nstatic int GetSupportedSizesWeb(gkSize* sizes)\r\n{\r\n\tprintf(\"getSupportedSizes\\n\");\r\n\tif (sizes)\r\n\t\tsizes[0] = GK_SIZE(100,100);\r\n\treturn 1;\r\n}\r\n\r\nstatic GK_BOOL GoFullscreenWeb()\r\n{\r\n\tprintf(\"goFullscreen\\n\");\r\n\treturn GK_TRUE;\r\n}\r\n\r\nstatic void GoWindowedWeb(GK_BOOL oldVal)\r\n{\r\n\tprintf(\"goWindowed\\n\");\r\n}\r\n\r\nstatic GK_BOOL SetFullscreenWeb(GK_BOOL enable)\r\n{\r\n\tGK_BOOL wasFullscreen = gkIsFullscreen();\r\n\tGK_BOOL success = GK_FALSE;\r\n\tif (enable)\r\n\t\tenable = success = GoFullscreenWeb();\r\n\tif (!enable)\r\n\t\tGoWindowedWeb(wasFullscreen);\r\n\treturn success;\r\n}\r\n\r\nstatic void SetWindowTitleWeb(char* title)\r\n{\r\n\tprintf(\"setWindowTitle\\n\");\r\n}\r\n\r\nstatic void GetWindowTitleWeb(char* dst, size_t dstSize)\r\n{\r\n\tprintf(\"getWindowTitle\\n\");\r\n}\r\n\r\nstatic void SetWindowResizableWeb(GK_BOOL resizable)\r\n{\r\n\tprintf(\"setWindowResizable\\n\");\r\n}\r\n\r\nstatic void SleepWeb(uint32_t ms)\r\n{\r\n//\tprintf(\"sleep\\n\");\r\n}\r\n\r\nstatic uint16_t PrepareKeyWeb(uint16_t keyCode, uint16_t scanCode, GK_BOOL keyDown)\r\n{\r\n    return keyCode;\r\n}\r\n\r\nstatic void ProcessEventsWeb()\r\n{\r\n\tglfwPollEvents();\r\n\t\r\n    int x_pos, y_pos;\r\n    glfwGetMousePos(&x_pos, &y_pos);\r\n\tonWindowMouseMove((float)x_pos, (float)y_pos);\r\n\t\r\n    const int left_mouse_button_state = glfwGetMouseButton(GLFW_MOUSE_BUTTON_1);\r\n    if (left_mouse_button_state == GLFW_PRESS) {\r\n\t\tonWindowMouseDown((float)x_pos, (float)y_pos, 0);\r\n    }\r\n}\r\n\r\nstatic void SwapBuffersWeb()\r\n{\r\n\tglfwTerminate();\r\n}\r\n\r\n#ifdef __cplusplus\r\nextern \"C\"{\r\n#endif\r\n\r\n\tgkPlatform gkGetPlatform()\r\n\t{\r\n\t\tgkPlatform platform;\r\n\r\n\t\tplatform.Init = initWeb;\r\n\t\tplatform.Run = runWeb;\r\n\t\tplatform.Cleanup = cleanupWeb;\r\n\t\tplatform.Exit = ExitAppWeb;\r\n\r\n\t\tplatform.GetAppDir = GetAppDirWeb;\r\n\t\tplatform.SetVSync = SetVSyncWeb;\r\n\r\n\t\tplatform.ResizeScreen = ResizeScreenWeb;\r\n\t\tplatform.GetSupportedSizes = GetSupportedSizesWeb;\r\n\t\tplatform.SetFullscreen = SetFullscreenWeb;\r\n\r\n\t\tplatform.SetWindowTitle = SetWindowTitleWeb;\r\n\t\tplatform.GetWindowTitle = GetWindowTitleWeb;\r\n\r\n\t\tplatform.SetWindowResizable = SetWindowResizableWeb;\r\n\r\n\t\tplatform.Sleep = SleepWeb;\r\n\r\n\t\tplatform.PrepareKey = PrepareKeyWeb;\r\n\r\n\t\tplatform.ProcessEvents = ProcessEventsWeb;\r\n\r\n\t\tplatform.SwapBuffers = SwapBuffersWeb;\r\n\r\n\t\treturn platform;\r\n\t}\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif","/* Copyright (c) 2014 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include <gkTypes.h>\r\n#include <stdlib.h>\r\n\r\nsize_t\tgkUtf8Length(char* str)\r\n{\r\n\tsize_t len = 0;\r\n\tchar* p = str;\r\n\twhile (*p)\r\n\t\tif ((*p++ & 0xC0) !=  0x80) len++;\r\n\treturn len;\r\n}\r\n\r\nchar*\tgkUtf8CharCode(char* str, unsigned int* dstCharCode)\r\n{\r\n\tint result = 0, bytesLeft = 0;\r\n\tchar* p = str, c = *p;\r\n\tif (!c) {\r\n\t\t*dstCharCode = 0;\r\n\t\treturn p;\r\n\t}\r\n\tdo{\r\n\t\tif ((c & 0xC0) == 0x80) {\r\n\t\t\tresult = (result << 6) | (c & 0x7F);\r\n\t\t} else {\r\n\t\t\tbytesLeft = 0;\r\n\t\t\twhile (c&0x80) {\r\n\t\t\t\tbytesLeft++;\r\n\t\t\t\tc = c<<1;\r\n\t\t\t}\r\n\t\t\tresult = c>>bytesLeft;\r\n\t\t}\r\n\t\tc = *++p;\r\n\t}while (c && --bytesLeft>0);\r\n\t*dstCharCode = result;\r\n\treturn p;\r\n}\r\n\r\nsize_t\tgkUtf8ToWcs(wchar_t* dst, char* src, size_t dstSize)\r\n{\r\n\tsize_t pos, maxPos = dstSize/sizeof(wchar_t);\r\n\twchar_t* d = dst;\r\n\tchar* s = src;\r\n\tunsigned int uc;\r\n\r\n\tif (d) {\r\n\t\tfor (pos = 0, uc = 1; pos < maxPos && uc; pos++) {\r\n\t\t\ts = gkUtf8CharCode(s, &uc);\r\n\t\t\t*d++ = (wchar_t)uc;\r\n\t\t}\r\n\t} else {\r\n\t\treturn (gkUtf8Length(src) + 1)*sizeof(wchar_t);\r\n\t}\r\n\treturn pos*sizeof(wchar_t);\r\n}\r\n\r\nstatic size_t utf8RequiredBytes(unsigned int c)\r\n{\r\n\tif (c<0x80)\r\n\t\treturn 1;\r\n\telse if (c<0x800)\r\n\t\treturn 2;\r\n\telse if (c<0x10000)\r\n\t\treturn 3;\r\n\telse if (c<0x200000)\r\n\t\treturn 4;\r\n\telse if (c<0x4000000)\r\n\t\treturn 5;\r\n\treturn 6;\r\n}\r\n\r\nchar* gkUtf8Char(char* dst, uint32_t c, size_t dstSize)\r\n{\r\n\tsize_t bytesRequired = utf8RequiredBytes(c);\r\n\tint i;\r\n\tchar r = 0;\r\n\r\n\tif(bytesRequired>dstSize)\r\n\t\treturn 0;\r\n\r\n\tif (bytesRequired == 1) {\t\r\n\t\t*dst = (char)c;\r\n\t\treturn dst + 1;\r\n\t}\r\n\r\n\tfor(i = bytesRequired - 1; i>=0; i--)\r\n\t{\r\n\t\tdst[i] = 0x80 | (c&0x3F);\r\n\t\tc = c>>6;\r\n\t\tr |= (r>>1) | 0x80;\r\n\t}\r\n\t*dst |= r;\r\n\treturn dst + bytesRequired;\r\n}\r\n\r\nsize_t\tgkWcsToUtf8(char* dst, wchar_t* src, size_t dstSize)\r\n{\r\n\tsize_t pos, dstLeft = dstSize;\r\n\tchar* d = dst;\r\n\twchar_t* s = src;\r\n\r\n\tif (d) {\r\n\t\tfor (pos = 0; d && pos<dstSize; pos++, s++) {\r\n\t\t\td = gkUtf8Char(d, *s, dstLeft);\r\n\t\t\tdstLeft = d - dst;\r\n\t\t\tif (!*s) break;\r\n\t\t}\r\n\t} else {\r\n\t\tpos = 1;\r\n\t\twhile (*s)\r\n\t\t\tpos += utf8RequiredBytes((uint32_t)*s++);\r\n\t}\r\n\r\n\treturn pos;\r\n}\r\n\r\n\r\nwchar_t* gkWcsFromUtf8(char* src)\r\n{\r\n\tsize_t size = gkUtf8ToWcs(0, src, 0);\r\n\twchar_t* res = (wchar_t*)malloc(size);\r\n\tgkUtf8ToWcs(res, src, size);\r\n\treturn res;\r\n}\r\n\r\nchar*\tgkUtf8FromWcs(wchar_t* src)\r\n{\r\n\tsize_t size = gkWcsToUtf8(0, src, 0);\r\n\tchar* res = (char*)malloc(size);\r\n\tgkWcsToUtf8(res, src, size);\r\n\treturn res;\r\n}","/* Copyright (c) 2012 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#define GK_INTERNAL\r\n\r\n#include \"gk.h\"\r\n\r\n#include \"gkGL.h\"\r\n\r\n#include <stdlib.h>\r\n\r\nvoid gkProcessChildrenLayout(gkPanel* panel);\r\nvoid gkProcessLayoutPanel(gkPanel* panel, gkRect* clientRect);\r\n\r\n#define FABS(x) x<0?-x:x\r\n\r\ngkPanel* gkMouseTarget = 0;\r\ngkPanel* gkFocusPanel = 0;\r\n\r\ngkPanel* gkCreatePanel()\r\n{\r\n    return gkCreatePanelEx(sizeof(gkPanel));\r\n}\r\n\r\ngkPanel* gkCreatePanelEx(size_t panelSize){\r\n\tgkPanel* panel = (gkPanel*)malloc(panelSize);\r\n\tgkInitDispatcher(&panel->dispatcher);\r\n\tpanel->x = 0;\r\n\tpanel->y = 0;\r\n\tpanel->width = 0;\r\n\tpanel->height = 0;\r\n\tpanel->transform = gkMatrixCreateIdentity();\r\n\tpanel->anchorX = 0;\r\n\tpanel->anchorY = 0;\r\n\tpanel->colorFilter = GK_COLOR(1,1,1,1);\r\n\tpanel->data = 0;\r\n\tpanel->layoutFunc = 0;\r\n\tpanel->updateFunc = 0;\r\n\tpanel->drawFunc = 0;\r\n\tpanel->parent = 0;\r\n\tpanel->numChildren = 0;\r\n\tpanel->mouseOver = GK_FALSE;\r\n\tpanel->mouseX = panel->mouseY = 0;\r\n\tpanel->mouseEnabled = panel->mouseChildren = panel->keyboardEnabled = panel->keyboardChildren = GK_TRUE;\r\n\tpanel->visible = GK_TRUE;\r\n\r\n\tpanel->mChildren.first = panel->mChildren.last = 0;\r\n\tpanel->mNext = 0;\r\n\tpanel->mNextChild = 0;\r\n\tpanel->mGuardDestroy = GK_FALSE;\r\n\tpanel->mMustDestroy = GK_FALSE;\r\n\tpanel->mViewport = GK_FALSE;\r\n\treturn panel;\r\n}\r\n\r\ngkPanel* gkCreateViewportPanel()\r\n{\r\n    return gkCreateViewportPanelEx(sizeof(gkPanel));\r\n}\r\n\r\ngkPanel* gkCreateViewportPanelEx(size_t panelSize){\r\n\tgkPanel* panel = gkCreatePanelEx(panelSize);\r\n\tpanel->mViewport = GK_TRUE;\r\n\treturn panel;\r\n}\r\n\r\nstatic void gkGuardDestroy(gkPanel* panel)\r\n{\r\n    panel->mGuardDestroy = GK_TRUE;\r\n}\r\nstatic void gkUnguardDestroy(gkPanel* panel)\r\n{\r\n    panel->mGuardDestroy = GK_FALSE;\r\n    if(panel->mMustDestroy)\r\n        gkDestroyPanel(panel);\r\n}\r\n\r\nvoid gkDestroyPanel(gkPanel* panel){\r\n\tgkPanel *p;\r\n\tif(panel->mGuardDestroy){\r\n\t\tpanel->mMustDestroy = GK_TRUE;\r\n\t}else{\r\n\t\tif(panel->parent) gkRemoveChild(panel);\r\n\t\tif(gkFocusPanel == panel) gkSetFocus(0);\r\n\t\tgkCleanupDispatcher(&panel->dispatcher);\r\n\t\tfor(p = panel->mChildren.first; p; p = panel->mNextChild){\r\n\t\t\tpanel->mNextChild = p->mNext;\r\n\t\t\tp->parent = 0;\r\n\t\t\tp->mNext = 0;\r\n\t\t}\r\n\t\tif(gkMouseTarget == panel)\r\n        {\r\n            gkMouseTarget = 0;\r\n        }\r\n\t\tfree(panel);\r\n\t}\r\n}\r\n\r\nvoid gkAddChild(gkPanel* parent, gkPanel* child){\r\n    gkAddChildAt(parent, child, parent->numChildren);\r\n}\r\n\r\nvoid gkAddChildAt(gkPanel* parent, gkPanel* child, int index){\r\n    gkPanel* p;\r\n\tgkEvent evt;\r\n\tint i = 1;\r\n\tif(child->parent) gkRemoveChild(child);\r\n\r\n\tgkProcessChildrenLayout(parent);\r\n\r\n\tchild->parent = parent;\r\n\tchild->mNext = 0;\r\n\tif(parent->mChildren.last){\r\n        if(index >= parent->numChildren)\r\n        {\r\n            parent->mChildren.last->mNext = child;\r\n            parent->mChildren.last = child;\r\n        }else if(index>0){\r\n\t\t\tfor(p = parent->mChildren.first; p && i<index; p = p->mNext) i++;\r\n\t\t\tchild->mNext = p->mNext;\r\n\t\t\tp->mNext = child;\r\n\t\t}else{\r\n\t\t\tchild->mNext = parent->mChildren.first;\r\n\t\t\tparent->mChildren.first = child;\r\n\t\t}\r\n\t}else{\r\n\t\tparent->mChildren.first = parent->mChildren.last = child;\r\n\t}\r\n\tparent->numChildren++;\r\n\r\n\tevt.type = GK_ON_PANEL_ADDED;\r\n\tevt.target = evt.currentTarget = child;\r\n\tgkDispatch(child, &evt);\r\n}\r\n\r\nvoid gkRemoveChild(gkPanel* child){\r\n\tgkPanel *panel = child->parent;\r\n\tif(panel){\r\n\t\tgkEvent evt;\r\n\t\tgkPanel* p, *prev = 0;\r\n\t\tfor(p = panel->mChildren.first; p && p != child; p = p->mNext) prev = p;\r\n\t\tif(p != 0){\r\n\t\t\tif(p == panel->mChildren.last) panel->mChildren.last = prev;\r\n\t\t\tif(prev){\r\n\t\t\t\tprev->mNext = p->mNext;\r\n\t\t\t}else{\r\n\t\t\t\tpanel->mChildren.first = p->mNext;\r\n\t\t\t}\r\n\t\t\tif(p == panel->mNextChild) panel->mNextChild = p->mNext;\r\n\t\t\tpanel->numChildren--;\r\n\t\t}\r\n\t\tchild->parent = 0;\r\n\t\tchild->mNext = 0;\r\n\t\tif(gkFocusPanel == child) gkSetFocus(0);\r\n\t\tevt.type = GK_ON_PANEL_REMOVED;\r\n\t\tevt.target = evt.currentTarget = child;\r\n\t\tgkDispatch(child, &evt);\r\n\t}\r\n}\r\n\r\nvoid gkRemoveChildAt(gkPanel* parent, int childIndex){\r\n\tgkRemoveChild(gkGetChildAt(parent, childIndex));\r\n}\r\n\r\nint gkGetChildIndex(gkPanel* child){\r\n\tgkPanel *parent = child->parent, *p;\r\n\tint index = 0;\r\n\tif(parent){\r\n\t\tfor(p = parent->mChildren.first; p && p != child; p = p->mNext)\t\tindex++;\r\n\t}\r\n\treturn index;\r\n}\r\n\r\ngkPanel* gkGetChildAt(gkPanel* parent, int childIndex){\r\n\tgkPanel *p;\r\n\tint index = 0;\r\n\tif(parent){\r\n\t\tfor(p = parent->mChildren.first; p && index != childIndex; p = p->mNext)\t\tindex++;\r\n\t}\r\n\treturn p;\r\n}\r\n\r\nvoid gkProcessLayoutMainPanel(gkPanel* panel, float width, float height)\r\n{\r\n    float oldWidth = panel->width;\r\n    float oldHeight = panel->height;\r\n    gkRect clientRect = {0,0, width, height};\r\n\r\n\tif(panel->layoutFunc)\r\n    {\r\n\t\tpanel->layoutFunc(panel, &clientRect);\r\n    }\r\n\r\n\tpanel->width = width;\r\n\tpanel->height = height;\r\n\r\n    gkProcessChildrenLayout(panel);\r\n\r\n    if(oldWidth != width || oldHeight != height)\r\n    {\r\n        gkEvent changedEvent;\r\n        changedEvent.type = GK_ON_PANEL_RESIZED;\r\n        changedEvent.target = panel;\r\n        changedEvent.currentTarget = panel;\r\n        gkDispatch(panel, &changedEvent);\r\n    }\r\n}\r\n\r\nvoid gkProcessLayoutPanel(gkPanel* panel, gkRect* clientRect)\r\n{\r\n    float oldWidth = panel->width;\r\n    float oldHeight = panel->height;\r\n\r\n\tif(panel->layoutFunc)\r\n    {\r\n\t\tpanel->layoutFunc(panel, clientRect);\r\n\t}\r\n\r\n    gkProcessChildrenLayout(panel);\r\n\r\n    if(oldWidth != panel->width || oldHeight != panel->height)\r\n    {\r\n        gkEvent changedEvent;\r\n        changedEvent.type = GK_ON_PANEL_RESIZED;\r\n        changedEvent.target = panel;\r\n        changedEvent.currentTarget = panel;\r\n        gkDispatch(panel, &changedEvent);\r\n    }\r\n}\r\nvoid gkProcessChildrenLayout(gkPanel* panel)\r\n{\r\n    gkPanel* p;\r\n    gkRect clientRect = { 0, 0, panel->width, panel->height };\r\n\tgkGuardDestroy(panel);\r\n\tfor(p = panel->mChildren.first; p; p = panel->mNextChild){\r\n\t\tpanel->mNextChild = p->mNext;\r\n        gkProcessLayoutPanel(p, &clientRect);\r\n    }\r\n\tgkUnguardDestroy(panel);\r\n}\r\n\r\nvoid gkProcessUpdatePanel(gkPanel* panel){\r\n\tgkPanel* p;\r\n\tgkGuardDestroy(panel);\r\n\tif(panel->updateFunc){\r\n\t\tpanel->updateFunc(panel);\r\n\t}\r\n\tfor(p = panel->mChildren.first; p; p = panel->mNextChild){\r\n\t\tpanel->mNextChild = p->mNext;\r\n\t\tgkProcessUpdatePanel(p);\r\n\t}\r\n\tgkUnguardDestroy(panel);\r\n}\r\n\r\nvoid gkProcessDrawPanel(gkPanel* panel)\r\n{\r\n\tgkPanel* p;\r\n\tgkMatrix t = gkMatrixCreateTranslation(panel->x, panel->y);\r\n\tgkMatrix t2 = gkMatrixCreateTranslation(-panel->anchorX*panel->width, -panel->anchorY*panel->height);\r\n\tif(!panel->visible)\r\n        return;\t/* Don't draw invisible panels */\r\n\tgkGuardDestroy(panel);\r\n\tgkPushColorFilter(panel->colorFilter.r, panel->colorFilter.g, panel->colorFilter.b, panel->colorFilter.a);\r\n\tgkPushTransform(&t);\r\n\tgkPushTransform(&panel->transform);\r\n\tgkPushTransform(&t2);\r\n\tif(panel->mViewport)\r\n    {\r\n\t\tgkMatrix m = gkLocalToGlobal(panel);\r\n\t\tgkPoint topLeft = gkTransformPoint(GK_POINT(0,0), &m);\r\n\t\tgkPoint bottomRight = gkTransformPoint(GK_POINT(panel->width, panel->height), &m);\r\n\t\tfloat h = FABS(bottomRight.y - topLeft.y);\r\n\t\tglPushMatrix();\r\n\t\tglMatrixMode(GL_PROJECTION);\r\n\t\tglPushMatrix();\r\n/*\r\n * \tTODO: glPushAttrib is not supported in GLES\r\n\t\tglPushAttrib(GL_ALL_ATTRIB_BITS);\r\n\t\tglPushClientAttrib(GL_CLIENT_ALL_ATTRIB_BITS);\r\n\t\tglViewport((GLint)topLeft.x, (GLint)gkGetScreenSize().height - topLeft.y - h, FABS(bottomRight.x - topLeft.x), h);\r\n\t\tif(panel->drawFunc){\r\n\t\t\tpanel->drawFunc(panel);\r\n\t\t}\r\n\t\tglPopClientAttrib();\r\n\t\tglPopAttrib();\r\n*/\r\n\t\tglMatrixMode(GL_PROJECTION);\r\n\t\tglPopMatrix();\r\n\t\tglMatrixMode(GL_MODELVIEW);\r\n\t\tglPopMatrix();\r\n\t}else{\r\n\t\tif(panel->drawFunc){\r\n\t\t\tpanel->drawFunc(panel);\r\n\t\t}\r\n\t\tfor(p = panel->mChildren.first; p; p = panel->mNextChild){\r\n\t\t\tpanel->mNextChild = p->mNext;\r\n\t\t\tgkProcessDrawPanel(p);\r\n\t\t}\r\n\t}\r\n\tgkPopTransform();\r\n\tgkPopTransform();\r\n\tgkPopTransform();\r\n\tgkPopColorFilter();\r\n\tgkUnguardDestroy(panel);\r\n}\r\n\r\ngkMatrix gkGlobalToLocal(gkPanel* panel){\r\n\tgkMatrix m = gkLocalToGlobal(panel);\r\n\tgkMatrixInverse(&m);\r\n\treturn m;\r\n}\r\n\r\ngkMatrix gkLocalToGlobal(gkPanel* panel){\r\n\tgkMatrix m = gkMatrixCreateIdentity(), t, t2;\r\n\tgkPanel* p = panel;\r\n\tdo{\r\n\t\tt = gkMatrixCreateTranslation(p->x, p->y);\r\n\t\tt2 = gkMatrixCreateTranslation(-p->anchorX*p->width, -p->anchorY*p->height);\r\n\t\tgkMatrixMultPtr(&m, &t2);\r\n\t\tgkMatrixMultPtr(&m, &p->transform);\r\n\t\tgkMatrixMultPtr(&m, &t);\r\n\t\tp = p->parent;\r\n\t}while(p);\r\n\treturn m;\r\n}\r\n\r\n/*** Panel input handling ***/\r\n\r\ngkPoint gkMousePosition;\r\n\r\n#define BYTE_OFFSET(obj, prop) ((char*)&obj->prop - (char*)obj)\r\n\r\ngkPanel* gkGetMouseTarget(gkPanel* panel, gkPoint pos, size_t enabledOffset, size_t enabledChildrenOffset){\r\n\tgkPanel** children, *p;\r\n\tint i = panel->numChildren;\r\n\tGK_BOOL *enabled = (GK_BOOL*)((char*)panel + enabledOffset);\r\n\tGK_BOOL *enabledChildren = (GK_BOOL*)((char*)panel + enabledChildrenOffset);\r\n\tif(!panel->visible) return 0;\t/* ignore invisible panels */\r\n\tif(*enabledChildren){\r\n\t\tchildren = (gkPanel**)calloc(panel->numChildren, sizeof(gkPanel*));\r\n\t\tfor(p = panel->mChildren.first; p && i>0; p = p->mNext) children[--i] = p;\t/* also reverses the order so in the next loop it starts from the last and goes to first */\r\n\t\tfor(i = 0; i<panel->numChildren; i++){\r\n            gkMatrix translate, t;\r\n\t\t\tgkPoint tmpPos = pos;\r\n\t\t\tp = children[i];\r\n            translate = gkMatrixCreateTranslation(p->x, p->y);\r\n            t = gkMatrixCreateTranslation(-p->anchorX*p->width, -p->anchorY*p->height);\r\n            gkMatrixMultPtr(&t, &p->transform);\r\n\t\t\tgkMatrixMultPtr(&t, &translate);\r\n\t\t\tgkMatrixInverse(&t);\r\n\t\t\ttmpPos = gkTransformPoint(tmpPos, &t);\r\n\t\t\tif((p = gkGetMouseTarget(p, tmpPos, enabledOffset, enabledChildrenOffset)) != 0){\r\n\t\t\t\tpanel->mouseX = pos.x;\r\n\t\t\t\tpanel->mouseY = pos.y;\r\n\t\t\t\tfree(children);\r\n\t\t\t\treturn p;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfree(children);\r\n\t}\r\n\tif(pos.x>=0 && pos.y>=0 && pos.x<=panel->width && pos.y<=panel->height && *enabled){\r\n\t\tpanel->mouseX = pos.x;\r\n\t\tpanel->mouseY = pos.y;\r\n\t\treturn panel;\r\n\t}else return 0;\r\n}\r\n\r\nvoid gkCheckFocusedPanel(){\r\n\tif(gkFocusPanel){\r\n\t\tgkPanel* p = gkFocusPanel;\r\n\t\tGK_BOOL focusable = p->keyboardEnabled && p->visible;\r\n\t\tif(focusable){\r\n\t\t\tp = p->parent;\r\n\t\t\twhile(p && focusable){\r\n\t\t\t\tif(!(p->keyboardChildren && p->visible)) focusable = GK_FALSE;\r\n\t\t\t\tp = p->parent;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!focusable) gkSetFocus(0);\r\n\t}\r\n}\r\n\r\nvoid gkUpdateMouseTarget(gkPanel* mainPanel){\r\n\tgkPanel *oldMouseTarget, *p, *lastCommon;\r\n\tgkPoint pos = gkMousePosition;\r\n\tif(!mainPanel){\r\n\t\tgkMouseTarget = 0;\r\n\t\treturn;\r\n\t}\r\n\toldMouseTarget = gkMouseTarget;\r\n\tgkMouseTarget = gkGetMouseTarget(mainPanel, pos, BYTE_OFFSET(mainPanel, mouseEnabled), BYTE_OFFSET(mainPanel, mouseChildren));\r\n\tif(oldMouseTarget != gkMouseTarget){\r\n\t\tgkMouseEvent enter, leave;\r\n\t\tenter.type = GK_ON_MOUSE_ENTER;\r\n\t\tenter.target = gkMouseTarget;\r\n\t\tenter.position = gkMousePosition;\r\n\t\tleave.type = GK_ON_MOUSE_LEAVE;\r\n\t\tleave.target = oldMouseTarget;\r\n\t\tleave.position = gkMousePosition;\r\n\r\n\t\tfor(p = oldMouseTarget; p; p = p->parent) p->mouseOver = GK_FALSE;\t/* reset mouse over */\r\n\t\tfor(p = gkMouseTarget; p; p = p->parent) p->mouseOver = GK_TRUE;\t/* set mouse over to all panels under the mouse */\r\n\t\tfor(p = oldMouseTarget; p && !p->mouseOver; p = p->parent){\r\n\t\t\tleave.currentTarget = p;\r\n\t\t\tgkDispatch(p, &leave);\t/* dispatch GK_ON_MOUSE_LEAVE */\r\n\t\t}\r\n\t\tlastCommon = p;\r\n\t\tfor(p = gkMouseTarget; p != 0 && p != lastCommon; p = p->parent){\r\n\t\t\tenter.currentTarget = p;\r\n\t\t\tgkDispatch(p, &enter);\t/* dispatch GK_ON_MOUSE_ENTER */\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid gkProcessMouseEvent(gkMouseEvent* mouseEvent){\r\n\tgkPanel* current, *newFocusTarget = 0, *curFocusTarget = gkFocusPanel;\r\n\tgkMousePosition = mouseEvent->position;\r\n\tif(mouseEvent->type == GK_ON_MOUSE_DOWN){\r\n\t\tnewFocusTarget = gkGetMouseTarget(gkMainPanel, gkMousePosition, BYTE_OFFSET(gkMainPanel, keyboardEnabled), BYTE_OFFSET(gkMainPanel, keyboardChildren));\r\n\t}\r\n\tif(gkMouseTarget){\r\n\t\tmouseEvent->target = current = gkMouseTarget;\r\n\t\tdo{\r\n\t\t\tgkMatrix m = gkGlobalToLocal(current);\r\n\t\t\tmouseEvent->position = gkTransformPoint(gkMousePosition, &m);\r\n\t\t\tmouseEvent->currentTarget = current;\r\n\t\t}while(gkDispatch(current, mouseEvent) && (current = current->parent));\r\n\t}\r\n\tif(newFocusTarget && curFocusTarget == gkFocusPanel){\r\n\t\tgkSetFocus(newFocusTarget);\r\n\t}\r\n}\r\n\r\n\r\nvoid gkSetFocus(gkPanel* panel){\r\n\tstatic gkPanel *tmpNextFocused = 0;\r\n\tgkPanel* tmp = gkFocusPanel;\r\n\tif(panel == gkFocusPanel) return;\r\n\ttmpNextFocused = panel;\r\n\tgkFocusPanel = 0;\r\n\tif(tmp){\r\n\t\tgkEvent evt;\r\n\t\tevt.type = GK_ON_PANEL_FOCUS_OUT;\r\n\t\tevt.target = evt.currentTarget = tmp;\r\n\t\tgkDispatch(tmp, &evt);\r\n\t}\r\n\tif(gkFocusPanel != tmpNextFocused){\r\n\t\tif(tmpNextFocused->keyboardEnabled && tmpNextFocused->visible){\r\n\t\t\tgkFocusPanel = tmpNextFocused;\r\n\t\t\tif(gkFocusPanel){\r\n\t\t\t\tgkEvent evt;\r\n\t\t\t\tevt.type = GK_ON_PANEL_FOCUS_IN;\r\n\t\t\t\tevt.target = evt.currentTarget = gkFocusPanel;\r\n\t\t\t\tgkDispatch(gkFocusPanel, &evt);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\ngkPanel* gkGetFocus(){\r\n\treturn gkFocusPanel;\r\n}\r\n\r\nvoid gkProcessKeyboardEvent(gkKeyboardEvent* keyboardEvent){\r\n\tif(!gkFocusPanel) return;\r\n\tkeyboardEvent->target = keyboardEvent->currentTarget = gkFocusPanel;\r\n\tgkDispatch(gkFocusPanel, keyboardEvent);\r\n}\r\n","/* Copyright (c) 2012 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n\r\n#include \"gk.h\"\r\n#include \"gk_internal.h\"\r\n\r\n#include <stdlib.h>\r\n\r\nuint64_t gkAppStartTime = 0;\r\n\r\n#ifdef GK_PLATFORM_WIN\r\n#include <windows.h>\r\n\r\nuint64_t gkMilliseconds(){\r\n\tLARGE_INTEGER count, freq;\r\n\tif(!QueryPerformanceCounter(&count)){\r\n\t\treturn GetTickCount() - gkAppStartTime;\r\n\t}\r\n\tQueryPerformanceFrequency(&freq);\r\n\treturn (count.QuadPart/(freq.QuadPart/1000)) - gkAppStartTime;\r\n}\r\n\r\n#elif defined(GK_PLATFORM_LINUX) || defined(GK_PLATFORM_WEB)\r\n#include <unistd.h>\r\n#include <time.h>\r\n\r\nuint64_t gkMilliseconds(){\r\n    struct timespec tv;\r\n    clock_gettime(CLOCK_MONOTONIC, &tv);\r\n    return (tv.tv_sec*1000 + tv.tv_nsec/1000000) - gkAppStartTime;\r\n}\r\n\r\n#elif defined(GK_PLATFORM_TIZEN)\r\n\t// implemented in gkPlatformTizen.cpp\r\n#elif defined(GK_PLATFORM_ANDROID)\r\n#include <unistd.h>\r\n#include <time.h>\r\n\r\nuint64_t gkMilliseconds(){\r\n    struct timespec tv;\r\n    clock_gettime(CLOCK_MONOTONIC, &tv);\r\n    return (tv.tv_sec*1000 + tv.tv_nsec/1000000) - gkAppStartTime;\r\n}\r\n#else\r\n\r\nuint64_t gkMilliseconds(){\r\n#ifdef GK_SHOW_PLATFORM_ERRORS\r\n#error gkMilliseconds not implemented\r\n#else\r\n\treturn 0;\r\n#endif\r\n}\r\n\r\n#endif\r\n\r\ntypedef struct gkTimerRefStruct gkTimerRef;\r\nstruct gkTimerRefStruct{\r\n\tgkTimerRef *next;\r\n\tgkTimer* timer;\r\n};\r\n\r\ngkTimerRef *gkTimers, *gkTimersLast;\r\n\r\nstruct gkTimerStructEx{\r\n\tgkDispatcher dispatcher;\r\n\tuint64_t delay;\r\n\tuint32_t repeats;\r\n\tuint64_t interval;\r\n\tGK_BOOL running;\r\n\tGK_BOOL destroyOnComplete;\r\n\t/* hidden fields */\r\n\tgkTimerRef* ref;\r\n\tuint64_t startTime;\r\n\tuint32_t repeatsElapsed;\r\n};\r\ntypedef struct gkTimerStructEx gkTimerEx;\r\n\r\ngkTimer* gkCreateTimer(){\r\n\tgkTimerEx* timer = (gkTimerEx*)malloc(sizeof(gkTimerEx));\r\n\tgkTimerRef* ref = (gkTimerRef*)malloc(sizeof(gkTimerRef));\r\n\tgkInitDispatcher(&timer->dispatcher);\r\n\ttimer->delay = 0;\r\n\ttimer->repeats = 0;\r\n\ttimer->interval = 0;\r\n\ttimer->running = GK_FALSE;\r\n\ttimer->destroyOnComplete = GK_FALSE;\r\n\ttimer->repeatsElapsed = 0;\r\n\tref->next = 0;\r\n\tref->timer = (gkTimer*)timer;\r\n\ttimer->ref = ref;\r\n\tif(gkTimers == 0){\r\n\t\tgkTimersLast = gkTimers = ref;\r\n\t}else{\r\n\t\tgkTimersLast->next = ref;\r\n\t\tgkTimersLast = ref;\r\n\t}\r\n\treturn (gkTimer*)timer;\r\n}\r\n\r\nvoid gkStartTimer(gkTimer* timer, GK_BOOL destroyOnComplete){\r\n\tgkTimerEx* t = (gkTimerEx*)timer;\r\n\tt->startTime = gkMilliseconds();\r\n\tt->repeatsElapsed = 0;\r\n\tt->destroyOnComplete = destroyOnComplete;\r\n\tt->running = GK_TRUE;\r\n}\r\n\r\nvoid gkStopTimer(gkTimer* timer){\r\n\t((gkTimerEx*)timer)->running = GK_FALSE;\r\n}\r\n\r\nvoid gkDestroyTimer(gkTimer* timer){\r\n\t((gkTimerEx*)timer)->ref->timer = 0;\r\n\tgkCleanupDispatcher(&timer->dispatcher);\r\n\tfree(timer);\r\n}\r\n\r\nvoid gkUpdateTimers(){\r\n\tgkTimerRef* ref = gkTimers, *prev = 0, *p;\r\n\tgkTimerEx* timer;\r\n\tuint64_t currentTime = gkMilliseconds();\r\n\twhile(ref){\r\n\t\tif(ref->timer == 0){\r\n\t\t\tif(ref == gkTimersLast) gkTimersLast = prev;\r\n\t\t\tif(prev){\r\n\t\t\t\tprev->next = ref->next;\r\n\t\t\t}else{\r\n\t\t\t\tgkTimers = ref->next;\r\n\t\t\t}\r\n\t\t\tref = (p = ref)->next;\r\n\t\t\tfree(p);\r\n\t\t}else{\r\n\t\t\ttimer = (gkTimerEx*)ref->timer;\r\n\t\t\tif(timer->running){\r\n\t\t\t\tif(\t(timer->repeatsElapsed == 0 && (currentTime - timer->startTime) >= timer->delay) ||\r\n\t\t\t\t\t(timer->repeatsElapsed > 0 && (currentTime - timer->startTime) >= timer->interval) ){\r\n\t\t\t\t\tgkEvent evt;\r\n\t\t\t\t\tevt.type = GK_ON_TIMER;\r\n\t\t\t\t\tevt.currentTarget = evt.target = timer;\r\n\t\t\t\t\tgkDispatch(timer, &evt);\r\n\t\t\t\t\tif(ref->timer){\r\n\t\t\t\t\t\ttimer->startTime = currentTime;\r\n\t\t\t\t\t\ttimer->repeatsElapsed++;\r\n\t\t\t\t\t\tif(timer->repeats > 0 && timer->repeatsElapsed == timer->repeats){\r\n\t\t\t\t\t\t\tgkStopTimer((gkTimer*)timer);\r\n\t\t\t\t\t\t\tevt.type = GK_ON_TIMER_COMPLETE;\r\n\t\t\t\t\t\t\tevt.currentTarget = evt.target = timer;\r\n\t\t\t\t\t\t\tgkDispatch(timer, &evt);\r\n\t\t\t\t\t\t\tif(ref->timer && timer->destroyOnComplete){\r\n\t\t\t\t\t\t\t\tgkDestroyTimer((gkTimer*)timer);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprev = ref;\r\n\t\t\tref = ref->next;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid gkInitTimers(){\r\n\tgkTimers = 0;\r\n\tgkTimersLast = 0;\r\n}\r\n\r\nvoid gkCleanupTimers(){\r\n\tgkTimerRef\t*ref = gkTimers, *p;\r\n\twhile(ref){\r\n\t\tif(ref->timer)\tgkDestroyTimer(ref->timer);\r\n\t\tref = (p = ref)->next;\r\n\t\tfree(p);\r\n\t}\r\n\tgkTimersLast = gkTimers = 0;\r\n}\r\n","/* Copyright (c) 2012 Toni Georgiev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n\r\n#include \"gk.h\"\r\n#include \"gk_internal.h\"\r\n\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <math.h>\r\n\r\n#define GK_TWEEN_FREQ\t15\r\n#define GK_FLOAT_PI     3.14159265358979323846f\r\n\r\nstruct gkTweenStruct{\r\n\tgkDispatcher listeners;\r\n\tvoid* var;\r\n\tuint32_t transitionType;\r\n\tuint64_t transitionTime;\r\n\tuint32_t varType;\r\n\tunion{\r\n\t\tstruct{\r\n\t\t\tuint8_t start;\r\n\t\t\tuint8_t end;\r\n\t\t}ub;\r\n\t\tstruct{\r\n\t\t\tint8_t start;\r\n\t\t\tint8_t end;\r\n\t\t}b;\r\n\t\tstruct{\r\n\t\t\tuint16_t start;\r\n\t\t\tuint16_t end;\r\n\t\t}us;\r\n\t\tstruct{\r\n\t\t\tint16_t start;\r\n\t\t\tint16_t end;\r\n\t\t}s;\r\n\t\tstruct{\r\n\t\t\tuint32_t start;\r\n\t\t\tuint32_t end;\r\n\t\t}ui;\r\n\t\tstruct{\r\n\t\t\tint32_t start;\r\n\t\t\tint32_t end;\r\n\t\t}i;\r\n\t\tstruct{\r\n\t\t\tfloat start;\r\n\t\t\tfloat end;\r\n\t\t}f;\r\n\t\tstruct{\r\n\t\t\tdouble start;\r\n\t\t\tdouble end;\r\n\t\t}d;\r\n\t}value;\r\n\tuint64_t startTime;\r\n};\r\ntypedef struct gkTweenStruct gkTweenEx;\r\n\r\ntypedef struct gkTweenRefStruct gkTweenRef;\r\nstruct gkTweenRefStruct{\r\n\tgkTweenRef* next;\r\n\tgkTweenEx* tween;\r\n}*gkTweens, *gkTweensLast;\r\n\r\nuint64_t gkLastTweenUpdate = 0;\r\n\r\nGK_BOOL gkProcessTween(gkTweenEx* tween);\r\n\r\nvoid gkInitTweens(){\r\n\tgkTweens = gkTweensLast = 0;\r\n\tgkLastTweenUpdate = gkMilliseconds();\r\n}\r\n\r\nvoid gkDestroyTween(gkTweenRef* tweenRef){\r\n\tgkTweenEx* tween = tweenRef->tween;\r\n\tif(tween)\r\n\t{\r\n\t\tgkCleanupDispatcher(&tween->listeners);\r\n\t\tfree(tween);\r\n\t}\r\n\ttweenRef->tween = 0;\r\n}\r\n\r\ngkTween* gkAddTween(void* var, uint32_t transitionType, uint64_t transitionTime, uint32_t varType, ...){\r\n\tva_list arglist;\r\n\tgkTweenEx* tween = (gkTweenEx*)malloc(sizeof(gkTweenEx));\r\n\tgkTweenRef* tweenRef = (gkTweenRef*)malloc(sizeof(gkTweenRef));\r\n\tgkRemoveTweens(var, sizeof(void*));\t/* Remove any previous tweens on the same variable */\r\n\tgkInitDispatcher(&tween->listeners);\r\n\ttween->var = var;\r\n\ttween->transitionType = transitionType;\r\n\ttween->transitionTime = transitionTime;\r\n\ttween->varType = varType;\r\n\tva_start(arglist, varType);\r\n\tswitch(varType){\r\n\t\tcase GK_UNSIGNED_BYTE:\r\n\t\t\ttween->value.ub.start = (uint8_t)va_arg(arglist, int);\r\n\t\t\ttween->value.ub.end = (uint8_t)va_arg(arglist, int);\r\n\t\tbreak;\r\n\t\tcase GK_BYTE:\r\n\t\t\ttween->value.b.start = (int8_t)va_arg(arglist, int);\r\n\t\t\ttween->value.b.end = (int8_t)va_arg(arglist, int);\r\n\t\tbreak;\r\n\t\tcase GK_UNSIGNED_SHORT:\r\n\t\t\ttween->value.us.start = (uint16_t)va_arg(arglist, int);\r\n\t\t\ttween->value.us.end = (uint16_t)va_arg(arglist, int);\r\n\t\tbreak;\r\n\t\tcase GK_SHORT:\r\n\t\t\ttween->value.s.start = (int16_t)va_arg(arglist, int);\r\n\t\t\ttween->value.s.end = (int16_t)va_arg(arglist, int);\r\n\t\tbreak;\r\n\t\tcase GK_UNSIGNED_INT:\r\n\t\t\ttween->value.ui.start = va_arg(arglist, uint32_t);\r\n\t\t\ttween->value.ui.end = va_arg(arglist, uint32_t);\r\n\t\tbreak;\r\n\t\tcase GK_INT:\r\n\t\t\ttween->value.i.start = va_arg(arglist, int32_t);\r\n\t\t\ttween->value.i.end = va_arg(arglist, int32_t);\r\n\t\tbreak;\r\n\t\tcase GK_FLOAT:\r\n\t\t\ttween->value.f.start = (float)va_arg(arglist, double);\r\n\t\t\ttween->value.f.end = (float)va_arg(arglist, double);\r\n\t\tbreak;\r\n\t\tcase GK_DOUBLE:\r\n\t\t\ttween->value.d.start = va_arg(arglist, double);\r\n\t\t\ttween->value.d.end = va_arg(arglist, double);\r\n\t\tbreak;\r\n\t}\r\n\ttween->startTime = gkMilliseconds();\r\n\tva_end(arglist);\r\n\ttweenRef->next = 0;\r\n\ttweenRef->tween = tween;\r\n\tif(gkTweens){\r\n\t\tgkTweensLast->next = tweenRef;\r\n\t\tgkTweensLast = tweenRef;\r\n\t}else{\r\n\t\tgkTweens = gkTweensLast = tweenRef;\r\n\t}\r\n\treturn (gkTween*)tween;\r\n}\r\n\r\nvoid gkRemoveTweens(void* memOffset, size_t size){\r\n\tgkTweenRef* ref = gkTweens;\r\n\twhile(ref){\r\n\t\tif(ref->tween){\r\n\t\t\tif(ref->tween->var >= memOffset && ref->tween->var < (void*)((uint8_t*)memOffset + size)){\r\n\t\t\t\tgkDestroyTween(ref);\r\n\t\t\t}\r\n\t\t}\r\n\t\tref = ref->next;\r\n\t}\r\n}\r\n\r\nvoid gkUpdateTweens(){\r\n\tgkTweenRef* ref = gkTweens, *prev = 0, *p;\r\n\tif(gkMilliseconds() - gkLastTweenUpdate < GK_TWEEN_FREQ) return;\r\n\tgkLastTweenUpdate = gkMilliseconds();\r\n\twhile(ref){\r\n\t\tif(ref->tween == 0){\r\n\t\t\tif(prev){\r\n\t\t\t\tprev->next = ref->next;\r\n\t\t\t\tif(prev->next == 0)\r\n\t\t\t\t\tgkTweensLast = prev;\r\n\t\t\t}else{\r\n\t\t\t\tgkTweens = ref->next;\r\n\t\t\t}\r\n\t\t\tref = (p = ref)->next;\r\n\t\t\tfree(p);\r\n\t\t}else{\r\n\t\t\tgkTweenEvent evt;\r\n\t\t\tGK_BOOL finished = gkProcessTween(ref->tween);\r\n\t\t\tevt.type = GK_ON_TWEEN_UPDATE;\r\n\t\t\tevt.currentTarget = evt.target = ref->tween;\r\n\t\t\tevt.var = ref->tween->var;\r\n\t\t\tgkDispatch(ref->tween, &evt);\r\n\t\t\tif(finished){\r\n\t\t\t\tevt.type = GK_ON_TWEEN_FINISHED;\r\n\t\t\t\tgkDispatch(ref->tween, &evt);\r\n\t\t\t\tgkDestroyTween(ref);\r\n\t\t\t}\r\n\t\t\tprev = ref;\r\n\t\t\tref = ref->next;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid gkCleanupTweens(){\r\n\tgkTweenRef\t*ref = gkTweens, *p;\r\n\twhile(ref){\r\n\t\tif(ref->tween)\tgkDestroyTween(ref);\r\n\t\tref = (p = ref)->next;\r\n\t\tfree(p);\r\n\t}\r\n\tgkTweensLast = gkTweens = 0;\r\n}\r\n\r\n\r\nfloat gkInterpolate(float start, float end, float time, int type){\r\n\tswitch(type){\r\n\t\tcase GK_TWEEN_LINEAR:\r\n\t\t\treturn start + (end - start)*time;\r\n\t\tcase GK_TWEEN_EASE_IN_SINE:\r\n\t\t\treturn start + (end - start)*(sinf(time*GK_FLOAT_PI/2.0f - GK_FLOAT_PI/2.0f) + 1.0f);\r\n\t\tcase GK_TWEEN_EASE_OUT_SINE:\r\n\t\t\treturn start + (end - start)*(sinf(time*GK_FLOAT_PI/2.0f));\r\n\t\tcase GK_TWEEN_EASE_INOUT_SINE:\r\n\t\t\treturn start + (end - start)*(sinf((time - 0.5f)*GK_FLOAT_PI) + 1.0f)/2.0f;\r\n\t\tcase GK_TWEEN_EASE_OUTIN_SINE:\r\n\t\t\treturn start + (end - start)*(time<0.5f?sinf(time*GK_FLOAT_PI)/2.0f:sinf(time*GK_FLOAT_PI)/-2.0f + 1.0f);\r\n\t\tcase GK_TWEEN_EASE_IN_ELASTIC:{\r\n\t\t\tfloat density = 6;\r\n\t\t\treturn start + (end - start)*(sinf((time*GK_FLOAT_PI)*density + GK_FLOAT_PI/2.0f)*(time*time) + (powf(time,10.0f)))/2.0f;\r\n\t\t}\r\n\t\tcase GK_TWEEN_EASE_OUT_ELASTIC:{\r\n\t\t\tfloat density = 6;\r\n\t\t\tfloat rtime = 1 - time;\r\n\t\t\treturn start + (end - start)*(1.0f- (sinf((rtime*GK_FLOAT_PI)*density + GK_FLOAT_PI/2.0f)*(rtime*rtime) + (powf(rtime,10)))/2);\r\n\t\t}\r\n\t\tcase GK_TWEEN_EASE_IN_BOUNCE:{\r\n\t\t\tfloat k;\r\n\t\t\tfloat t = (1.0f - time);\r\n\t\t\tif (t < (1.0f/2.75f)) {\r\n\t\t\t\tk = (7.5625f*t*t);\r\n\t\t\t} else if (t < (2.0f/2.75f)) {\r\n\t\t\t\tt-=(1.5f/2.75f);\r\n\t\t\t\tk = (7.5625f*t*t + 0.75f);\r\n\t\t\t} else if (t < (2.5f/2.75f)) {\r\n\t\t\t\tt-=(2.25f/2.75f);\r\n\t\t\t\tk = (7.5625f*t*t + 0.9375f);\r\n\t\t\t} else {\r\n\t\t\t\tt-=(2.625f/2.75f);\r\n\t\t\t\tk = (7.5625f*t*t + 0.984375f);\r\n\t\t\t}\r\n\t\t\treturn start + (end - start)*(1.0f -k);\r\n\t\t}\r\n\t\tcase GK_TWEEN_EASE_OUT_BOUNCE:{\r\n\t\t\tfloat k;\r\n\t\t\tfloat t = time;\r\n\t\t\tif (t < (1.0f/2.75f)) {\r\n\t\t\t\tk = (7.5625f*t*t);\r\n\t\t\t} else if (t < (2.0f/2.75f)) {\r\n\t\t\t\tt-=(1.5f/2.75f);\r\n\t\t\t\tk = (7.5625f*t*t + 0.75f);\r\n\t\t\t} else if (t < (2.5f/2.75f)) {\r\n\t\t\t\tt-=(2.25f/2.75f);\r\n\t\t\t\tk = (7.5625f*t*t + 0.9375f);\r\n\t\t\t} else {\r\n\t\t\t\tt-=(2.625f/2.75f);\r\n\t\t\t\tk = (7.5625f*t*t + 0.984375f);\r\n\t\t\t}\r\n\t\t\treturn start + (end - start)*k;\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\treturn end;\r\n\t}\r\n}\r\n\r\nGK_BOOL gkProcessTween(gkTweenEx* tween){\r\n\tfloat t = 0.0f;\r\n\tif(gkLastTweenUpdate > tween->startTime)\r\n\t{\r\n\t\tt = (float)(gkLastTweenUpdate - tween->startTime)/(float)tween->transitionTime;\r\n\t\tif(t > 1.0f) t = 1.0f;\r\n\t}\r\n\tswitch(tween->varType){\r\n\t\tcase GK_UNSIGNED_BYTE:\r\n\t\t\t*((uint8_t*)tween->var) = (uint8_t)gkInterpolate((float)tween->value.ub.start, (float)tween->value.ub.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_BYTE:\r\n\t\t\t*((int8_t*)tween->var) = (int8_t)gkInterpolate((float)tween->value.b.start, (float)tween->value.b.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_UNSIGNED_SHORT:\r\n\t\t\t*((uint16_t*)tween->var) = (uint16_t)gkInterpolate((float)tween->value.us.start, (float)tween->value.us.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_SHORT:\r\n\t\t\t*((int16_t*)tween->var) = (int16_t)gkInterpolate((float)tween->value.s.start, (float)tween->value.s.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_UNSIGNED_INT:\r\n\t\t\t*((uint32_t*)tween->var) = (uint32_t)gkInterpolate((float)tween->value.ui.start, (float)tween->value.ui.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_INT:\r\n\t\t\t*((int32_t*)tween->var) = (int32_t)gkInterpolate((float)tween->value.i.start, (float)tween->value.i.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_FLOAT:\r\n\t\t\t*((float*)tween->var) = (float)gkInterpolate(tween->value.f.start, tween->value.f.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t\tcase GK_DOUBLE:\r\n\t\t\t*((double*)tween->var) = (double)gkInterpolate((float)tween->value.d.start, (float)tween->value.d.end, t, tween->transitionType);\r\n\t\tbreak;\r\n\t}\r\n\treturn t == 1.0f;\r\n}\r\n","#include \"gkStream.h\"\r\n\r\nsize_t gkStreamRead(gkStream* stream, void *buffer, size_t size)\r\n{\r\n\treturn stream->read(stream, buffer, size);\r\n}\r\n\r\nint gkStreamSeek(gkStream* stream, size_t offset, int origin)\r\n{\r\n\treturn stream->seek(stream, offset, origin);\r\n}\r\n\r\nsize_t gkStreamTell(gkStream* stream)\r\n{\r\n\treturn stream->tell(stream);\r\n}\r\n\r\nGK_BOOL gkStreamEnd(gkStream* stream)\r\n{\r\n\treturn stream->end(stream);\r\n}\r\n\r\nsize_t gkStreamWrite(gkStream* stream, const void *buffer, size_t size)\r\n{\r\n\treturn stream->write(stream, buffer, size);\r\n}\r\n\r\nvoid gkStreamClose(gkStream* stream)\r\n{\r\n\tstream->close(stream);\r\n}\r\n\r\nGK_BOOL gkIsPathRelative(char* path)\r\n{\r\n\tif (path[1] == ':' || path[0] == '/')\r\n\t\treturn GK_FALSE;\r\n\treturn GK_TRUE;\r\n}","#include \"gkStream.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef struct gkFileStream\r\n{\r\n\tgkStream base;\r\n\tFILE* file;\r\n}gkFileStream;\r\n\r\nstatic size_t fileStreamRead(gkStream* stream, void* buffer, size_t size)\r\n{\r\n\tgkFileStream* fileStream = (gkFileStream*)stream;\r\n\r\n\tsize_t res = fread(buffer, sizeof(char), size, fileStream->file);\r\n\tif(res == 0)\r\n\t\treturn ferror(fileStream->file) ? -1: 0;\r\n\treturn res;\r\n}\r\n\r\nstatic int fileStreamSeek(gkStream* stream, size_t offset, int origin)\r\n{\r\n\tgkFileStream* fileStream = (gkFileStream*)stream;\r\n\treturn fseek(fileStream->file, offset, origin);\r\n}\r\n\r\nstatic size_t fileStreamTell(gkStream* stream)\r\n{\r\n\tgkFileStream* fileStream = (gkFileStream*)stream;\r\n\treturn ftell(fileStream->file);\r\n}\r\n\r\nstatic GK_BOOL fileStreamEnd(gkStream* stream)\r\n{\r\n\tgkFileStream* fileStream = (gkFileStream*)stream;\r\n\treturn feof(fileStream->file);\r\n}\r\n\r\nstatic size_t fileStreamWrite(gkStream* stream, const void* buffer, size_t size)\r\n{\r\n\tgkFileStream* fileStream = (gkFileStream*)stream;\r\n\r\n\tsize_t res = fwrite(buffer, sizeof(char), size, fileStream->file);\r\n\tif(res == 0)\r\n\t\treturn ferror(fileStream->file) ? -1: 0;\r\n\treturn res;\r\n}\r\n\r\nstatic void fileStreamClose(gkStream* stream)\r\n{\r\n\tgkFileStream* fileStream = (gkFileStream*)stream;\r\n\tfclose(fileStream->file);\r\n\tfree(fileStream);\r\n}\r\n\r\ngkStream* gkOpenFileStd(char *filename, char *mode)\r\n{\r\n\tFILE* file = fopen(filename, mode);\r\n\tgkFileStream* fileStream;\r\n\r\n\tif (!file) \r\n\t\treturn 0;\r\n\r\n\tfileStream = (gkFileStream*)malloc(sizeof(gkFileStream));\r\n\tfileStream->file = file;\r\n\tfileStream->base.seekable = GK_TRUE;\r\n\tfileStream->base.read = fileStreamRead;\r\n\tfileStream->base.seek = fileStreamSeek;\r\n\tfileStream->base.tell = fileStreamTell;\r\n\tfileStream->base.end = fileStreamEnd;\r\n\tfileStream->base.write = fileStreamWrite;\r\n\tfileStream->base.close = fileStreamClose;\r\n\treturn (gkStream*)fileStream;\r\n}\r\n\r\n#ifdef GK_PLATFORM_ANDROID\r\ngkStream* gkOpenFileAndroid(char *filename, char *mode);\r\n#endif\r\n\r\ngkStream* gkOpenFile(char *filename, char *mode)\r\n{\r\n#ifdef GK_PLATFORM_ANDROID\r\n\tif (gkIsPathRelative(filename))\r\n\t\treturn gkOpenFileAndroid(filename, mode);\r\n#endif\r\n\treturn gkOpenFileStd(filename, mode);\r\n}","/*\r\n * jcomapi.c\r\n *\r\n * Copyright (C) 1994-1997, Thomas G. Lane.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains application interface routines that are used for both\r\n * compression and decompression.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/*\r\n * Abort processing of a JPEG compression or decompression operation,\r\n * but don't destroy the object itself.\r\n *\r\n * For this, we merely clean up all the nonpermanent memory pools.\r\n * Note that temp files (virtual arrays) are not allowed to belong to\r\n * the permanent pool, so we will be able to close all temp files here.\r\n * Closing a data source or destination, if necessary, is the application's\r\n * responsibility.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_abort (j_common_ptr cinfo)\r\n{\r\n  int pool;\r\n\r\n  /* Do nothing if called on a not-initialized or destroyed JPEG object. */\r\n  if (cinfo->mem == NULL)\r\n    return;\r\n\r\n  /* Releasing pools in reverse order might help avoid fragmentation\r\n   * with some (brain-damaged) malloc libraries.\r\n   */\r\n  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {\r\n    (*cinfo->mem->free_pool) (cinfo, pool);\r\n  }\r\n\r\n  /* Reset overall state for possible reuse of object */\r\n  if (cinfo->is_decompressor) {\r\n    cinfo->global_state = DSTATE_START;\r\n    /* Try to keep application from accessing now-deleted marker list.\r\n     * A bit kludgy to do it here, but this is the most central place.\r\n     */\r\n    ((j_decompress_ptr) cinfo)->marker_list = NULL;\r\n  } else {\r\n    cinfo->global_state = CSTATE_START;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Destruction of a JPEG object.\r\n *\r\n * Everything gets deallocated except the master jpeg_compress_struct itself\r\n * and the error manager struct.  Both of these are supplied by the application\r\n * and must be freed, if necessary, by the application.  (Often they are on\r\n * the stack and so don't need to be freed anyway.)\r\n * Closing a data source or destination, if necessary, is the application's\r\n * responsibility.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_destroy (j_common_ptr cinfo)\r\n{\r\n  /* We need only tell the memory manager to release everything. */\r\n  /* NB: mem pointer is NULL if memory mgr failed to initialize. */\r\n  if (cinfo->mem != NULL)\r\n    (*cinfo->mem->self_destruct) (cinfo);\r\n  cinfo->mem = NULL;\t\t/* be safe if jpeg_destroy is called twice */\r\n  cinfo->global_state = 0;\t/* mark it destroyed */\r\n}\r\n\r\n\r\n/*\r\n * Convenience routines for allocating quantization and Huffman tables.\r\n * (Would jutils.c be a more reasonable place to put these?)\r\n */\r\n\r\nGLOBAL(JQUANT_TBL *)\r\njpeg_alloc_quant_table (j_common_ptr cinfo)\r\n{\r\n  JQUANT_TBL *tbl;\r\n\r\n  tbl = (JQUANT_TBL *)\r\n    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));\r\n  tbl->sent_table = FALSE;\t/* make sure this is false in any new table */\r\n  return tbl;\r\n}\r\n\r\n\r\nGLOBAL(JHUFF_TBL *)\r\njpeg_alloc_huff_table (j_common_ptr cinfo)\r\n{\r\n  JHUFF_TBL *tbl;\r\n\r\n  tbl = (JHUFF_TBL *)\r\n    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));\r\n  tbl->sent_table = FALSE;\t/* make sure this is false in any new table */\r\n  return tbl;\r\n}\r\n","/*\r\n * jdapimin.c\r\n *\r\n * Copyright (C) 1994-1998, Thomas G. Lane.\r\n * Modified 2009-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains application interface code for the decompression half\r\n * of the JPEG library.  These are the \"minimum\" API routines that may be\r\n * needed in either the normal full-decompression case or the\r\n * transcoding-only case.\r\n *\r\n * Most of the routines intended to be called directly by an application\r\n * are in this file or in jdapistd.c.  But also see jcomapi.c for routines\r\n * shared by compression and decompression, and jdtrans.c for the transcoding\r\n * case.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/*\r\n * Initialization of a JPEG decompression object.\r\n * The error manager must already be set up (in case memory manager fails).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)\r\n{\r\n  int i;\r\n\r\n  /* Guard against version mismatches between library and caller. */\r\n  cinfo->mem = NULL;\t\t/* so jpeg_destroy knows mem mgr not called */\r\n  if (version != JPEG_LIB_VERSION)\r\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\r\n  if (structsize != SIZEOF(struct jpeg_decompress_struct))\r\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, \r\n\t     (int) SIZEOF(struct jpeg_decompress_struct), (int) structsize);\r\n\r\n  /* For debugging purposes, we zero the whole master structure.\r\n   * But the application has already set the err pointer, and may have set\r\n   * client_data, so we have to save and restore those fields.\r\n   * Note: if application hasn't set client_data, tools like Purify may\r\n   * complain here.\r\n   */\r\n  {\r\n    struct jpeg_error_mgr * err = cinfo->err;\r\n    void * client_data = cinfo->client_data; /* ignore Purify complaint here */\r\n    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));\r\n    cinfo->err = err;\r\n    cinfo->client_data = client_data;\r\n  }\r\n  cinfo->is_decompressor = TRUE;\r\n\r\n  /* Initialize a memory manager instance for this object */\r\n  jinit_memory_mgr((j_common_ptr) cinfo);\r\n\r\n  /* Zero out pointers to permanent structures. */\r\n  cinfo->progress = NULL;\r\n  cinfo->src = NULL;\r\n\r\n  for (i = 0; i < NUM_QUANT_TBLS; i++)\r\n    cinfo->quant_tbl_ptrs[i] = NULL;\r\n\r\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\r\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\r\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\r\n  }\r\n\r\n  /* Initialize marker processor so application can override methods\r\n   * for COM, APPn markers before calling jpeg_read_header.\r\n   */\r\n  cinfo->marker_list = NULL;\r\n  jinit_marker_reader(cinfo);\r\n\r\n  /* And initialize the overall input controller. */\r\n  jinit_input_controller(cinfo);\r\n\r\n  /* OK, I'm ready */\r\n  cinfo->global_state = DSTATE_START;\r\n}\r\n\r\n\r\n/*\r\n * Destruction of a JPEG decompression object\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_destroy_decompress (j_decompress_ptr cinfo)\r\n{\r\n  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */\r\n}\r\n\r\n\r\n/*\r\n * Abort processing of a JPEG decompression operation,\r\n * but don't destroy the object itself.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_abort_decompress (j_decompress_ptr cinfo)\r\n{\r\n  jpeg_abort((j_common_ptr) cinfo); /* use common routine */\r\n}\r\n\r\n\r\n/*\r\n * Set default decompression parameters.\r\n */\r\n\r\nLOCAL(void)\r\ndefault_decompress_parms (j_decompress_ptr cinfo)\r\n{\r\n  int cid0, cid1, cid2;\r\n\r\n  /* Guess the input colorspace, and set output colorspace accordingly. */\r\n  /* Note application may override our guesses. */\r\n  switch (cinfo->num_components) {\r\n  case 1:\r\n    cinfo->jpeg_color_space = JCS_GRAYSCALE;\r\n    cinfo->out_color_space = JCS_GRAYSCALE;\r\n    break;\r\n    \r\n  case 3:\r\n    cid0 = cinfo->comp_info[0].component_id;\r\n    cid1 = cinfo->comp_info[1].component_id;\r\n    cid2 = cinfo->comp_info[2].component_id;\r\n\r\n    /* First try to guess from the component IDs */\r\n    if      (cid0 == 0x01 && cid1 == 0x02 && cid2 == 0x03)\r\n      cinfo->jpeg_color_space = JCS_YCbCr;\r\n    else if (cid0 == 0x01 && cid1 == 0x22 && cid2 == 0x23)\r\n      cinfo->jpeg_color_space = JCS_BG_YCC;\r\n    else if (cid0 == 0x52 && cid1 == 0x47 && cid2 == 0x42)\r\n      cinfo->jpeg_color_space = JCS_RGB;\t/* ASCII 'R', 'G', 'B' */\r\n    else if (cid0 == 0x72 && cid1 == 0x67 && cid2 == 0x62)\r\n      cinfo->jpeg_color_space = JCS_BG_RGB;\t/* ASCII 'r', 'g', 'b' */\r\n    else if (cinfo->saw_JFIF_marker)\r\n      cinfo->jpeg_color_space = JCS_YCbCr;\t/* assume it's YCbCr */\r\n    else if (cinfo->saw_Adobe_marker) {\r\n      switch (cinfo->Adobe_transform) {\r\n      case 0:\r\n\tcinfo->jpeg_color_space = JCS_RGB;\r\n\tbreak;\r\n      case 1:\r\n\tcinfo->jpeg_color_space = JCS_YCbCr;\r\n\tbreak;\r\n      default:\r\n\tWARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);\r\n\tcinfo->jpeg_color_space = JCS_YCbCr;\t/* assume it's YCbCr */\r\n\tbreak;\r\n      }\r\n    } else {\r\n      TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);\r\n      cinfo->jpeg_color_space = JCS_YCbCr;\t/* assume it's YCbCr */\r\n    }\r\n    /* Always guess RGB is proper output colorspace. */\r\n    cinfo->out_color_space = JCS_RGB;\r\n    break;\r\n    \r\n  case 4:\r\n    if (cinfo->saw_Adobe_marker) {\r\n      switch (cinfo->Adobe_transform) {\r\n      case 0:\r\n\tcinfo->jpeg_color_space = JCS_CMYK;\r\n\tbreak;\r\n      case 2:\r\n\tcinfo->jpeg_color_space = JCS_YCCK;\r\n\tbreak;\r\n      default:\r\n\tWARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);\r\n\tcinfo->jpeg_color_space = JCS_YCCK;\t/* assume it's YCCK */\r\n\tbreak;\r\n      }\r\n    } else {\r\n      /* No special markers, assume straight CMYK. */\r\n      cinfo->jpeg_color_space = JCS_CMYK;\r\n    }\r\n    cinfo->out_color_space = JCS_CMYK;\r\n    break;\r\n    \r\n  default:\r\n    cinfo->jpeg_color_space = JCS_UNKNOWN;\r\n    cinfo->out_color_space = JCS_UNKNOWN;\r\n    break;\r\n  }\r\n\r\n  /* Set defaults for other decompression parameters. */\r\n  cinfo->scale_num = cinfo->block_size;\t\t/* 1:1 scaling */\r\n  cinfo->scale_denom = cinfo->block_size;\r\n  cinfo->output_gamma = 1.0;\r\n  cinfo->buffered_image = FALSE;\r\n  cinfo->raw_data_out = FALSE;\r\n  cinfo->dct_method = JDCT_DEFAULT;\r\n  cinfo->do_fancy_upsampling = TRUE;\r\n  cinfo->do_block_smoothing = TRUE;\r\n  cinfo->quantize_colors = FALSE;\r\n  /* We set these in case application only sets quantize_colors. */\r\n  cinfo->dither_mode = JDITHER_FS;\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n  cinfo->two_pass_quantize = TRUE;\r\n#else\r\n  cinfo->two_pass_quantize = FALSE;\r\n#endif\r\n  cinfo->desired_number_of_colors = 256;\r\n  cinfo->colormap = NULL;\r\n  /* Initialize for no mode change in buffered-image mode. */\r\n  cinfo->enable_1pass_quant = FALSE;\r\n  cinfo->enable_external_quant = FALSE;\r\n  cinfo->enable_2pass_quant = FALSE;\r\n}\r\n\r\n\r\n/*\r\n * Decompression startup: read start of JPEG datastream to see what's there.\r\n * Need only initialize JPEG object and supply a data source before calling.\r\n *\r\n * This routine will read as far as the first SOS marker (ie, actual start of\r\n * compressed data), and will save all tables and parameters in the JPEG\r\n * object.  It will also initialize the decompression parameters to default\r\n * values, and finally return JPEG_HEADER_OK.  On return, the application may\r\n * adjust the decompression parameters and then call jpeg_start_decompress.\r\n * (Or, if the application only wanted to determine the image parameters,\r\n * the data need not be decompressed.  In that case, call jpeg_abort or\r\n * jpeg_destroy to release any temporary space.)\r\n * If an abbreviated (tables only) datastream is presented, the routine will\r\n * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then\r\n * re-use the JPEG object to read the abbreviated image datastream(s).\r\n * It is unnecessary (but OK) to call jpeg_abort in this case.\r\n * The JPEG_SUSPENDED return code only occurs if the data source module\r\n * requests suspension of the decompressor.  In this case the application\r\n * should load more source data and then re-call jpeg_read_header to resume\r\n * processing.\r\n * If a non-suspending data source is used and require_image is TRUE, then the\r\n * return code need not be inspected since only JPEG_HEADER_OK is possible.\r\n *\r\n * This routine is now just a front end to jpeg_consume_input, with some\r\n * extra error checking.\r\n */\r\n\r\nGLOBAL(int)\r\njpeg_read_header (j_decompress_ptr cinfo, boolean require_image)\r\n{\r\n  int retcode;\r\n\r\n  if (cinfo->global_state != DSTATE_START &&\r\n      cinfo->global_state != DSTATE_INHEADER)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n\r\n  retcode = jpeg_consume_input(cinfo);\r\n\r\n  switch (retcode) {\r\n  case JPEG_REACHED_SOS:\r\n    retcode = JPEG_HEADER_OK;\r\n    break;\r\n  case JPEG_REACHED_EOI:\r\n    if (require_image)\t\t/* Complain if application wanted an image */\r\n      ERREXIT(cinfo, JERR_NO_IMAGE);\r\n    /* Reset to start state; it would be safer to require the application to\r\n     * call jpeg_abort, but we can't change it now for compatibility reasons.\r\n     * A side effect is to free any temporary memory (there shouldn't be any).\r\n     */\r\n    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */\r\n    retcode = JPEG_HEADER_TABLES_ONLY;\r\n    break;\r\n  case JPEG_SUSPENDED:\r\n    /* no work */\r\n    break;\r\n  }\r\n\r\n  return retcode;\r\n}\r\n\r\n\r\n/*\r\n * Consume data in advance of what the decompressor requires.\r\n * This can be called at any time once the decompressor object has\r\n * been created and a data source has been set up.\r\n *\r\n * This routine is essentially a state machine that handles a couple\r\n * of critical state-transition actions, namely initial setup and\r\n * transition from header scanning to ready-for-start_decompress.\r\n * All the actual input is done via the input controller's consume_input\r\n * method.\r\n */\r\n\r\nGLOBAL(int)\r\njpeg_consume_input (j_decompress_ptr cinfo)\r\n{\r\n  int retcode = JPEG_SUSPENDED;\r\n\r\n  /* NB: every possible DSTATE value should be listed in this switch */\r\n  switch (cinfo->global_state) {\r\n  case DSTATE_START:\r\n    /* Start-of-datastream actions: reset appropriate modules */\r\n    (*cinfo->inputctl->reset_input_controller) (cinfo);\r\n    /* Initialize application's data source module */\r\n    (*cinfo->src->init_source) (cinfo);\r\n    cinfo->global_state = DSTATE_INHEADER;\r\n    /*FALLTHROUGH*/\r\n  case DSTATE_INHEADER:\r\n    retcode = (*cinfo->inputctl->consume_input) (cinfo);\r\n    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */\r\n      /* Set up default parameters based on header data */\r\n      default_decompress_parms(cinfo);\r\n      /* Set global state: ready for start_decompress */\r\n      cinfo->global_state = DSTATE_READY;\r\n    }\r\n    break;\r\n  case DSTATE_READY:\r\n    /* Can't advance past first SOS until start_decompress is called */\r\n    retcode = JPEG_REACHED_SOS;\r\n    break;\r\n  case DSTATE_PRELOAD:\r\n  case DSTATE_PRESCAN:\r\n  case DSTATE_SCANNING:\r\n  case DSTATE_RAW_OK:\r\n  case DSTATE_BUFIMAGE:\r\n  case DSTATE_BUFPOST:\r\n  case DSTATE_STOPPING:\r\n    retcode = (*cinfo->inputctl->consume_input) (cinfo);\r\n    break;\r\n  default:\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  }\r\n  return retcode;\r\n}\r\n\r\n\r\n/*\r\n * Have we finished reading the input file?\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_input_complete (j_decompress_ptr cinfo)\r\n{\r\n  /* Check for valid jpeg object */\r\n  if (cinfo->global_state < DSTATE_START ||\r\n      cinfo->global_state > DSTATE_STOPPING)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  return cinfo->inputctl->eoi_reached;\r\n}\r\n\r\n\r\n/*\r\n * Is there more than one scan?\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_has_multiple_scans (j_decompress_ptr cinfo)\r\n{\r\n  /* Only valid after jpeg_read_header completes */\r\n  if (cinfo->global_state < DSTATE_READY ||\r\n      cinfo->global_state > DSTATE_STOPPING)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  return cinfo->inputctl->has_multiple_scans;\r\n}\r\n\r\n\r\n/*\r\n * Finish JPEG decompression.\r\n *\r\n * This will normally just verify the file trailer and release temp storage.\r\n *\r\n * Returns FALSE if suspended.  The return value need be inspected only if\r\n * a suspending data source is used.\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_finish_decompress (j_decompress_ptr cinfo)\r\n{\r\n  if ((cinfo->global_state == DSTATE_SCANNING ||\r\n       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {\r\n    /* Terminate final pass of non-buffered mode */\r\n    if (cinfo->output_scanline < cinfo->output_height)\r\n      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);\r\n    (*cinfo->master->finish_output_pass) (cinfo);\r\n    cinfo->global_state = DSTATE_STOPPING;\r\n  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {\r\n    /* Finishing after a buffered-image operation */\r\n    cinfo->global_state = DSTATE_STOPPING;\r\n  } else if (cinfo->global_state != DSTATE_STOPPING) {\r\n    /* STOPPING = repeat call after a suspension, anything else is error */\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  }\r\n  /* Read until EOI */\r\n  while (! cinfo->inputctl->eoi_reached) {\r\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\r\n      return FALSE;\t\t/* Suspend, come back later */\r\n  }\r\n  /* Do final cleanup */\r\n  (*cinfo->src->term_source) (cinfo);\r\n  /* We can use jpeg_abort to release memory and reset global_state */\r\n  jpeg_abort((j_common_ptr) cinfo);\r\n  return TRUE;\r\n}\r\n","/*\r\n * jdapistd.c\r\n *\r\n * Copyright (C) 1994-1996, Thomas G. Lane.\r\n * Modified 2002-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains application interface code for the decompression half\r\n * of the JPEG library.  These are the \"standard\" API routines that are\r\n * used in the normal full-decompression case.  They are not used by a\r\n * transcoding-only application.  Note that if an application links in\r\n * jpeg_start_decompress, it will end up linking in the entire decompressor.\r\n * We thus must separate this file from jdapimin.c to avoid linking the\r\n * whole decompression library into a transcoder.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Forward declarations */\r\nLOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));\r\n\r\n\r\n/*\r\n * Decompression initialization.\r\n * jpeg_read_header must be completed before calling this.\r\n *\r\n * If a multipass operating mode was selected, this will do all but the\r\n * last pass, and thus may take a great deal of time.\r\n *\r\n * Returns FALSE if suspended.  The return value need be inspected only if\r\n * a suspending data source is used.\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_start_decompress (j_decompress_ptr cinfo)\r\n{\r\n  if (cinfo->global_state == DSTATE_READY) {\r\n    /* First call: initialize master control, select active modules */\r\n    jinit_master_decompress(cinfo);\r\n    if (cinfo->buffered_image) {\r\n      /* No more work here; expecting jpeg_start_output next */\r\n      cinfo->global_state = DSTATE_BUFIMAGE;\r\n      return TRUE;\r\n    }\r\n    cinfo->global_state = DSTATE_PRELOAD;\r\n  }\r\n  if (cinfo->global_state == DSTATE_PRELOAD) {\r\n    /* If file has multiple scans, absorb them all into the coef buffer */\r\n    if (cinfo->inputctl->has_multiple_scans) {\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n      for (;;) {\r\n\tint retcode;\r\n\t/* Call progress monitor hook if present */\r\n\tif (cinfo->progress != NULL)\r\n\t  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\r\n\t/* Absorb some more input */\r\n\tretcode = (*cinfo->inputctl->consume_input) (cinfo);\r\n\tif (retcode == JPEG_SUSPENDED)\r\n\t  return FALSE;\r\n\tif (retcode == JPEG_REACHED_EOI)\r\n\t  break;\r\n\t/* Advance progress counter if appropriate */\r\n\tif (cinfo->progress != NULL &&\r\n\t    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {\r\n\t  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {\r\n\t    /* jdmaster underestimated number of scans; ratchet up one scan */\r\n\t    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;\r\n\t  }\r\n\t}\r\n      }\r\n#else\r\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\r\n    }\r\n    cinfo->output_scan_number = cinfo->input_scan_number;\r\n  } else if (cinfo->global_state != DSTATE_PRESCAN)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  /* Perform any dummy output passes, and set up for the final pass */\r\n  return output_pass_setup(cinfo);\r\n}\r\n\r\n\r\n/*\r\n * Set up for an output pass, and perform any dummy pass(es) needed.\r\n * Common subroutine for jpeg_start_decompress and jpeg_start_output.\r\n * Entry: global_state = DSTATE_PRESCAN only if previously suspended.\r\n * Exit: If done, returns TRUE and sets global_state for proper output mode.\r\n *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.\r\n */\r\n\r\nLOCAL(boolean)\r\noutput_pass_setup (j_decompress_ptr cinfo)\r\n{\r\n  if (cinfo->global_state != DSTATE_PRESCAN) {\r\n    /* First call: do pass setup */\r\n    (*cinfo->master->prepare_for_output_pass) (cinfo);\r\n    cinfo->output_scanline = 0;\r\n    cinfo->global_state = DSTATE_PRESCAN;\r\n  }\r\n  /* Loop over any required dummy passes */\r\n  while (cinfo->master->is_dummy_pass) {\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n    /* Crank through the dummy pass */\r\n    while (cinfo->output_scanline < cinfo->output_height) {\r\n      JDIMENSION last_scanline;\r\n      /* Call progress monitor hook if present */\r\n      if (cinfo->progress != NULL) {\r\n\tcinfo->progress->pass_counter = (long) cinfo->output_scanline;\r\n\tcinfo->progress->pass_limit = (long) cinfo->output_height;\r\n\t(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\r\n      }\r\n      /* Process some data */\r\n      last_scanline = cinfo->output_scanline;\r\n      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,\r\n\t\t\t\t    &cinfo->output_scanline, (JDIMENSION) 0);\r\n      if (cinfo->output_scanline == last_scanline)\r\n\treturn FALSE;\t\t/* No progress made, must suspend */\r\n    }\r\n    /* Finish up dummy pass, and set up for another one */\r\n    (*cinfo->master->finish_output_pass) (cinfo);\r\n    (*cinfo->master->prepare_for_output_pass) (cinfo);\r\n    cinfo->output_scanline = 0;\r\n#else\r\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n  }\r\n  /* Ready for application to drive output pass through\r\n   * jpeg_read_scanlines or jpeg_read_raw_data.\r\n   */\r\n  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Read some scanlines of data from the JPEG decompressor.\r\n *\r\n * The return value will be the number of lines actually read.\r\n * This may be less than the number requested in several cases,\r\n * including bottom of image, data source suspension, and operating\r\n * modes that emit multiple scanlines at a time.\r\n *\r\n * Note: we warn about excess calls to jpeg_read_scanlines() since\r\n * this likely signals an application programmer error.  However,\r\n * an oversize buffer (max_lines > scanlines remaining) is not an error.\r\n */\r\n\r\nGLOBAL(JDIMENSION)\r\njpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,\r\n\t\t     JDIMENSION max_lines)\r\n{\r\n  JDIMENSION row_ctr;\r\n\r\n  if (cinfo->global_state != DSTATE_SCANNING)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  if (cinfo->output_scanline >= cinfo->output_height) {\r\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\r\n    return 0;\r\n  }\r\n\r\n  /* Call progress monitor hook if present */\r\n  if (cinfo->progress != NULL) {\r\n    cinfo->progress->pass_counter = (long) cinfo->output_scanline;\r\n    cinfo->progress->pass_limit = (long) cinfo->output_height;\r\n    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\r\n  }\r\n\r\n  /* Process some data */\r\n  row_ctr = 0;\r\n  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);\r\n  cinfo->output_scanline += row_ctr;\r\n  return row_ctr;\r\n}\r\n\r\n\r\n/*\r\n * Alternate entry point to read raw data.\r\n * Processes exactly one iMCU row per call, unless suspended.\r\n */\r\n\r\nGLOBAL(JDIMENSION)\r\njpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,\r\n\t\t    JDIMENSION max_lines)\r\n{\r\n  JDIMENSION lines_per_iMCU_row;\r\n\r\n  if (cinfo->global_state != DSTATE_RAW_OK)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  if (cinfo->output_scanline >= cinfo->output_height) {\r\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\r\n    return 0;\r\n  }\r\n\r\n  /* Call progress monitor hook if present */\r\n  if (cinfo->progress != NULL) {\r\n    cinfo->progress->pass_counter = (long) cinfo->output_scanline;\r\n    cinfo->progress->pass_limit = (long) cinfo->output_height;\r\n    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\r\n  }\r\n\r\n  /* Verify that at least one iMCU row can be returned. */\r\n  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_v_scaled_size;\r\n  if (max_lines < lines_per_iMCU_row)\r\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\r\n\r\n  /* Decompress directly into user's buffer. */\r\n  if (! (*cinfo->coef->decompress_data) (cinfo, data))\r\n    return 0;\t\t\t/* suspension forced, can do nothing more */\r\n\r\n  /* OK, we processed one iMCU row. */\r\n  cinfo->output_scanline += lines_per_iMCU_row;\r\n  return lines_per_iMCU_row;\r\n}\r\n\r\n\r\n/* Additional entry points for buffered-image mode. */\r\n\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n\r\n/*\r\n * Initialize for an output pass in buffered-image mode.\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_start_output (j_decompress_ptr cinfo, int scan_number)\r\n{\r\n  if (cinfo->global_state != DSTATE_BUFIMAGE &&\r\n      cinfo->global_state != DSTATE_PRESCAN)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  /* Limit scan number to valid range */\r\n  if (scan_number <= 0)\r\n    scan_number = 1;\r\n  if (cinfo->inputctl->eoi_reached &&\r\n      scan_number > cinfo->input_scan_number)\r\n    scan_number = cinfo->input_scan_number;\r\n  cinfo->output_scan_number = scan_number;\r\n  /* Perform any dummy output passes, and set up for the real pass */\r\n  return output_pass_setup(cinfo);\r\n}\r\n\r\n\r\n/*\r\n * Finish up after an output pass in buffered-image mode.\r\n *\r\n * Returns FALSE if suspended.  The return value need be inspected only if\r\n * a suspending data source is used.\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_finish_output (j_decompress_ptr cinfo)\r\n{\r\n  if ((cinfo->global_state == DSTATE_SCANNING ||\r\n       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {\r\n    /* Terminate this pass. */\r\n    /* We do not require the whole pass to have been completed. */\r\n    (*cinfo->master->finish_output_pass) (cinfo);\r\n    cinfo->global_state = DSTATE_BUFPOST;\r\n  } else if (cinfo->global_state != DSTATE_BUFPOST) {\r\n    /* BUFPOST = repeat call after a suspension, anything else is error */\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n  }\r\n  /* Read markers looking for SOS or EOI */\r\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\r\n\t ! cinfo->inputctl->eoi_reached) {\r\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\r\n      return FALSE;\t\t/* Suspend, come back later */\r\n  }\r\n  cinfo->global_state = DSTATE_BUFIMAGE;\r\n  return TRUE;\r\n}\r\n\r\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\r\n","/*\r\n * jdarith.c\r\n *\r\n * Developed 1997-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains portable arithmetic entropy decoding routines for JPEG\r\n * (implementing the ISO/IEC IS 10918-1 and CCITT Recommendation ITU-T T.81).\r\n *\r\n * Both sequential and progressive modes are supported in this single module.\r\n *\r\n * Suspension is not currently supported in this module.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Expanded entropy decoder object for arithmetic decoding. */\r\n\r\ntypedef struct {\r\n  struct jpeg_entropy_decoder pub; /* public fields */\r\n\r\n  INT32 c;       /* C register, base of coding interval + input bit buffer */\r\n  INT32 a;               /* A register, normalized size of coding interval */\r\n  int ct;     /* bit shift counter, # of bits left in bit buffer part of C */\r\n                                                         /* init: ct = -16 */\r\n                                                         /* run: ct = 0..7 */\r\n                                                         /* error: ct = -1 */\r\n  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */\r\n  int dc_context[MAX_COMPS_IN_SCAN]; /* context index for DC conditioning */\r\n\r\n  unsigned int restarts_to_go;\t/* MCUs left in this restart interval */\r\n\r\n  /* Pointers to statistics areas (these workspaces have image lifespan) */\r\n  unsigned char * dc_stats[NUM_ARITH_TBLS];\r\n  unsigned char * ac_stats[NUM_ARITH_TBLS];\r\n\r\n  /* Statistics bin for coding with fixed probability 0.5 */\r\n  unsigned char fixed_bin[4];\r\n} arith_entropy_decoder;\r\n\r\ntypedef arith_entropy_decoder * arith_entropy_ptr;\r\n\r\n/* The following two definitions specify the allocation chunk size\r\n * for the statistics area.\r\n * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least\r\n * 49 statistics bins for DC, and 245 statistics bins for AC coding.\r\n *\r\n * We use a compact representation with 1 byte per statistics bin,\r\n * thus the numbers directly represent byte sizes.\r\n * This 1 byte per statistics bin contains the meaning of the MPS\r\n * (more probable symbol) in the highest bit (mask 0x80), and the\r\n * index into the probability estimation state machine table\r\n * in the lower bits (mask 0x7F).\r\n */\r\n\r\n#define DC_STAT_BINS 64\r\n#define AC_STAT_BINS 256\r\n\r\n\r\nLOCAL(int)\r\nget_byte (j_decompress_ptr cinfo)\r\n/* Read next input byte; we do not support suspension in this module. */\r\n{\r\n  struct jpeg_source_mgr * src = cinfo->src;\r\n\r\n  if (src->bytes_in_buffer == 0)\r\n    if (! (*src->fill_input_buffer) (cinfo))\r\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\r\n  src->bytes_in_buffer--;\r\n  return GETJOCTET(*src->next_input_byte++);\r\n}\r\n\r\n\r\n/*\r\n * The core arithmetic decoding routine (common in JPEG and JBIG).\r\n * This needs to go as fast as possible.\r\n * Machine-dependent optimization facilities\r\n * are not utilized in this portable implementation.\r\n * However, this code should be fairly efficient and\r\n * may be a good base for further optimizations anyway.\r\n *\r\n * Return value is 0 or 1 (binary decision).\r\n *\r\n * Note: I've changed the handling of the code base & bit\r\n * buffer register C compared to other implementations\r\n * based on the standards layout & procedures.\r\n * While it also contains both the actual base of the\r\n * coding interval (16 bits) and the next-bits buffer,\r\n * the cut-point between these two parts is floating\r\n * (instead of fixed) with the bit shift counter CT.\r\n * Thus, we also need only one (variable instead of\r\n * fixed size) shift for the LPS/MPS decision, and\r\n * we can get away with any renormalization update\r\n * of C (except for new data insertion, of course).\r\n *\r\n * I've also introduced a new scheme for accessing\r\n * the probability estimation state machine table,\r\n * derived from Markus Kuhn's JBIG implementation.\r\n */\r\n\r\nLOCAL(int)\r\narith_decode (j_decompress_ptr cinfo, unsigned char *st)\r\n{\r\n  register arith_entropy_ptr e = (arith_entropy_ptr) cinfo->entropy;\r\n  register unsigned char nl, nm;\r\n  register INT32 qe, temp;\r\n  register int sv, data;\r\n\r\n  /* Renormalization & data input per section D.2.6 */\r\n  while (e->a < 0x8000L) {\r\n    if (--e->ct < 0) {\r\n      /* Need to fetch next data byte */\r\n      if (cinfo->unread_marker)\r\n\tdata = 0;\t\t/* stuff zero data */\r\n      else {\r\n\tdata = get_byte(cinfo);\t/* read next input byte */\r\n\tif (data == 0xFF) {\t/* zero stuff or marker code */\r\n\t  do data = get_byte(cinfo);\r\n\t  while (data == 0xFF);\t/* swallow extra 0xFF bytes */\r\n\t  if (data == 0)\r\n\t    data = 0xFF;\t/* discard stuffed zero byte */\r\n\t  else {\r\n\t    /* Note: Different from the Huffman decoder, hitting\r\n\t     * a marker while processing the compressed data\r\n\t     * segment is legal in arithmetic coding.\r\n\t     * The convention is to supply zero data\r\n\t     * then until decoding is complete.\r\n\t     */\r\n\t    cinfo->unread_marker = data;\r\n\t    data = 0;\r\n\t  }\r\n\t}\r\n      }\r\n      e->c = (e->c << 8) | data; /* insert data into C register */\r\n      if ((e->ct += 8) < 0)\t /* update bit shift counter */\r\n\t/* Need more initial bytes */\r\n\tif (++e->ct == 0)\r\n\t  /* Got 2 initial bytes -> re-init A and exit loop */\r\n\t  e->a = 0x8000L; /* => e->a = 0x10000L after loop exit */\r\n    }\r\n    e->a <<= 1;\r\n  }\r\n\r\n  /* Fetch values from our compact representation of Table D.3(D.2):\r\n   * Qe values and probability estimation state machine\r\n   */\r\n  sv = *st;\r\n  qe = jpeg_aritab[sv & 0x7F];\t/* => Qe_Value */\r\n  nl = qe & 0xFF; qe >>= 8;\t/* Next_Index_LPS + Switch_MPS */\r\n  nm = qe & 0xFF; qe >>= 8;\t/* Next_Index_MPS */\r\n\r\n  /* Decode & estimation procedures per sections D.2.4 & D.2.5 */\r\n  temp = e->a - qe;\r\n  e->a = temp;\r\n  temp <<= e->ct;\r\n  if (e->c >= temp) {\r\n    e->c -= temp;\r\n    /* Conditional LPS (less probable symbol) exchange */\r\n    if (e->a < qe) {\r\n      e->a = qe;\r\n      *st = (sv & 0x80) ^ nm;\t/* Estimate_after_MPS */\r\n    } else {\r\n      e->a = qe;\r\n      *st = (sv & 0x80) ^ nl;\t/* Estimate_after_LPS */\r\n      sv ^= 0x80;\t\t/* Exchange LPS/MPS */\r\n    }\r\n  } else if (e->a < 0x8000L) {\r\n    /* Conditional MPS (more probable symbol) exchange */\r\n    if (e->a < qe) {\r\n      *st = (sv & 0x80) ^ nl;\t/* Estimate_after_LPS */\r\n      sv ^= 0x80;\t\t/* Exchange LPS/MPS */\r\n    } else {\r\n      *st = (sv & 0x80) ^ nm;\t/* Estimate_after_MPS */\r\n    }\r\n  }\r\n\r\n  return sv >> 7;\r\n}\r\n\r\n\r\n/*\r\n * Check for a restart marker & resynchronize decoder.\r\n */\r\n\r\nLOCAL(void)\r\nprocess_restart (j_decompress_ptr cinfo)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  int ci;\r\n  jpeg_component_info * compptr;\r\n\r\n  /* Advance past the RSTn marker */\r\n  if (! (*cinfo->marker->read_restart_marker) (cinfo))\r\n    ERREXIT(cinfo, JERR_CANT_SUSPEND);\r\n\r\n  /* Re-initialize statistics areas */\r\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n    compptr = cinfo->cur_comp_info[ci];\r\n    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {\r\n      MEMZERO(entropy->dc_stats[compptr->dc_tbl_no], DC_STAT_BINS);\r\n      /* Reset DC predictions to 0 */\r\n      entropy->last_dc_val[ci] = 0;\r\n      entropy->dc_context[ci] = 0;\r\n    }\r\n    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||\r\n\t(cinfo->progressive_mode && cinfo->Ss)) {\r\n      MEMZERO(entropy->ac_stats[compptr->ac_tbl_no], AC_STAT_BINS);\r\n    }\r\n  }\r\n\r\n  /* Reset arithmetic decoding variables */\r\n  entropy->c = 0;\r\n  entropy->a = 0;\r\n  entropy->ct = -16;\t/* force reading 2 initial bytes to fill C */\r\n\r\n  /* Reset restart counter */\r\n  entropy->restarts_to_go = cinfo->restart_interval;\r\n}\r\n\r\n\r\n/*\r\n * Arithmetic MCU decoding.\r\n * Each of these routines decodes and returns one MCU's worth of\r\n * arithmetic-compressed coefficients.\r\n * The coefficients are reordered from zigzag order into natural array order,\r\n * but are not dequantized.\r\n *\r\n * The i'th block of the MCU is stored into the block pointed to by\r\n * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.\r\n */\r\n\r\n/*\r\n * MCU decoding for DC initial scan (either spectral selection,\r\n * or first pass of successive approximation).\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  JBLOCKROW block;\r\n  unsigned char *st;\r\n  int blkn, ci, tbl, sign;\r\n  int v, m;\r\n\r\n  /* Process restart marker if needed */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      process_restart(cinfo);\r\n    entropy->restarts_to_go--;\r\n  }\r\n\r\n  if (entropy->ct == -1) return TRUE;\t/* if error do nothing */\r\n\r\n  /* Outer loop handles each block in the MCU */\r\n\r\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n    block = MCU_data[blkn];\r\n    ci = cinfo->MCU_membership[blkn];\r\n    tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;\r\n\r\n    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */\r\n\r\n    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */\r\n    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];\r\n\r\n    /* Figure F.19: Decode_DC_DIFF */\r\n    if (arith_decode(cinfo, st) == 0)\r\n      entropy->dc_context[ci] = 0;\r\n    else {\r\n      /* Figure F.21: Decoding nonzero value v */\r\n      /* Figure F.22: Decoding the sign of v */\r\n      sign = arith_decode(cinfo, st + 1);\r\n      st += 2; st += sign;\r\n      /* Figure F.23: Decoding the magnitude category of v */\r\n      if ((m = arith_decode(cinfo, st)) != 0) {\r\n\tst = entropy->dc_stats[tbl] + 20;\t/* Table F.4: X1 = 20 */\r\n\twhile (arith_decode(cinfo, st)) {\r\n\t  if ((m <<= 1) == 0x8000) {\r\n\t    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\t    entropy->ct = -1;\t\t\t/* magnitude overflow */\r\n\t    return TRUE;\r\n\t  }\r\n\t  st += 1;\r\n\t}\r\n      }\r\n      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */\r\n      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))\r\n\tentropy->dc_context[ci] = 0;\t\t   /* zero diff category */\r\n      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))\r\n\tentropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */\r\n      else\r\n\tentropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */\r\n      v = m;\r\n      /* Figure F.24: Decoding the magnitude bit pattern of v */\r\n      st += 14;\r\n      while (m >>= 1)\r\n\tif (arith_decode(cinfo, st)) v |= m;\r\n      v += 1; if (sign) v = -v;\r\n      entropy->last_dc_val[ci] += v;\r\n    }\r\n\r\n    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */\r\n    (*block)[0] = (JCOEF) (entropy->last_dc_val[ci] << cinfo->Al);\r\n  }\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * MCU decoding for AC initial scan (either spectral selection,\r\n * or first pass of successive approximation).\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  JBLOCKROW block;\r\n  unsigned char *st;\r\n  int tbl, sign, k;\r\n  int v, m;\r\n  const int * natural_order;\r\n\r\n  /* Process restart marker if needed */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      process_restart(cinfo);\r\n    entropy->restarts_to_go--;\r\n  }\r\n\r\n  if (entropy->ct == -1) return TRUE;\t/* if error do nothing */\r\n\r\n  natural_order = cinfo->natural_order;\r\n\r\n  /* There is always only one block per MCU */\r\n  block = MCU_data[0];\r\n  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;\r\n\r\n  /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */\r\n\r\n  /* Figure F.20: Decode_AC_coefficients */\r\n  k = cinfo->Ss - 1;\r\n  do {\r\n    st = entropy->ac_stats[tbl] + 3 * k;\r\n    if (arith_decode(cinfo, st)) break;\t\t/* EOB flag */\r\n    for (;;) {\r\n      k++;\r\n      if (arith_decode(cinfo, st + 1)) break;\r\n      st += 3;\r\n      if (k >= cinfo->Se) {\r\n\tWARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\tentropy->ct = -1;\t\t\t/* spectral overflow */\r\n\treturn TRUE;\r\n      }\r\n    }\r\n    /* Figure F.21: Decoding nonzero value v */\r\n    /* Figure F.22: Decoding the sign of v */\r\n    sign = arith_decode(cinfo, entropy->fixed_bin);\r\n    st += 2;\r\n    /* Figure F.23: Decoding the magnitude category of v */\r\n    if ((m = arith_decode(cinfo, st)) != 0) {\r\n      if (arith_decode(cinfo, st)) {\r\n\tm <<= 1;\r\n\tst = entropy->ac_stats[tbl] +\r\n\t     (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);\r\n\twhile (arith_decode(cinfo, st)) {\r\n\t  if ((m <<= 1) == 0x8000) {\r\n\t    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\t    entropy->ct = -1;\t\t\t/* magnitude overflow */\r\n\t    return TRUE;\r\n\t  }\r\n\t  st += 1;\r\n\t}\r\n      }\r\n    }\r\n    v = m;\r\n    /* Figure F.24: Decoding the magnitude bit pattern of v */\r\n    st += 14;\r\n    while (m >>= 1)\r\n      if (arith_decode(cinfo, st)) v |= m;\r\n    v += 1; if (sign) v = -v;\r\n    /* Scale and output coefficient in natural (dezigzagged) order */\r\n    (*block)[natural_order[k]] = (JCOEF) (v << cinfo->Al);\r\n  } while (k < cinfo->Se);\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * MCU decoding for DC successive approximation refinement scan.\r\n * Note: we assume such scans can be multi-component,\r\n * although the spec is not very clear on the point.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  unsigned char *st;\r\n  int p1, blkn;\r\n\r\n  /* Process restart marker if needed */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      process_restart(cinfo);\r\n    entropy->restarts_to_go--;\r\n  }\r\n\r\n  st = entropy->fixed_bin;\t/* use fixed probability estimation */\r\n  p1 = 1 << cinfo->Al;\t\t/* 1 in the bit position being coded */\r\n\r\n  /* Outer loop handles each block in the MCU */\r\n\r\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n    /* Encoded data is simply the next bit of the two's-complement DC value */\r\n    if (arith_decode(cinfo, st))\r\n      MCU_data[blkn][0][0] |= p1;\r\n  }\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * MCU decoding for AC successive approximation refinement scan.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  JBLOCKROW block;\r\n  JCOEFPTR thiscoef;\r\n  unsigned char *st;\r\n  int tbl, k, kex;\r\n  int p1, m1;\r\n  const int * natural_order;\r\n\r\n  /* Process restart marker if needed */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      process_restart(cinfo);\r\n    entropy->restarts_to_go--;\r\n  }\r\n\r\n  if (entropy->ct == -1) return TRUE;\t/* if error do nothing */\r\n\r\n  natural_order = cinfo->natural_order;\r\n\r\n  /* There is always only one block per MCU */\r\n  block = MCU_data[0];\r\n  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;\r\n\r\n  p1 = 1 << cinfo->Al;\t\t/* 1 in the bit position being coded */\r\n  m1 = (-1) << cinfo->Al;\t/* -1 in the bit position being coded */\r\n\r\n  /* Establish EOBx (previous stage end-of-block) index */\r\n  kex = cinfo->Se;\r\n  do {\r\n    if ((*block)[natural_order[kex]]) break;\r\n  } while (--kex);\r\n\r\n  k = cinfo->Ss - 1;\r\n  do {\r\n    st = entropy->ac_stats[tbl] + 3 * k;\r\n    if (k >= kex)\r\n      if (arith_decode(cinfo, st)) break;\t/* EOB flag */\r\n    for (;;) {\r\n      thiscoef = *block + natural_order[++k];\r\n      if (*thiscoef) {\t\t\t\t/* previously nonzero coef */\r\n\tif (arith_decode(cinfo, st + 2)) {\r\n\t  if (*thiscoef < 0)\r\n\t    *thiscoef += m1;\r\n\t  else\r\n\t    *thiscoef += p1;\r\n\t}\r\n\tbreak;\r\n      }\r\n      if (arith_decode(cinfo, st + 1)) {\t/* newly nonzero coef */\r\n\tif (arith_decode(cinfo, entropy->fixed_bin))\r\n\t  *thiscoef = m1;\r\n\telse\r\n\t  *thiscoef = p1;\r\n\tbreak;\r\n      }\r\n      st += 3;\r\n      if (k >= cinfo->Se) {\r\n\tWARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\tentropy->ct = -1;\t\t\t/* spectral overflow */\r\n\treturn TRUE;\r\n      }\r\n    }\r\n  } while (k < cinfo->Se);\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Decode one MCU's worth of arithmetic-compressed coefficients.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  jpeg_component_info * compptr;\r\n  JBLOCKROW block;\r\n  unsigned char *st;\r\n  int blkn, ci, tbl, sign, k;\r\n  int v, m;\r\n  const int * natural_order;\r\n\r\n  /* Process restart marker if needed */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      process_restart(cinfo);\r\n    entropy->restarts_to_go--;\r\n  }\r\n\r\n  if (entropy->ct == -1) return TRUE;\t/* if error do nothing */\r\n\r\n  natural_order = cinfo->natural_order;\r\n\r\n  /* Outer loop handles each block in the MCU */\r\n\r\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n    block = MCU_data[blkn];\r\n    ci = cinfo->MCU_membership[blkn];\r\n    compptr = cinfo->cur_comp_info[ci];\r\n\r\n    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */\r\n\r\n    tbl = compptr->dc_tbl_no;\r\n\r\n    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */\r\n    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];\r\n\r\n    /* Figure F.19: Decode_DC_DIFF */\r\n    if (arith_decode(cinfo, st) == 0)\r\n      entropy->dc_context[ci] = 0;\r\n    else {\r\n      /* Figure F.21: Decoding nonzero value v */\r\n      /* Figure F.22: Decoding the sign of v */\r\n      sign = arith_decode(cinfo, st + 1);\r\n      st += 2; st += sign;\r\n      /* Figure F.23: Decoding the magnitude category of v */\r\n      if ((m = arith_decode(cinfo, st)) != 0) {\r\n\tst = entropy->dc_stats[tbl] + 20;\t/* Table F.4: X1 = 20 */\r\n\twhile (arith_decode(cinfo, st)) {\r\n\t  if ((m <<= 1) == 0x8000) {\r\n\t    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\t    entropy->ct = -1;\t\t\t/* magnitude overflow */\r\n\t    return TRUE;\r\n\t  }\r\n\t  st += 1;\r\n\t}\r\n      }\r\n      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */\r\n      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))\r\n\tentropy->dc_context[ci] = 0;\t\t   /* zero diff category */\r\n      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))\r\n\tentropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */\r\n      else\r\n\tentropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */\r\n      v = m;\r\n      /* Figure F.24: Decoding the magnitude bit pattern of v */\r\n      st += 14;\r\n      while (m >>= 1)\r\n\tif (arith_decode(cinfo, st)) v |= m;\r\n      v += 1; if (sign) v = -v;\r\n      entropy->last_dc_val[ci] += v;\r\n    }\r\n\r\n    (*block)[0] = (JCOEF) entropy->last_dc_val[ci];\r\n\r\n    /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */\r\n\r\n    if (cinfo->lim_Se == 0) continue;\r\n    tbl = compptr->ac_tbl_no;\r\n    k = 0;\r\n\r\n    /* Figure F.20: Decode_AC_coefficients */\r\n    do {\r\n      st = entropy->ac_stats[tbl] + 3 * k;\r\n      if (arith_decode(cinfo, st)) break;\t/* EOB flag */\r\n      for (;;) {\r\n\tk++;\r\n\tif (arith_decode(cinfo, st + 1)) break;\r\n\tst += 3;\r\n\tif (k >= cinfo->lim_Se) {\r\n\t  WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\t  entropy->ct = -1;\t\t\t/* spectral overflow */\r\n\t  return TRUE;\r\n\t}\r\n      }\r\n      /* Figure F.21: Decoding nonzero value v */\r\n      /* Figure F.22: Decoding the sign of v */\r\n      sign = arith_decode(cinfo, entropy->fixed_bin);\r\n      st += 2;\r\n      /* Figure F.23: Decoding the magnitude category of v */\r\n      if ((m = arith_decode(cinfo, st)) != 0) {\r\n\tif (arith_decode(cinfo, st)) {\r\n\t  m <<= 1;\r\n\t  st = entropy->ac_stats[tbl] +\r\n\t       (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);\r\n\t  while (arith_decode(cinfo, st)) {\r\n\t    if ((m <<= 1) == 0x8000) {\r\n\t      WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\r\n\t      entropy->ct = -1;\t\t\t/* magnitude overflow */\r\n\t      return TRUE;\r\n\t    }\r\n\t    st += 1;\r\n\t  }\r\n\t}\r\n      }\r\n      v = m;\r\n      /* Figure F.24: Decoding the magnitude bit pattern of v */\r\n      st += 14;\r\n      while (m >>= 1)\r\n\tif (arith_decode(cinfo, st)) v |= m;\r\n      v += 1; if (sign) v = -v;\r\n      (*block)[natural_order[k]] = (JCOEF) v;\r\n    } while (k < cinfo->lim_Se);\r\n  }\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Initialize for an arithmetic-compressed scan.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass (j_decompress_ptr cinfo)\r\n{\r\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\r\n  int ci, tbl;\r\n  jpeg_component_info * compptr;\r\n\r\n  if (cinfo->progressive_mode) {\r\n    /* Validate progressive scan parameters */\r\n    if (cinfo->Ss == 0) {\r\n      if (cinfo->Se != 0)\r\n\tgoto bad;\r\n    } else {\r\n      /* need not check Ss/Se < 0 since they came from unsigned bytes */\r\n      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)\r\n\tgoto bad;\r\n      /* AC scans may have only one component */\r\n      if (cinfo->comps_in_scan != 1)\r\n\tgoto bad;\r\n    }\r\n    if (cinfo->Ah != 0) {\r\n      /* Successive approximation refinement scan: must have Al = Ah-1. */\r\n      if (cinfo->Ah-1 != cinfo->Al)\r\n\tgoto bad;\r\n    }\r\n    if (cinfo->Al > 13) {\t/* need not check for < 0 */\r\n      bad:\r\n      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\r\n\t       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\r\n    }\r\n    /* Update progression status, and verify that scan order is legal.\r\n     * Note that inter-scan inconsistencies are treated as warnings\r\n     * not fatal errors ... not clear if this is right way to behave.\r\n     */\r\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;\r\n      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];\r\n      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */\r\n\tWARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);\r\n      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {\r\n\tint expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];\r\n\tif (cinfo->Ah != expected)\r\n\t  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);\r\n\tcoef_bit_ptr[coefi] = cinfo->Al;\r\n      }\r\n    }\r\n    /* Select MCU decoding routine */\r\n    if (cinfo->Ah == 0) {\r\n      if (cinfo->Ss == 0)\r\n\tentropy->pub.decode_mcu = decode_mcu_DC_first;\r\n      else\r\n\tentropy->pub.decode_mcu = decode_mcu_AC_first;\r\n    } else {\r\n      if (cinfo->Ss == 0)\r\n\tentropy->pub.decode_mcu = decode_mcu_DC_refine;\r\n      else\r\n\tentropy->pub.decode_mcu = decode_mcu_AC_refine;\r\n    }\r\n  } else {\r\n    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.\r\n     * This ought to be an error condition, but we make it a warning.\r\n     */\r\n    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||\r\n\t(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))\r\n      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);\r\n    /* Select MCU decoding routine */\r\n    entropy->pub.decode_mcu = decode_mcu;\r\n  }\r\n\r\n  /* Allocate & initialize requested statistics areas */\r\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n    compptr = cinfo->cur_comp_info[ci];\r\n    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {\r\n      tbl = compptr->dc_tbl_no;\r\n      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)\r\n\tERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);\r\n      if (entropy->dc_stats[tbl] == NULL)\r\n\tentropy->dc_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)\r\n\t  ((j_common_ptr) cinfo, JPOOL_IMAGE, DC_STAT_BINS);\r\n      MEMZERO(entropy->dc_stats[tbl], DC_STAT_BINS);\r\n      /* Initialize DC predictions to 0 */\r\n      entropy->last_dc_val[ci] = 0;\r\n      entropy->dc_context[ci] = 0;\r\n    }\r\n    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||\r\n\t(cinfo->progressive_mode && cinfo->Ss)) {\r\n      tbl = compptr->ac_tbl_no;\r\n      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)\r\n\tERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);\r\n      if (entropy->ac_stats[tbl] == NULL)\r\n\tentropy->ac_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)\r\n\t  ((j_common_ptr) cinfo, JPOOL_IMAGE, AC_STAT_BINS);\r\n      MEMZERO(entropy->ac_stats[tbl], AC_STAT_BINS);\r\n    }\r\n  }\r\n\r\n  /* Initialize arithmetic decoding variables */\r\n  entropy->c = 0;\r\n  entropy->a = 0;\r\n  entropy->ct = -16;\t/* force reading 2 initial bytes to fill C */\r\n\r\n  /* Initialize restart counter */\r\n  entropy->restarts_to_go = cinfo->restart_interval;\r\n}\r\n\r\n\r\n/*\r\n * Finish up at the end of an arithmetic-compressed scan.\r\n */\r\n\r\nMETHODDEF(void)\r\nfinish_pass (j_decompress_ptr cinfo)\r\n{\r\n  /* no work necessary here */\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for arithmetic entropy decoding.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_arith_decoder (j_decompress_ptr cinfo)\r\n{\r\n  arith_entropy_ptr entropy;\r\n  int i;\r\n\r\n  entropy = (arith_entropy_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(arith_entropy_decoder));\r\n  cinfo->entropy = &entropy->pub;\r\n  entropy->pub.start_pass = start_pass;\r\n  entropy->pub.finish_pass = finish_pass;\r\n\r\n  /* Mark tables unallocated */\r\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\r\n    entropy->dc_stats[i] = NULL;\r\n    entropy->ac_stats[i] = NULL;\r\n  }\r\n\r\n  /* Initialize index for fixed probability estimation */\r\n  entropy->fixed_bin[0] = 113;\r\n\r\n  if (cinfo->progressive_mode) {\r\n    /* Create progression status table */\r\n    int *coef_bit_ptr, ci;\r\n    cinfo->coef_bits = (int (*)[DCTSIZE2])\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  cinfo->num_components*DCTSIZE2*SIZEOF(int));\r\n    coef_bit_ptr = & cinfo->coef_bits[0][0];\r\n    for (ci = 0; ci < cinfo->num_components; ci++) \r\n      for (i = 0; i < DCTSIZE2; i++)\r\n\t*coef_bit_ptr++ = -1;\r\n  }\r\n}\r\n","/*\r\n * jdatasrc.c\r\n *\r\n * Copyright (C) 1994-1996, Thomas G. Lane.\r\n * Modified 2009-2011 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains decompression data source routines for the case of\r\n * reading JPEG data from memory or from a file (or any stdio stream).\r\n * While these routines are sufficient for most applications,\r\n * some will want to use a different source manager.\r\n * IMPORTANT: we assume that fread() will correctly transcribe an array of\r\n * JOCTETs from 8-bit-wide elements on external storage.  If char is wider\r\n * than 8 bits on your machine, you may need to do some tweaking.\r\n */\r\n\r\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jerror.h\"\r\n\r\n\r\n/* Expanded data source object for stdio input */\r\n\r\ntypedef struct {\r\n  struct jpeg_source_mgr pub;\t/* public fields */\r\n\r\n  FILE * infile;\t\t/* source stream */\r\n  JOCTET * buffer;\t\t/* start of buffer */\r\n  boolean start_of_file;\t/* have we gotten any data yet? */\r\n} my_source_mgr;\r\n\r\ntypedef my_source_mgr * my_src_ptr;\r\n\r\n#define INPUT_BUF_SIZE  4096\t/* choose an efficiently fread'able size */\r\n\r\n\r\n/*\r\n * Initialize source --- called by jpeg_read_header\r\n * before any data is actually read.\r\n */\r\n\r\nMETHODDEF(void)\r\ninit_source (j_decompress_ptr cinfo)\r\n{\r\n  my_src_ptr src = (my_src_ptr) cinfo->src;\r\n\r\n  /* We reset the empty-input-file flag for each image,\r\n   * but we don't clear the input buffer.\r\n   * This is correct behavior for reading a series of images from one source.\r\n   */\r\n  src->start_of_file = TRUE;\r\n}\r\n\r\nMETHODDEF(void)\r\ninit_mem_source (j_decompress_ptr cinfo)\r\n{\r\n  /* no work necessary here */\r\n}\r\n\r\n\r\n/*\r\n * Fill the input buffer --- called whenever buffer is emptied.\r\n *\r\n * In typical applications, this should read fresh data into the buffer\r\n * (ignoring the current state of next_input_byte & bytes_in_buffer),\r\n * reset the pointer & count to the start of the buffer, and return TRUE\r\n * indicating that the buffer has been reloaded.  It is not necessary to\r\n * fill the buffer entirely, only to obtain at least one more byte.\r\n *\r\n * There is no such thing as an EOF return.  If the end of the file has been\r\n * reached, the routine has a choice of ERREXIT() or inserting fake data into\r\n * the buffer.  In most cases, generating a warning message and inserting a\r\n * fake EOI marker is the best course of action --- this will allow the\r\n * decompressor to output however much of the image is there.  However,\r\n * the resulting error message is misleading if the real problem is an empty\r\n * input file, so we handle that case specially.\r\n *\r\n * In applications that need to be able to suspend compression due to input\r\n * not being available yet, a FALSE return indicates that no more data can be\r\n * obtained right now, but more may be forthcoming later.  In this situation,\r\n * the decompressor will return to its caller (with an indication of the\r\n * number of scanlines it has read, if any).  The application should resume\r\n * decompression after it has loaded more data into the input buffer.  Note\r\n * that there are substantial restrictions on the use of suspension --- see\r\n * the documentation.\r\n *\r\n * When suspending, the decompressor will back up to a convenient restart point\r\n * (typically the start of the current MCU). next_input_byte & bytes_in_buffer\r\n * indicate where the restart point will be if the current call returns FALSE.\r\n * Data beyond this point must be rescanned after resumption, so move it to\r\n * the front of the buffer rather than discarding it.\r\n */\r\n\r\nMETHODDEF(boolean)\r\nfill_input_buffer (j_decompress_ptr cinfo)\r\n{\r\n  my_src_ptr src = (my_src_ptr) cinfo->src;\r\n  size_t nbytes;\r\n\r\n  nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);\r\n\r\n  if (nbytes <= 0) {\r\n    if (src->start_of_file)\t/* Treat empty input file as fatal error */\r\n      ERREXIT(cinfo, JERR_INPUT_EMPTY);\r\n    WARNMS(cinfo, JWRN_JPEG_EOF);\r\n    /* Insert a fake EOI marker */\r\n    src->buffer[0] = (JOCTET) 0xFF;\r\n    src->buffer[1] = (JOCTET) JPEG_EOI;\r\n    nbytes = 2;\r\n  }\r\n\r\n  src->pub.next_input_byte = src->buffer;\r\n  src->pub.bytes_in_buffer = nbytes;\r\n  src->start_of_file = FALSE;\r\n\r\n  return TRUE;\r\n}\r\n\r\nMETHODDEF(boolean)\r\nfill_mem_input_buffer (j_decompress_ptr cinfo)\r\n{\r\n  static const JOCTET mybuffer[4] = {\r\n    (JOCTET) 0xFF, (JOCTET) JPEG_EOI, 0, 0\r\n  };\r\n\r\n  /* The whole JPEG data is expected to reside in the supplied memory\r\n   * buffer, so any request for more data beyond the given buffer size\r\n   * is treated as an error.\r\n   */\r\n  WARNMS(cinfo, JWRN_JPEG_EOF);\r\n\r\n  /* Insert a fake EOI marker */\r\n\r\n  cinfo->src->next_input_byte = mybuffer;\r\n  cinfo->src->bytes_in_buffer = 2;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Skip data --- used to skip over a potentially large amount of\r\n * uninteresting data (such as an APPn marker).\r\n *\r\n * Writers of suspendable-input applications must note that skip_input_data\r\n * is not granted the right to give a suspension return.  If the skip extends\r\n * beyond the data currently in the buffer, the buffer can be marked empty so\r\n * that the next read will cause a fill_input_buffer call that can suspend.\r\n * Arranging for additional bytes to be discarded before reloading the input\r\n * buffer is the application writer's problem.\r\n */\r\n\r\nMETHODDEF(void)\r\nskip_input_data (j_decompress_ptr cinfo, long num_bytes)\r\n{\r\n  struct jpeg_source_mgr * src = cinfo->src;\r\n\r\n  /* Just a dumb implementation for now.  Could use fseek() except\r\n   * it doesn't work on pipes.  Not clear that being smart is worth\r\n   * any trouble anyway --- large skips are infrequent.\r\n   */\r\n  if (num_bytes > 0) {\r\n    while (num_bytes > (long) src->bytes_in_buffer) {\r\n      num_bytes -= (long) src->bytes_in_buffer;\r\n      (void) (*src->fill_input_buffer) (cinfo);\r\n      /* note we assume that fill_input_buffer will never return FALSE,\r\n       * so suspension need not be handled.\r\n       */\r\n    }\r\n    src->next_input_byte += (size_t) num_bytes;\r\n    src->bytes_in_buffer -= (size_t) num_bytes;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * An additional method that can be provided by data source modules is the\r\n * resync_to_restart method for error recovery in the presence of RST markers.\r\n * For the moment, this source module just uses the default resync method\r\n * provided by the JPEG library.  That method assumes that no backtracking\r\n * is possible.\r\n */\r\n\r\n\r\n/*\r\n * Terminate source --- called by jpeg_finish_decompress\r\n * after all data has been read.  Often a no-op.\r\n *\r\n * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding\r\n * application must deal with any cleanup that should happen even\r\n * for error exit.\r\n */\r\n\r\nMETHODDEF(void)\r\nterm_source (j_decompress_ptr cinfo)\r\n{\r\n  /* no work necessary here */\r\n}\r\n\r\n\r\n/*\r\n * Prepare for input from a stdio stream.\r\n * The caller must have already opened the stream, and is responsible\r\n * for closing it after finishing decompression.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)\r\n{\r\n  my_src_ptr src;\r\n\r\n  /* The source object and input buffer are made permanent so that a series\r\n   * of JPEG images can be read from the same file by calling jpeg_stdio_src\r\n   * only before the first one.  (If we discarded the buffer at the end of\r\n   * one image, we'd likely lose the start of the next one.)\r\n   * This makes it unsafe to use this manager and a different source\r\n   * manager serially with the same JPEG object.  Caveat programmer.\r\n   */\r\n  if (cinfo->src == NULL) {\t/* first time for this JPEG object? */\r\n    cinfo->src = (struct jpeg_source_mgr *)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\r\n\t\t\t\t  SIZEOF(my_source_mgr));\r\n    src = (my_src_ptr) cinfo->src;\r\n    src->buffer = (JOCTET *)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\r\n\t\t\t\t  INPUT_BUF_SIZE * SIZEOF(JOCTET));\r\n  }\r\n\r\n  src = (my_src_ptr) cinfo->src;\r\n  src->pub.init_source = init_source;\r\n  src->pub.fill_input_buffer = fill_input_buffer;\r\n  src->pub.skip_input_data = skip_input_data;\r\n  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\r\n  src->pub.term_source = term_source;\r\n  src->infile = infile;\r\n  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */\r\n  src->pub.next_input_byte = NULL; /* until buffer loaded */\r\n}\r\n\r\n\r\n/*\r\n * Prepare for input from a supplied memory buffer.\r\n * The buffer must contain the whole JPEG data.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_mem_src (j_decompress_ptr cinfo,\r\n\t      unsigned char * inbuffer, unsigned long insize)\r\n{\r\n  struct jpeg_source_mgr * src;\r\n\r\n  if (inbuffer == NULL || insize == 0)\t/* Treat empty input as fatal error */\r\n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\r\n\r\n  /* The source object is made permanent so that a series of JPEG images\r\n   * can be read from the same buffer by calling jpeg_mem_src only before\r\n   * the first one.\r\n   */\r\n  if (cinfo->src == NULL) {\t/* first time for this JPEG object? */\r\n    cinfo->src = (struct jpeg_source_mgr *)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\r\n\t\t\t\t  SIZEOF(struct jpeg_source_mgr));\r\n  }\r\n\r\n  src = cinfo->src;\r\n  src->init_source = init_mem_source;\r\n  src->fill_input_buffer = fill_mem_input_buffer;\r\n  src->skip_input_data = skip_input_data;\r\n  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */\r\n  src->term_source = term_source;\r\n  src->bytes_in_buffer = (size_t) insize;\r\n  src->next_input_byte = (JOCTET *) inbuffer;\r\n}\r\n","/*\r\n * jdcoefct.c\r\n *\r\n * Copyright (C) 1994-1997, Thomas G. Lane.\r\n * Modified 2002-2011 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains the coefficient buffer controller for decompression.\r\n * This controller is the top level of the JPEG decompressor proper.\r\n * The coefficient buffer lies between entropy decoding and inverse-DCT steps.\r\n *\r\n * In buffered-image mode, this controller is the interface between\r\n * input-oriented processing and output-oriented processing.\r\n * Also, the input side (only) is used when reading a file for transcoding.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n/* Block smoothing is only applicable for progressive JPEG, so: */\r\n#ifndef D_PROGRESSIVE_SUPPORTED\r\n#undef BLOCK_SMOOTHING_SUPPORTED\r\n#endif\r\n\r\n/* Private buffer controller object */\r\n\r\ntypedef struct {\r\n  struct jpeg_d_coef_controller pub; /* public fields */\r\n\r\n  /* These variables keep track of the current location of the input side. */\r\n  /* cinfo->input_iMCU_row is also used for this. */\r\n  JDIMENSION MCU_ctr;\t\t/* counts MCUs processed in current row */\r\n  int MCU_vert_offset;\t\t/* counts MCU rows within iMCU row */\r\n  int MCU_rows_per_iMCU_row;\t/* number of such rows needed */\r\n\r\n  /* The output side's location is represented by cinfo->output_iMCU_row. */\r\n\r\n  /* In single-pass modes, it's sufficient to buffer just one MCU.\r\n   * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,\r\n   * and let the entropy decoder write into that workspace each time.\r\n   * (On 80x86, the workspace is FAR even though it's not really very big;\r\n   * this is to keep the module interfaces unchanged when a large coefficient\r\n   * buffer is necessary.)\r\n   * In multi-pass modes, this array points to the current MCU's blocks\r\n   * within the virtual arrays; it is used only by the input side.\r\n   */\r\n  JBLOCKROW MCU_buffer[D_MAX_BLOCKS_IN_MCU];\r\n\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n  /* In multi-pass modes, we need a virtual block array for each component. */\r\n  jvirt_barray_ptr whole_image[MAX_COMPONENTS];\r\n#endif\r\n\r\n#ifdef BLOCK_SMOOTHING_SUPPORTED\r\n  /* When doing block smoothing, we latch coefficient Al values here */\r\n  int * coef_bits_latch;\r\n#define SAVED_COEFS  6\t\t/* we save coef_bits[0..5] */\r\n#endif\r\n} my_coef_controller;\r\n\r\ntypedef my_coef_controller * my_coef_ptr;\r\n\r\n/* Forward declarations */\r\nMETHODDEF(int) decompress_onepass\r\n\tJPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\nMETHODDEF(int) decompress_data\r\n\tJPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));\r\n#endif\r\n#ifdef BLOCK_SMOOTHING_SUPPORTED\r\nLOCAL(boolean) smoothing_ok JPP((j_decompress_ptr cinfo));\r\nMETHODDEF(int) decompress_smooth_data\r\n\tJPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));\r\n#endif\r\n\r\n\r\nLOCAL(void)\r\nstart_iMCU_row (j_decompress_ptr cinfo)\r\n/* Reset within-iMCU-row counters for a new row (input side) */\r\n{\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n\r\n  /* In an interleaved scan, an MCU row is the same as an iMCU row.\r\n   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.\r\n   * But at the bottom of the image, process only what's left.\r\n   */\r\n  if (cinfo->comps_in_scan > 1) {\r\n    coef->MCU_rows_per_iMCU_row = 1;\r\n  } else {\r\n    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))\r\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;\r\n    else\r\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;\r\n  }\r\n\r\n  coef->MCU_ctr = 0;\r\n  coef->MCU_vert_offset = 0;\r\n}\r\n\r\n\r\n/*\r\n * Initialize for an input processing pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_input_pass (j_decompress_ptr cinfo)\r\n{\r\n  cinfo->input_iMCU_row = 0;\r\n  start_iMCU_row(cinfo);\r\n}\r\n\r\n\r\n/*\r\n * Initialize for an output processing pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_output_pass (j_decompress_ptr cinfo)\r\n{\r\n#ifdef BLOCK_SMOOTHING_SUPPORTED\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n\r\n  /* If multipass, check to see whether to use block smoothing on this pass */\r\n  if (coef->pub.coef_arrays != NULL) {\r\n    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))\r\n      coef->pub.decompress_data = decompress_smooth_data;\r\n    else\r\n      coef->pub.decompress_data = decompress_data;\r\n  }\r\n#endif\r\n  cinfo->output_iMCU_row = 0;\r\n}\r\n\r\n\r\n/*\r\n * Decompress and return some data in the single-pass case.\r\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\r\n * Input and output must run in lockstep since we have only a one-MCU buffer.\r\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\r\n *\r\n * NB: output_buf contains a plane for each component in image,\r\n * which we index according to the component's SOF position.\r\n */\r\n\r\nMETHODDEF(int)\r\ndecompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)\r\n{\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\r\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\r\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\r\n  int blkn, ci, xindex, yindex, yoffset, useful_width;\r\n  JSAMPARRAY output_ptr;\r\n  JDIMENSION start_col, output_col;\r\n  jpeg_component_info *compptr;\r\n  inverse_DCT_method_ptr inverse_DCT;\r\n\r\n  /* Loop to process as much as one whole iMCU row */\r\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\r\n       yoffset++) {\r\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;\r\n\t MCU_col_num++) {\r\n      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */\r\n      if (cinfo->lim_Se)\t/* can bypass in DC only case */\r\n\tFMEMZERO((void FAR *) coef->MCU_buffer[0],\r\n\t\t (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));\r\n      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\r\n\t/* Suspension forced; update state counters and exit */\r\n\tcoef->MCU_vert_offset = yoffset;\r\n\tcoef->MCU_ctr = MCU_col_num;\r\n\treturn JPEG_SUSPENDED;\r\n      }\r\n      /* Determine where data should go in output_buf and do the IDCT thing.\r\n       * We skip dummy blocks at the right and bottom edges (but blkn gets\r\n       * incremented past them!).  Note the inner loop relies on having\r\n       * allocated the MCU_buffer[] blocks sequentially.\r\n       */\r\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\r\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n\tcompptr = cinfo->cur_comp_info[ci];\r\n\t/* Don't bother to IDCT an uninteresting component. */\r\n\tif (! compptr->component_needed) {\r\n\t  blkn += compptr->MCU_blocks;\r\n\t  continue;\r\n\t}\r\n\tinverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];\r\n\tuseful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\r\n\t\t\t\t\t\t    : compptr->last_col_width;\r\n\toutput_ptr = output_buf[compptr->component_index] +\r\n\t  yoffset * compptr->DCT_v_scaled_size;\r\n\tstart_col = MCU_col_num * compptr->MCU_sample_width;\r\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\r\n\t  if (cinfo->input_iMCU_row < last_iMCU_row ||\r\n\t      yoffset+yindex < compptr->last_row_height) {\r\n\t    output_col = start_col;\r\n\t    for (xindex = 0; xindex < useful_width; xindex++) {\r\n\t      (*inverse_DCT) (cinfo, compptr,\r\n\t\t\t      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],\r\n\t\t\t      output_ptr, output_col);\r\n\t      output_col += compptr->DCT_h_scaled_size;\r\n\t    }\r\n\t  }\r\n\t  blkn += compptr->MCU_width;\r\n\t  output_ptr += compptr->DCT_v_scaled_size;\r\n\t}\r\n      }\r\n    }\r\n    /* Completed an MCU row, but perhaps not an iMCU row */\r\n    coef->MCU_ctr = 0;\r\n  }\r\n  /* Completed the iMCU row, advance counters for next one */\r\n  cinfo->output_iMCU_row++;\r\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\r\n    start_iMCU_row(cinfo);\r\n    return JPEG_ROW_COMPLETED;\r\n  }\r\n  /* Completed the scan */\r\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\r\n  return JPEG_SCAN_COMPLETED;\r\n}\r\n\r\n\r\n/*\r\n * Dummy consume-input routine for single-pass operation.\r\n */\r\n\r\nMETHODDEF(int)\r\ndummy_consume_data (j_decompress_ptr cinfo)\r\n{\r\n  return JPEG_SUSPENDED;\t/* Always indicate nothing was done */\r\n}\r\n\r\n\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n\r\n/*\r\n * Consume input data and store it in the full-image coefficient buffer.\r\n * We read as much as one fully interleaved MCU row (\"iMCU\" row) per call,\r\n * ie, v_samp_factor block rows for each component in the scan.\r\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\r\n */\r\n\r\nMETHODDEF(int)\r\nconsume_data (j_decompress_ptr cinfo)\r\n{\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\r\n  int blkn, ci, xindex, yindex, yoffset;\r\n  JDIMENSION start_col;\r\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\r\n  JBLOCKROW buffer_ptr;\r\n  jpeg_component_info *compptr;\r\n\r\n  /* Align the virtual buffers for the components used in this scan. */\r\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n    compptr = cinfo->cur_comp_info[ci];\r\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\r\n      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],\r\n       cinfo->input_iMCU_row * compptr->v_samp_factor,\r\n       (JDIMENSION) compptr->v_samp_factor, TRUE);\r\n    /* Note: entropy decoder expects buffer to be zeroed,\r\n     * but this is handled automatically by the memory manager\r\n     * because we requested a pre-zeroed array.\r\n     */\r\n  }\r\n\r\n  /* Loop to process one whole iMCU row */\r\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\r\n       yoffset++) {\r\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;\r\n\t MCU_col_num++) {\r\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\r\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\r\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n\tcompptr = cinfo->cur_comp_info[ci];\r\n\tstart_col = MCU_col_num * compptr->MCU_width;\r\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\r\n\t  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\r\n\t  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\r\n\t    coef->MCU_buffer[blkn++] = buffer_ptr++;\r\n\t  }\r\n\t}\r\n      }\r\n      /* Try to fetch the MCU. */\r\n      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\r\n\t/* Suspension forced; update state counters and exit */\r\n\tcoef->MCU_vert_offset = yoffset;\r\n\tcoef->MCU_ctr = MCU_col_num;\r\n\treturn JPEG_SUSPENDED;\r\n      }\r\n    }\r\n    /* Completed an MCU row, but perhaps not an iMCU row */\r\n    coef->MCU_ctr = 0;\r\n  }\r\n  /* Completed the iMCU row, advance counters for next one */\r\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\r\n    start_iMCU_row(cinfo);\r\n    return JPEG_ROW_COMPLETED;\r\n  }\r\n  /* Completed the scan */\r\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\r\n  return JPEG_SCAN_COMPLETED;\r\n}\r\n\r\n\r\n/*\r\n * Decompress and return some data in the multi-pass case.\r\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\r\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\r\n *\r\n * NB: output_buf contains a plane for each component in image.\r\n */\r\n\r\nMETHODDEF(int)\r\ndecompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)\r\n{\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\r\n  JDIMENSION block_num;\r\n  int ci, block_row, block_rows;\r\n  JBLOCKARRAY buffer;\r\n  JBLOCKROW buffer_ptr;\r\n  JSAMPARRAY output_ptr;\r\n  JDIMENSION output_col;\r\n  jpeg_component_info *compptr;\r\n  inverse_DCT_method_ptr inverse_DCT;\r\n\r\n  /* Force some input to be done if we are getting ahead of the input. */\r\n  while (cinfo->input_scan_number < cinfo->output_scan_number ||\r\n\t (cinfo->input_scan_number == cinfo->output_scan_number &&\r\n\t  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {\r\n    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)\r\n      return JPEG_SUSPENDED;\r\n  }\r\n\r\n  /* OK, output from the virtual arrays. */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Don't bother to IDCT an uninteresting component. */\r\n    if (! compptr->component_needed)\r\n      continue;\r\n    /* Align the virtual buffer for this component. */\r\n    buffer = (*cinfo->mem->access_virt_barray)\r\n      ((j_common_ptr) cinfo, coef->whole_image[ci],\r\n       cinfo->output_iMCU_row * compptr->v_samp_factor,\r\n       (JDIMENSION) compptr->v_samp_factor, FALSE);\r\n    /* Count non-dummy DCT block rows in this iMCU row. */\r\n    if (cinfo->output_iMCU_row < last_iMCU_row)\r\n      block_rows = compptr->v_samp_factor;\r\n    else {\r\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\r\n      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\r\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\r\n    }\r\n    inverse_DCT = cinfo->idct->inverse_DCT[ci];\r\n    output_ptr = output_buf[ci];\r\n    /* Loop over all DCT blocks to be processed. */\r\n    for (block_row = 0; block_row < block_rows; block_row++) {\r\n      buffer_ptr = buffer[block_row];\r\n      output_col = 0;\r\n      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {\r\n\t(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,\r\n\t\t\toutput_ptr, output_col);\r\n\tbuffer_ptr++;\r\n\toutput_col += compptr->DCT_h_scaled_size;\r\n      }\r\n      output_ptr += compptr->DCT_v_scaled_size;\r\n    }\r\n  }\r\n\r\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\r\n    return JPEG_ROW_COMPLETED;\r\n  return JPEG_SCAN_COMPLETED;\r\n}\r\n\r\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\r\n\r\n\r\n#ifdef BLOCK_SMOOTHING_SUPPORTED\r\n\r\n/*\r\n * This code applies interblock smoothing as described by section K.8\r\n * of the JPEG standard: the first 5 AC coefficients are estimated from\r\n * the DC values of a DCT block and its 8 neighboring blocks.\r\n * We apply smoothing only for progressive JPEG decoding, and only if\r\n * the coefficients it can estimate are not yet known to full precision.\r\n */\r\n\r\n/* Natural-order array positions of the first 5 zigzag-order coefficients */\r\n#define Q01_POS  1\r\n#define Q10_POS  8\r\n#define Q20_POS  16\r\n#define Q11_POS  9\r\n#define Q02_POS  2\r\n\r\n/*\r\n * Determine whether block smoothing is applicable and safe.\r\n * We also latch the current states of the coef_bits[] entries for the\r\n * AC coefficients; otherwise, if the input side of the decompressor\r\n * advances into a new scan, we might think the coefficients are known\r\n * more accurately than they really are.\r\n */\r\n\r\nLOCAL(boolean)\r\nsmoothing_ok (j_decompress_ptr cinfo)\r\n{\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n  boolean smoothing_useful = FALSE;\r\n  int ci, coefi;\r\n  jpeg_component_info *compptr;\r\n  JQUANT_TBL * qtable;\r\n  int * coef_bits;\r\n  int * coef_bits_latch;\r\n\r\n  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)\r\n    return FALSE;\r\n\r\n  /* Allocate latch area if not already done */\r\n  if (coef->coef_bits_latch == NULL)\r\n    coef->coef_bits_latch = (int *)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  cinfo->num_components *\r\n\t\t\t\t  (SAVED_COEFS * SIZEOF(int)));\r\n  coef_bits_latch = coef->coef_bits_latch;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* All components' quantization values must already be latched. */\r\n    if ((qtable = compptr->quant_table) == NULL)\r\n      return FALSE;\r\n    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */\r\n    if (qtable->quantval[0] == 0 ||\r\n\tqtable->quantval[Q01_POS] == 0 ||\r\n\tqtable->quantval[Q10_POS] == 0 ||\r\n\tqtable->quantval[Q20_POS] == 0 ||\r\n\tqtable->quantval[Q11_POS] == 0 ||\r\n\tqtable->quantval[Q02_POS] == 0)\r\n      return FALSE;\r\n    /* DC values must be at least partly known for all components. */\r\n    coef_bits = cinfo->coef_bits[ci];\r\n    if (coef_bits[0] < 0)\r\n      return FALSE;\r\n    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */\r\n    for (coefi = 1; coefi <= 5; coefi++) {\r\n      coef_bits_latch[coefi] = coef_bits[coefi];\r\n      if (coef_bits[coefi] != 0)\r\n\tsmoothing_useful = TRUE;\r\n    }\r\n    coef_bits_latch += SAVED_COEFS;\r\n  }\r\n\r\n  return smoothing_useful;\r\n}\r\n\r\n\r\n/*\r\n * Variant of decompress_data for use when doing block smoothing.\r\n */\r\n\r\nMETHODDEF(int)\r\ndecompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)\r\n{\r\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\r\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\r\n  JDIMENSION block_num, last_block_column;\r\n  int ci, block_row, block_rows, access_rows;\r\n  JBLOCKARRAY buffer;\r\n  JBLOCKROW buffer_ptr, prev_block_row, next_block_row;\r\n  JSAMPARRAY output_ptr;\r\n  JDIMENSION output_col;\r\n  jpeg_component_info *compptr;\r\n  inverse_DCT_method_ptr inverse_DCT;\r\n  boolean first_row, last_row;\r\n  JBLOCK workspace;\r\n  int *coef_bits;\r\n  JQUANT_TBL *quanttbl;\r\n  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;\r\n  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;\r\n  int Al, pred;\r\n\r\n  /* Force some input to be done if we are getting ahead of the input. */\r\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\r\n\t ! cinfo->inputctl->eoi_reached) {\r\n    if (cinfo->input_scan_number == cinfo->output_scan_number) {\r\n      /* If input is working on current scan, we ordinarily want it to\r\n       * have completed the current row.  But if input scan is DC,\r\n       * we want it to keep one row ahead so that next block row's DC\r\n       * values are up to date.\r\n       */\r\n      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;\r\n      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)\r\n\tbreak;\r\n    }\r\n    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)\r\n      return JPEG_SUSPENDED;\r\n  }\r\n\r\n  /* OK, output from the virtual arrays. */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Don't bother to IDCT an uninteresting component. */\r\n    if (! compptr->component_needed)\r\n      continue;\r\n    /* Count non-dummy DCT block rows in this iMCU row. */\r\n    if (cinfo->output_iMCU_row < last_iMCU_row) {\r\n      block_rows = compptr->v_samp_factor;\r\n      access_rows = block_rows * 2; /* this and next iMCU row */\r\n      last_row = FALSE;\r\n    } else {\r\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\r\n      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\r\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\r\n      access_rows = block_rows; /* this iMCU row only */\r\n      last_row = TRUE;\r\n    }\r\n    /* Align the virtual buffer for this component. */\r\n    if (cinfo->output_iMCU_row > 0) {\r\n      access_rows += compptr->v_samp_factor; /* prior iMCU row too */\r\n      buffer = (*cinfo->mem->access_virt_barray)\r\n\t((j_common_ptr) cinfo, coef->whole_image[ci],\r\n\t (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,\r\n\t (JDIMENSION) access_rows, FALSE);\r\n      buffer += compptr->v_samp_factor;\t/* point to current iMCU row */\r\n      first_row = FALSE;\r\n    } else {\r\n      buffer = (*cinfo->mem->access_virt_barray)\r\n\t((j_common_ptr) cinfo, coef->whole_image[ci],\r\n\t (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);\r\n      first_row = TRUE;\r\n    }\r\n    /* Fetch component-dependent info */\r\n    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);\r\n    quanttbl = compptr->quant_table;\r\n    Q00 = quanttbl->quantval[0];\r\n    Q01 = quanttbl->quantval[Q01_POS];\r\n    Q10 = quanttbl->quantval[Q10_POS];\r\n    Q20 = quanttbl->quantval[Q20_POS];\r\n    Q11 = quanttbl->quantval[Q11_POS];\r\n    Q02 = quanttbl->quantval[Q02_POS];\r\n    inverse_DCT = cinfo->idct->inverse_DCT[ci];\r\n    output_ptr = output_buf[ci];\r\n    /* Loop over all DCT blocks to be processed. */\r\n    for (block_row = 0; block_row < block_rows; block_row++) {\r\n      buffer_ptr = buffer[block_row];\r\n      if (first_row && block_row == 0)\r\n\tprev_block_row = buffer_ptr;\r\n      else\r\n\tprev_block_row = buffer[block_row-1];\r\n      if (last_row && block_row == block_rows-1)\r\n\tnext_block_row = buffer_ptr;\r\n      else\r\n\tnext_block_row = buffer[block_row+1];\r\n      /* We fetch the surrounding DC values using a sliding-register approach.\r\n       * Initialize all nine here so as to do the right thing on narrow pics.\r\n       */\r\n      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];\r\n      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];\r\n      DC7 = DC8 = DC9 = (int) next_block_row[0][0];\r\n      output_col = 0;\r\n      last_block_column = compptr->width_in_blocks - 1;\r\n      for (block_num = 0; block_num <= last_block_column; block_num++) {\r\n\t/* Fetch current DCT block into workspace so we can modify it. */\r\n\tjcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);\r\n\t/* Update DC values */\r\n\tif (block_num < last_block_column) {\r\n\t  DC3 = (int) prev_block_row[1][0];\r\n\t  DC6 = (int) buffer_ptr[1][0];\r\n\t  DC9 = (int) next_block_row[1][0];\r\n\t}\r\n\t/* Compute coefficient estimates per K.8.\r\n\t * An estimate is applied only if coefficient is still zero,\r\n\t * and is not known to be fully accurate.\r\n\t */\r\n\t/* AC01 */\r\n\tif ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {\r\n\t  num = 36 * Q00 * (DC4 - DC6);\r\n\t  if (num >= 0) {\r\n\t    pred = (int) (((Q01<<7) + num) / (Q01<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t  } else {\r\n\t    pred = (int) (((Q01<<7) - num) / (Q01<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t    pred = -pred;\r\n\t  }\r\n\t  workspace[1] = (JCOEF) pred;\r\n\t}\r\n\t/* AC10 */\r\n\tif ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {\r\n\t  num = 36 * Q00 * (DC2 - DC8);\r\n\t  if (num >= 0) {\r\n\t    pred = (int) (((Q10<<7) + num) / (Q10<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t  } else {\r\n\t    pred = (int) (((Q10<<7) - num) / (Q10<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t    pred = -pred;\r\n\t  }\r\n\t  workspace[8] = (JCOEF) pred;\r\n\t}\r\n\t/* AC20 */\r\n\tif ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {\r\n\t  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);\r\n\t  if (num >= 0) {\r\n\t    pred = (int) (((Q20<<7) + num) / (Q20<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t  } else {\r\n\t    pred = (int) (((Q20<<7) - num) / (Q20<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t    pred = -pred;\r\n\t  }\r\n\t  workspace[16] = (JCOEF) pred;\r\n\t}\r\n\t/* AC11 */\r\n\tif ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {\r\n\t  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);\r\n\t  if (num >= 0) {\r\n\t    pred = (int) (((Q11<<7) + num) / (Q11<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t  } else {\r\n\t    pred = (int) (((Q11<<7) - num) / (Q11<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t    pred = -pred;\r\n\t  }\r\n\t  workspace[9] = (JCOEF) pred;\r\n\t}\r\n\t/* AC02 */\r\n\tif ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {\r\n\t  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);\r\n\t  if (num >= 0) {\r\n\t    pred = (int) (((Q02<<7) + num) / (Q02<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t  } else {\r\n\t    pred = (int) (((Q02<<7) - num) / (Q02<<8));\r\n\t    if (Al > 0 && pred >= (1<<Al))\r\n\t      pred = (1<<Al)-1;\r\n\t    pred = -pred;\r\n\t  }\r\n\t  workspace[2] = (JCOEF) pred;\r\n\t}\r\n\t/* OK, do the IDCT */\r\n\t(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,\r\n\t\t\toutput_ptr, output_col);\r\n\t/* Advance for next column */\r\n\tDC1 = DC2; DC2 = DC3;\r\n\tDC4 = DC5; DC5 = DC6;\r\n\tDC7 = DC8; DC8 = DC9;\r\n\tbuffer_ptr++, prev_block_row++, next_block_row++;\r\n\toutput_col += compptr->DCT_h_scaled_size;\r\n      }\r\n      output_ptr += compptr->DCT_v_scaled_size;\r\n    }\r\n  }\r\n\r\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\r\n    return JPEG_ROW_COMPLETED;\r\n  return JPEG_SCAN_COMPLETED;\r\n}\r\n\r\n#endif /* BLOCK_SMOOTHING_SUPPORTED */\r\n\r\n\r\n/*\r\n * Initialize coefficient buffer controller.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)\r\n{\r\n  my_coef_ptr coef;\r\n\r\n  coef = (my_coef_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_coef_controller));\r\n  cinfo->coef = (struct jpeg_d_coef_controller *) coef;\r\n  coef->pub.start_input_pass = start_input_pass;\r\n  coef->pub.start_output_pass = start_output_pass;\r\n#ifdef BLOCK_SMOOTHING_SUPPORTED\r\n  coef->coef_bits_latch = NULL;\r\n#endif\r\n\r\n  /* Create the coefficient buffer. */\r\n  if (need_full_buffer) {\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n    /* Allocate a full-image virtual array for each component, */\r\n    /* padded to a multiple of samp_factor DCT blocks in each direction. */\r\n    /* Note we ask for a pre-zeroed array. */\r\n    int ci, access_rows;\r\n    jpeg_component_info *compptr;\r\n\r\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n\t ci++, compptr++) {\r\n      access_rows = compptr->v_samp_factor;\r\n#ifdef BLOCK_SMOOTHING_SUPPORTED\r\n      /* If block smoothing could be used, need a bigger window */\r\n      if (cinfo->progressive_mode)\r\n\taccess_rows *= 3;\r\n#endif\r\n      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)\r\n\t((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,\r\n\t (JDIMENSION) jround_up((long) compptr->width_in_blocks,\r\n\t\t\t\t(long) compptr->h_samp_factor),\r\n\t (JDIMENSION) jround_up((long) compptr->height_in_blocks,\r\n\t\t\t\t(long) compptr->v_samp_factor),\r\n\t (JDIMENSION) access_rows);\r\n    }\r\n    coef->pub.consume_data = consume_data;\r\n    coef->pub.decompress_data = decompress_data;\r\n    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */\r\n#else\r\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif\r\n  } else {\r\n    /* We only need a single-MCU buffer. */\r\n    JBLOCKROW buffer;\r\n    int i;\r\n\r\n    buffer = (JBLOCKROW)\r\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\r\n    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {\r\n      coef->MCU_buffer[i] = buffer + i;\r\n    }\r\n    if (cinfo->lim_Se == 0)\t/* DC only case: want to bypass later */\r\n      FMEMZERO((void FAR *) buffer,\r\n\t       (size_t) (D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK)));\r\n    coef->pub.consume_data = dummy_consume_data;\r\n    coef->pub.decompress_data = decompress_onepass;\r\n    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */\r\n  }\r\n}\r\n","/*\r\n * jdcolor.c\r\n *\r\n * Copyright (C) 1991-1997, Thomas G. Lane.\r\n * Modified 2011-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains output colorspace conversion routines.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Private subobject */\r\n\r\ntypedef struct {\r\n  struct jpeg_color_deconverter pub; /* public fields */\r\n\r\n  /* Private state for YCbCr->RGB and BG_YCC->RGB conversion */\r\n  int * Cr_r_tab;\t\t/* => table for Cr to R conversion */\r\n  int * Cb_b_tab;\t\t/* => table for Cb to B conversion */\r\n  INT32 * Cr_g_tab;\t\t/* => table for Cr to G conversion */\r\n  INT32 * Cb_g_tab;\t\t/* => table for Cb to G conversion */\r\n\r\n  JSAMPLE * range_limit; /* pointer to normal sample range limit table, */\r\n\t\t     /* or extended sample range limit table for BG_YCC */\r\n\r\n  /* Private state for RGB->Y conversion */\r\n  INT32 * rgb_y_tab;\t\t/* => table for RGB to Y conversion */\r\n} my_color_deconverter;\r\n\r\ntypedef my_color_deconverter * my_cconvert_ptr;\r\n\r\n\r\n/***************  YCbCr -> RGB conversion: most common case **************/\r\n/*************** BG_YCC -> RGB conversion: less common case **************/\r\n/***************    RGB -> Y   conversion: less common case **************/\r\n\r\n/*\r\n * YCbCr is defined per Recommendation ITU-R BT.601-7 (03/2011),\r\n * previously known as Recommendation CCIR 601-1, except that Cb and Cr\r\n * are normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.\r\n * sRGB (standard RGB color space) is defined per IEC 61966-2-1:1999.\r\n * sYCC (standard luma-chroma-chroma color space with extended gamut)\r\n * is defined per IEC 61966-2-1:1999 Amendment A1:2003 Annex F.\r\n * bg-sRGB and bg-sYCC (big gamut standard color spaces)\r\n * are defined per IEC 61966-2-1:1999 Amendment A1:2003 Annex G.\r\n * Note that the derived conversion coefficients given in some of these\r\n * documents are imprecise.  The general conversion equations are\r\n *\r\n *\tR = Y + K * (1 - Kr) * Cr\r\n *\tG = Y - K * (Kb * (1 - Kb) * Cb + Kr * (1 - Kr) * Cr) / (1 - Kr - Kb)\r\n *\tB = Y + K * (1 - Kb) * Cb\r\n *\r\n *\tY = Kr * R + (1 - Kr - Kb) * G + Kb * B\r\n *\r\n * With Kr = 0.299 and Kb = 0.114 (derived according to SMPTE RP 177-1993\r\n * from the 1953 FCC NTSC primaries and CIE Illuminant C), K = 2 for sYCC,\r\n * the conversion equations to be implemented are therefore\r\n *\r\n *\tR = Y + 1.402 * Cr\r\n *\tG = Y - 0.344136286 * Cb - 0.714136286 * Cr\r\n *\tB = Y + 1.772 * Cb\r\n *\r\n *\tY = 0.299 * R + 0.587 * G + 0.114 * B\r\n *\r\n * where Cb and Cr represent the incoming values less CENTERJSAMPLE.\r\n * For bg-sYCC, with K = 4, the equations are\r\n *\r\n *\tR = Y + 2.804 * Cr\r\n *\tG = Y - 0.688272572 * Cb - 1.428272572 * Cr\r\n *\tB = Y + 3.544 * Cb\r\n *\r\n * To avoid floating-point arithmetic, we represent the fractional constants\r\n * as integers scaled up by 2^16 (about 4 digits precision); we have to divide\r\n * the products by 2^16, with appropriate rounding, to get the correct answer.\r\n * Notice that Y, being an integral input, does not contribute any fraction\r\n * so it need not participate in the rounding.\r\n *\r\n * For even more speed, we avoid doing any multiplications in the inner loop\r\n * by precalculating the constants times Cb and Cr for all possible values.\r\n * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);\r\n * for 9-bit to 12-bit samples it is still acceptable.  It's not very\r\n * reasonable for 16-bit samples, but if you want lossless storage you\r\n * shouldn't be changing colorspace anyway.\r\n * The Cr=>R and Cb=>B values can be rounded to integers in advance; the\r\n * values for the G calculation are left scaled up, since we must add them\r\n * together before rounding.\r\n */\r\n\r\n#define SCALEBITS\t16\t/* speediest right-shift on some machines */\r\n#define ONE_HALF\t((INT32) 1 << (SCALEBITS-1))\r\n#define FIX(x)\t\t((INT32) ((x) * (1L<<SCALEBITS) + 0.5))\r\n\r\n/* We allocate one big table for RGB->Y conversion and divide it up into\r\n * three parts, instead of doing three alloc_small requests.  This lets us\r\n * use a single table base address, which can be held in a register in the\r\n * inner loops on many machines (more than can hold all three addresses,\r\n * anyway).\r\n */\r\n\r\n#define R_Y_OFF\t\t0\t\t\t/* offset to R => Y section */\r\n#define G_Y_OFF\t\t(1*(MAXJSAMPLE+1))\t/* offset to G => Y section */\r\n#define B_Y_OFF\t\t(2*(MAXJSAMPLE+1))\t/* etc. */\r\n#define TABLE_SIZE\t(3*(MAXJSAMPLE+1))\r\n\r\n\r\n/*\r\n * Initialize tables for YCbCr->RGB and BG_YCC->RGB colorspace conversion.\r\n */\r\n\r\nLOCAL(void)\r\nbuild_ycc_rgb_table (j_decompress_ptr cinfo)\r\n/* Normal case, sYCC */\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  int i;\r\n  INT32 x;\r\n  SHIFT_TEMPS\r\n\r\n  cconvert->Cr_r_tab = (int *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\r\n  cconvert->Cb_b_tab = (int *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\r\n  cconvert->Cr_g_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\r\n  cconvert->Cb_g_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\r\n\r\n  cconvert->range_limit = cinfo->sample_range_limit;\r\n\r\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\r\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\r\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\r\n    /* Cr=>R value is nearest int to 1.402 * x */\r\n    cconvert->Cr_r_tab[i] = (int)\r\n\t\t    RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);\r\n    /* Cb=>B value is nearest int to 1.772 * x */\r\n    cconvert->Cb_b_tab[i] = (int)\r\n\t\t    RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);\r\n    /* Cr=>G value is scaled-up -0.714136286 * x */\r\n    cconvert->Cr_g_tab[i] = (- FIX(0.714136286)) * x;\r\n    /* Cb=>G value is scaled-up -0.344136286 * x */\r\n    /* We also add in ONE_HALF so that need not do it in inner loop */\r\n    cconvert->Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\nbuild_bg_ycc_rgb_table (j_decompress_ptr cinfo)\r\n/* Wide gamut case, bg-sYCC */\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  int i;\r\n  INT32 x;\r\n  SHIFT_TEMPS\r\n\r\n  cconvert->Cr_r_tab = (int *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\r\n  cconvert->Cb_b_tab = (int *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\r\n  cconvert->Cr_g_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\r\n  cconvert->Cb_g_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\r\n\r\n  cconvert->range_limit = (JSAMPLE *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t5 * (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));\r\n\r\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\r\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\r\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\r\n    /* Cr=>R value is nearest int to 2.804 * x */\r\n    cconvert->Cr_r_tab[i] = (int)\r\n\t\t    RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);\r\n    /* Cb=>B value is nearest int to 3.544 * x */\r\n    cconvert->Cb_b_tab[i] = (int)\r\n\t\t    RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);\r\n    /* Cr=>G value is scaled-up -1.428272572 * x */\r\n    cconvert->Cr_g_tab[i] = (- FIX(1.428272572)) * x;\r\n    /* Cb=>G value is scaled-up -0.688272572 * x */\r\n    /* We also add in ONE_HALF so that need not do it in inner loop */\r\n    cconvert->Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;\r\n  }\r\n\r\n  /* Cb and Cr portions can extend to double range in wide gamut case,\r\n   * so we prepare an appropriate extended range limit table.\r\n   */\r\n\r\n  /* First segment of range limit table: limit[x] = 0 for x < 0 */\r\n  MEMZERO(cconvert->range_limit, 2 * (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));\r\n  cconvert->range_limit += 2 * (MAXJSAMPLE+1);\r\n  /* Main part of range limit table: limit[x] = x */\r\n  for (i = 0; i <= MAXJSAMPLE; i++)\r\n    cconvert->range_limit[i] = (JSAMPLE) i;\r\n  /* End of range limit table: limit[x] = MAXJSAMPLE for x > MAXJSAMPLE */\r\n  for (; i < 3 * (MAXJSAMPLE+1); i++)\r\n    cconvert->range_limit[i] = MAXJSAMPLE;\r\n}\r\n\r\n\r\n/*\r\n * Convert some rows of samples to the output colorspace.\r\n *\r\n * Note that we change from noninterleaved, one-plane-per-component format\r\n * to interleaved-pixel format.  The output buffer is therefore three times\r\n * as wide as the input buffer.\r\n * A starting row offset is provided only for the input buffer.  The caller\r\n * can easily adjust the passed output_buf value to accommodate any row\r\n * offset required on that side.\r\n */\r\n\r\nMETHODDEF(void)\r\nycc_rgb_convert (j_decompress_ptr cinfo,\r\n\t\t JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  register int y, cb, cr;\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr0, inptr1, inptr2;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n  /* copy these pointers into registers if possible */\r\n  register JSAMPLE * range_limit = cconvert->range_limit;\r\n  register int * Crrtab = cconvert->Cr_r_tab;\r\n  register int * Cbbtab = cconvert->Cb_b_tab;\r\n  register INT32 * Crgtab = cconvert->Cr_g_tab;\r\n  register INT32 * Cbgtab = cconvert->Cb_g_tab;\r\n  SHIFT_TEMPS\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr0 = input_buf[0][input_row];\r\n    inptr1 = input_buf[1][input_row];\r\n    inptr2 = input_buf[2][input_row];\r\n    input_row++;\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      y  = GETJSAMPLE(inptr0[col]);\r\n      cb = GETJSAMPLE(inptr1[col]);\r\n      cr = GETJSAMPLE(inptr2[col]);\r\n      /* Range-limiting is essential due to noise introduced by DCT losses,\r\n       * for extended gamut (sYCC) and wide gamut (bg-sYCC) encodings.\r\n       */\r\n      outptr[RGB_RED]   = range_limit[y + Crrtab[cr]];\r\n      outptr[RGB_GREEN] = range_limit[y +\r\n\t\t\t      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\r\n\t\t\t\t\t\t SCALEBITS))];\r\n      outptr[RGB_BLUE]  = range_limit[y + Cbbtab[cb]];\r\n      outptr += RGB_PIXELSIZE;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**************** Cases other than YCC -> RGB ****************/\r\n\r\n\r\n/*\r\n * Initialize for RGB->grayscale colorspace conversion.\r\n */\r\n\r\nLOCAL(void)\r\nbuild_rgb_y_table (j_decompress_ptr cinfo)\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  INT32 * rgb_y_tab;\r\n  INT32 i;\r\n\r\n  /* Allocate and fill in the conversion tables. */\r\n  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(TABLE_SIZE * SIZEOF(INT32)));\r\n\r\n  for (i = 0; i <= MAXJSAMPLE; i++) {\r\n    rgb_y_tab[i+R_Y_OFF] = FIX(0.299) * i;\r\n    rgb_y_tab[i+G_Y_OFF] = FIX(0.587) * i;\r\n    rgb_y_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Convert RGB to grayscale.\r\n */\r\n\r\nMETHODDEF(void)\r\nrgb_gray_convert (j_decompress_ptr cinfo,\r\n\t\t  JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t  JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  register INT32 * ctab = cconvert->rgb_y_tab;\r\n  register int r, g, b;\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr0, inptr1, inptr2;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr0 = input_buf[0][input_row];\r\n    inptr1 = input_buf[1][input_row];\r\n    inptr2 = input_buf[2][input_row];\r\n    input_row++;\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      r = GETJSAMPLE(inptr0[col]);\r\n      g = GETJSAMPLE(inptr1[col]);\r\n      b = GETJSAMPLE(inptr2[col]);\r\n      /* Y */\r\n      outptr[col] = (JSAMPLE)\r\n\t\t((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\r\n\t\t >> SCALEBITS);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * [R-G,G,B-G] to [R,G,B] conversion with modulo calculation\r\n * (inverse color transform).\r\n * This can be seen as an adaption of the general YCbCr->RGB\r\n * conversion equation with Kr = Kb = 0, while replacing the\r\n * normalization by modulo calculation.\r\n */\r\n\r\nMETHODDEF(void)\r\nrgb1_rgb_convert (j_decompress_ptr cinfo,\r\n\t\t  JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t  JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  register int r, g, b;\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr0, inptr1, inptr2;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr0 = input_buf[0][input_row];\r\n    inptr1 = input_buf[1][input_row];\r\n    inptr2 = input_buf[2][input_row];\r\n    input_row++;\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      r = GETJSAMPLE(inptr0[col]);\r\n      g = GETJSAMPLE(inptr1[col]);\r\n      b = GETJSAMPLE(inptr2[col]);\r\n      /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD\r\n       * (modulo) operator is equivalent to the bitmask operator AND.\r\n       */\r\n      outptr[RGB_RED]   = (JSAMPLE) ((r + g - CENTERJSAMPLE) & MAXJSAMPLE);\r\n      outptr[RGB_GREEN] = (JSAMPLE) g;\r\n      outptr[RGB_BLUE]  = (JSAMPLE) ((b + g - CENTERJSAMPLE) & MAXJSAMPLE);\r\n      outptr += RGB_PIXELSIZE;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * [R-G,G,B-G] to grayscale conversion with modulo calculation\r\n * (inverse color transform).\r\n */\r\n\r\nMETHODDEF(void)\r\nrgb1_gray_convert (j_decompress_ptr cinfo,\r\n\t\t   JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t   JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  register INT32 * ctab = cconvert->rgb_y_tab;\r\n  register int r, g, b;\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr0, inptr1, inptr2;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr0 = input_buf[0][input_row];\r\n    inptr1 = input_buf[1][input_row];\r\n    inptr2 = input_buf[2][input_row];\r\n    input_row++;\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      r = GETJSAMPLE(inptr0[col]);\r\n      g = GETJSAMPLE(inptr1[col]);\r\n      b = GETJSAMPLE(inptr2[col]);\r\n      /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD\r\n       * (modulo) operator is equivalent to the bitmask operator AND.\r\n       */\r\n      r = (r + g - CENTERJSAMPLE) & MAXJSAMPLE;\r\n      b = (b + g - CENTERJSAMPLE) & MAXJSAMPLE;\r\n      /* Y */\r\n      outptr[col] = (JSAMPLE)\r\n\t\t((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\r\n\t\t >> SCALEBITS);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * No colorspace change, but conversion from separate-planes\r\n * to interleaved representation.\r\n */\r\n\r\nMETHODDEF(void)\r\nrgb_convert (j_decompress_ptr cinfo,\r\n\t     JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t     JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr0, inptr1, inptr2;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr0 = input_buf[0][input_row];\r\n    inptr1 = input_buf[1][input_row];\r\n    inptr2 = input_buf[2][input_row];\r\n    input_row++;\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      /* We can dispense with GETJSAMPLE() here */\r\n      outptr[RGB_RED]   = inptr0[col];\r\n      outptr[RGB_GREEN] = inptr1[col];\r\n      outptr[RGB_BLUE]  = inptr2[col];\r\n      outptr += RGB_PIXELSIZE;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Color conversion for no colorspace change: just copy the data,\r\n * converting from separate-planes to interleaved representation.\r\n */\r\n\r\nMETHODDEF(void)\r\nnull_convert (j_decompress_ptr cinfo,\r\n\t      JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t      JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  int ci;\r\n  register int nc = cinfo->num_components;\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n\r\n  while (--num_rows >= 0) {\r\n    for (ci = 0; ci < nc; ci++) {\r\n      inptr = input_buf[ci][input_row];\r\n      outptr = output_buf[0] + ci;\r\n      for (col = 0; col < num_cols; col++) {\r\n\t*outptr = *inptr++;\t/* needn't bother with GETJSAMPLE() here */\r\n\toutptr += nc;\r\n      }\r\n    }\r\n    input_row++;\r\n    output_buf++;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Color conversion for grayscale: just copy the data.\r\n * This also works for YCC -> grayscale conversion, in which\r\n * we just copy the Y (luminance) component and ignore chrominance.\r\n */\r\n\r\nMETHODDEF(void)\r\ngrayscale_convert (j_decompress_ptr cinfo,\r\n\t\t   JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t   JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,\r\n\t\t    num_rows, cinfo->output_width);\r\n}\r\n\r\n\r\n/*\r\n * Convert grayscale to RGB: just duplicate the graylevel three times.\r\n * This is provided to support applications that don't want to cope\r\n * with grayscale as a separate case.\r\n */\r\n\r\nMETHODDEF(void)\r\ngray_rgb_convert (j_decompress_ptr cinfo,\r\n\t\t  JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t  JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr = input_buf[0][input_row++];\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      /* We can dispense with GETJSAMPLE() here */\r\n      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];\r\n      outptr += RGB_PIXELSIZE;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Adobe-style YCCK->CMYK conversion.\r\n * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same\r\n * conversion as above, while passing K (black) unchanged.\r\n * We assume build_ycc_rgb_table has been called.\r\n */\r\n\r\nMETHODDEF(void)\r\nycck_cmyk_convert (j_decompress_ptr cinfo,\r\n\t\t   JSAMPIMAGE input_buf, JDIMENSION input_row,\r\n\t\t   JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\r\n  register int y, cb, cr;\r\n  register JSAMPROW outptr;\r\n  register JSAMPROW inptr0, inptr1, inptr2, inptr3;\r\n  register JDIMENSION col;\r\n  JDIMENSION num_cols = cinfo->output_width;\r\n  /* copy these pointers into registers if possible */\r\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\r\n  register int * Crrtab = cconvert->Cr_r_tab;\r\n  register int * Cbbtab = cconvert->Cb_b_tab;\r\n  register INT32 * Crgtab = cconvert->Cr_g_tab;\r\n  register INT32 * Cbgtab = cconvert->Cb_g_tab;\r\n  SHIFT_TEMPS\r\n\r\n  while (--num_rows >= 0) {\r\n    inptr0 = input_buf[0][input_row];\r\n    inptr1 = input_buf[1][input_row];\r\n    inptr2 = input_buf[2][input_row];\r\n    inptr3 = input_buf[3][input_row];\r\n    input_row++;\r\n    outptr = *output_buf++;\r\n    for (col = 0; col < num_cols; col++) {\r\n      y  = GETJSAMPLE(inptr0[col]);\r\n      cb = GETJSAMPLE(inptr1[col]);\r\n      cr = GETJSAMPLE(inptr2[col]);\r\n      /* Range-limiting is essential due to noise introduced by DCT losses,\r\n       * and for extended gamut encodings (sYCC).\r\n       */\r\n      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];\t/* red */\r\n      outptr[1] = range_limit[MAXJSAMPLE - (y +\t\t\t/* green */\r\n\t\t\t      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\r\n\t\t\t\t\t\t SCALEBITS)))];\r\n      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];\t/* blue */\r\n      /* K passes through unchanged */\r\n      outptr[3] = inptr3[col];\t/* don't need GETJSAMPLE here */\r\n      outptr += 4;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Empty method for start_pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_dcolor (j_decompress_ptr cinfo)\r\n{\r\n  /* no work needed */\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for output colorspace conversion.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_color_deconverter (j_decompress_ptr cinfo)\r\n{\r\n  my_cconvert_ptr cconvert;\r\n  int ci;\r\n\r\n  cconvert = (my_cconvert_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_color_deconverter));\r\n  cinfo->cconvert = &cconvert->pub;\r\n  cconvert->pub.start_pass = start_pass_dcolor;\r\n\r\n  /* Make sure num_components agrees with jpeg_color_space */\r\n  switch (cinfo->jpeg_color_space) {\r\n  case JCS_GRAYSCALE:\r\n    if (cinfo->num_components != 1)\r\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\r\n    break;\r\n\r\n  case JCS_RGB:\r\n  case JCS_YCbCr:\r\n  case JCS_BG_RGB:\r\n  case JCS_BG_YCC:\r\n    if (cinfo->num_components != 3)\r\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\r\n    break;\r\n\r\n  case JCS_CMYK:\r\n  case JCS_YCCK:\r\n    if (cinfo->num_components != 4)\r\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\r\n    break;\r\n\r\n  default:\t\t\t/* JCS_UNKNOWN can be anything */\r\n    if (cinfo->num_components < 1)\r\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\r\n    break;\r\n  }\r\n\r\n  /* Support color transform only for RGB colorspaces */\r\n  if (cinfo->color_transform &&\r\n      cinfo->jpeg_color_space != JCS_RGB &&\r\n      cinfo->jpeg_color_space != JCS_BG_RGB)\r\n    ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n\r\n  /* Set out_color_components and conversion method based on requested space.\r\n   * Also clear the component_needed flags for any unused components,\r\n   * so that earlier pipeline stages can avoid useless computation.\r\n   */\r\n\r\n  switch (cinfo->out_color_space) {\r\n  case JCS_GRAYSCALE:\r\n    cinfo->out_color_components = 1;\r\n    switch (cinfo->jpeg_color_space) {\r\n    case JCS_GRAYSCALE:\r\n    case JCS_YCbCr:\r\n    case JCS_BG_YCC:\r\n      cconvert->pub.color_convert = grayscale_convert;\r\n      /* For color->grayscale conversion, only the Y (0) component is needed */\r\n      for (ci = 1; ci < cinfo->num_components; ci++)\r\n\tcinfo->comp_info[ci].component_needed = FALSE;\r\n      break;\r\n    case JCS_RGB:\r\n      switch (cinfo->color_transform) {\r\n      case JCT_NONE:\r\n\tcconvert->pub.color_convert = rgb_gray_convert;\r\n\tbreak;\r\n      case JCT_SUBTRACT_GREEN:\r\n\tcconvert->pub.color_convert = rgb1_gray_convert;\r\n\tbreak;\r\n      default:\r\n\tERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n      }\r\n      build_rgb_y_table(cinfo);\r\n      break;\r\n    default:\r\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n    }\r\n    break;\r\n\r\n  case JCS_RGB:\r\n    cinfo->out_color_components = RGB_PIXELSIZE;\r\n    switch (cinfo->jpeg_color_space) {\r\n    case JCS_GRAYSCALE:\r\n      cconvert->pub.color_convert = gray_rgb_convert;\r\n      break;\r\n    case JCS_YCbCr:\r\n      cconvert->pub.color_convert = ycc_rgb_convert;\r\n      build_ycc_rgb_table(cinfo);\r\n      break;\r\n    case JCS_BG_YCC:\r\n      cconvert->pub.color_convert = ycc_rgb_convert;\r\n      build_bg_ycc_rgb_table(cinfo);\r\n      break;\r\n    case JCS_RGB:\r\n      switch (cinfo->color_transform) {\r\n      case JCT_NONE:\r\n\tcconvert->pub.color_convert = rgb_convert;\r\n\tbreak;\r\n      case JCT_SUBTRACT_GREEN:\r\n\tcconvert->pub.color_convert = rgb1_rgb_convert;\r\n\tbreak;\r\n      default:\r\n\tERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n      }\r\n      break;\r\n    default:\r\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n    }\r\n    break;\r\n\r\n  case JCS_BG_RGB:\r\n    cinfo->out_color_components = RGB_PIXELSIZE;\r\n    if (cinfo->jpeg_color_space == JCS_BG_RGB) {\r\n      switch (cinfo->color_transform) {\r\n      case JCT_NONE:\r\n\tcconvert->pub.color_convert = rgb_convert;\r\n\tbreak;\r\n      case JCT_SUBTRACT_GREEN:\r\n\tcconvert->pub.color_convert = rgb1_rgb_convert;\r\n\tbreak;\r\n      default:\r\n\tERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n      }\r\n    } else\r\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n    break;\r\n\r\n  case JCS_CMYK:\r\n    cinfo->out_color_components = 4;\r\n    switch (cinfo->jpeg_color_space) {\r\n    case JCS_YCCK:\r\n      cconvert->pub.color_convert = ycck_cmyk_convert;\r\n      build_ycc_rgb_table(cinfo);\r\n      break;\r\n    case JCS_CMYK:\r\n      cconvert->pub.color_convert = null_convert;\r\n      break;\r\n    default:\r\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n    }\r\n    break;\r\n\r\n  default:\r\n    /* Permit null conversion to same output space */\r\n    if (cinfo->out_color_space == cinfo->jpeg_color_space) {\r\n      cinfo->out_color_components = cinfo->num_components;\r\n      cconvert->pub.color_convert = null_convert;\r\n    } else\t\t\t/* unsupported non-null conversion */\r\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n    break;\r\n  }\r\n\r\n  if (cinfo->quantize_colors)\r\n    cinfo->output_components = 1; /* single colormapped output component */\r\n  else\r\n    cinfo->output_components = cinfo->out_color_components;\r\n}\r\n","/*\r\n * jddctmgr.c\r\n *\r\n * Copyright (C) 1994-1996, Thomas G. Lane.\r\n * Modified 2002-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains the inverse-DCT management logic.\r\n * This code selects a particular IDCT implementation to be used,\r\n * and it performs related housekeeping chores.  No code in this file\r\n * is executed per IDCT step, only during output pass setup.\r\n *\r\n * Note that the IDCT routines are responsible for performing coefficient\r\n * dequantization as well as the IDCT proper.  This module sets up the\r\n * dequantization multiplier table needed by the IDCT routine.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jdct.h\"\t\t/* Private declarations for DCT subsystem */\r\n\r\n\r\n/*\r\n * The decompressor input side (jdinput.c) saves away the appropriate\r\n * quantization table for each component at the start of the first scan\r\n * involving that component.  (This is necessary in order to correctly\r\n * decode files that reuse Q-table slots.)\r\n * When we are ready to make an output pass, the saved Q-table is converted\r\n * to a multiplier table that will actually be used by the IDCT routine.\r\n * The multiplier table contents are IDCT-method-dependent.  To support\r\n * application changes in IDCT method between scans, we can remake the\r\n * multiplier tables if necessary.\r\n * In buffered-image mode, the first output pass may occur before any data\r\n * has been seen for some components, and thus before their Q-tables have\r\n * been saved away.  To handle this case, multiplier tables are preset\r\n * to zeroes; the result of the IDCT will be a neutral gray level.\r\n */\r\n\r\n\r\n/* Private subobject for this module */\r\n\r\ntypedef struct {\r\n  struct jpeg_inverse_dct pub;\t/* public fields */\r\n\r\n  /* This array contains the IDCT method code that each multiplier table\r\n   * is currently set up for, or -1 if it's not yet set up.\r\n   * The actual multiplier tables are pointed to by dct_table in the\r\n   * per-component comp_info structures.\r\n   */\r\n  int cur_method[MAX_COMPONENTS];\r\n} my_idct_controller;\r\n\r\ntypedef my_idct_controller * my_idct_ptr;\r\n\r\n\r\n/* Allocated multiplier tables: big enough for any supported variant */\r\n\r\ntypedef union {\r\n  ISLOW_MULT_TYPE islow_array[DCTSIZE2];\r\n#ifdef DCT_IFAST_SUPPORTED\r\n  IFAST_MULT_TYPE ifast_array[DCTSIZE2];\r\n#endif\r\n#ifdef DCT_FLOAT_SUPPORTED\r\n  FLOAT_MULT_TYPE float_array[DCTSIZE2];\r\n#endif\r\n} multiplier_table;\r\n\r\n\r\n/* The current scaled-IDCT routines require ISLOW-style multiplier tables,\r\n * so be sure to compile that code if either ISLOW or SCALING is requested.\r\n */\r\n#ifdef DCT_ISLOW_SUPPORTED\r\n#define PROVIDE_ISLOW_TABLES\r\n#else\r\n#ifdef IDCT_SCALING_SUPPORTED\r\n#define PROVIDE_ISLOW_TABLES\r\n#endif\r\n#endif\r\n\r\n\r\n/*\r\n * Prepare for an output pass.\r\n * Here we select the proper IDCT routine for each component and build\r\n * a matching multiplier table.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass (j_decompress_ptr cinfo)\r\n{\r\n  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;\r\n  int ci, i;\r\n  jpeg_component_info *compptr;\r\n  int method = 0;\r\n  inverse_DCT_method_ptr method_ptr = NULL;\r\n  JQUANT_TBL * qtbl;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Select the proper IDCT routine for this component's scaling */\r\n    switch ((compptr->DCT_h_scaled_size << 8) + compptr->DCT_v_scaled_size) {\r\n#ifdef IDCT_SCALING_SUPPORTED\r\n    case ((1 << 8) + 1):\r\n      method_ptr = jpeg_idct_1x1;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((2 << 8) + 2):\r\n      method_ptr = jpeg_idct_2x2;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((3 << 8) + 3):\r\n      method_ptr = jpeg_idct_3x3;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((4 << 8) + 4):\r\n      method_ptr = jpeg_idct_4x4;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((5 << 8) + 5):\r\n      method_ptr = jpeg_idct_5x5;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((6 << 8) + 6):\r\n      method_ptr = jpeg_idct_6x6;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((7 << 8) + 7):\r\n      method_ptr = jpeg_idct_7x7;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((9 << 8) + 9):\r\n      method_ptr = jpeg_idct_9x9;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((10 << 8) + 10):\r\n      method_ptr = jpeg_idct_10x10;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((11 << 8) + 11):\r\n      method_ptr = jpeg_idct_11x11;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((12 << 8) + 12):\r\n      method_ptr = jpeg_idct_12x12;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((13 << 8) + 13):\r\n      method_ptr = jpeg_idct_13x13;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((14 << 8) + 14):\r\n      method_ptr = jpeg_idct_14x14;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((15 << 8) + 15):\r\n      method_ptr = jpeg_idct_15x15;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((16 << 8) + 16):\r\n      method_ptr = jpeg_idct_16x16;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((16 << 8) + 8):\r\n      method_ptr = jpeg_idct_16x8;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((14 << 8) + 7):\r\n      method_ptr = jpeg_idct_14x7;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((12 << 8) + 6):\r\n      method_ptr = jpeg_idct_12x6;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((10 << 8) + 5):\r\n      method_ptr = jpeg_idct_10x5;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((8 << 8) + 4):\r\n      method_ptr = jpeg_idct_8x4;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((6 << 8) + 3):\r\n      method_ptr = jpeg_idct_6x3;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((4 << 8) + 2):\r\n      method_ptr = jpeg_idct_4x2;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((2 << 8) + 1):\r\n      method_ptr = jpeg_idct_2x1;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((8 << 8) + 16):\r\n      method_ptr = jpeg_idct_8x16;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((7 << 8) + 14):\r\n      method_ptr = jpeg_idct_7x14;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((6 << 8) + 12):\r\n      method_ptr = jpeg_idct_6x12;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((5 << 8) + 10):\r\n      method_ptr = jpeg_idct_5x10;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((4 << 8) + 8):\r\n      method_ptr = jpeg_idct_4x8;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((3 << 8) + 6):\r\n      method_ptr = jpeg_idct_3x6;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((2 << 8) + 4):\r\n      method_ptr = jpeg_idct_2x4;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n    case ((1 << 8) + 2):\r\n      method_ptr = jpeg_idct_1x2;\r\n      method = JDCT_ISLOW;\t/* jidctint uses islow-style table */\r\n      break;\r\n#endif\r\n    case ((DCTSIZE << 8) + DCTSIZE):\r\n      switch (cinfo->dct_method) {\r\n#ifdef DCT_ISLOW_SUPPORTED\r\n      case JDCT_ISLOW:\r\n\tmethod_ptr = jpeg_idct_islow;\r\n\tmethod = JDCT_ISLOW;\r\n\tbreak;\r\n#endif\r\n#ifdef DCT_IFAST_SUPPORTED\r\n      case JDCT_IFAST:\r\n\tmethod_ptr = jpeg_idct_ifast;\r\n\tmethod = JDCT_IFAST;\r\n\tbreak;\r\n#endif\r\n#ifdef DCT_FLOAT_SUPPORTED\r\n      case JDCT_FLOAT:\r\n\tmethod_ptr = jpeg_idct_float;\r\n\tmethod = JDCT_FLOAT;\r\n\tbreak;\r\n#endif\r\n      default:\r\n\tERREXIT(cinfo, JERR_NOT_COMPILED);\r\n\tbreak;\r\n      }\r\n      break;\r\n    default:\r\n      ERREXIT2(cinfo, JERR_BAD_DCTSIZE,\r\n\t       compptr->DCT_h_scaled_size, compptr->DCT_v_scaled_size);\r\n      break;\r\n    }\r\n    idct->pub.inverse_DCT[ci] = method_ptr;\r\n    /* Create multiplier table from quant table.\r\n     * However, we can skip this if the component is uninteresting\r\n     * or if we already built the table.  Also, if no quant table\r\n     * has yet been saved for the component, we leave the\r\n     * multiplier table all-zero; we'll be reading zeroes from the\r\n     * coefficient controller's buffer anyway.\r\n     */\r\n    if (! compptr->component_needed || idct->cur_method[ci] == method)\r\n      continue;\r\n    qtbl = compptr->quant_table;\r\n    if (qtbl == NULL)\t\t/* happens if no data yet for component */\r\n      continue;\r\n    idct->cur_method[ci] = method;\r\n    switch (method) {\r\n#ifdef PROVIDE_ISLOW_TABLES\r\n    case JDCT_ISLOW:\r\n      {\r\n\t/* For LL&M IDCT method, multipliers are equal to raw quantization\r\n\t * coefficients, but are stored as ints to ensure access efficiency.\r\n\t */\r\n\tISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n\tfor (i = 0; i < DCTSIZE2; i++) {\r\n\t  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];\r\n\t}\r\n      }\r\n      break;\r\n#endif\r\n#ifdef DCT_IFAST_SUPPORTED\r\n    case JDCT_IFAST:\r\n      {\r\n\t/* For AA&N IDCT method, multipliers are equal to quantization\r\n\t * coefficients scaled by scalefactor[row]*scalefactor[col], where\r\n\t *   scalefactor[0] = 1\r\n\t *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\r\n\t * For integer operation, the multiplier table is to be scaled by\r\n\t * IFAST_SCALE_BITS.\r\n\t */\r\n\tIFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;\r\n#define CONST_BITS 14\r\n\tstatic const INT16 aanscales[DCTSIZE2] = {\r\n\t  /* precomputed values scaled up by 14 bits */\r\n\t  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\r\n\t  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,\r\n\t  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,\r\n\t  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,\r\n\t  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\r\n\t  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,\r\n\t   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,\r\n\t   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247\r\n\t};\r\n\tSHIFT_TEMPS\r\n\r\n\tfor (i = 0; i < DCTSIZE2; i++) {\r\n\t  ifmtbl[i] = (IFAST_MULT_TYPE)\r\n\t    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],\r\n\t\t\t\t  (INT32) aanscales[i]),\r\n\t\t    CONST_BITS-IFAST_SCALE_BITS);\r\n\t}\r\n      }\r\n      break;\r\n#endif\r\n#ifdef DCT_FLOAT_SUPPORTED\r\n    case JDCT_FLOAT:\r\n      {\r\n\t/* For float AA&N IDCT method, multipliers are equal to quantization\r\n\t * coefficients scaled by scalefactor[row]*scalefactor[col], where\r\n\t *   scalefactor[0] = 1\r\n\t *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\r\n\t * We apply a further scale factor of 1/8.\r\n\t */\r\n\tFLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;\r\n\tint row, col;\r\n\tstatic const double aanscalefactor[DCTSIZE] = {\r\n\t  1.0, 1.387039845, 1.306562965, 1.175875602,\r\n\t  1.0, 0.785694958, 0.541196100, 0.275899379\r\n\t};\r\n\r\n\ti = 0;\r\n\tfor (row = 0; row < DCTSIZE; row++) {\r\n\t  for (col = 0; col < DCTSIZE; col++) {\r\n\t    fmtbl[i] = (FLOAT_MULT_TYPE)\r\n\t      ((double) qtbl->quantval[i] *\r\n\t       aanscalefactor[row] * aanscalefactor[col] * 0.125);\r\n\t    i++;\r\n\t  }\r\n\t}\r\n      }\r\n      break;\r\n#endif\r\n    default:\r\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Initialize IDCT manager.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_inverse_dct (j_decompress_ptr cinfo)\r\n{\r\n  my_idct_ptr idct;\r\n  int ci;\r\n  jpeg_component_info *compptr;\r\n\r\n  idct = (my_idct_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_idct_controller));\r\n  cinfo->idct = &idct->pub;\r\n  idct->pub.start_pass = start_pass;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Allocate and pre-zero a multiplier table for each component */\r\n    compptr->dct_table =\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  SIZEOF(multiplier_table));\r\n    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));\r\n    /* Mark multiplier table not yet set up for any method */\r\n    idct->cur_method[ci] = -1;\r\n  }\r\n}\r\n","/*\r\n * jdhuff.c\r\n *\r\n * Copyright (C) 1991-1997, Thomas G. Lane.\r\n * Modified 2006-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains Huffman entropy decoding routines.\r\n * Both sequential and progressive modes are supported in this single module.\r\n *\r\n * Much of the complexity here has to do with supporting input suspension.\r\n * If the data source module demands suspension, we want to be able to back\r\n * up to the start of the current MCU.  To do this, we copy state variables\r\n * into local working storage, and update them back to the permanent\r\n * storage only upon successful completion of an MCU.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Derived data constructed for each Huffman table */\r\n\r\n#define HUFF_LOOKAHEAD\t8\t/* # of bits of lookahead */\r\n\r\ntypedef struct {\r\n  /* Basic tables: (element [0] of each array is unused) */\r\n  INT32 maxcode[18];\t\t/* largest code of length k (-1 if none) */\r\n  /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */\r\n  INT32 valoffset[17];\t\t/* huffval[] offset for codes of length k */\r\n  /* valoffset[k] = huffval[] index of 1st symbol of code length k, less\r\n   * the smallest code of length k; so given a code of length k, the\r\n   * corresponding symbol is huffval[code + valoffset[k]]\r\n   */\r\n\r\n  /* Link to public Huffman table (needed only in jpeg_huff_decode) */\r\n  JHUFF_TBL *pub;\r\n\r\n  /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of\r\n   * the input data stream.  If the next Huffman code is no more\r\n   * than HUFF_LOOKAHEAD bits long, we can obtain its length and\r\n   * the corresponding symbol directly from these tables.\r\n   */\r\n  int look_nbits[1<<HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */\r\n  UINT8 look_sym[1<<HUFF_LOOKAHEAD]; /* symbol, or unused */\r\n} d_derived_tbl;\r\n\r\n\r\n/*\r\n * Fetching the next N bits from the input stream is a time-critical operation\r\n * for the Huffman decoders.  We implement it with a combination of inline\r\n * macros and out-of-line subroutines.  Note that N (the number of bits\r\n * demanded at one time) never exceeds 15 for JPEG use.\r\n *\r\n * We read source bytes into get_buffer and dole out bits as needed.\r\n * If get_buffer already contains enough bits, they are fetched in-line\r\n * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough\r\n * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer\r\n * as full as possible (not just to the number of bits needed; this\r\n * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).\r\n * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.\r\n * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains\r\n * at least the requested number of bits --- dummy zeroes are inserted if\r\n * necessary.\r\n */\r\n\r\ntypedef INT32 bit_buf_type;\t/* type of bit-extraction buffer */\r\n#define BIT_BUF_SIZE  32\t/* size of buffer in bits */\r\n\r\n/* If long is > 32 bits on your machine, and shifting/masking longs is\r\n * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE\r\n * appropriately should be a win.  Unfortunately we can't define the size\r\n * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)\r\n * because not all machines measure sizeof in 8-bit bytes.\r\n */\r\n\r\ntypedef struct {\t\t/* Bitreading state saved across MCUs */\r\n  bit_buf_type get_buffer;\t/* current bit-extraction buffer */\r\n  int bits_left;\t\t/* # of unused bits in it */\r\n} bitread_perm_state;\r\n\r\ntypedef struct {\t\t/* Bitreading working state within an MCU */\r\n  /* Current data source location */\r\n  /* We need a copy, rather than munging the original, in case of suspension */\r\n  const JOCTET * next_input_byte; /* => next byte to read from source */\r\n  size_t bytes_in_buffer;\t/* # of bytes remaining in source buffer */\r\n  /* Bit input buffer --- note these values are kept in register variables,\r\n   * not in this struct, inside the inner loops.\r\n   */\r\n  bit_buf_type get_buffer;\t/* current bit-extraction buffer */\r\n  int bits_left;\t\t/* # of unused bits in it */\r\n  /* Pointer needed by jpeg_fill_bit_buffer. */\r\n  j_decompress_ptr cinfo;\t/* back link to decompress master record */\r\n} bitread_working_state;\r\n\r\n/* Macros to declare and load/save bitread local variables. */\r\n#define BITREAD_STATE_VARS  \\\r\n\tregister bit_buf_type get_buffer;  \\\r\n\tregister int bits_left;  \\\r\n\tbitread_working_state br_state\r\n\r\n#define BITREAD_LOAD_STATE(cinfop,permstate)  \\\r\n\tbr_state.cinfo = cinfop; \\\r\n\tbr_state.next_input_byte = cinfop->src->next_input_byte; \\\r\n\tbr_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \\\r\n\tget_buffer = permstate.get_buffer; \\\r\n\tbits_left = permstate.bits_left;\r\n\r\n#define BITREAD_SAVE_STATE(cinfop,permstate)  \\\r\n\tcinfop->src->next_input_byte = br_state.next_input_byte; \\\r\n\tcinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \\\r\n\tpermstate.get_buffer = get_buffer; \\\r\n\tpermstate.bits_left = bits_left\r\n\r\n/*\r\n * These macros provide the in-line portion of bit fetching.\r\n * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer\r\n * before using GET_BITS, PEEK_BITS, or DROP_BITS.\r\n * The variables get_buffer and bits_left are assumed to be locals,\r\n * but the state struct might not be (jpeg_huff_decode needs this).\r\n *\tCHECK_BIT_BUFFER(state,n,action);\r\n *\t\tEnsure there are N bits in get_buffer; if suspend, take action.\r\n *      val = GET_BITS(n);\r\n *\t\tFetch next N bits.\r\n *      val = PEEK_BITS(n);\r\n *\t\tFetch next N bits without removing them from the buffer.\r\n *\tDROP_BITS(n);\r\n *\t\tDiscard next N bits.\r\n * The value N should be a simple variable, not an expression, because it\r\n * is evaluated multiple times.\r\n */\r\n\r\n#define CHECK_BIT_BUFFER(state,nbits,action) \\\r\n\t{ if (bits_left < (nbits)) {  \\\r\n\t    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \\\r\n\t      { action; }  \\\r\n\t    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }\r\n\r\n#define GET_BITS(nbits) \\\r\n\t(((int) (get_buffer >> (bits_left -= (nbits)))) & BIT_MASK(nbits))\r\n\r\n#define PEEK_BITS(nbits) \\\r\n\t(((int) (get_buffer >> (bits_left -  (nbits)))) & BIT_MASK(nbits))\r\n\r\n#define DROP_BITS(nbits) \\\r\n\t(bits_left -= (nbits))\r\n\r\n\r\n/*\r\n * Code for extracting next Huffman-coded symbol from input bit stream.\r\n * Again, this is time-critical and we make the main paths be macros.\r\n *\r\n * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits\r\n * without looping.  Usually, more than 95% of the Huffman codes will be 8\r\n * or fewer bits long.  The few overlength codes are handled with a loop,\r\n * which need not be inline code.\r\n *\r\n * Notes about the HUFF_DECODE macro:\r\n * 1. Near the end of the data segment, we may fail to get enough bits\r\n *    for a lookahead.  In that case, we do it the hard way.\r\n * 2. If the lookahead table contains no entry, the next code must be\r\n *    more than HUFF_LOOKAHEAD bits long.\r\n * 3. jpeg_huff_decode returns -1 if forced to suspend.\r\n */\r\n\r\n#define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \\\r\n{ register int nb, look; \\\r\n  if (bits_left < HUFF_LOOKAHEAD) { \\\r\n    if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \\\r\n    get_buffer = state.get_buffer; bits_left = state.bits_left; \\\r\n    if (bits_left < HUFF_LOOKAHEAD) { \\\r\n      nb = 1; goto slowlabel; \\\r\n    } \\\r\n  } \\\r\n  look = PEEK_BITS(HUFF_LOOKAHEAD); \\\r\n  if ((nb = htbl->look_nbits[look]) != 0) { \\\r\n    DROP_BITS(nb); \\\r\n    result = htbl->look_sym[look]; \\\r\n  } else { \\\r\n    nb = HUFF_LOOKAHEAD+1; \\\r\nslowlabel: \\\r\n    if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \\\r\n\t{ failaction; } \\\r\n    get_buffer = state.get_buffer; bits_left = state.bits_left; \\\r\n  } \\\r\n}\r\n\r\n\r\n/*\r\n * Expanded entropy decoder object for Huffman decoding.\r\n *\r\n * The savable_state subrecord contains fields that change within an MCU,\r\n * but must not be updated permanently until we complete the MCU.\r\n */\r\n\r\ntypedef struct {\r\n  unsigned int EOBRUN;\t\t\t/* remaining EOBs in EOBRUN */\r\n  int last_dc_val[MAX_COMPS_IN_SCAN];\t/* last DC coef for each component */\r\n} savable_state;\r\n\r\n/* This macro is to work around compilers with missing or broken\r\n * structure assignment.  You'll need to fix this code if you have\r\n * such a compiler and you change MAX_COMPS_IN_SCAN.\r\n */\r\n\r\n#ifndef NO_STRUCT_ASSIGN\r\n#define ASSIGN_STATE(dest,src)  ((dest) = (src))\r\n#else\r\n#if MAX_COMPS_IN_SCAN == 4\r\n#define ASSIGN_STATE(dest,src)  \\\r\n\t((dest).EOBRUN = (src).EOBRUN, \\\r\n\t (dest).last_dc_val[0] = (src).last_dc_val[0], \\\r\n\t (dest).last_dc_val[1] = (src).last_dc_val[1], \\\r\n\t (dest).last_dc_val[2] = (src).last_dc_val[2], \\\r\n\t (dest).last_dc_val[3] = (src).last_dc_val[3])\r\n#endif\r\n#endif\r\n\r\n\r\ntypedef struct {\r\n  struct jpeg_entropy_decoder pub; /* public fields */\r\n\r\n  /* These fields are loaded into local variables at start of each MCU.\r\n   * In case of suspension, we exit WITHOUT updating them.\r\n   */\r\n  bitread_perm_state bitstate;\t/* Bit buffer at start of MCU */\r\n  savable_state saved;\t\t/* Other state at start of MCU */\r\n\r\n  /* These fields are NOT loaded into local working state. */\r\n  boolean insufficient_data;\t/* set TRUE after emitting warning */\r\n  unsigned int restarts_to_go;\t/* MCUs left in this restart interval */\r\n\r\n  /* Following two fields used only in progressive mode */\r\n\r\n  /* Pointers to derived tables (these workspaces have image lifespan) */\r\n  d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];\r\n\r\n  d_derived_tbl * ac_derived_tbl; /* active table during an AC scan */\r\n\r\n  /* Following fields used only in sequential mode */\r\n\r\n  /* Pointers to derived tables (these workspaces have image lifespan) */\r\n  d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];\r\n  d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];\r\n\r\n  /* Precalculated info set up by start_pass for use in decode_mcu: */\r\n\r\n  /* Pointers to derived tables to be used for each block within an MCU */\r\n  d_derived_tbl * dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];\r\n  d_derived_tbl * ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];\r\n  /* Whether we care about the DC and AC coefficient values for each block */\r\n  int coef_limit[D_MAX_BLOCKS_IN_MCU];\r\n} huff_entropy_decoder;\r\n\r\ntypedef huff_entropy_decoder * huff_entropy_ptr;\r\n\r\n\r\nstatic const int jpeg_zigzag_order[8][8] = {\r\n  {  0,  1,  5,  6, 14, 15, 27, 28 },\r\n  {  2,  4,  7, 13, 16, 26, 29, 42 },\r\n  {  3,  8, 12, 17, 25, 30, 41, 43 },\r\n  {  9, 11, 18, 24, 31, 40, 44, 53 },\r\n  { 10, 19, 23, 32, 39, 45, 52, 54 },\r\n  { 20, 22, 33, 38, 46, 51, 55, 60 },\r\n  { 21, 34, 37, 47, 50, 56, 59, 61 },\r\n  { 35, 36, 48, 49, 57, 58, 62, 63 }\r\n};\r\n\r\nstatic const int jpeg_zigzag_order7[7][7] = {\r\n  {  0,  1,  5,  6, 14, 15, 27 },\r\n  {  2,  4,  7, 13, 16, 26, 28 },\r\n  {  3,  8, 12, 17, 25, 29, 38 },\r\n  {  9, 11, 18, 24, 30, 37, 39 },\r\n  { 10, 19, 23, 31, 36, 40, 45 },\r\n  { 20, 22, 32, 35, 41, 44, 46 },\r\n  { 21, 33, 34, 42, 43, 47, 48 }\r\n};\r\n\r\nstatic const int jpeg_zigzag_order6[6][6] = {\r\n  {  0,  1,  5,  6, 14, 15 },\r\n  {  2,  4,  7, 13, 16, 25 },\r\n  {  3,  8, 12, 17, 24, 26 },\r\n  {  9, 11, 18, 23, 27, 32 },\r\n  { 10, 19, 22, 28, 31, 33 },\r\n  { 20, 21, 29, 30, 34, 35 }\r\n};\r\n\r\nstatic const int jpeg_zigzag_order5[5][5] = {\r\n  {  0,  1,  5,  6, 14 },\r\n  {  2,  4,  7, 13, 15 },\r\n  {  3,  8, 12, 16, 21 },\r\n  {  9, 11, 17, 20, 22 },\r\n  { 10, 18, 19, 23, 24 }\r\n};\r\n\r\nstatic const int jpeg_zigzag_order4[4][4] = {\r\n  { 0,  1,  5,  6 },\r\n  { 2,  4,  7, 12 },\r\n  { 3,  8, 11, 13 },\r\n  { 9, 10, 14, 15 }\r\n};\r\n\r\nstatic const int jpeg_zigzag_order3[3][3] = {\r\n  { 0, 1, 5 },\r\n  { 2, 4, 6 },\r\n  { 3, 7, 8 }\r\n};\r\n\r\nstatic const int jpeg_zigzag_order2[2][2] = {\r\n  { 0, 1 },\r\n  { 2, 3 }\r\n};\r\n\r\n\r\n/*\r\n * Compute the derived values for a Huffman table.\r\n * This routine also performs some validation checks on the table.\r\n */\r\n\r\nLOCAL(void)\r\njpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,\r\n\t\t\t d_derived_tbl ** pdtbl)\r\n{\r\n  JHUFF_TBL *htbl;\r\n  d_derived_tbl *dtbl;\r\n  int p, i, l, si, numsymbols;\r\n  int lookbits, ctr;\r\n  char huffsize[257];\r\n  unsigned int huffcode[257];\r\n  unsigned int code;\r\n\r\n  /* Note that huffsize[] and huffcode[] are filled in code-length order,\r\n   * paralleling the order of the symbols themselves in htbl->huffval[].\r\n   */\r\n\r\n  /* Find the input Huffman table */\r\n  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)\r\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\r\n  htbl =\r\n    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];\r\n  if (htbl == NULL)\r\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\r\n\r\n  /* Allocate a workspace if we haven't already done so. */\r\n  if (*pdtbl == NULL)\r\n    *pdtbl = (d_derived_tbl *)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  SIZEOF(d_derived_tbl));\r\n  dtbl = *pdtbl;\r\n  dtbl->pub = htbl;\t\t/* fill in back link */\r\n  \r\n  /* Figure C.1: make table of Huffman code length for each symbol */\r\n\r\n  p = 0;\r\n  for (l = 1; l <= 16; l++) {\r\n    i = (int) htbl->bits[l];\r\n    if (i < 0 || p + i > 256)\t/* protect against table overrun */\r\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\r\n    while (i--)\r\n      huffsize[p++] = (char) l;\r\n  }\r\n  huffsize[p] = 0;\r\n  numsymbols = p;\r\n  \r\n  /* Figure C.2: generate the codes themselves */\r\n  /* We also validate that the counts represent a legal Huffman code tree. */\r\n  \r\n  code = 0;\r\n  si = huffsize[0];\r\n  p = 0;\r\n  while (huffsize[p]) {\r\n    while (((int) huffsize[p]) == si) {\r\n      huffcode[p++] = code;\r\n      code++;\r\n    }\r\n    /* code is now 1 more than the last code used for codelength si; but\r\n     * it must still fit in si bits, since no code is allowed to be all ones.\r\n     */\r\n    if (((INT32) code) >= (((INT32) 1) << si))\r\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\r\n    code <<= 1;\r\n    si++;\r\n  }\r\n\r\n  /* Figure F.15: generate decoding tables for bit-sequential decoding */\r\n\r\n  p = 0;\r\n  for (l = 1; l <= 16; l++) {\r\n    if (htbl->bits[l]) {\r\n      /* valoffset[l] = huffval[] index of 1st symbol of code length l,\r\n       * minus the minimum code of length l\r\n       */\r\n      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];\r\n      p += htbl->bits[l];\r\n      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */\r\n    } else {\r\n      dtbl->maxcode[l] = -1;\t/* -1 if no codes of this length */\r\n    }\r\n  }\r\n  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */\r\n\r\n  /* Compute lookahead tables to speed up decoding.\r\n   * First we set all the table entries to 0, indicating \"too long\";\r\n   * then we iterate through the Huffman codes that are short enough and\r\n   * fill in all the entries that correspond to bit sequences starting\r\n   * with that code.\r\n   */\r\n\r\n  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));\r\n\r\n  p = 0;\r\n  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {\r\n    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {\r\n      /* l = current code's length, p = its index in huffcode[] & huffval[]. */\r\n      /* Generate left-justified code followed by all possible bit sequences */\r\n      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);\r\n      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {\r\n\tdtbl->look_nbits[lookbits] = l;\r\n\tdtbl->look_sym[lookbits] = htbl->huffval[p];\r\n\tlookbits++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Validate symbols as being reasonable.\r\n   * For AC tables, we make no check, but accept all byte values 0..255.\r\n   * For DC tables, we require the symbols to be in range 0..15.\r\n   * (Tighter bounds could be applied depending on the data depth and mode,\r\n   * but this is sufficient to ensure safe decoding.)\r\n   */\r\n  if (isDC) {\r\n    for (i = 0; i < numsymbols; i++) {\r\n      int sym = htbl->huffval[i];\r\n      if (sym < 0 || sym > 15)\r\n\tERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Out-of-line code for bit fetching.\r\n * Note: current values of get_buffer and bits_left are passed as parameters,\r\n * but are returned in the corresponding fields of the state struct.\r\n *\r\n * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width\r\n * of get_buffer to be used.  (On machines with wider words, an even larger\r\n * buffer could be used.)  However, on some machines 32-bit shifts are\r\n * quite slow and take time proportional to the number of places shifted.\r\n * (This is true with most PC compilers, for instance.)  In this case it may\r\n * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the\r\n * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.\r\n */\r\n\r\n#ifdef SLOW_SHIFT_32\r\n#define MIN_GET_BITS  15\t/* minimum allowable value */\r\n#else\r\n#define MIN_GET_BITS  (BIT_BUF_SIZE-7)\r\n#endif\r\n\r\n\r\nLOCAL(boolean)\r\njpeg_fill_bit_buffer (bitread_working_state * state,\r\n\t\t      register bit_buf_type get_buffer, register int bits_left,\r\n\t\t      int nbits)\r\n/* Load up the bit buffer to a depth of at least nbits */\r\n{\r\n  /* Copy heavily used state fields into locals (hopefully registers) */\r\n  register const JOCTET * next_input_byte = state->next_input_byte;\r\n  register size_t bytes_in_buffer = state->bytes_in_buffer;\r\n  j_decompress_ptr cinfo = state->cinfo;\r\n\r\n  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */\r\n  /* (It is assumed that no request will be for more than that many bits.) */\r\n  /* We fail to do so only if we hit a marker or are forced to suspend. */\r\n\r\n  if (cinfo->unread_marker == 0) {\t/* cannot advance past a marker */\r\n    while (bits_left < MIN_GET_BITS) {\r\n      register int c;\r\n\r\n      /* Attempt to read a byte */\r\n      if (bytes_in_buffer == 0) {\r\n\tif (! (*cinfo->src->fill_input_buffer) (cinfo))\r\n\t  return FALSE;\r\n\tnext_input_byte = cinfo->src->next_input_byte;\r\n\tbytes_in_buffer = cinfo->src->bytes_in_buffer;\r\n      }\r\n      bytes_in_buffer--;\r\n      c = GETJOCTET(*next_input_byte++);\r\n\r\n      /* If it's 0xFF, check and discard stuffed zero byte */\r\n      if (c == 0xFF) {\r\n\t/* Loop here to discard any padding FF's on terminating marker,\r\n\t * so that we can save a valid unread_marker value.  NOTE: we will\r\n\t * accept multiple FF's followed by a 0 as meaning a single FF data\r\n\t * byte.  This data pattern is not valid according to the standard.\r\n\t */\r\n\tdo {\r\n\t  if (bytes_in_buffer == 0) {\r\n\t    if (! (*cinfo->src->fill_input_buffer) (cinfo))\r\n\t      return FALSE;\r\n\t    next_input_byte = cinfo->src->next_input_byte;\r\n\t    bytes_in_buffer = cinfo->src->bytes_in_buffer;\r\n\t  }\r\n\t  bytes_in_buffer--;\r\n\t  c = GETJOCTET(*next_input_byte++);\r\n\t} while (c == 0xFF);\r\n\r\n\tif (c == 0) {\r\n\t  /* Found FF/00, which represents an FF data byte */\r\n\t  c = 0xFF;\r\n\t} else {\r\n\t  /* Oops, it's actually a marker indicating end of compressed data.\r\n\t   * Save the marker code for later use.\r\n\t   * Fine point: it might appear that we should save the marker into\r\n\t   * bitread working state, not straight into permanent state.  But\r\n\t   * once we have hit a marker, we cannot need to suspend within the\r\n\t   * current MCU, because we will read no more bytes from the data\r\n\t   * source.  So it is OK to update permanent state right away.\r\n\t   */\r\n\t  cinfo->unread_marker = c;\r\n\t  /* See if we need to insert some fake zero bits. */\r\n\t  goto no_more_bytes;\r\n\t}\r\n      }\r\n\r\n      /* OK, load c into get_buffer */\r\n      get_buffer = (get_buffer << 8) | c;\r\n      bits_left += 8;\r\n    } /* end while */\r\n  } else {\r\n  no_more_bytes:\r\n    /* We get here if we've read the marker that terminates the compressed\r\n     * data segment.  There should be enough bits in the buffer register\r\n     * to satisfy the request; if so, no problem.\r\n     */\r\n    if (nbits > bits_left) {\r\n      /* Uh-oh.  Report corrupted data to user and stuff zeroes into\r\n       * the data stream, so that we can produce some kind of image.\r\n       * We use a nonvolatile flag to ensure that only one warning message\r\n       * appears per data segment.\r\n       */\r\n      if (! ((huff_entropy_ptr) cinfo->entropy)->insufficient_data) {\r\n\tWARNMS(cinfo, JWRN_HIT_MARKER);\r\n\t((huff_entropy_ptr) cinfo->entropy)->insufficient_data = TRUE;\r\n      }\r\n      /* Fill the buffer with zero bits */\r\n      get_buffer <<= MIN_GET_BITS - bits_left;\r\n      bits_left = MIN_GET_BITS;\r\n    }\r\n  }\r\n\r\n  /* Unload the local registers */\r\n  state->next_input_byte = next_input_byte;\r\n  state->bytes_in_buffer = bytes_in_buffer;\r\n  state->get_buffer = get_buffer;\r\n  state->bits_left = bits_left;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Figure F.12: extend sign bit.\r\n * On some machines, a shift and sub will be faster than a table lookup.\r\n */\r\n\r\n#ifdef AVOID_TABLES\r\n\r\n#define BIT_MASK(nbits)   ((1<<(nbits))-1)\r\n#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) - ((1<<(s))-1) : (x))\r\n\r\n#else\r\n\r\n#define BIT_MASK(nbits)   bmask[nbits]\r\n#define HUFF_EXTEND(x,s)  ((x) <= bmask[(s) - 1] ? (x) - bmask[s] : (x))\r\n\r\nstatic const int bmask[16] =\t/* bmask[n] is mask for n rightmost bits */\r\n  { 0, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,\r\n    0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF };\r\n\r\n#endif /* AVOID_TABLES */\r\n\r\n\r\n/*\r\n * Out-of-line code for Huffman code decoding.\r\n */\r\n\r\nLOCAL(int)\r\njpeg_huff_decode (bitread_working_state * state,\r\n\t\t  register bit_buf_type get_buffer, register int bits_left,\r\n\t\t  d_derived_tbl * htbl, int min_bits)\r\n{\r\n  register int l = min_bits;\r\n  register INT32 code;\r\n\r\n  /* HUFF_DECODE has determined that the code is at least min_bits */\r\n  /* bits long, so fetch that many bits in one swoop. */\r\n\r\n  CHECK_BIT_BUFFER(*state, l, return -1);\r\n  code = GET_BITS(l);\r\n\r\n  /* Collect the rest of the Huffman code one bit at a time. */\r\n  /* This is per Figure F.16 in the JPEG spec. */\r\n\r\n  while (code > htbl->maxcode[l]) {\r\n    code <<= 1;\r\n    CHECK_BIT_BUFFER(*state, 1, return -1);\r\n    code |= GET_BITS(1);\r\n    l++;\r\n  }\r\n\r\n  /* Unload the local registers */\r\n  state->get_buffer = get_buffer;\r\n  state->bits_left = bits_left;\r\n\r\n  /* With garbage input we may reach the sentinel value l = 17. */\r\n\r\n  if (l > 16) {\r\n    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);\r\n    return 0;\t\t\t/* fake a zero as the safest result */\r\n  }\r\n\r\n  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];\r\n}\r\n\r\n\r\n/*\r\n * Finish up at the end of a Huffman-compressed scan.\r\n */\r\n\r\nMETHODDEF(void)\r\nfinish_pass_huff (j_decompress_ptr cinfo)\r\n{\r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n\r\n  /* Throw away any unused bits remaining in bit buffer; */\r\n  /* include any full bytes in next_marker's count of discarded bytes */\r\n  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;\r\n  entropy->bitstate.bits_left = 0;\r\n}\r\n\r\n\r\n/*\r\n * Check for a restart marker & resynchronize decoder.\r\n * Returns FALSE if must suspend.\r\n */\r\n\r\nLOCAL(boolean)\r\nprocess_restart (j_decompress_ptr cinfo)\r\n{\r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  int ci;\r\n\r\n  finish_pass_huff(cinfo);\r\n\r\n  /* Advance past the RSTn marker */\r\n  if (! (*cinfo->marker->read_restart_marker) (cinfo))\r\n    return FALSE;\r\n\r\n  /* Re-initialize DC predictions to 0 */\r\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++)\r\n    entropy->saved.last_dc_val[ci] = 0;\r\n  /* Re-init EOB run count, too */\r\n  entropy->saved.EOBRUN = 0;\r\n\r\n  /* Reset restart counter */\r\n  entropy->restarts_to_go = cinfo->restart_interval;\r\n\r\n  /* Reset out-of-data flag, unless read_restart_marker left us smack up\r\n   * against a marker.  In that case we will end up treating the next data\r\n   * segment as empty, and we can avoid producing bogus output pixels by\r\n   * leaving the flag set.\r\n   */\r\n  if (cinfo->unread_marker == 0)\r\n    entropy->insufficient_data = FALSE;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Huffman MCU decoding.\r\n * Each of these routines decodes and returns one MCU's worth of\r\n * Huffman-compressed coefficients. \r\n * The coefficients are reordered from zigzag order into natural array order,\r\n * but are not dequantized.\r\n *\r\n * The i'th block of the MCU is stored into the block pointed to by\r\n * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.\r\n * (Wholesale zeroing is usually a little faster than retail...)\r\n *\r\n * We return FALSE if data source requested suspension.  In that case no\r\n * changes have been made to permanent state.  (Exception: some output\r\n * coefficients may already have been assigned.  This is harmless for\r\n * spectral selection, since we'll just re-assign them on the next call.\r\n * Successive approximation AC refinement has to be more careful, however.)\r\n */\r\n\r\n/*\r\n * MCU decoding for DC initial scan (either spectral selection,\r\n * or first pass of successive approximation).\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{   \r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  int Al = cinfo->Al;\r\n  register int s, r;\r\n  int blkn, ci;\r\n  JBLOCKROW block;\r\n  BITREAD_STATE_VARS;\r\n  savable_state state;\r\n  d_derived_tbl * tbl;\r\n  jpeg_component_info * compptr;\r\n\r\n  /* Process restart marker if needed; may have to suspend */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      if (! process_restart(cinfo))\r\n\treturn FALSE;\r\n  }\r\n\r\n  /* If we've run out of data, just leave the MCU set to zeroes.\r\n   * This way, we return uniform gray for the remainder of the segment.\r\n   */\r\n  if (! entropy->insufficient_data) {\r\n\r\n    /* Load up working state */\r\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\r\n    ASSIGN_STATE(state, entropy->saved);\r\n\r\n    /* Outer loop handles each block in the MCU */\r\n\r\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n      block = MCU_data[blkn];\r\n      ci = cinfo->MCU_membership[blkn];\r\n      compptr = cinfo->cur_comp_info[ci];\r\n      tbl = entropy->derived_tbls[compptr->dc_tbl_no];\r\n\r\n      /* Decode a single block's worth of coefficients */\r\n\r\n      /* Section F.2.2.1: decode the DC coefficient difference */\r\n      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);\r\n      if (s) {\r\n\tCHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\tr = GET_BITS(s);\r\n\ts = HUFF_EXTEND(r, s);\r\n      }\r\n\r\n      /* Convert DC difference to actual value, update last_dc_val */\r\n      s += state.last_dc_val[ci];\r\n      state.last_dc_val[ci] = s;\r\n      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */\r\n      (*block)[0] = (JCOEF) (s << Al);\r\n    }\r\n\r\n    /* Completed MCU, so update state */\r\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\r\n    ASSIGN_STATE(entropy->saved, state);\r\n  }\r\n\r\n  /* Account for restart interval (no-op if not using restarts) */\r\n  entropy->restarts_to_go--;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * MCU decoding for AC initial scan (either spectral selection,\r\n * or first pass of successive approximation).\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{   \r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  register int s, k, r;\r\n  unsigned int EOBRUN;\r\n  int Se, Al;\r\n  const int * natural_order;\r\n  JBLOCKROW block;\r\n  BITREAD_STATE_VARS;\r\n  d_derived_tbl * tbl;\r\n\r\n  /* Process restart marker if needed; may have to suspend */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      if (! process_restart(cinfo))\r\n\treturn FALSE;\r\n  }\r\n\r\n  /* If we've run out of data, just leave the MCU set to zeroes.\r\n   * This way, we return uniform gray for the remainder of the segment.\r\n   */\r\n  if (! entropy->insufficient_data) {\r\n\r\n    Se = cinfo->Se;\r\n    Al = cinfo->Al;\r\n    natural_order = cinfo->natural_order;\r\n\r\n    /* Load up working state.\r\n     * We can avoid loading/saving bitread state if in an EOB run.\r\n     */\r\n    EOBRUN = entropy->saved.EOBRUN;\t/* only part of saved state we need */\r\n\r\n    /* There is always only one block per MCU */\r\n\r\n    if (EOBRUN)\t\t\t/* if it's a band of zeroes... */\r\n      EOBRUN--;\t\t\t/* ...process it now (we do nothing) */\r\n    else {\r\n      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\r\n      block = MCU_data[0];\r\n      tbl = entropy->ac_derived_tbl;\r\n\r\n      for (k = cinfo->Ss; k <= Se; k++) {\r\n\tHUFF_DECODE(s, br_state, tbl, return FALSE, label2);\r\n\tr = s >> 4;\r\n\ts &= 15;\r\n\tif (s) {\r\n\t  k += r;\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  r = GET_BITS(s);\r\n\t  s = HUFF_EXTEND(r, s);\r\n\t  /* Scale and output coefficient in natural (dezigzagged) order */\r\n\t  (*block)[natural_order[k]] = (JCOEF) (s << Al);\r\n\t} else {\r\n\t  if (r != 15) {\t/* EOBr, run length is 2^r + appended bits */\r\n\t    if (r) {\t\t/* EOBr, r > 0 */\r\n\t      EOBRUN = 1 << r;\r\n\t      CHECK_BIT_BUFFER(br_state, r, return FALSE);\r\n\t      r = GET_BITS(r);\r\n\t      EOBRUN += r;\r\n\t      EOBRUN--;\t\t/* this band is processed at this moment */\r\n\t    }\r\n\t    break;\t\t/* force end-of-band */\r\n\t  }\r\n\t  k += 15;\t\t/* ZRL: skip 15 zeroes in band */\r\n\t}\r\n      }\r\n\r\n      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\r\n    }\r\n\r\n    /* Completed MCU, so update state */\r\n    entropy->saved.EOBRUN = EOBRUN;\t/* only part of saved state we need */\r\n  }\r\n\r\n  /* Account for restart interval (no-op if not using restarts) */\r\n  entropy->restarts_to_go--;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * MCU decoding for DC successive approximation refinement scan.\r\n * Note: we assume such scans can be multi-component,\r\n * although the spec is not very clear on the point.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{   \r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  int p1, blkn;\r\n  BITREAD_STATE_VARS;\r\n\r\n  /* Process restart marker if needed; may have to suspend */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      if (! process_restart(cinfo))\r\n\treturn FALSE;\r\n  }\r\n\r\n  /* Not worth the cycles to check insufficient_data here,\r\n   * since we will not change the data anyway if we read zeroes.\r\n   */\r\n\r\n  /* Load up working state */\r\n  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\r\n\r\n  p1 = 1 << cinfo->Al;\t\t/* 1 in the bit position being coded */\r\n\r\n  /* Outer loop handles each block in the MCU */\r\n\r\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n    /* Encoded data is simply the next bit of the two's-complement DC value */\r\n    CHECK_BIT_BUFFER(br_state, 1, return FALSE);\r\n    if (GET_BITS(1))\r\n      MCU_data[blkn][0][0] |= p1;\r\n    /* Note: since we use |=, repeating the assignment later is safe */\r\n  }\r\n\r\n  /* Completed MCU, so update state */\r\n  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\r\n\r\n  /* Account for restart interval (no-op if not using restarts) */\r\n  entropy->restarts_to_go--;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * MCU decoding for AC successive approximation refinement scan.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{   \r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  register int s, k, r;\r\n  unsigned int EOBRUN;\r\n  int Se, p1, m1;\r\n  const int * natural_order;\r\n  JBLOCKROW block;\r\n  JCOEFPTR thiscoef;\r\n  BITREAD_STATE_VARS;\r\n  d_derived_tbl * tbl;\r\n  int num_newnz;\r\n  int newnz_pos[DCTSIZE2];\r\n\r\n  /* Process restart marker if needed; may have to suspend */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      if (! process_restart(cinfo))\r\n\treturn FALSE;\r\n  }\r\n\r\n  /* If we've run out of data, don't modify the MCU.\r\n   */\r\n  if (! entropy->insufficient_data) {\r\n\r\n    Se = cinfo->Se;\r\n    p1 = 1 << cinfo->Al;\t/* 1 in the bit position being coded */\r\n    m1 = (-1) << cinfo->Al;\t/* -1 in the bit position being coded */\r\n    natural_order = cinfo->natural_order;\r\n\r\n    /* Load up working state */\r\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\r\n    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */\r\n\r\n    /* There is always only one block per MCU */\r\n    block = MCU_data[0];\r\n    tbl = entropy->ac_derived_tbl;\r\n\r\n    /* If we are forced to suspend, we must undo the assignments to any newly\r\n     * nonzero coefficients in the block, because otherwise we'd get confused\r\n     * next time about which coefficients were already nonzero.\r\n     * But we need not undo addition of bits to already-nonzero coefficients;\r\n     * instead, we can test the current bit to see if we already did it.\r\n     */\r\n    num_newnz = 0;\r\n\r\n    /* initialize coefficient loop counter to start of band */\r\n    k = cinfo->Ss;\r\n\r\n    if (EOBRUN == 0) {\r\n      do {\r\n\tHUFF_DECODE(s, br_state, tbl, goto undoit, label3);\r\n\tr = s >> 4;\r\n\ts &= 15;\r\n\tif (s) {\r\n\t  if (s != 1)\t\t/* size of new coef should always be 1 */\r\n\t    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);\r\n\t  CHECK_BIT_BUFFER(br_state, 1, goto undoit);\r\n\t  if (GET_BITS(1))\r\n\t    s = p1;\t\t/* newly nonzero coef is positive */\r\n\t  else\r\n\t    s = m1;\t\t/* newly nonzero coef is negative */\r\n\t} else {\r\n\t  if (r != 15) {\r\n\t    EOBRUN = 1 << r;\t/* EOBr, run length is 2^r + appended bits */\r\n\t    if (r) {\r\n\t      CHECK_BIT_BUFFER(br_state, r, goto undoit);\r\n\t      r = GET_BITS(r);\r\n\t      EOBRUN += r;\r\n\t    }\r\n\t    break;\t\t/* rest of block is handled by EOB logic */\r\n\t  }\r\n\t  /* note s = 0 for processing ZRL */\r\n\t}\r\n\t/* Advance over already-nonzero coefs and r still-zero coefs,\r\n\t * appending correction bits to the nonzeroes.  A correction bit is 1\r\n\t * if the absolute value of the coefficient must be increased.\r\n\t */\r\n\tdo {\r\n\t  thiscoef = *block + natural_order[k];\r\n\t  if (*thiscoef) {\r\n\t    CHECK_BIT_BUFFER(br_state, 1, goto undoit);\r\n\t    if (GET_BITS(1)) {\r\n\t      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */\r\n\t\tif (*thiscoef >= 0)\r\n\t\t  *thiscoef += p1;\r\n\t\telse\r\n\t\t  *thiscoef += m1;\r\n\t      }\r\n\t    }\r\n\t  } else {\r\n\t    if (--r < 0)\r\n\t      break;\t\t/* reached target zero coefficient */\r\n\t  }\r\n\t  k++;\r\n\t} while (k <= Se);\r\n\tif (s) {\r\n\t  int pos = natural_order[k];\r\n\t  /* Output newly nonzero coefficient */\r\n\t  (*block)[pos] = (JCOEF) s;\r\n\t  /* Remember its position in case we have to suspend */\r\n\t  newnz_pos[num_newnz++] = pos;\r\n\t}\r\n\tk++;\r\n      } while (k <= Se);\r\n    }\r\n\r\n    if (EOBRUN) {\r\n      /* Scan any remaining coefficient positions after the end-of-band\r\n       * (the last newly nonzero coefficient, if any).  Append a correction\r\n       * bit to each already-nonzero coefficient.  A correction bit is 1\r\n       * if the absolute value of the coefficient must be increased.\r\n       */\r\n      do {\r\n\tthiscoef = *block + natural_order[k];\r\n\tif (*thiscoef) {\r\n\t  CHECK_BIT_BUFFER(br_state, 1, goto undoit);\r\n\t  if (GET_BITS(1)) {\r\n\t    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */\r\n\t      if (*thiscoef >= 0)\r\n\t\t*thiscoef += p1;\r\n\t      else\r\n\t\t*thiscoef += m1;\r\n\t    }\r\n\t  }\r\n\t}\r\n\tk++;\r\n      } while (k <= Se);\r\n      /* Count one block completed in EOB run */\r\n      EOBRUN--;\r\n    }\r\n\r\n    /* Completed MCU, so update state */\r\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\r\n    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */\r\n  }\r\n\r\n  /* Account for restart interval (no-op if not using restarts) */\r\n  entropy->restarts_to_go--;\r\n\r\n  return TRUE;\r\n\r\nundoit:\r\n  /* Re-zero any output coefficients that we made newly nonzero */\r\n  while (num_newnz)\r\n    (*block)[newnz_pos[--num_newnz]] = 0;\r\n\r\n  return FALSE;\r\n}\r\n\r\n\r\n/*\r\n * Decode one MCU's worth of Huffman-compressed coefficients,\r\n * partial blocks.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  const int * natural_order;\r\n  int Se, blkn;\r\n  BITREAD_STATE_VARS;\r\n  savable_state state;\r\n\r\n  /* Process restart marker if needed; may have to suspend */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      if (! process_restart(cinfo))\r\n\treturn FALSE;\r\n  }\r\n\r\n  /* If we've run out of data, just leave the MCU set to zeroes.\r\n   * This way, we return uniform gray for the remainder of the segment.\r\n   */\r\n  if (! entropy->insufficient_data) {\r\n\r\n    natural_order = cinfo->natural_order;\r\n    Se = cinfo->lim_Se;\r\n\r\n    /* Load up working state */\r\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\r\n    ASSIGN_STATE(state, entropy->saved);\r\n\r\n    /* Outer loop handles each block in the MCU */\r\n\r\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n      JBLOCKROW block = MCU_data[blkn];\r\n      d_derived_tbl * htbl;\r\n      register int s, k, r;\r\n      int coef_limit, ci;\r\n\r\n      /* Decode a single block's worth of coefficients */\r\n\r\n      /* Section F.2.2.1: decode the DC coefficient difference */\r\n      htbl = entropy->dc_cur_tbls[blkn];\r\n      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);\r\n\r\n      htbl = entropy->ac_cur_tbls[blkn];\r\n      k = 1;\r\n      coef_limit = entropy->coef_limit[blkn];\r\n      if (coef_limit) {\r\n\t/* Convert DC difference to actual value, update last_dc_val */\r\n\tif (s) {\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  r = GET_BITS(s);\r\n\t  s = HUFF_EXTEND(r, s);\r\n\t}\r\n\tci = cinfo->MCU_membership[blkn];\r\n\ts += state.last_dc_val[ci];\r\n\tstate.last_dc_val[ci] = s;\r\n\t/* Output the DC coefficient */\r\n\t(*block)[0] = (JCOEF) s;\r\n\r\n\t/* Section F.2.2.2: decode the AC coefficients */\r\n\t/* Since zeroes are skipped, output area must be cleared beforehand */\r\n\tfor (; k < coef_limit; k++) {\r\n\t  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);\r\n\r\n\t  r = s >> 4;\r\n\t  s &= 15;\r\n\r\n\t  if (s) {\r\n\t    k += r;\r\n\t    CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t    r = GET_BITS(s);\r\n\t    s = HUFF_EXTEND(r, s);\r\n\t    /* Output coefficient in natural (dezigzagged) order.\r\n\t     * Note: the extra entries in natural_order[] will save us\r\n\t     * if k > Se, which could happen if the data is corrupted.\r\n\t     */\r\n\t    (*block)[natural_order[k]] = (JCOEF) s;\r\n\t  } else {\r\n\t    if (r != 15)\r\n\t      goto EndOfBlock;\r\n\t    k += 15;\r\n\t  }\r\n\t}\r\n      } else {\r\n\tif (s) {\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  DROP_BITS(s);\r\n\t}\r\n      }\r\n\r\n      /* Section F.2.2.2: decode the AC coefficients */\r\n      /* In this path we just discard the values */\r\n      for (; k <= Se; k++) {\r\n\tHUFF_DECODE(s, br_state, htbl, return FALSE, label3);\r\n\r\n\tr = s >> 4;\r\n\ts &= 15;\r\n\r\n\tif (s) {\r\n\t  k += r;\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  DROP_BITS(s);\r\n\t} else {\r\n\t  if (r != 15)\r\n\t    break;\r\n\t  k += 15;\r\n\t}\r\n      }\r\n\r\n      EndOfBlock: ;\r\n    }\r\n\r\n    /* Completed MCU, so update state */\r\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\r\n    ASSIGN_STATE(entropy->saved, state);\r\n  }\r\n\r\n  /* Account for restart interval (no-op if not using restarts) */\r\n  entropy->restarts_to_go--;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Decode one MCU's worth of Huffman-compressed coefficients,\r\n * full-size blocks.\r\n */\r\n\r\nMETHODDEF(boolean)\r\ndecode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\r\n{\r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  int blkn;\r\n  BITREAD_STATE_VARS;\r\n  savable_state state;\r\n\r\n  /* Process restart marker if needed; may have to suspend */\r\n  if (cinfo->restart_interval) {\r\n    if (entropy->restarts_to_go == 0)\r\n      if (! process_restart(cinfo))\r\n\treturn FALSE;\r\n  }\r\n\r\n  /* If we've run out of data, just leave the MCU set to zeroes.\r\n   * This way, we return uniform gray for the remainder of the segment.\r\n   */\r\n  if (! entropy->insufficient_data) {\r\n\r\n    /* Load up working state */\r\n    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);\r\n    ASSIGN_STATE(state, entropy->saved);\r\n\r\n    /* Outer loop handles each block in the MCU */\r\n\r\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n      JBLOCKROW block = MCU_data[blkn];\r\n      d_derived_tbl * htbl;\r\n      register int s, k, r;\r\n      int coef_limit, ci;\r\n\r\n      /* Decode a single block's worth of coefficients */\r\n\r\n      /* Section F.2.2.1: decode the DC coefficient difference */\r\n      htbl = entropy->dc_cur_tbls[blkn];\r\n      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);\r\n\r\n      htbl = entropy->ac_cur_tbls[blkn];\r\n      k = 1;\r\n      coef_limit = entropy->coef_limit[blkn];\r\n      if (coef_limit) {\r\n\t/* Convert DC difference to actual value, update last_dc_val */\r\n\tif (s) {\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  r = GET_BITS(s);\r\n\t  s = HUFF_EXTEND(r, s);\r\n\t}\r\n\tci = cinfo->MCU_membership[blkn];\r\n\ts += state.last_dc_val[ci];\r\n\tstate.last_dc_val[ci] = s;\r\n\t/* Output the DC coefficient */\r\n\t(*block)[0] = (JCOEF) s;\r\n\r\n\t/* Section F.2.2.2: decode the AC coefficients */\r\n\t/* Since zeroes are skipped, output area must be cleared beforehand */\r\n\tfor (; k < coef_limit; k++) {\r\n\t  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);\r\n\r\n\t  r = s >> 4;\r\n\t  s &= 15;\r\n\r\n\t  if (s) {\r\n\t    k += r;\r\n\t    CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t    r = GET_BITS(s);\r\n\t    s = HUFF_EXTEND(r, s);\r\n\t    /* Output coefficient in natural (dezigzagged) order.\r\n\t     * Note: the extra entries in jpeg_natural_order[] will save us\r\n\t     * if k >= DCTSIZE2, which could happen if the data is corrupted.\r\n\t     */\r\n\t    (*block)[jpeg_natural_order[k]] = (JCOEF) s;\r\n\t  } else {\r\n\t    if (r != 15)\r\n\t      goto EndOfBlock;\r\n\t    k += 15;\r\n\t  }\r\n\t}\r\n      } else {\r\n\tif (s) {\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  DROP_BITS(s);\r\n\t}\r\n      }\r\n\r\n      /* Section F.2.2.2: decode the AC coefficients */\r\n      /* In this path we just discard the values */\r\n      for (; k < DCTSIZE2; k++) {\r\n\tHUFF_DECODE(s, br_state, htbl, return FALSE, label3);\r\n\r\n\tr = s >> 4;\r\n\ts &= 15;\r\n\r\n\tif (s) {\r\n\t  k += r;\r\n\t  CHECK_BIT_BUFFER(br_state, s, return FALSE);\r\n\t  DROP_BITS(s);\r\n\t} else {\r\n\t  if (r != 15)\r\n\t    break;\r\n\t  k += 15;\r\n\t}\r\n      }\r\n\r\n      EndOfBlock: ;\r\n    }\r\n\r\n    /* Completed MCU, so update state */\r\n    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);\r\n    ASSIGN_STATE(entropy->saved, state);\r\n  }\r\n\r\n  /* Account for restart interval (no-op if not using restarts) */\r\n  entropy->restarts_to_go--;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Initialize for a Huffman-compressed scan.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_huff_decoder (j_decompress_ptr cinfo)\r\n{\r\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\r\n  int ci, blkn, tbl, i;\r\n  jpeg_component_info * compptr;\r\n\r\n  if (cinfo->progressive_mode) {\r\n    /* Validate progressive scan parameters */\r\n    if (cinfo->Ss == 0) {\r\n      if (cinfo->Se != 0)\r\n\tgoto bad;\r\n    } else {\r\n      /* need not check Ss/Se < 0 since they came from unsigned bytes */\r\n      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)\r\n\tgoto bad;\r\n      /* AC scans may have only one component */\r\n      if (cinfo->comps_in_scan != 1)\r\n\tgoto bad;\r\n    }\r\n    if (cinfo->Ah != 0) {\r\n      /* Successive approximation refinement scan: must have Al = Ah-1. */\r\n      if (cinfo->Ah-1 != cinfo->Al)\r\n\tgoto bad;\r\n    }\r\n    if (cinfo->Al > 13) {\t/* need not check for < 0 */\r\n      /* Arguably the maximum Al value should be less than 13 for 8-bit precision,\r\n       * but the spec doesn't say so, and we try to be liberal about what we\r\n       * accept.  Note: large Al values could result in out-of-range DC\r\n       * coefficients during early scans, leading to bizarre displays due to\r\n       * overflows in the IDCT math.  But we won't crash.\r\n       */\r\n      bad:\r\n      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\r\n\t       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\r\n    }\r\n    /* Update progression status, and verify that scan order is legal.\r\n     * Note that inter-scan inconsistencies are treated as warnings\r\n     * not fatal errors ... not clear if this is right way to behave.\r\n     */\r\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;\r\n      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];\r\n      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */\r\n\tWARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);\r\n      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {\r\n\tint expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];\r\n\tif (cinfo->Ah != expected)\r\n\t  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);\r\n\tcoef_bit_ptr[coefi] = cinfo->Al;\r\n      }\r\n    }\r\n\r\n    /* Select MCU decoding routine */\r\n    if (cinfo->Ah == 0) {\r\n      if (cinfo->Ss == 0)\r\n\tentropy->pub.decode_mcu = decode_mcu_DC_first;\r\n      else\r\n\tentropy->pub.decode_mcu = decode_mcu_AC_first;\r\n    } else {\r\n      if (cinfo->Ss == 0)\r\n\tentropy->pub.decode_mcu = decode_mcu_DC_refine;\r\n      else\r\n\tentropy->pub.decode_mcu = decode_mcu_AC_refine;\r\n    }\r\n\r\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n      compptr = cinfo->cur_comp_info[ci];\r\n      /* Make sure requested tables are present, and compute derived tables.\r\n       * We may build same derived table more than once, but it's not expensive.\r\n       */\r\n      if (cinfo->Ss == 0) {\r\n\tif (cinfo->Ah == 0) {\t/* DC refinement needs no table */\r\n\t  tbl = compptr->dc_tbl_no;\r\n\t  jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,\r\n\t\t\t\t  & entropy->derived_tbls[tbl]);\r\n\t}\r\n      } else {\r\n\ttbl = compptr->ac_tbl_no;\r\n\tjpeg_make_d_derived_tbl(cinfo, FALSE, tbl,\r\n\t\t\t\t& entropy->derived_tbls[tbl]);\r\n\t/* remember the single active table */\r\n\tentropy->ac_derived_tbl = entropy->derived_tbls[tbl];\r\n      }\r\n      /* Initialize DC predictions to 0 */\r\n      entropy->saved.last_dc_val[ci] = 0;\r\n    }\r\n\r\n    /* Initialize private state variables */\r\n    entropy->saved.EOBRUN = 0;\r\n  } else {\r\n    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.\r\n     * This ought to be an error condition, but we make it a warning because\r\n     * there are some baseline files out there with all zeroes in these bytes.\r\n     */\r\n    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||\r\n\t((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&\r\n\tcinfo->Se != cinfo->lim_Se))\r\n      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);\r\n\r\n    /* Select MCU decoding routine */\r\n    /* We retain the hard-coded case for full-size blocks.\r\n     * This is not necessary, but it appears that this version is slightly\r\n     * more performant in the given implementation.\r\n     * With an improved implementation we would prefer a single optimized\r\n     * function.\r\n     */\r\n    if (cinfo->lim_Se != DCTSIZE2-1)\r\n      entropy->pub.decode_mcu = decode_mcu_sub;\r\n    else\r\n      entropy->pub.decode_mcu = decode_mcu;\r\n\r\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n      compptr = cinfo->cur_comp_info[ci];\r\n      /* Compute derived values for Huffman tables */\r\n      /* We may do this more than once for a table, but it's not expensive */\r\n      tbl = compptr->dc_tbl_no;\r\n      jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,\r\n\t\t\t      & entropy->dc_derived_tbls[tbl]);\r\n      if (cinfo->lim_Se) {\t/* AC needs no table when not present */\r\n\ttbl = compptr->ac_tbl_no;\r\n\tjpeg_make_d_derived_tbl(cinfo, FALSE, tbl,\r\n\t\t\t\t& entropy->ac_derived_tbls[tbl]);\r\n      }\r\n      /* Initialize DC predictions to 0 */\r\n      entropy->saved.last_dc_val[ci] = 0;\r\n    }\r\n\r\n    /* Precalculate decoding info for each block in an MCU of this scan */\r\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\r\n      ci = cinfo->MCU_membership[blkn];\r\n      compptr = cinfo->cur_comp_info[ci];\r\n      /* Precalculate which table to use for each block */\r\n      entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];\r\n      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];\r\n      /* Decide whether we really care about the coefficient values */\r\n      if (compptr->component_needed) {\r\n\tci = compptr->DCT_v_scaled_size;\r\n\ti = compptr->DCT_h_scaled_size;\r\n\tswitch (cinfo->lim_Se) {\r\n\tcase (1*1-1):\r\n\t  entropy->coef_limit[blkn] = 1;\r\n\t  break;\r\n\tcase (2*2-1):\r\n\t  if (ci <= 0 || ci > 2) ci = 2;\r\n\t  if (i <= 0 || i > 2) i = 2;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];\r\n\t  break;\r\n\tcase (3*3-1):\r\n\t  if (ci <= 0 || ci > 3) ci = 3;\r\n\t  if (i <= 0 || i > 3) i = 3;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];\r\n\t  break;\r\n\tcase (4*4-1):\r\n\t  if (ci <= 0 || ci > 4) ci = 4;\r\n\t  if (i <= 0 || i > 4) i = 4;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];\r\n\t  break;\r\n\tcase (5*5-1):\r\n\t  if (ci <= 0 || ci > 5) ci = 5;\r\n\t  if (i <= 0 || i > 5) i = 5;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];\r\n\t  break;\r\n\tcase (6*6-1):\r\n\t  if (ci <= 0 || ci > 6) ci = 6;\r\n\t  if (i <= 0 || i > 6) i = 6;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];\r\n\t  break;\r\n\tcase (7*7-1):\r\n\t  if (ci <= 0 || ci > 7) ci = 7;\r\n\t  if (i <= 0 || i > 7) i = 7;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];\r\n\t  break;\r\n\tdefault:\r\n\t  if (ci <= 0 || ci > 8) ci = 8;\r\n\t  if (i <= 0 || i > 8) i = 8;\r\n\t  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];\r\n\t  break;\r\n\t}\r\n      } else {\r\n\tentropy->coef_limit[blkn] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Initialize bitread state variables */\r\n  entropy->bitstate.bits_left = 0;\r\n  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */\r\n  entropy->insufficient_data = FALSE;\r\n\r\n  /* Initialize restart counter */\r\n  entropy->restarts_to_go = cinfo->restart_interval;\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for Huffman entropy decoding.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_huff_decoder (j_decompress_ptr cinfo)\r\n{\r\n  huff_entropy_ptr entropy;\r\n  int i;\r\n\r\n  entropy = (huff_entropy_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(huff_entropy_decoder));\r\n  cinfo->entropy = &entropy->pub;\r\n  entropy->pub.start_pass = start_pass_huff_decoder;\r\n  entropy->pub.finish_pass = finish_pass_huff;\r\n\r\n  if (cinfo->progressive_mode) {\r\n    /* Create progression status table */\r\n    int *coef_bit_ptr, ci;\r\n    cinfo->coef_bits = (int (*)[DCTSIZE2])\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  cinfo->num_components*DCTSIZE2*SIZEOF(int));\r\n    coef_bit_ptr = & cinfo->coef_bits[0][0];\r\n    for (ci = 0; ci < cinfo->num_components; ci++)\r\n      for (i = 0; i < DCTSIZE2; i++)\r\n\t*coef_bit_ptr++ = -1;\r\n\r\n    /* Mark derived tables unallocated */\r\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\r\n      entropy->derived_tbls[i] = NULL;\r\n    }\r\n  } else {\r\n    /* Mark tables unallocated */\r\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\r\n      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;\r\n    }\r\n  }\r\n}\r\n","/*\r\n * jdinput.c\r\n *\r\n * Copyright (C) 1991-1997, Thomas G. Lane.\r\n * Modified 2002-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains input control logic for the JPEG decompressor.\r\n * These routines are concerned with controlling the decompressor's input\r\n * processing (marker reading and coefficient decoding).  The actual input\r\n * reading is done in jdmarker.c, jdhuff.c, and jdarith.c.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Private state */\r\n\r\ntypedef struct {\r\n  struct jpeg_input_controller pub; /* public fields */\r\n\r\n  int inheaders;\t\t/* Nonzero until first SOS is reached */\r\n} my_input_controller;\r\n\r\ntypedef my_input_controller * my_inputctl_ptr;\r\n\r\n\r\n/* Forward declarations */\r\nMETHODDEF(int) consume_markers JPP((j_decompress_ptr cinfo));\r\n\r\n\r\n/*\r\n * Routines to calculate various quantities related to the size of the image.\r\n */\r\n\r\n\r\n/*\r\n * Compute output image dimensions and related values.\r\n * NOTE: this is exported for possible use by application.\r\n * Hence it mustn't do anything that can't be done twice.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_core_output_dimensions (j_decompress_ptr cinfo)\r\n/* Do computations that are needed before master selection phase.\r\n * This function is used for transcoding and full decompression.\r\n */\r\n{\r\n#ifdef IDCT_SCALING_SUPPORTED\r\n  int ci;\r\n  jpeg_component_info *compptr;\r\n\r\n  /* Compute actual output image dimensions and DCT scaling choices. */\r\n  if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom) {\r\n    /* Provide 1/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 1;\r\n    cinfo->min_DCT_v_scaled_size = 1;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 2) {\r\n    /* Provide 2/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 2L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 2L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 2;\r\n    cinfo->min_DCT_v_scaled_size = 2;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 3) {\r\n    /* Provide 3/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 3L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 3L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 3;\r\n    cinfo->min_DCT_v_scaled_size = 3;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 4) {\r\n    /* Provide 4/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 4L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 4L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 4;\r\n    cinfo->min_DCT_v_scaled_size = 4;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 5) {\r\n    /* Provide 5/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 5L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 5L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 5;\r\n    cinfo->min_DCT_v_scaled_size = 5;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 6) {\r\n    /* Provide 6/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 6L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 6L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 6;\r\n    cinfo->min_DCT_v_scaled_size = 6;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 7) {\r\n    /* Provide 7/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 7L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 7L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 7;\r\n    cinfo->min_DCT_v_scaled_size = 7;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 8) {\r\n    /* Provide 8/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 8L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 8L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 8;\r\n    cinfo->min_DCT_v_scaled_size = 8;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 9) {\r\n    /* Provide 9/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 9L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 9L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 9;\r\n    cinfo->min_DCT_v_scaled_size = 9;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 10) {\r\n    /* Provide 10/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 10L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 10L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 10;\r\n    cinfo->min_DCT_v_scaled_size = 10;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 11) {\r\n    /* Provide 11/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 11L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 11L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 11;\r\n    cinfo->min_DCT_v_scaled_size = 11;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 12) {\r\n    /* Provide 12/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 12L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 12L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 12;\r\n    cinfo->min_DCT_v_scaled_size = 12;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 13) {\r\n    /* Provide 13/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 13L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 13L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 13;\r\n    cinfo->min_DCT_v_scaled_size = 13;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 14) {\r\n    /* Provide 14/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 14L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 14L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 14;\r\n    cinfo->min_DCT_v_scaled_size = 14;\r\n  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 15) {\r\n    /* Provide 15/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 15L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 15L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 15;\r\n    cinfo->min_DCT_v_scaled_size = 15;\r\n  } else {\r\n    /* Provide 16/block_size scaling */\r\n    cinfo->output_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * 16L, (long) cinfo->block_size);\r\n    cinfo->output_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * 16L, (long) cinfo->block_size);\r\n    cinfo->min_DCT_h_scaled_size = 16;\r\n    cinfo->min_DCT_v_scaled_size = 16;\r\n  }\r\n\r\n  /* Recompute dimensions of components */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size;\r\n    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size;\r\n  }\r\n\r\n#else /* !IDCT_SCALING_SUPPORTED */\r\n\r\n  /* Hardwire it to \"no scaling\" */\r\n  cinfo->output_width = cinfo->image_width;\r\n  cinfo->output_height = cinfo->image_height;\r\n  /* initial_setup has already initialized DCT_scaled_size,\r\n   * and has computed unscaled downsampled_width and downsampled_height.\r\n   */\r\n\r\n#endif /* IDCT_SCALING_SUPPORTED */\r\n}\r\n\r\n\r\nLOCAL(void)\r\ninitial_setup (j_decompress_ptr cinfo)\r\n/* Called once, when first SOS marker is reached */\r\n{\r\n  int ci;\r\n  jpeg_component_info *compptr;\r\n\r\n  /* Make sure image isn't bigger than I can handle */\r\n  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||\r\n      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)\r\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);\r\n\r\n  /* Only 8 to 12 bits data precision are supported for DCT based JPEG */\r\n  if (cinfo->data_precision < 8 || cinfo->data_precision > 12)\r\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\r\n\r\n  /* Check that number of components won't exceed internal array sizes */\r\n  if (cinfo->num_components > MAX_COMPONENTS)\r\n    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,\r\n\t     MAX_COMPONENTS);\r\n\r\n  /* Compute maximum sampling factors; check factor validity */\r\n  cinfo->max_h_samp_factor = 1;\r\n  cinfo->max_v_samp_factor = 1;\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||\r\n\tcompptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)\r\n      ERREXIT(cinfo, JERR_BAD_SAMPLING);\r\n    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,\r\n\t\t\t\t   compptr->h_samp_factor);\r\n    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,\r\n\t\t\t\t   compptr->v_samp_factor);\r\n  }\r\n\r\n  /* Derive block_size, natural_order, and lim_Se */\r\n  if (cinfo->is_baseline || (cinfo->progressive_mode &&\r\n      cinfo->comps_in_scan)) { /* no pseudo SOS marker */\r\n    cinfo->block_size = DCTSIZE;\r\n    cinfo->natural_order = jpeg_natural_order;\r\n    cinfo->lim_Se = DCTSIZE2-1;\r\n  } else\r\n    switch (cinfo->Se) {\r\n    case (1*1-1):\r\n      cinfo->block_size = 1;\r\n      cinfo->natural_order = jpeg_natural_order; /* not needed */\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (2*2-1):\r\n      cinfo->block_size = 2;\r\n      cinfo->natural_order = jpeg_natural_order2;\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (3*3-1):\r\n      cinfo->block_size = 3;\r\n      cinfo->natural_order = jpeg_natural_order3;\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (4*4-1):\r\n      cinfo->block_size = 4;\r\n      cinfo->natural_order = jpeg_natural_order4;\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (5*5-1):\r\n      cinfo->block_size = 5;\r\n      cinfo->natural_order = jpeg_natural_order5;\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (6*6-1):\r\n      cinfo->block_size = 6;\r\n      cinfo->natural_order = jpeg_natural_order6;\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (7*7-1):\r\n      cinfo->block_size = 7;\r\n      cinfo->natural_order = jpeg_natural_order7;\r\n      cinfo->lim_Se = cinfo->Se;\r\n      break;\r\n    case (8*8-1):\r\n      cinfo->block_size = 8;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (9*9-1):\r\n      cinfo->block_size = 9;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (10*10-1):\r\n      cinfo->block_size = 10;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (11*11-1):\r\n      cinfo->block_size = 11;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (12*12-1):\r\n      cinfo->block_size = 12;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (13*13-1):\r\n      cinfo->block_size = 13;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (14*14-1):\r\n      cinfo->block_size = 14;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (15*15-1):\r\n      cinfo->block_size = 15;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    case (16*16-1):\r\n      cinfo->block_size = 16;\r\n      cinfo->natural_order = jpeg_natural_order;\r\n      cinfo->lim_Se = DCTSIZE2-1;\r\n      break;\r\n    default:\r\n      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\r\n\t       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\r\n      break;\r\n    }\r\n\r\n  /* We initialize DCT_scaled_size and min_DCT_scaled_size to block_size.\r\n   * In the full decompressor,\r\n   * this will be overridden by jpeg_calc_output_dimensions in jdmaster.c;\r\n   * but in the transcoder,\r\n   * jpeg_calc_output_dimensions is not used, so we must do it here.\r\n   */\r\n  cinfo->min_DCT_h_scaled_size = cinfo->block_size;\r\n  cinfo->min_DCT_v_scaled_size = cinfo->block_size;\r\n\r\n  /* Compute dimensions of components */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    compptr->DCT_h_scaled_size = cinfo->block_size;\r\n    compptr->DCT_v_scaled_size = cinfo->block_size;\r\n    /* Size in DCT blocks */\r\n    compptr->width_in_blocks = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,\r\n\t\t    (long) (cinfo->max_h_samp_factor * cinfo->block_size));\r\n    compptr->height_in_blocks = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,\r\n\t\t    (long) (cinfo->max_v_samp_factor * cinfo->block_size));\r\n    /* downsampled_width and downsampled_height will also be overridden by\r\n     * jdmaster.c if we are doing full decompression.  The transcoder library\r\n     * doesn't use these values, but the calling application might.\r\n     */\r\n    /* Size in samples */\r\n    compptr->downsampled_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,\r\n\t\t    (long) cinfo->max_h_samp_factor);\r\n    compptr->downsampled_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,\r\n\t\t    (long) cinfo->max_v_samp_factor);\r\n    /* Mark component needed, until color conversion says otherwise */\r\n    compptr->component_needed = TRUE;\r\n    /* Mark no quantization table yet saved for component */\r\n    compptr->quant_table = NULL;\r\n  }\r\n\r\n  /* Compute number of fully interleaved MCU rows. */\r\n  cinfo->total_iMCU_rows = (JDIMENSION)\r\n    jdiv_round_up((long) cinfo->image_height,\r\n\t          (long) (cinfo->max_v_samp_factor * cinfo->block_size));\r\n\r\n  /* Decide whether file contains multiple scans */\r\n  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)\r\n    cinfo->inputctl->has_multiple_scans = TRUE;\r\n  else\r\n    cinfo->inputctl->has_multiple_scans = FALSE;\r\n}\r\n\r\n\r\nLOCAL(void)\r\nper_scan_setup (j_decompress_ptr cinfo)\r\n/* Do computations that are needed before processing a JPEG scan */\r\n/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */\r\n{\r\n  int ci, mcublks, tmp;\r\n  jpeg_component_info *compptr;\r\n  \r\n  if (cinfo->comps_in_scan == 1) {\r\n    \r\n    /* Noninterleaved (single-component) scan */\r\n    compptr = cinfo->cur_comp_info[0];\r\n    \r\n    /* Overall image size in MCUs */\r\n    cinfo->MCUs_per_row = compptr->width_in_blocks;\r\n    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;\r\n    \r\n    /* For noninterleaved scan, always one block per MCU */\r\n    compptr->MCU_width = 1;\r\n    compptr->MCU_height = 1;\r\n    compptr->MCU_blocks = 1;\r\n    compptr->MCU_sample_width = compptr->DCT_h_scaled_size;\r\n    compptr->last_col_width = 1;\r\n    /* For noninterleaved scans, it is convenient to define last_row_height\r\n     * as the number of block rows present in the last iMCU row.\r\n     */\r\n    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\r\n    if (tmp == 0) tmp = compptr->v_samp_factor;\r\n    compptr->last_row_height = tmp;\r\n    \r\n    /* Prepare array describing MCU composition */\r\n    cinfo->blocks_in_MCU = 1;\r\n    cinfo->MCU_membership[0] = 0;\r\n    \r\n  } else {\r\n    \r\n    /* Interleaved (multi-component) scan */\r\n    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)\r\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,\r\n\t       MAX_COMPS_IN_SCAN);\r\n    \r\n    /* Overall image size in MCUs */\r\n    cinfo->MCUs_per_row = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width,\r\n\t\t    (long) (cinfo->max_h_samp_factor * cinfo->block_size));\r\n    cinfo->MCU_rows_in_scan = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height,\r\n\t\t    (long) (cinfo->max_v_samp_factor * cinfo->block_size));\r\n    \r\n    cinfo->blocks_in_MCU = 0;\r\n    \r\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n      compptr = cinfo->cur_comp_info[ci];\r\n      /* Sampling factors give # of blocks of component in each MCU */\r\n      compptr->MCU_width = compptr->h_samp_factor;\r\n      compptr->MCU_height = compptr->v_samp_factor;\r\n      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;\r\n      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_h_scaled_size;\r\n      /* Figure number of non-dummy blocks in last MCU column & row */\r\n      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);\r\n      if (tmp == 0) tmp = compptr->MCU_width;\r\n      compptr->last_col_width = tmp;\r\n      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);\r\n      if (tmp == 0) tmp = compptr->MCU_height;\r\n      compptr->last_row_height = tmp;\r\n      /* Prepare array describing MCU composition */\r\n      mcublks = compptr->MCU_blocks;\r\n      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)\r\n\tERREXIT(cinfo, JERR_BAD_MCU_SIZE);\r\n      while (mcublks-- > 0) {\r\n\tcinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;\r\n      }\r\n    }\r\n    \r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Save away a copy of the Q-table referenced by each component present\r\n * in the current scan, unless already saved during a prior scan.\r\n *\r\n * In a multiple-scan JPEG file, the encoder could assign different components\r\n * the same Q-table slot number, but change table definitions between scans\r\n * so that each component uses a different Q-table.  (The IJG encoder is not\r\n * currently capable of doing this, but other encoders might.)  Since we want\r\n * to be able to dequantize all the components at the end of the file, this\r\n * means that we have to save away the table actually used for each component.\r\n * We do this by copying the table at the start of the first scan containing\r\n * the component.\r\n * The JPEG spec prohibits the encoder from changing the contents of a Q-table\r\n * slot between scans of a component using that slot.  If the encoder does so\r\n * anyway, this decoder will simply use the Q-table values that were current\r\n * at the start of the first scan for the component.\r\n *\r\n * The decompressor output side looks only at the saved quant tables,\r\n * not at the current Q-table slots.\r\n */\r\n\r\nLOCAL(void)\r\nlatch_quant_tables (j_decompress_ptr cinfo)\r\n{\r\n  int ci, qtblno;\r\n  jpeg_component_info *compptr;\r\n  JQUANT_TBL * qtbl;\r\n\r\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\r\n    compptr = cinfo->cur_comp_info[ci];\r\n    /* No work if we already saved Q-table for this component */\r\n    if (compptr->quant_table != NULL)\r\n      continue;\r\n    /* Make sure specified quantization table is present */\r\n    qtblno = compptr->quant_tbl_no;\r\n    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||\r\n\tcinfo->quant_tbl_ptrs[qtblno] == NULL)\r\n      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);\r\n    /* OK, save away the quantization table */\r\n    qtbl = (JQUANT_TBL *)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  SIZEOF(JQUANT_TBL));\r\n    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));\r\n    compptr->quant_table = qtbl;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Initialize the input modules to read a scan of compressed data.\r\n * The first call to this is done by jdmaster.c after initializing\r\n * the entire decompressor (during jpeg_start_decompress).\r\n * Subsequent calls come from consume_markers, below.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_input_pass (j_decompress_ptr cinfo)\r\n{\r\n  per_scan_setup(cinfo);\r\n  latch_quant_tables(cinfo);\r\n  (*cinfo->entropy->start_pass) (cinfo);\r\n  (*cinfo->coef->start_input_pass) (cinfo);\r\n  cinfo->inputctl->consume_input = cinfo->coef->consume_data;\r\n}\r\n\r\n\r\n/*\r\n * Finish up after inputting a compressed-data scan.\r\n * This is called by the coefficient controller after it's read all\r\n * the expected data of the scan.\r\n */\r\n\r\nMETHODDEF(void)\r\nfinish_input_pass (j_decompress_ptr cinfo)\r\n{\r\n  (*cinfo->entropy->finish_pass) (cinfo);\r\n  cinfo->inputctl->consume_input = consume_markers;\r\n}\r\n\r\n\r\n/*\r\n * Read JPEG markers before, between, or after compressed-data scans.\r\n * Change state as necessary when a new scan is reached.\r\n * Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.\r\n *\r\n * The consume_input method pointer points either here or to the\r\n * coefficient controller's consume_data routine, depending on whether\r\n * we are reading a compressed data segment or inter-segment markers.\r\n *\r\n * Note: This function should NOT return a pseudo SOS marker (with zero\r\n * component number) to the caller.  A pseudo marker received by\r\n * read_markers is processed and then skipped for other markers.\r\n */\r\n\r\nMETHODDEF(int)\r\nconsume_markers (j_decompress_ptr cinfo)\r\n{\r\n  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;\r\n  int val;\r\n\r\n  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */\r\n    return JPEG_REACHED_EOI;\r\n\r\n  for (;;) {\t\t\t/* Loop to pass pseudo SOS marker */\r\n    val = (*cinfo->marker->read_markers) (cinfo);\r\n\r\n    switch (val) {\r\n    case JPEG_REACHED_SOS:\t/* Found SOS */\r\n      if (inputctl->inheaders) { /* 1st SOS */\r\n\tif (inputctl->inheaders == 1)\r\n\t  initial_setup(cinfo);\r\n\tif (cinfo->comps_in_scan == 0) { /* pseudo SOS marker */\r\n\t  inputctl->inheaders = 2;\r\n\t  break;\r\n\t}\r\n\tinputctl->inheaders = 0;\r\n\t/* Note: start_input_pass must be called by jdmaster.c\r\n\t * before any more input can be consumed.  jdapimin.c is\r\n\t * responsible for enforcing this sequencing.\r\n\t */\r\n      } else {\t\t\t/* 2nd or later SOS marker */\r\n\tif (! inputctl->pub.has_multiple_scans)\r\n\t  ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */\r\n\tif (cinfo->comps_in_scan == 0) /* unexpected pseudo SOS marker */\r\n\t  break;\r\n\tstart_input_pass(cinfo);\r\n      }\r\n      return val;\r\n    case JPEG_REACHED_EOI:\t/* Found EOI */\r\n      inputctl->pub.eoi_reached = TRUE;\r\n      if (inputctl->inheaders) { /* Tables-only datastream, apparently */\r\n\tif (cinfo->marker->saw_SOF)\r\n\t  ERREXIT(cinfo, JERR_SOF_NO_SOS);\r\n      } else {\r\n\t/* Prevent infinite loop in coef ctlr's decompress_data routine\r\n\t * if user set output_scan_number larger than number of scans.\r\n\t */\r\n\tif (cinfo->output_scan_number > cinfo->input_scan_number)\r\n\t  cinfo->output_scan_number = cinfo->input_scan_number;\r\n      }\r\n      return val;\r\n    case JPEG_SUSPENDED:\r\n      return val;\r\n    default:\r\n      return val;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Reset state to begin a fresh datastream.\r\n */\r\n\r\nMETHODDEF(void)\r\nreset_input_controller (j_decompress_ptr cinfo)\r\n{\r\n  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;\r\n\r\n  inputctl->pub.consume_input = consume_markers;\r\n  inputctl->pub.has_multiple_scans = FALSE; /* \"unknown\" would be better */\r\n  inputctl->pub.eoi_reached = FALSE;\r\n  inputctl->inheaders = 1;\r\n  /* Reset other modules */\r\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);\r\n  (*cinfo->marker->reset_marker_reader) (cinfo);\r\n  /* Reset progression state -- would be cleaner if entropy decoder did this */\r\n  cinfo->coef_bits = NULL;\r\n}\r\n\r\n\r\n/*\r\n * Initialize the input controller module.\r\n * This is called only once, when the decompression object is created.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_input_controller (j_decompress_ptr cinfo)\r\n{\r\n  my_inputctl_ptr inputctl;\r\n\r\n  /* Create subobject in permanent pool */\r\n  inputctl = (my_inputctl_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\r\n\t\t\t\tSIZEOF(my_input_controller));\r\n  cinfo->inputctl = &inputctl->pub;\r\n  /* Initialize method pointers */\r\n  inputctl->pub.consume_input = consume_markers;\r\n  inputctl->pub.reset_input_controller = reset_input_controller;\r\n  inputctl->pub.start_input_pass = start_input_pass;\r\n  inputctl->pub.finish_input_pass = finish_input_pass;\r\n  /* Initialize state: can't use reset_input_controller since we don't\r\n   * want to try to reset other modules yet.\r\n   */\r\n  inputctl->pub.has_multiple_scans = FALSE; /* \"unknown\" would be better */\r\n  inputctl->pub.eoi_reached = FALSE;\r\n  inputctl->inheaders = 1;\r\n}\r\n","/*\r\n * jdmainct.c\r\n *\r\n * Copyright (C) 1994-1996, Thomas G. Lane.\r\n * Modified 2002-2012 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains the main buffer controller for decompression.\r\n * The main buffer lies between the JPEG decompressor proper and the\r\n * post-processor; it holds downsampled data in the JPEG colorspace.\r\n *\r\n * Note that this code is bypassed in raw-data mode, since the application\r\n * supplies the equivalent of the main buffer in that case.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/*\r\n * In the current system design, the main buffer need never be a full-image\r\n * buffer; any full-height buffers will be found inside the coefficient or\r\n * postprocessing controllers.  Nonetheless, the main controller is not\r\n * trivial.  Its responsibility is to provide context rows for upsampling/\r\n * rescaling, and doing this in an efficient fashion is a bit tricky.\r\n *\r\n * Postprocessor input data is counted in \"row groups\".  A row group\r\n * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)\r\n * sample rows of each component.  (We require DCT_scaled_size values to be\r\n * chosen such that these numbers are integers.  In practice DCT_scaled_size\r\n * values will likely be powers of two, so we actually have the stronger\r\n * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)\r\n * Upsampling will typically produce max_v_samp_factor pixel rows from each\r\n * row group (times any additional scale factor that the upsampler is\r\n * applying).\r\n *\r\n * The coefficient controller will deliver data to us one iMCU row at a time;\r\n * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or\r\n * exactly min_DCT_scaled_size row groups.  (This amount of data corresponds\r\n * to one row of MCUs when the image is fully interleaved.)  Note that the\r\n * number of sample rows varies across components, but the number of row\r\n * groups does not.  Some garbage sample rows may be included in the last iMCU\r\n * row at the bottom of the image.\r\n *\r\n * Depending on the vertical scaling algorithm used, the upsampler may need\r\n * access to the sample row(s) above and below its current input row group.\r\n * The upsampler is required to set need_context_rows TRUE at global selection\r\n * time if so.  When need_context_rows is FALSE, this controller can simply\r\n * obtain one iMCU row at a time from the coefficient controller and dole it\r\n * out as row groups to the postprocessor.\r\n *\r\n * When need_context_rows is TRUE, this controller guarantees that the buffer\r\n * passed to postprocessing contains at least one row group's worth of samples\r\n * above and below the row group(s) being processed.  Note that the context\r\n * rows \"above\" the first passed row group appear at negative row offsets in\r\n * the passed buffer.  At the top and bottom of the image, the required\r\n * context rows are manufactured by duplicating the first or last real sample\r\n * row; this avoids having special cases in the upsampling inner loops.\r\n *\r\n * The amount of context is fixed at one row group just because that's a\r\n * convenient number for this controller to work with.  The existing\r\n * upsamplers really only need one sample row of context.  An upsampler\r\n * supporting arbitrary output rescaling might wish for more than one row\r\n * group of context when shrinking the image; tough, we don't handle that.\r\n * (This is justified by the assumption that downsizing will be handled mostly\r\n * by adjusting the DCT_scaled_size values, so that the actual scale factor at\r\n * the upsample step needn't be much less than one.)\r\n *\r\n * To provide the desired context, we have to retain the last two row groups\r\n * of one iMCU row while reading in the next iMCU row.  (The last row group\r\n * can't be processed until we have another row group for its below-context,\r\n * and so we have to save the next-to-last group too for its above-context.)\r\n * We could do this most simply by copying data around in our buffer, but\r\n * that'd be very slow.  We can avoid copying any data by creating a rather\r\n * strange pointer structure.  Here's how it works.  We allocate a workspace\r\n * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number\r\n * of row groups per iMCU row).  We create two sets of redundant pointers to\r\n * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized\r\n * pointer lists look like this:\r\n *                   M+1                          M-1\r\n * master pointer --> 0         master pointer --> 0\r\n *                    1                            1\r\n *                   ...                          ...\r\n *                   M-3                          M-3\r\n *                   M-2                           M\r\n *                   M-1                          M+1\r\n *                    M                           M-2\r\n *                   M+1                          M-1\r\n *                    0                            0\r\n * We read alternate iMCU rows using each master pointer; thus the last two\r\n * row groups of the previous iMCU row remain un-overwritten in the workspace.\r\n * The pointer lists are set up so that the required context rows appear to\r\n * be adjacent to the proper places when we pass the pointer lists to the\r\n * upsampler.\r\n *\r\n * The above pictures describe the normal state of the pointer lists.\r\n * At top and bottom of the image, we diddle the pointer lists to duplicate\r\n * the first or last sample row as necessary (this is cheaper than copying\r\n * sample rows around).\r\n *\r\n * This scheme breaks down if M < 2, ie, min_DCT_scaled_size is 1.  In that\r\n * situation each iMCU row provides only one row group so the buffering logic\r\n * must be different (eg, we must read two iMCU rows before we can emit the\r\n * first row group).  For now, we simply do not support providing context\r\n * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to\r\n * be worth providing --- if someone wants a 1/8th-size preview, they probably\r\n * want it quick and dirty, so a context-free upsampler is sufficient.\r\n */\r\n\r\n\r\n/* Private buffer controller object */\r\n\r\ntypedef struct {\r\n  struct jpeg_d_main_controller pub; /* public fields */\r\n\r\n  /* Pointer to allocated workspace (M or M+2 row groups). */\r\n  JSAMPARRAY buffer[MAX_COMPONENTS];\r\n\r\n  boolean buffer_full;\t\t/* Have we gotten an iMCU row from decoder? */\r\n  JDIMENSION rowgroup_ctr;\t/* counts row groups output to postprocessor */\r\n\r\n  /* Remaining fields are only used in the context case. */\r\n\r\n  /* These are the master pointers to the funny-order pointer lists. */\r\n  JSAMPIMAGE xbuffer[2];\t/* pointers to weird pointer lists */\r\n\r\n  int whichptr;\t\t\t/* indicates which pointer set is now in use */\r\n  int context_state;\t\t/* process_data state machine status */\r\n  JDIMENSION rowgroups_avail;\t/* row groups available to postprocessor */\r\n  JDIMENSION iMCU_row_ctr;\t/* counts iMCU rows to detect image top/bot */\r\n} my_main_controller;\r\n\r\ntypedef my_main_controller * my_main_ptr;\r\n\r\n/* context_state values: */\r\n#define CTX_PREPARE_FOR_IMCU\t0\t/* need to prepare for MCU row */\r\n#define CTX_PROCESS_IMCU\t1\t/* feeding iMCU to postprocessor */\r\n#define CTX_POSTPONED_ROW\t2\t/* feeding postponed row group */\r\n\r\n\r\n/* Forward declarations */\r\nMETHODDEF(void) process_data_simple_main\r\n\tJPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,\r\n\t     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));\r\nMETHODDEF(void) process_data_context_main\r\n\tJPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,\r\n\t     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));\r\n#ifdef QUANT_2PASS_SUPPORTED\r\nMETHODDEF(void) process_data_crank_post\r\n\tJPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,\r\n\t     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));\r\n#endif\r\n\r\n\r\nLOCAL(void)\r\nalloc_funny_pointers (j_decompress_ptr cinfo)\r\n/* Allocate space for the funny pointer lists.\r\n * This is done only once, not once per pass.\r\n */\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n  int ci, rgroup;\r\n  int M = cinfo->min_DCT_v_scaled_size;\r\n  jpeg_component_info *compptr;\r\n  JSAMPARRAY xbuf;\r\n\r\n  /* Get top-level space for component array pointers.\r\n   * We alloc both arrays with one call to save a few cycles.\r\n   */\r\n  mainp->xbuffer[0] = (JSAMPIMAGE)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tcinfo->num_components * 2 * SIZEOF(JSAMPARRAY));\r\n  mainp->xbuffer[1] = mainp->xbuffer[0] + cinfo->num_components;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\r\n      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */\r\n    /* Get space for pointer lists --- M+4 row groups in each list.\r\n     * We alloc both pointer lists with one call to save a few cycles.\r\n     */\r\n    xbuf = (JSAMPARRAY)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));\r\n    xbuf += rgroup;\t\t/* want one row group at negative offsets */\r\n    mainp->xbuffer[0][ci] = xbuf;\r\n    xbuf += rgroup * (M + 4);\r\n    mainp->xbuffer[1][ci] = xbuf;\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\nmake_funny_pointers (j_decompress_ptr cinfo)\r\n/* Create the funny pointer lists discussed in the comments above.\r\n * The actual workspace is already allocated (in main->buffer),\r\n * and the space for the pointer lists is allocated too.\r\n * This routine just fills in the curiously ordered lists.\r\n * This will be repeated at the beginning of each pass.\r\n */\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n  int ci, i, rgroup;\r\n  int M = cinfo->min_DCT_v_scaled_size;\r\n  jpeg_component_info *compptr;\r\n  JSAMPARRAY buf, xbuf0, xbuf1;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\r\n      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */\r\n    xbuf0 = mainp->xbuffer[0][ci];\r\n    xbuf1 = mainp->xbuffer[1][ci];\r\n    /* First copy the workspace pointers as-is */\r\n    buf = mainp->buffer[ci];\r\n    for (i = 0; i < rgroup * (M + 2); i++) {\r\n      xbuf0[i] = xbuf1[i] = buf[i];\r\n    }\r\n    /* In the second list, put the last four row groups in swapped order */\r\n    for (i = 0; i < rgroup * 2; i++) {\r\n      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];\r\n      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];\r\n    }\r\n    /* The wraparound pointers at top and bottom will be filled later\r\n     * (see set_wraparound_pointers, below).  Initially we want the \"above\"\r\n     * pointers to duplicate the first actual data line.  This only needs\r\n     * to happen in xbuffer[0].\r\n     */\r\n    for (i = 0; i < rgroup; i++) {\r\n      xbuf0[i - rgroup] = xbuf0[0];\r\n    }\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\nset_wraparound_pointers (j_decompress_ptr cinfo)\r\n/* Set up the \"wraparound\" pointers at top and bottom of the pointer lists.\r\n * This changes the pointer list state from top-of-image to the normal state.\r\n */\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n  int ci, i, rgroup;\r\n  int M = cinfo->min_DCT_v_scaled_size;\r\n  jpeg_component_info *compptr;\r\n  JSAMPARRAY xbuf0, xbuf1;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\r\n      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */\r\n    xbuf0 = mainp->xbuffer[0][ci];\r\n    xbuf1 = mainp->xbuffer[1][ci];\r\n    for (i = 0; i < rgroup; i++) {\r\n      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];\r\n      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];\r\n      xbuf0[rgroup*(M+2) + i] = xbuf0[i];\r\n      xbuf1[rgroup*(M+2) + i] = xbuf1[i];\r\n    }\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\nset_bottom_pointers (j_decompress_ptr cinfo)\r\n/* Change the pointer lists to duplicate the last sample row at the bottom\r\n * of the image.  whichptr indicates which xbuffer holds the final iMCU row.\r\n * Also sets rowgroups_avail to indicate number of nondummy row groups in row.\r\n */\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n  int ci, i, rgroup, iMCUheight, rows_left;\r\n  jpeg_component_info *compptr;\r\n  JSAMPARRAY xbuf;\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Count sample rows in one iMCU row and in one row group */\r\n    iMCUheight = compptr->v_samp_factor * compptr->DCT_v_scaled_size;\r\n    rgroup = iMCUheight / cinfo->min_DCT_v_scaled_size;\r\n    /* Count nondummy sample rows remaining for this component */\r\n    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);\r\n    if (rows_left == 0) rows_left = iMCUheight;\r\n    /* Count nondummy row groups.  Should get same answer for each component,\r\n     * so we need only do it once.\r\n     */\r\n    if (ci == 0) {\r\n      mainp->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);\r\n    }\r\n    /* Duplicate the last real sample row rgroup*2 times; this pads out the\r\n     * last partial rowgroup and ensures at least one full rowgroup of context.\r\n     */\r\n    xbuf = mainp->xbuffer[mainp->whichptr][ci];\r\n    for (i = 0; i < rgroup * 2; i++) {\r\n      xbuf[rows_left + i] = xbuf[rows_left-1];\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Initialize for a processing pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n\r\n  switch (pass_mode) {\r\n  case JBUF_PASS_THRU:\r\n    if (cinfo->upsample->need_context_rows) {\r\n      mainp->pub.process_data = process_data_context_main;\r\n      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */\r\n      mainp->whichptr = 0;\t/* Read first iMCU row into xbuffer[0] */\r\n      mainp->context_state = CTX_PREPARE_FOR_IMCU;\r\n      mainp->iMCU_row_ctr = 0;\r\n    } else {\r\n      /* Simple case with no context needed */\r\n      mainp->pub.process_data = process_data_simple_main;\r\n    }\r\n    mainp->buffer_full = FALSE;\t/* Mark buffer empty */\r\n    mainp->rowgroup_ctr = 0;\r\n    break;\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n  case JBUF_CRANK_DEST:\r\n    /* For last pass of 2-pass quantization, just crank the postprocessor */\r\n    mainp->pub.process_data = process_data_crank_post;\r\n    break;\r\n#endif\r\n  default:\r\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\r\n    break;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Process some data.\r\n * This handles the simple case where no context is required.\r\n */\r\n\r\nMETHODDEF(void)\r\nprocess_data_simple_main (j_decompress_ptr cinfo,\r\n\t\t\t  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t\t  JDIMENSION out_rows_avail)\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n  JDIMENSION rowgroups_avail;\r\n\r\n  /* Read input data if we haven't filled the main buffer yet */\r\n  if (! mainp->buffer_full) {\r\n    if (! (*cinfo->coef->decompress_data) (cinfo, mainp->buffer))\r\n      return;\t\t\t/* suspension forced, can do nothing more */\r\n    mainp->buffer_full = TRUE;\t/* OK, we have an iMCU row to work with */\r\n  }\r\n\r\n  /* There are always min_DCT_scaled_size row groups in an iMCU row. */\r\n  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_v_scaled_size;\r\n  /* Note: at the bottom of the image, we may pass extra garbage row groups\r\n   * to the postprocessor.  The postprocessor has to check for bottom\r\n   * of image anyway (at row resolution), so no point in us doing it too.\r\n   */\r\n\r\n  /* Feed the postprocessor */\r\n  (*cinfo->post->post_process_data) (cinfo, mainp->buffer,\r\n\t\t\t\t     &mainp->rowgroup_ctr, rowgroups_avail,\r\n\t\t\t\t     output_buf, out_row_ctr, out_rows_avail);\r\n\r\n  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */\r\n  if (mainp->rowgroup_ctr >= rowgroups_avail) {\r\n    mainp->buffer_full = FALSE;\r\n    mainp->rowgroup_ctr = 0;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Process some data.\r\n * This handles the case where context rows must be provided.\r\n */\r\n\r\nMETHODDEF(void)\r\nprocess_data_context_main (j_decompress_ptr cinfo,\r\n\t\t\t   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t\t   JDIMENSION out_rows_avail)\r\n{\r\n  my_main_ptr mainp = (my_main_ptr) cinfo->main;\r\n\r\n  /* Read input data if we haven't filled the main buffer yet */\r\n  if (! mainp->buffer_full) {\r\n    if (! (*cinfo->coef->decompress_data) (cinfo,\r\n\t\t\t\t\t   mainp->xbuffer[mainp->whichptr]))\r\n      return;\t\t\t/* suspension forced, can do nothing more */\r\n    mainp->buffer_full = TRUE;\t/* OK, we have an iMCU row to work with */\r\n    mainp->iMCU_row_ctr++;\t/* count rows received */\r\n  }\r\n\r\n  /* Postprocessor typically will not swallow all the input data it is handed\r\n   * in one call (due to filling the output buffer first).  Must be prepared\r\n   * to exit and restart.  This switch lets us keep track of how far we got.\r\n   * Note that each case falls through to the next on successful completion.\r\n   */\r\n  switch (mainp->context_state) {\r\n  case CTX_POSTPONED_ROW:\r\n    /* Call postprocessor using previously set pointers for postponed row */\r\n    (*cinfo->post->post_process_data) (cinfo, mainp->xbuffer[mainp->whichptr],\r\n\t\t\t&mainp->rowgroup_ctr, mainp->rowgroups_avail,\r\n\t\t\toutput_buf, out_row_ctr, out_rows_avail);\r\n    if (mainp->rowgroup_ctr < mainp->rowgroups_avail)\r\n      return;\t\t\t/* Need to suspend */\r\n    mainp->context_state = CTX_PREPARE_FOR_IMCU;\r\n    if (*out_row_ctr >= out_rows_avail)\r\n      return;\t\t\t/* Postprocessor exactly filled output buf */\r\n    /*FALLTHROUGH*/\r\n  case CTX_PREPARE_FOR_IMCU:\r\n    /* Prepare to process first M-1 row groups of this iMCU row */\r\n    mainp->rowgroup_ctr = 0;\r\n    mainp->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);\r\n    /* Check for bottom of image: if so, tweak pointers to \"duplicate\"\r\n     * the last sample row, and adjust rowgroups_avail to ignore padding rows.\r\n     */\r\n    if (mainp->iMCU_row_ctr == cinfo->total_iMCU_rows)\r\n      set_bottom_pointers(cinfo);\r\n    mainp->context_state = CTX_PROCESS_IMCU;\r\n    /*FALLTHROUGH*/\r\n  case CTX_PROCESS_IMCU:\r\n    /* Call postprocessor using previously set pointers */\r\n    (*cinfo->post->post_process_data) (cinfo, mainp->xbuffer[mainp->whichptr],\r\n\t\t\t&mainp->rowgroup_ctr, mainp->rowgroups_avail,\r\n\t\t\toutput_buf, out_row_ctr, out_rows_avail);\r\n    if (mainp->rowgroup_ctr < mainp->rowgroups_avail)\r\n      return;\t\t\t/* Need to suspend */\r\n    /* After the first iMCU, change wraparound pointers to normal state */\r\n    if (mainp->iMCU_row_ctr == 1)\r\n      set_wraparound_pointers(cinfo);\r\n    /* Prepare to load new iMCU row using other xbuffer list */\r\n    mainp->whichptr ^= 1;\t/* 0=>1 or 1=>0 */\r\n    mainp->buffer_full = FALSE;\r\n    /* Still need to process last row group of this iMCU row, */\r\n    /* which is saved at index M+1 of the other xbuffer */\r\n    mainp->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);\r\n    mainp->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);\r\n    mainp->context_state = CTX_POSTPONED_ROW;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Process some data.\r\n * Final pass of two-pass quantization: just call the postprocessor.\r\n * Source data will be the postprocessor controller's internal buffer.\r\n */\r\n\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n\r\nMETHODDEF(void)\r\nprocess_data_crank_post (j_decompress_ptr cinfo,\r\n\t\t\t JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t\t JDIMENSION out_rows_avail)\r\n{\r\n  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,\r\n\t\t\t\t     (JDIMENSION *) NULL, (JDIMENSION) 0,\r\n\t\t\t\t     output_buf, out_row_ctr, out_rows_avail);\r\n}\r\n\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n\r\n\r\n/*\r\n * Initialize main buffer controller.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)\r\n{\r\n  my_main_ptr mainp;\r\n  int ci, rgroup, ngroups;\r\n  jpeg_component_info *compptr;\r\n\r\n  mainp = (my_main_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_main_controller));\r\n  cinfo->main = &mainp->pub;\r\n  mainp->pub.start_pass = start_pass_main;\r\n\r\n  if (need_full_buffer)\t\t/* shouldn't happen */\r\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\r\n\r\n  /* Allocate the workspace.\r\n   * ngroups is the number of row groups we need.\r\n   */\r\n  if (cinfo->upsample->need_context_rows) {\r\n    if (cinfo->min_DCT_v_scaled_size < 2) /* unsupported, see comments above */\r\n      ERREXIT(cinfo, JERR_NOTIMPL);\r\n    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */\r\n    ngroups = cinfo->min_DCT_v_scaled_size + 2;\r\n  } else {\r\n    ngroups = cinfo->min_DCT_v_scaled_size;\r\n  }\r\n\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\r\n      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */\r\n    mainp->buffer[ci] = (*cinfo->mem->alloc_sarray)\r\n      ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n       compptr->width_in_blocks * ((JDIMENSION) compptr->DCT_h_scaled_size),\r\n       (JDIMENSION) (rgroup * ngroups));\r\n  }\r\n}\r\n","/*\r\n * jdmarker.c\r\n *\r\n * Copyright (C) 1991-1998, Thomas G. Lane.\r\n * Modified 2009-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains routines to decode JPEG datastream markers.\r\n * Most of the complexity arises from our desire to support input\r\n * suspension: if not all of the data for a marker is available,\r\n * we must exit back to the application.  On resumption, we reprocess\r\n * the marker.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\ntypedef enum {\t\t\t/* JPEG marker codes */\r\n  M_SOF0  = 0xc0,\r\n  M_SOF1  = 0xc1,\r\n  M_SOF2  = 0xc2,\r\n  M_SOF3  = 0xc3,\r\n\r\n  M_SOF5  = 0xc5,\r\n  M_SOF6  = 0xc6,\r\n  M_SOF7  = 0xc7,\r\n\r\n  M_JPG   = 0xc8,\r\n  M_SOF9  = 0xc9,\r\n  M_SOF10 = 0xca,\r\n  M_SOF11 = 0xcb,\r\n\r\n  M_SOF13 = 0xcd,\r\n  M_SOF14 = 0xce,\r\n  M_SOF15 = 0xcf,\r\n\r\n  M_DHT   = 0xc4,\r\n\r\n  M_DAC   = 0xcc,\r\n\r\n  M_RST0  = 0xd0,\r\n  M_RST1  = 0xd1,\r\n  M_RST2  = 0xd2,\r\n  M_RST3  = 0xd3,\r\n  M_RST4  = 0xd4,\r\n  M_RST5  = 0xd5,\r\n  M_RST6  = 0xd6,\r\n  M_RST7  = 0xd7,\r\n\r\n  M_SOI   = 0xd8,\r\n  M_EOI   = 0xd9,\r\n  M_SOS   = 0xda,\r\n  M_DQT   = 0xdb,\r\n  M_DNL   = 0xdc,\r\n  M_DRI   = 0xdd,\r\n  M_DHP   = 0xde,\r\n  M_EXP   = 0xdf,\r\n\r\n  M_APP0  = 0xe0,\r\n  M_APP1  = 0xe1,\r\n  M_APP2  = 0xe2,\r\n  M_APP3  = 0xe3,\r\n  M_APP4  = 0xe4,\r\n  M_APP5  = 0xe5,\r\n  M_APP6  = 0xe6,\r\n  M_APP7  = 0xe7,\r\n  M_APP8  = 0xe8,\r\n  M_APP9  = 0xe9,\r\n  M_APP10 = 0xea,\r\n  M_APP11 = 0xeb,\r\n  M_APP12 = 0xec,\r\n  M_APP13 = 0xed,\r\n  M_APP14 = 0xee,\r\n  M_APP15 = 0xef,\r\n\r\n  M_JPG0  = 0xf0,\r\n  M_JPG8  = 0xf8,\r\n  M_JPG13 = 0xfd,\r\n  M_COM   = 0xfe,\r\n\r\n  M_TEM   = 0x01,\r\n\r\n  M_ERROR = 0x100\r\n} JPEG_MARKER;\r\n\r\n\r\n/* Private state */\r\n\r\ntypedef struct {\r\n  struct jpeg_marker_reader pub; /* public fields */\r\n\r\n  /* Application-overridable marker processing methods */\r\n  jpeg_marker_parser_method process_COM;\r\n  jpeg_marker_parser_method process_APPn[16];\r\n\r\n  /* Limit on marker data length to save for each marker type */\r\n  unsigned int length_limit_COM;\r\n  unsigned int length_limit_APPn[16];\r\n\r\n  /* Status of COM/APPn marker saving */\r\n  jpeg_saved_marker_ptr cur_marker;\t/* NULL if not processing a marker */\r\n  unsigned int bytes_read;\t\t/* data bytes read so far in marker */\r\n  /* Note: cur_marker is not linked into marker_list until it's all read. */\r\n} my_marker_reader;\r\n\r\ntypedef my_marker_reader * my_marker_ptr;\r\n\r\n\r\n/*\r\n * Macros for fetching data from the data source module.\r\n *\r\n * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect\r\n * the current restart point; we update them only when we have reached a\r\n * suitable place to restart if a suspension occurs.\r\n */\r\n\r\n/* Declare and initialize local copies of input pointer/count */\r\n#define INPUT_VARS(cinfo)  \\\r\n\tstruct jpeg_source_mgr * datasrc = (cinfo)->src;  \\\r\n\tconst JOCTET * next_input_byte = datasrc->next_input_byte;  \\\r\n\tsize_t bytes_in_buffer = datasrc->bytes_in_buffer\r\n\r\n/* Unload the local copies --- do this only at a restart boundary */\r\n#define INPUT_SYNC(cinfo)  \\\r\n\t( datasrc->next_input_byte = next_input_byte,  \\\r\n\t  datasrc->bytes_in_buffer = bytes_in_buffer )\r\n\r\n/* Reload the local copies --- used only in MAKE_BYTE_AVAIL */\r\n#define INPUT_RELOAD(cinfo)  \\\r\n\t( next_input_byte = datasrc->next_input_byte,  \\\r\n\t  bytes_in_buffer = datasrc->bytes_in_buffer )\r\n\r\n/* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.\r\n * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,\r\n * but we must reload the local copies after a successful fill.\r\n */\r\n#define MAKE_BYTE_AVAIL(cinfo,action)  \\\r\n\tif (bytes_in_buffer == 0) {  \\\r\n\t  if (! (*datasrc->fill_input_buffer) (cinfo))  \\\r\n\t    { action; }  \\\r\n\t  INPUT_RELOAD(cinfo);  \\\r\n\t}\r\n\r\n/* Read a byte into variable V.\r\n * If must suspend, take the specified action (typically \"return FALSE\").\r\n */\r\n#define INPUT_BYTE(cinfo,V,action)  \\\r\n\tMAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\r\n\t\t  bytes_in_buffer--; \\\r\n\t\t  V = GETJOCTET(*next_input_byte++); )\r\n\r\n/* As above, but read two bytes interpreted as an unsigned 16-bit integer.\r\n * V should be declared unsigned int or perhaps INT32.\r\n */\r\n#define INPUT_2BYTES(cinfo,V,action)  \\\r\n\tMAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\r\n\t\t  bytes_in_buffer--; \\\r\n\t\t  V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \\\r\n\t\t  MAKE_BYTE_AVAIL(cinfo,action); \\\r\n\t\t  bytes_in_buffer--; \\\r\n\t\t  V += GETJOCTET(*next_input_byte++); )\r\n\r\n\r\n/*\r\n * Routines to process JPEG markers.\r\n *\r\n * Entry condition: JPEG marker itself has been read and its code saved\r\n *   in cinfo->unread_marker; input restart point is just after the marker.\r\n *\r\n * Exit: if return TRUE, have read and processed any parameters, and have\r\n *   updated the restart point to point after the parameters.\r\n *   If return FALSE, was forced to suspend before reaching end of\r\n *   marker parameters; restart point has not been moved.  Same routine\r\n *   will be called again after application supplies more input data.\r\n *\r\n * This approach to suspension assumes that all of a marker's parameters\r\n * can fit into a single input bufferload.  This should hold for \"normal\"\r\n * markers.  Some COM/APPn markers might have large parameter segments\r\n * that might not fit.  If we are simply dropping such a marker, we use\r\n * skip_input_data to get past it, and thereby put the problem on the\r\n * source manager's shoulders.  If we are saving the marker's contents\r\n * into memory, we use a slightly different convention: when forced to\r\n * suspend, the marker processor updates the restart point to the end of\r\n * what it's consumed (ie, the end of the buffer) before returning FALSE.\r\n * On resumption, cinfo->unread_marker still contains the marker code,\r\n * but the data source will point to the next chunk of marker data.\r\n * The marker processor must retain internal state to deal with this.\r\n *\r\n * Note that we don't bother to avoid duplicate trace messages if a\r\n * suspension occurs within marker parameters.  Other side effects\r\n * require more care.\r\n */\r\n\r\n\r\nLOCAL(boolean)\r\nget_soi (j_decompress_ptr cinfo)\r\n/* Process an SOI marker */\r\n{\r\n  int i;\r\n  \r\n  TRACEMS(cinfo, 1, JTRC_SOI);\r\n\r\n  if (cinfo->marker->saw_SOI)\r\n    ERREXIT(cinfo, JERR_SOI_DUPLICATE);\r\n\r\n  /* Reset all parameters that are defined to be reset by SOI */\r\n\r\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\r\n    cinfo->arith_dc_L[i] = 0;\r\n    cinfo->arith_dc_U[i] = 1;\r\n    cinfo->arith_ac_K[i] = 5;\r\n  }\r\n  cinfo->restart_interval = 0;\r\n\r\n  /* Set initial assumptions for colorspace etc */\r\n\r\n  cinfo->jpeg_color_space = JCS_UNKNOWN;\r\n  cinfo->color_transform = JCT_NONE;\r\n  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */\r\n\r\n  cinfo->saw_JFIF_marker = FALSE;\r\n  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */\r\n  cinfo->JFIF_minor_version = 1;\r\n  cinfo->density_unit = 0;\r\n  cinfo->X_density = 1;\r\n  cinfo->Y_density = 1;\r\n  cinfo->saw_Adobe_marker = FALSE;\r\n  cinfo->Adobe_transform = 0;\r\n\r\n  cinfo->marker->saw_SOI = TRUE;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\nLOCAL(boolean)\r\nget_sof (j_decompress_ptr cinfo, boolean is_baseline, boolean is_prog,\r\n\t boolean is_arith)\r\n/* Process a SOFn marker */\r\n{\r\n  INT32 length;\r\n  int c, ci, i;\r\n  jpeg_component_info * compptr;\r\n  INPUT_VARS(cinfo);\r\n\r\n  cinfo->is_baseline = is_baseline;\r\n  cinfo->progressive_mode = is_prog;\r\n  cinfo->arith_code = is_arith;\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n\r\n  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);\r\n  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);\r\n  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);\r\n  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);\r\n\r\n  length -= 8;\r\n\r\n  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,\r\n\t   (int) cinfo->image_width, (int) cinfo->image_height,\r\n\t   cinfo->num_components);\r\n\r\n  if (cinfo->marker->saw_SOF)\r\n    ERREXIT(cinfo, JERR_SOF_DUPLICATE);\r\n\r\n  /* We don't support files in which the image height is initially specified */\r\n  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */\r\n  /* might as well have a general sanity check. */\r\n  if (cinfo->image_height <= 0 || cinfo->image_width <= 0 ||\r\n      cinfo->num_components <= 0)\r\n    ERREXIT(cinfo, JERR_EMPTY_IMAGE);\r\n\r\n  if (length != (cinfo->num_components * 3))\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  if (cinfo->comp_info == NULL)\t/* do only once, even if suspend */\r\n    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)\r\n\t\t\t((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t cinfo->num_components * SIZEOF(jpeg_component_info));\r\n\r\n  for (ci = 0; ci < cinfo->num_components; ci++) {\r\n    INPUT_BYTE(cinfo, c, return FALSE);\r\n    /* Check to see whether component id has already been seen   */\r\n    /* (in violation of the spec, but unfortunately seen in some */\r\n    /* files).  If so, create \"fake\" component id equal to the   */\r\n    /* max id seen so far + 1. */\r\n    for (i = 0, compptr = cinfo->comp_info; i < ci; i++, compptr++) {\r\n      if (c == compptr->component_id) {\r\n\tcompptr = cinfo->comp_info;\r\n\tc = compptr->component_id;\r\n\tcompptr++;\r\n\tfor (i = 1; i < ci; i++, compptr++) {\r\n\t  if (compptr->component_id > c) c = compptr->component_id;\r\n\t}\r\n\tc++;\r\n\tbreak;\r\n      }\r\n    }\r\n    compptr->component_id = c;\r\n    compptr->component_index = ci;\r\n    INPUT_BYTE(cinfo, c, return FALSE);\r\n    compptr->h_samp_factor = (c >> 4) & 15;\r\n    compptr->v_samp_factor = (c     ) & 15;\r\n    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);\r\n\r\n    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,\r\n\t     compptr->component_id, compptr->h_samp_factor,\r\n\t     compptr->v_samp_factor, compptr->quant_tbl_no);\r\n  }\r\n\r\n  cinfo->marker->saw_SOF = TRUE;\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\nLOCAL(boolean)\r\nget_sos (j_decompress_ptr cinfo)\r\n/* Process a SOS marker */\r\n{\r\n  INT32 length;\r\n  int c, ci, i, n;\r\n  jpeg_component_info * compptr;\r\n  INPUT_VARS(cinfo);\r\n\r\n  if (! cinfo->marker->saw_SOF)\r\n    ERREXITS(cinfo, JERR_SOF_BEFORE, \"SOS\");\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n\r\n  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */\r\n\r\n  TRACEMS1(cinfo, 1, JTRC_SOS, n);\r\n\r\n  if (length != (n * 2 + 6) || n > MAX_COMPS_IN_SCAN ||\r\n      (n == 0 && !cinfo->progressive_mode))\r\n      /* pseudo SOS marker only allowed in progressive mode */\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  cinfo->comps_in_scan = n;\r\n\r\n  /* Collect the component-spec parameters */\r\n\r\n  for (i = 0; i < n; i++) {\r\n    INPUT_BYTE(cinfo, c, return FALSE);\r\n\r\n    /* Detect the case where component id's are not unique, and, if so, */\r\n    /* create a fake component id using the same logic as in get_sof.   */\r\n    /* Note:  This also ensures that all of the SOF components are      */\r\n    /* referenced in the single scan case, which prevents access to     */\r\n    /* uninitialized memory in later decoding stages. */\r\n    for (ci = 0; ci < i; ci++) {\r\n      if (c == cinfo->cur_comp_info[ci]->component_id) {\r\n\tc = cinfo->cur_comp_info[0]->component_id;\r\n\tfor (ci = 1; ci < i; ci++) {\r\n\t  compptr = cinfo->cur_comp_info[ci];\r\n\t  if (compptr->component_id > c) c = compptr->component_id;\r\n\t}\r\n\tc++;\r\n\tbreak;\r\n      }\r\n    }\r\n\r\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n\t ci++, compptr++) {\r\n      if (c == compptr->component_id)\r\n\tgoto id_found;\r\n    }\r\n\r\n    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, c);\r\n\r\n  id_found:\r\n\r\n    cinfo->cur_comp_info[i] = compptr;\r\n    INPUT_BYTE(cinfo, c, return FALSE);\r\n    compptr->dc_tbl_no = (c >> 4) & 15;\r\n    compptr->ac_tbl_no = (c     ) & 15;\r\n\r\n    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, compptr->component_id,\r\n\t     compptr->dc_tbl_no, compptr->ac_tbl_no);\r\n  }\r\n\r\n  /* Collect the additional scan parameters Ss, Se, Ah/Al. */\r\n  INPUT_BYTE(cinfo, c, return FALSE);\r\n  cinfo->Ss = c;\r\n  INPUT_BYTE(cinfo, c, return FALSE);\r\n  cinfo->Se = c;\r\n  INPUT_BYTE(cinfo, c, return FALSE);\r\n  cinfo->Ah = (c >> 4) & 15;\r\n  cinfo->Al = (c     ) & 15;\r\n\r\n  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,\r\n\t   cinfo->Ah, cinfo->Al);\r\n\r\n  /* Prepare to scan data & restart markers */\r\n  cinfo->marker->next_restart_num = 0;\r\n\r\n  /* Count another (non-pseudo) SOS marker */\r\n  if (n) cinfo->input_scan_number++;\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\n#ifdef D_ARITH_CODING_SUPPORTED\r\n\r\nLOCAL(boolean)\r\nget_dac (j_decompress_ptr cinfo)\r\n/* Process a DAC marker */\r\n{\r\n  INT32 length;\r\n  int index, val;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n  length -= 2;\r\n  \r\n  while (length > 0) {\r\n    INPUT_BYTE(cinfo, index, return FALSE);\r\n    INPUT_BYTE(cinfo, val, return FALSE);\r\n\r\n    length -= 2;\r\n\r\n    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);\r\n\r\n    if (index < 0 || index >= (2*NUM_ARITH_TBLS))\r\n      ERREXIT1(cinfo, JERR_DAC_INDEX, index);\r\n\r\n    if (index >= NUM_ARITH_TBLS) { /* define AC table */\r\n      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;\r\n    } else {\t\t\t/* define DC table */\r\n      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);\r\n      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);\r\n      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])\r\n\tERREXIT1(cinfo, JERR_DAC_VALUE, val);\r\n    }\r\n  }\r\n\r\n  if (length != 0)\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n#else /* ! D_ARITH_CODING_SUPPORTED */\r\n\r\n#define get_dac(cinfo)  skip_variable(cinfo)\r\n\r\n#endif /* D_ARITH_CODING_SUPPORTED */\r\n\r\n\r\nLOCAL(boolean)\r\nget_dht (j_decompress_ptr cinfo)\r\n/* Process a DHT marker */\r\n{\r\n  INT32 length;\r\n  UINT8 bits[17];\r\n  UINT8 huffval[256];\r\n  int i, index, count;\r\n  JHUFF_TBL **htblptr;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n  length -= 2;\r\n  \r\n  while (length > 16) {\r\n    INPUT_BYTE(cinfo, index, return FALSE);\r\n\r\n    TRACEMS1(cinfo, 1, JTRC_DHT, index);\r\n      \r\n    bits[0] = 0;\r\n    count = 0;\r\n    for (i = 1; i <= 16; i++) {\r\n      INPUT_BYTE(cinfo, bits[i], return FALSE);\r\n      count += bits[i];\r\n    }\r\n\r\n    length -= 1 + 16;\r\n\r\n    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,\r\n\t     bits[1], bits[2], bits[3], bits[4],\r\n\t     bits[5], bits[6], bits[7], bits[8]);\r\n    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,\r\n\t     bits[9], bits[10], bits[11], bits[12],\r\n\t     bits[13], bits[14], bits[15], bits[16]);\r\n\r\n    /* Here we just do minimal validation of the counts to avoid walking\r\n     * off the end of our table space.  jdhuff.c will check more carefully.\r\n     */\r\n    if (count > 256 || ((INT32) count) > length)\r\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\r\n\r\n    MEMZERO(huffval, SIZEOF(huffval)); /* pre-zero array for later copy */\r\n\r\n    for (i = 0; i < count; i++)\r\n      INPUT_BYTE(cinfo, huffval[i], return FALSE);\r\n\r\n    length -= count;\r\n\r\n    if (index & 0x10) {\t\t/* AC table definition */\r\n      index -= 0x10;\r\n      htblptr = &cinfo->ac_huff_tbl_ptrs[index];\r\n    } else {\t\t\t/* DC table definition */\r\n      htblptr = &cinfo->dc_huff_tbl_ptrs[index];\r\n    }\r\n\r\n    if (index < 0 || index >= NUM_HUFF_TBLS)\r\n      ERREXIT1(cinfo, JERR_DHT_INDEX, index);\r\n\r\n    if (*htblptr == NULL)\r\n      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);\r\n  \r\n    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));\r\n    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));\r\n  }\r\n\r\n  if (length != 0)\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\nLOCAL(boolean)\r\nget_dqt (j_decompress_ptr cinfo)\r\n/* Process a DQT marker */\r\n{\r\n  INT32 length, count, i;\r\n  int n, prec;\r\n  unsigned int tmp;\r\n  JQUANT_TBL *quant_ptr;\r\n  const int *natural_order;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n  length -= 2;\r\n\r\n  while (length > 0) {\r\n    length--;\r\n    INPUT_BYTE(cinfo, n, return FALSE);\r\n    prec = n >> 4;\r\n    n &= 0x0F;\r\n\r\n    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);\r\n\r\n    if (n >= NUM_QUANT_TBLS)\r\n      ERREXIT1(cinfo, JERR_DQT_INDEX, n);\r\n      \r\n    if (cinfo->quant_tbl_ptrs[n] == NULL)\r\n      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);\r\n    quant_ptr = cinfo->quant_tbl_ptrs[n];\r\n\r\n    if (prec) {\r\n      if (length < DCTSIZE2 * 2) {\r\n\t/* Initialize full table for safety. */\r\n\tfor (i = 0; i < DCTSIZE2; i++) {\r\n\t  quant_ptr->quantval[i] = 1;\r\n\t}\r\n\tcount = length >> 1;\r\n      } else\r\n\tcount = DCTSIZE2;\r\n    } else {\r\n      if (length < DCTSIZE2) {\r\n\t/* Initialize full table for safety. */\r\n\tfor (i = 0; i < DCTSIZE2; i++) {\r\n\t  quant_ptr->quantval[i] = 1;\r\n\t}\r\n\tcount = length;\r\n      } else\r\n\tcount = DCTSIZE2;\r\n    }\r\n\r\n    switch (count) {\r\n    case (2*2): natural_order = jpeg_natural_order2; break;\r\n    case (3*3): natural_order = jpeg_natural_order3; break;\r\n    case (4*4): natural_order = jpeg_natural_order4; break;\r\n    case (5*5): natural_order = jpeg_natural_order5; break;\r\n    case (6*6): natural_order = jpeg_natural_order6; break;\r\n    case (7*7): natural_order = jpeg_natural_order7; break;\r\n    default:    natural_order = jpeg_natural_order;  break;\r\n    }\r\n\r\n    for (i = 0; i < count; i++) {\r\n      if (prec)\r\n\tINPUT_2BYTES(cinfo, tmp, return FALSE);\r\n      else\r\n\tINPUT_BYTE(cinfo, tmp, return FALSE);\r\n      /* We convert the zigzag-order table to natural array order. */\r\n      quant_ptr->quantval[natural_order[i]] = (UINT16) tmp;\r\n    }\r\n\r\n    if (cinfo->err->trace_level >= 2) {\r\n      for (i = 0; i < DCTSIZE2; i += 8) {\r\n\tTRACEMS8(cinfo, 2, JTRC_QUANTVALS,\r\n\t\t quant_ptr->quantval[i],   quant_ptr->quantval[i+1],\r\n\t\t quant_ptr->quantval[i+2], quant_ptr->quantval[i+3],\r\n\t\t quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],\r\n\t\t quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);\r\n      }\r\n    }\r\n\r\n    length -= count;\r\n    if (prec) length -= count;\r\n  }\r\n\r\n  if (length != 0)\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\nLOCAL(boolean)\r\nget_dri (j_decompress_ptr cinfo)\r\n/* Process a DRI marker */\r\n{\r\n  INT32 length;\r\n  unsigned int tmp;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n  \r\n  if (length != 4)\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n\r\n  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);\r\n\r\n  cinfo->restart_interval = tmp;\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\nLOCAL(boolean)\r\nget_lse (j_decompress_ptr cinfo)\r\n/* Process an LSE marker */\r\n{\r\n  INT32 length;\r\n  unsigned int tmp;\r\n  int cid;\r\n  INPUT_VARS(cinfo);\r\n\r\n  if (! cinfo->marker->saw_SOF)\r\n    ERREXITS(cinfo, JERR_SOF_BEFORE, \"LSE\");\r\n\r\n  if (cinfo->num_components < 3) goto bad;\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n\r\n  if (length != 24)\r\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\r\n\r\n  INPUT_BYTE(cinfo, tmp, return FALSE);\r\n  if (tmp != 0x0D)\t/* ID inverse transform specification */\r\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != MAXJSAMPLE) goto bad;\t\t/* MAXTRANS */\r\n  INPUT_BYTE(cinfo, tmp, return FALSE);\r\n  if (tmp != 3) goto bad;\t\t\t/* Nt=3 */\r\n  INPUT_BYTE(cinfo, cid, return FALSE);\r\n  if (cid != cinfo->comp_info[1].component_id) goto bad;\r\n  INPUT_BYTE(cinfo, cid, return FALSE);\r\n  if (cid != cinfo->comp_info[0].component_id) goto bad;\r\n  INPUT_BYTE(cinfo, cid, return FALSE);\r\n  if (cid != cinfo->comp_info[2].component_id) goto bad;\r\n  INPUT_BYTE(cinfo, tmp, return FALSE);\r\n  if (tmp != 0x80) goto bad;\t\t/* F1: CENTER1=1, NORM1=0 */\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != 0) goto bad;\t\t\t/* A(1,1)=0 */\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != 0) goto bad;\t\t\t/* A(1,2)=0 */\r\n  INPUT_BYTE(cinfo, tmp, return FALSE);\r\n  if (tmp != 0) goto bad;\t\t/* F2: CENTER2=0, NORM2=0 */\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != 1) goto bad;\t\t\t/* A(2,1)=1 */\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != 0) goto bad;\t\t\t/* A(2,2)=0 */\r\n  INPUT_BYTE(cinfo, tmp, return FALSE);\r\n  if (tmp != 0) goto bad;\t\t/* F3: CENTER3=0, NORM3=0 */\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != 1) goto bad;\t\t\t/* A(3,1)=1 */\r\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\r\n  if (tmp != 0) {\t\t\t\t/* A(3,2)=0 */\r\n    bad:\r\n    ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\r\n  }\r\n\r\n  /* OK, valid transform that we can handle. */\r\n  cinfo->color_transform = JCT_SUBTRACT_GREEN;\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Routines for processing APPn and COM markers.\r\n * These are either saved in memory or discarded, per application request.\r\n * APP0 and APP14 are specially checked to see if they are\r\n * JFIF and Adobe markers, respectively.\r\n */\r\n\r\n#define APP0_DATA_LEN\t14\t/* Length of interesting data in APP0 */\r\n#define APP14_DATA_LEN\t12\t/* Length of interesting data in APP14 */\r\n#define APPN_DATA_LEN\t14\t/* Must be the largest of the above!! */\r\n\r\n\r\nLOCAL(void)\r\nexamine_app0 (j_decompress_ptr cinfo, JOCTET FAR * data,\r\n\t      unsigned int datalen, INT32 remaining)\r\n/* Examine first few bytes from an APP0.\r\n * Take appropriate action if it is a JFIF marker.\r\n * datalen is # of bytes at data[], remaining is length of rest of marker data.\r\n */\r\n{\r\n  INT32 totallen = (INT32) datalen + remaining;\r\n\r\n  if (datalen >= APP0_DATA_LEN &&\r\n      GETJOCTET(data[0]) == 0x4A &&\r\n      GETJOCTET(data[1]) == 0x46 &&\r\n      GETJOCTET(data[2]) == 0x49 &&\r\n      GETJOCTET(data[3]) == 0x46 &&\r\n      GETJOCTET(data[4]) == 0) {\r\n    /* Found JFIF APP0 marker: save info */\r\n    cinfo->saw_JFIF_marker = TRUE;\r\n    cinfo->JFIF_major_version = GETJOCTET(data[5]);\r\n    cinfo->JFIF_minor_version = GETJOCTET(data[6]);\r\n    cinfo->density_unit = GETJOCTET(data[7]);\r\n    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);\r\n    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);\r\n    /* Check version.\r\n     * Major version must be 1 or 2, anything else signals an incompatible\r\n     * change.\r\n     * (We used to treat this as an error, but now it's a nonfatal warning,\r\n     * because some bozo at Hijaak couldn't read the spec.)\r\n     * Minor version should be 0..2, but process anyway if newer.\r\n     */\r\n    if (cinfo->JFIF_major_version != 1 && cinfo->JFIF_major_version != 2)\r\n      WARNMS2(cinfo, JWRN_JFIF_MAJOR,\r\n\t      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);\r\n    /* Generate trace messages */\r\n    TRACEMS5(cinfo, 1, JTRC_JFIF,\r\n\t     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,\r\n\t     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);\r\n    /* Validate thumbnail dimensions and issue appropriate messages */\r\n    if (GETJOCTET(data[12]) | GETJOCTET(data[13]))\r\n      TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL,\r\n\t       GETJOCTET(data[12]), GETJOCTET(data[13]));\r\n    totallen -= APP0_DATA_LEN;\r\n    if (totallen !=\r\n\t((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13]) * (INT32) 3))\r\n      TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) totallen);\r\n  } else if (datalen >= 6 &&\r\n      GETJOCTET(data[0]) == 0x4A &&\r\n      GETJOCTET(data[1]) == 0x46 &&\r\n      GETJOCTET(data[2]) == 0x58 &&\r\n      GETJOCTET(data[3]) == 0x58 &&\r\n      GETJOCTET(data[4]) == 0) {\r\n    /* Found JFIF \"JFXX\" extension APP0 marker */\r\n    /* The library doesn't actually do anything with these,\r\n     * but we try to produce a helpful trace message.\r\n     */\r\n    switch (GETJOCTET(data[5])) {\r\n    case 0x10:\r\n      TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);\r\n      break;\r\n    case 0x11:\r\n      TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);\r\n      break;\r\n    case 0x13:\r\n      TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);\r\n      break;\r\n    default:\r\n      TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,\r\n\t       GETJOCTET(data[5]), (int) totallen);\r\n      break;\r\n    }\r\n  } else {\r\n    /* Start of APP0 does not match \"JFIF\" or \"JFXX\", or too short */\r\n    TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\nexamine_app14 (j_decompress_ptr cinfo, JOCTET FAR * data,\r\n\t       unsigned int datalen, INT32 remaining)\r\n/* Examine first few bytes from an APP14.\r\n * Take appropriate action if it is an Adobe marker.\r\n * datalen is # of bytes at data[], remaining is length of rest of marker data.\r\n */\r\n{\r\n  unsigned int version, flags0, flags1, transform;\r\n\r\n  if (datalen >= APP14_DATA_LEN &&\r\n      GETJOCTET(data[0]) == 0x41 &&\r\n      GETJOCTET(data[1]) == 0x64 &&\r\n      GETJOCTET(data[2]) == 0x6F &&\r\n      GETJOCTET(data[3]) == 0x62 &&\r\n      GETJOCTET(data[4]) == 0x65) {\r\n    /* Found Adobe APP14 marker */\r\n    version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);\r\n    flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);\r\n    flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);\r\n    transform = GETJOCTET(data[11]);\r\n    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);\r\n    cinfo->saw_Adobe_marker = TRUE;\r\n    cinfo->Adobe_transform = (UINT8) transform;\r\n  } else {\r\n    /* Start of APP14 does not match \"Adobe\", or too short */\r\n    TRACEMS1(cinfo, 1, JTRC_APP14, (int) (datalen + remaining));\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(boolean)\r\nget_interesting_appn (j_decompress_ptr cinfo)\r\n/* Process an APP0 or APP14 marker without saving it */\r\n{\r\n  INT32 length;\r\n  JOCTET b[APPN_DATA_LEN];\r\n  unsigned int i, numtoread;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n  length -= 2;\r\n\r\n  /* get the interesting part of the marker data */\r\n  if (length >= APPN_DATA_LEN)\r\n    numtoread = APPN_DATA_LEN;\r\n  else if (length > 0)\r\n    numtoread = (unsigned int) length;\r\n  else\r\n    numtoread = 0;\r\n  for (i = 0; i < numtoread; i++)\r\n    INPUT_BYTE(cinfo, b[i], return FALSE);\r\n  length -= numtoread;\r\n\r\n  /* process it */\r\n  switch (cinfo->unread_marker) {\r\n  case M_APP0:\r\n    examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);\r\n    break;\r\n  case M_APP14:\r\n    examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);\r\n    break;\r\n  default:\r\n    /* can't get here unless jpeg_save_markers chooses wrong processor */\r\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);\r\n    break;\r\n  }\r\n\r\n  /* skip any remaining data -- could be lots */\r\n  INPUT_SYNC(cinfo);\r\n  if (length > 0)\r\n    (*cinfo->src->skip_input_data) (cinfo, (long) length);\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n#ifdef SAVE_MARKERS_SUPPORTED\r\n\r\nMETHODDEF(boolean)\r\nsave_marker (j_decompress_ptr cinfo)\r\n/* Save an APPn or COM marker into the marker list */\r\n{\r\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\r\n  jpeg_saved_marker_ptr cur_marker = marker->cur_marker;\r\n  unsigned int bytes_read, data_length;\r\n  JOCTET FAR * data;\r\n  INT32 length = 0;\r\n  INPUT_VARS(cinfo);\r\n\r\n  if (cur_marker == NULL) {\r\n    /* begin reading a marker */\r\n    INPUT_2BYTES(cinfo, length, return FALSE);\r\n    length -= 2;\r\n    if (length >= 0) {\t\t/* watch out for bogus length word */\r\n      /* figure out how much we want to save */\r\n      unsigned int limit;\r\n      if (cinfo->unread_marker == (int) M_COM)\r\n\tlimit = marker->length_limit_COM;\r\n      else\r\n\tlimit = marker->length_limit_APPn[cinfo->unread_marker - (int) M_APP0];\r\n      if ((unsigned int) length < limit)\r\n\tlimit = (unsigned int) length;\r\n      /* allocate and initialize the marker item */\r\n      cur_marker = (jpeg_saved_marker_ptr)\r\n\t(*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t    SIZEOF(struct jpeg_marker_struct) + limit);\r\n      cur_marker->next = NULL;\r\n      cur_marker->marker = (UINT8) cinfo->unread_marker;\r\n      cur_marker->original_length = (unsigned int) length;\r\n      cur_marker->data_length = limit;\r\n      /* data area is just beyond the jpeg_marker_struct */\r\n      data = cur_marker->data = (JOCTET FAR *) (cur_marker + 1);\r\n      marker->cur_marker = cur_marker;\r\n      marker->bytes_read = 0;\r\n      bytes_read = 0;\r\n      data_length = limit;\r\n    } else {\r\n      /* deal with bogus length word */\r\n      bytes_read = data_length = 0;\r\n      data = NULL;\r\n    }\r\n  } else {\r\n    /* resume reading a marker */\r\n    bytes_read = marker->bytes_read;\r\n    data_length = cur_marker->data_length;\r\n    data = cur_marker->data + bytes_read;\r\n  }\r\n\r\n  while (bytes_read < data_length) {\r\n    INPUT_SYNC(cinfo);\t\t/* move the restart point to here */\r\n    marker->bytes_read = bytes_read;\r\n    /* If there's not at least one byte in buffer, suspend */\r\n    MAKE_BYTE_AVAIL(cinfo, return FALSE);\r\n    /* Copy bytes with reasonable rapidity */\r\n    while (bytes_read < data_length && bytes_in_buffer > 0) {\r\n      *data++ = *next_input_byte++;\r\n      bytes_in_buffer--;\r\n      bytes_read++;\r\n    }\r\n  }\r\n\r\n  /* Done reading what we want to read */\r\n  if (cur_marker != NULL) {\t/* will be NULL if bogus length word */\r\n    /* Add new marker to end of list */\r\n    if (cinfo->marker_list == NULL) {\r\n      cinfo->marker_list = cur_marker;\r\n    } else {\r\n      jpeg_saved_marker_ptr prev = cinfo->marker_list;\r\n      while (prev->next != NULL)\r\n\tprev = prev->next;\r\n      prev->next = cur_marker;\r\n    }\r\n    /* Reset pointer & calc remaining data length */\r\n    data = cur_marker->data;\r\n    length = cur_marker->original_length - data_length;\r\n  }\r\n  /* Reset to initial state for next marker */\r\n  marker->cur_marker = NULL;\r\n\r\n  /* Process the marker if interesting; else just make a generic trace msg */\r\n  switch (cinfo->unread_marker) {\r\n  case M_APP0:\r\n    examine_app0(cinfo, data, data_length, length);\r\n    break;\r\n  case M_APP14:\r\n    examine_app14(cinfo, data, data_length, length);\r\n    break;\r\n  default:\r\n    TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,\r\n\t     (int) (data_length + length));\r\n    break;\r\n  }\r\n\r\n  /* skip any remaining data -- could be lots */\r\n  INPUT_SYNC(cinfo);\t\t/* do before skip_input_data */\r\n  if (length > 0)\r\n    (*cinfo->src->skip_input_data) (cinfo, (long) length);\r\n\r\n  return TRUE;\r\n}\r\n\r\n#endif /* SAVE_MARKERS_SUPPORTED */\r\n\r\n\r\nMETHODDEF(boolean)\r\nskip_variable (j_decompress_ptr cinfo)\r\n/* Skip over an unknown or uninteresting variable-length marker */\r\n{\r\n  INT32 length;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_2BYTES(cinfo, length, return FALSE);\r\n  length -= 2;\r\n  \r\n  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);\r\n\r\n  INPUT_SYNC(cinfo);\t\t/* do before skip_input_data */\r\n  if (length > 0)\r\n    (*cinfo->src->skip_input_data) (cinfo, (long) length);\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Find the next JPEG marker, save it in cinfo->unread_marker.\r\n * Returns FALSE if had to suspend before reaching a marker;\r\n * in that case cinfo->unread_marker is unchanged.\r\n *\r\n * Note that the result might not be a valid marker code,\r\n * but it will never be 0 or FF.\r\n */\r\n\r\nLOCAL(boolean)\r\nnext_marker (j_decompress_ptr cinfo)\r\n{\r\n  int c;\r\n  INPUT_VARS(cinfo);\r\n\r\n  for (;;) {\r\n    INPUT_BYTE(cinfo, c, return FALSE);\r\n    /* Skip any non-FF bytes.\r\n     * This may look a bit inefficient, but it will not occur in a valid file.\r\n     * We sync after each discarded byte so that a suspending data source\r\n     * can discard the byte from its buffer.\r\n     */\r\n    while (c != 0xFF) {\r\n      cinfo->marker->discarded_bytes++;\r\n      INPUT_SYNC(cinfo);\r\n      INPUT_BYTE(cinfo, c, return FALSE);\r\n    }\r\n    /* This loop swallows any duplicate FF bytes.  Extra FFs are legal as\r\n     * pad bytes, so don't count them in discarded_bytes.  We assume there\r\n     * will not be so many consecutive FF bytes as to overflow a suspending\r\n     * data source's input buffer.\r\n     */\r\n    do {\r\n      INPUT_BYTE(cinfo, c, return FALSE);\r\n    } while (c == 0xFF);\r\n    if (c != 0)\r\n      break;\t\t\t/* found a valid marker, exit loop */\r\n    /* Reach here if we found a stuffed-zero data sequence (FF/00).\r\n     * Discard it and loop back to try again.\r\n     */\r\n    cinfo->marker->discarded_bytes += 2;\r\n    INPUT_SYNC(cinfo);\r\n  }\r\n\r\n  if (cinfo->marker->discarded_bytes != 0) {\r\n    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);\r\n    cinfo->marker->discarded_bytes = 0;\r\n  }\r\n\r\n  cinfo->unread_marker = c;\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\nLOCAL(boolean)\r\nfirst_marker (j_decompress_ptr cinfo)\r\n/* Like next_marker, but used to obtain the initial SOI marker. */\r\n/* For this marker, we do not allow preceding garbage or fill; otherwise,\r\n * we might well scan an entire input file before realizing it ain't JPEG.\r\n * If an application wants to process non-JFIF files, it must seek to the\r\n * SOI before calling the JPEG library.\r\n */\r\n{\r\n  int c, c2;\r\n  INPUT_VARS(cinfo);\r\n\r\n  INPUT_BYTE(cinfo, c, return FALSE);\r\n  INPUT_BYTE(cinfo, c2, return FALSE);\r\n  if (c != 0xFF || c2 != (int) M_SOI)\r\n    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);\r\n\r\n  cinfo->unread_marker = c2;\r\n\r\n  INPUT_SYNC(cinfo);\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Read markers until SOS or EOI.\r\n *\r\n * Returns same codes as are defined for jpeg_consume_input:\r\n * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.\r\n *\r\n * Note: This function may return a pseudo SOS marker (with zero\r\n * component number) for treat by input controller's consume_input.\r\n * consume_input itself should filter out (skip) the pseudo marker\r\n * after processing for the caller.\r\n */\r\n\r\nMETHODDEF(int)\r\nread_markers (j_decompress_ptr cinfo)\r\n{\r\n  /* Outer loop repeats once for each marker. */\r\n  for (;;) {\r\n    /* Collect the marker proper, unless we already did. */\r\n    /* NB: first_marker() enforces the requirement that SOI appear first. */\r\n    if (cinfo->unread_marker == 0) {\r\n      if (! cinfo->marker->saw_SOI) {\r\n\tif (! first_marker(cinfo))\r\n\t  return JPEG_SUSPENDED;\r\n      } else {\r\n\tif (! next_marker(cinfo))\r\n\t  return JPEG_SUSPENDED;\r\n      }\r\n    }\r\n    /* At this point cinfo->unread_marker contains the marker code and the\r\n     * input point is just past the marker proper, but before any parameters.\r\n     * A suspension will cause us to return with this state still true.\r\n     */\r\n    switch (cinfo->unread_marker) {\r\n    case M_SOI:\r\n      if (! get_soi(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_SOF0:\t\t/* Baseline */\r\n      if (! get_sof(cinfo, TRUE, FALSE, FALSE))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_SOF1:\t\t/* Extended sequential, Huffman */\r\n      if (! get_sof(cinfo, FALSE, FALSE, FALSE))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_SOF2:\t\t/* Progressive, Huffman */\r\n      if (! get_sof(cinfo, FALSE, TRUE, FALSE))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_SOF9:\t\t/* Extended sequential, arithmetic */\r\n      if (! get_sof(cinfo, FALSE, FALSE, TRUE))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_SOF10:\t\t/* Progressive, arithmetic */\r\n      if (! get_sof(cinfo, FALSE, TRUE, TRUE))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    /* Currently unsupported SOFn types */\r\n    case M_SOF3:\t\t/* Lossless, Huffman */\r\n    case M_SOF5:\t\t/* Differential sequential, Huffman */\r\n    case M_SOF6:\t\t/* Differential progressive, Huffman */\r\n    case M_SOF7:\t\t/* Differential lossless, Huffman */\r\n    case M_JPG:\t\t\t/* Reserved for JPEG extensions */\r\n    case M_SOF11:\t\t/* Lossless, arithmetic */\r\n    case M_SOF13:\t\t/* Differential sequential, arithmetic */\r\n    case M_SOF14:\t\t/* Differential progressive, arithmetic */\r\n    case M_SOF15:\t\t/* Differential lossless, arithmetic */\r\n      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);\r\n      break;\r\n\r\n    case M_SOS:\r\n      if (! get_sos(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      cinfo->unread_marker = 0;\t/* processed the marker */\r\n      return JPEG_REACHED_SOS;\r\n\r\n    case M_EOI:\r\n      TRACEMS(cinfo, 1, JTRC_EOI);\r\n      cinfo->unread_marker = 0;\t/* processed the marker */\r\n      return JPEG_REACHED_EOI;\r\n\r\n    case M_DAC:\r\n      if (! get_dac(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_DHT:\r\n      if (! get_dht(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_DQT:\r\n      if (! get_dqt(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_DRI:\r\n      if (! get_dri(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_JPG8:\r\n      if (! get_lse(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_APP0:\r\n    case M_APP1:\r\n    case M_APP2:\r\n    case M_APP3:\r\n    case M_APP4:\r\n    case M_APP5:\r\n    case M_APP6:\r\n    case M_APP7:\r\n    case M_APP8:\r\n    case M_APP9:\r\n    case M_APP10:\r\n    case M_APP11:\r\n    case M_APP12:\r\n    case M_APP13:\r\n    case M_APP14:\r\n    case M_APP15:\r\n      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[\r\n\t\tcinfo->unread_marker - (int) M_APP0]) (cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_COM:\r\n      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    case M_RST0:\t\t/* these are all parameterless */\r\n    case M_RST1:\r\n    case M_RST2:\r\n    case M_RST3:\r\n    case M_RST4:\r\n    case M_RST5:\r\n    case M_RST6:\r\n    case M_RST7:\r\n    case M_TEM:\r\n      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);\r\n      break;\r\n\r\n    case M_DNL:\t\t\t/* Ignore DNL ... perhaps the wrong thing */\r\n      if (! skip_variable(cinfo))\r\n\treturn JPEG_SUSPENDED;\r\n      break;\r\n\r\n    default:\t\t\t/* must be DHP, EXP, JPGn, or RESn */\r\n      /* For now, we treat the reserved markers as fatal errors since they are\r\n       * likely to be used to signal incompatible JPEG Part 3 extensions.\r\n       * Once the JPEG 3 version-number marker is well defined, this code\r\n       * ought to change!\r\n       */\r\n      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);\r\n      break;\r\n    }\r\n    /* Successfully processed marker, so reset state variable */\r\n    cinfo->unread_marker = 0;\r\n  } /* end loop */\r\n}\r\n\r\n\r\n/*\r\n * Read a restart marker, which is expected to appear next in the datastream;\r\n * if the marker is not there, take appropriate recovery action.\r\n * Returns FALSE if suspension is required.\r\n *\r\n * This is called by the entropy decoder after it has read an appropriate\r\n * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder\r\n * has already read a marker from the data source.  Under normal conditions\r\n * cinfo->unread_marker will be reset to 0 before returning; if not reset,\r\n * it holds a marker which the decoder will be unable to read past.\r\n */\r\n\r\nMETHODDEF(boolean)\r\nread_restart_marker (j_decompress_ptr cinfo)\r\n{\r\n  /* Obtain a marker unless we already did. */\r\n  /* Note that next_marker will complain if it skips any data. */\r\n  if (cinfo->unread_marker == 0) {\r\n    if (! next_marker(cinfo))\r\n      return FALSE;\r\n  }\r\n\r\n  if (cinfo->unread_marker ==\r\n      ((int) M_RST0 + cinfo->marker->next_restart_num)) {\r\n    /* Normal case --- swallow the marker and let entropy decoder continue */\r\n    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);\r\n    cinfo->unread_marker = 0;\r\n  } else {\r\n    /* Uh-oh, the restart markers have been messed up. */\r\n    /* Let the data source manager determine how to resync. */\r\n    if (! (*cinfo->src->resync_to_restart) (cinfo,\r\n\t\t\t\t\t    cinfo->marker->next_restart_num))\r\n      return FALSE;\r\n  }\r\n\r\n  /* Update next-restart state */\r\n  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;\r\n\r\n  return TRUE;\r\n}\r\n\r\n\r\n/*\r\n * This is the default resync_to_restart method for data source managers\r\n * to use if they don't have any better approach.  Some data source managers\r\n * may be able to back up, or may have additional knowledge about the data\r\n * which permits a more intelligent recovery strategy; such managers would\r\n * presumably supply their own resync method.\r\n *\r\n * read_restart_marker calls resync_to_restart if it finds a marker other than\r\n * the restart marker it was expecting.  (This code is *not* used unless\r\n * a nonzero restart interval has been declared.)  cinfo->unread_marker is\r\n * the marker code actually found (might be anything, except 0 or FF).\r\n * The desired restart marker number (0..7) is passed as a parameter.\r\n * This routine is supposed to apply whatever error recovery strategy seems\r\n * appropriate in order to position the input stream to the next data segment.\r\n * Note that cinfo->unread_marker is treated as a marker appearing before\r\n * the current data-source input point; usually it should be reset to zero\r\n * before returning.\r\n * Returns FALSE if suspension is required.\r\n *\r\n * This implementation is substantially constrained by wanting to treat the\r\n * input as a data stream; this means we can't back up.  Therefore, we have\r\n * only the following actions to work with:\r\n *   1. Simply discard the marker and let the entropy decoder resume at next\r\n *      byte of file.\r\n *   2. Read forward until we find another marker, discarding intervening\r\n *      data.  (In theory we could look ahead within the current bufferload,\r\n *      without having to discard data if we don't find the desired marker.\r\n *      This idea is not implemented here, in part because it makes behavior\r\n *      dependent on buffer size and chance buffer-boundary positions.)\r\n *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).\r\n *      This will cause the entropy decoder to process an empty data segment,\r\n *      inserting dummy zeroes, and then we will reprocess the marker.\r\n *\r\n * #2 is appropriate if we think the desired marker lies ahead, while #3 is\r\n * appropriate if the found marker is a future restart marker (indicating\r\n * that we have missed the desired restart marker, probably because it got\r\n * corrupted).\r\n * We apply #2 or #3 if the found marker is a restart marker no more than\r\n * two counts behind or ahead of the expected one.  We also apply #2 if the\r\n * found marker is not a legal JPEG marker code (it's certainly bogus data).\r\n * If the found marker is a restart marker more than 2 counts away, we do #1\r\n * (too much risk that the marker is erroneous; with luck we will be able to\r\n * resync at some future point).\r\n * For any valid non-restart JPEG marker, we apply #3.  This keeps us from\r\n * overrunning the end of a scan.  An implementation limited to single-scan\r\n * files might find it better to apply #2 for markers other than EOI, since\r\n * any other marker would have to be bogus data in that case.\r\n */\r\n\r\nGLOBAL(boolean)\r\njpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)\r\n{\r\n  int marker = cinfo->unread_marker;\r\n  int action = 1;\r\n  \r\n  /* Always put up a warning. */\r\n  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);\r\n  \r\n  /* Outer loop handles repeated decision after scanning forward. */\r\n  for (;;) {\r\n    if (marker < (int) M_SOF0)\r\n      action = 2;\t\t/* invalid marker */\r\n    else if (marker < (int) M_RST0 || marker > (int) M_RST7)\r\n      action = 3;\t\t/* valid non-restart marker */\r\n    else {\r\n      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||\r\n\t  marker == ((int) M_RST0 + ((desired+2) & 7)))\r\n\taction = 3;\t\t/* one of the next two expected restarts */\r\n      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||\r\n\t       marker == ((int) M_RST0 + ((desired-2) & 7)))\r\n\taction = 2;\t\t/* a prior restart, so advance */\r\n      else\r\n\taction = 1;\t\t/* desired restart or too far away */\r\n    }\r\n    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);\r\n    switch (action) {\r\n    case 1:\r\n      /* Discard marker and let entropy decoder resume processing. */\r\n      cinfo->unread_marker = 0;\r\n      return TRUE;\r\n    case 2:\r\n      /* Scan to the next marker, and repeat the decision loop. */\r\n      if (! next_marker(cinfo))\r\n\treturn FALSE;\r\n      marker = cinfo->unread_marker;\r\n      break;\r\n    case 3:\r\n      /* Return without advancing past this marker. */\r\n      /* Entropy decoder will be forced to process an empty segment. */\r\n      return TRUE;\r\n    }\r\n  } /* end loop */\r\n}\r\n\r\n\r\n/*\r\n * Reset marker processing state to begin a fresh datastream.\r\n */\r\n\r\nMETHODDEF(void)\r\nreset_marker_reader (j_decompress_ptr cinfo)\r\n{\r\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\r\n\r\n  cinfo->comp_info = NULL;\t\t/* until allocated by get_sof */\r\n  cinfo->input_scan_number = 0;\t\t/* no SOS seen yet */\r\n  cinfo->unread_marker = 0;\t\t/* no pending marker */\r\n  marker->pub.saw_SOI = FALSE;\t\t/* set internal state too */\r\n  marker->pub.saw_SOF = FALSE;\r\n  marker->pub.discarded_bytes = 0;\r\n  marker->cur_marker = NULL;\r\n}\r\n\r\n\r\n/*\r\n * Initialize the marker reader module.\r\n * This is called only once, when the decompression object is created.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_marker_reader (j_decompress_ptr cinfo)\r\n{\r\n  my_marker_ptr marker;\r\n  int i;\r\n\r\n  /* Create subobject in permanent pool */\r\n  marker = (my_marker_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\r\n\t\t\t\tSIZEOF(my_marker_reader));\r\n  cinfo->marker = &marker->pub;\r\n  /* Initialize public method pointers */\r\n  marker->pub.reset_marker_reader = reset_marker_reader;\r\n  marker->pub.read_markers = read_markers;\r\n  marker->pub.read_restart_marker = read_restart_marker;\r\n  /* Initialize COM/APPn processing.\r\n   * By default, we examine and then discard APP0 and APP14,\r\n   * but simply discard COM and all other APPn.\r\n   */\r\n  marker->process_COM = skip_variable;\r\n  marker->length_limit_COM = 0;\r\n  for (i = 0; i < 16; i++) {\r\n    marker->process_APPn[i] = skip_variable;\r\n    marker->length_limit_APPn[i] = 0;\r\n  }\r\n  marker->process_APPn[0] = get_interesting_appn;\r\n  marker->process_APPn[14] = get_interesting_appn;\r\n  /* Reset marker processing state */\r\n  reset_marker_reader(cinfo);\r\n}\r\n\r\n\r\n/*\r\n * Control saving of COM and APPn markers into marker_list.\r\n */\r\n\r\n#ifdef SAVE_MARKERS_SUPPORTED\r\n\r\nGLOBAL(void)\r\njpeg_save_markers (j_decompress_ptr cinfo, int marker_code,\r\n\t\t   unsigned int length_limit)\r\n{\r\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\r\n  long maxlength;\r\n  jpeg_marker_parser_method processor;\r\n\r\n  /* Length limit mustn't be larger than what we can allocate\r\n   * (should only be a concern in a 16-bit environment).\r\n   */\r\n  maxlength = cinfo->mem->max_alloc_chunk - SIZEOF(struct jpeg_marker_struct);\r\n  if (((long) length_limit) > maxlength)\r\n    length_limit = (unsigned int) maxlength;\r\n\r\n  /* Choose processor routine to use.\r\n   * APP0/APP14 have special requirements.\r\n   */\r\n  if (length_limit) {\r\n    processor = save_marker;\r\n    /* If saving APP0/APP14, save at least enough for our internal use. */\r\n    if (marker_code == (int) M_APP0 && length_limit < APP0_DATA_LEN)\r\n      length_limit = APP0_DATA_LEN;\r\n    else if (marker_code == (int) M_APP14 && length_limit < APP14_DATA_LEN)\r\n      length_limit = APP14_DATA_LEN;\r\n  } else {\r\n    processor = skip_variable;\r\n    /* If discarding APP0/APP14, use our regular on-the-fly processor. */\r\n    if (marker_code == (int) M_APP0 || marker_code == (int) M_APP14)\r\n      processor = get_interesting_appn;\r\n  }\r\n\r\n  if (marker_code == (int) M_COM) {\r\n    marker->process_COM = processor;\r\n    marker->length_limit_COM = length_limit;\r\n  } else if (marker_code >= (int) M_APP0 && marker_code <= (int) M_APP15) {\r\n    marker->process_APPn[marker_code - (int) M_APP0] = processor;\r\n    marker->length_limit_APPn[marker_code - (int) M_APP0] = length_limit;\r\n  } else\r\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);\r\n}\r\n\r\n#endif /* SAVE_MARKERS_SUPPORTED */\r\n\r\n\r\n/*\r\n * Install a special processing method for COM or APPn markers.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,\r\n\t\t\t   jpeg_marker_parser_method routine)\r\n{\r\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\r\n\r\n  if (marker_code == (int) M_COM)\r\n    marker->process_COM = routine;\r\n  else if (marker_code >= (int) M_APP0 && marker_code <= (int) M_APP15)\r\n    marker->process_APPn[marker_code - (int) M_APP0] = routine;\r\n  else\r\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);\r\n}\r\n","/*\r\n * jdmaster.c\r\n *\r\n * Copyright (C) 1991-1997, Thomas G. Lane.\r\n * Modified 2002-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains master control logic for the JPEG decompressor.\r\n * These routines are concerned with selecting the modules to be executed\r\n * and with determining the number of passes and the work to be done in each\r\n * pass.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Private state */\r\n\r\ntypedef struct {\r\n  struct jpeg_decomp_master pub; /* public fields */\r\n\r\n  int pass_number;\t\t/* # of passes completed */\r\n\r\n  boolean using_merged_upsample; /* TRUE if using merged upsample/cconvert */\r\n\r\n  /* Saved references to initialized quantizer modules,\r\n   * in case we need to switch modes.\r\n   */\r\n  struct jpeg_color_quantizer * quantizer_1pass;\r\n  struct jpeg_color_quantizer * quantizer_2pass;\r\n} my_decomp_master;\r\n\r\ntypedef my_decomp_master * my_master_ptr;\r\n\r\n\r\n/*\r\n * Determine whether merged upsample/color conversion should be used.\r\n * CRUCIAL: this must match the actual capabilities of jdmerge.c!\r\n */\r\n\r\nLOCAL(boolean)\r\nuse_merged_upsample (j_decompress_ptr cinfo)\r\n{\r\n#ifdef UPSAMPLE_MERGING_SUPPORTED\r\n  /* Merging is the equivalent of plain box-filter upsampling */\r\n  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)\r\n    return FALSE;\r\n  /* jdmerge.c only supports YCC=>RGB color conversion */\r\n  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||\r\n      cinfo->out_color_space != JCS_RGB ||\r\n      cinfo->out_color_components != RGB_PIXELSIZE ||\r\n      cinfo->color_transform)\r\n    return FALSE;\r\n  /* and it only handles 2h1v or 2h2v sampling ratios */\r\n  if (cinfo->comp_info[0].h_samp_factor != 2 ||\r\n      cinfo->comp_info[1].h_samp_factor != 1 ||\r\n      cinfo->comp_info[2].h_samp_factor != 1 ||\r\n      cinfo->comp_info[0].v_samp_factor >  2 ||\r\n      cinfo->comp_info[1].v_samp_factor != 1 ||\r\n      cinfo->comp_info[2].v_samp_factor != 1)\r\n    return FALSE;\r\n  /* furthermore, it doesn't work if we've scaled the IDCTs differently */\r\n  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||\r\n      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||\r\n      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||\r\n      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||\r\n      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||\r\n      cinfo->comp_info[2].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size)\r\n    return FALSE;\r\n  /* ??? also need to test for upsample-time rescaling, when & if supported */\r\n  return TRUE;\t\t\t/* by golly, it'll work... */\r\n#else\r\n  return FALSE;\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n * Compute output image dimensions and related values.\r\n * NOTE: this is exported for possible use by application.\r\n * Hence it mustn't do anything that can't be done twice.\r\n * Also note that it may be called before the master module is initialized!\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_calc_output_dimensions (j_decompress_ptr cinfo)\r\n/* Do computations that are needed before master selection phase.\r\n * This function is used for full decompression.\r\n */\r\n{\r\n#ifdef IDCT_SCALING_SUPPORTED\r\n  int ci;\r\n  jpeg_component_info *compptr;\r\n#endif\r\n\r\n  /* Prevent application from calling me at wrong times */\r\n  if (cinfo->global_state != DSTATE_READY)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n\r\n  /* Compute core output image dimensions and DCT scaling choices. */\r\n  jpeg_core_output_dimensions(cinfo);\r\n\r\n#ifdef IDCT_SCALING_SUPPORTED\r\n\r\n  /* In selecting the actual DCT scaling for each component, we try to\r\n   * scale up the chroma components via IDCT scaling rather than upsampling.\r\n   * This saves time if the upsampler gets to use 1:1 scaling.\r\n   * Note this code adapts subsampling ratios which are powers of 2.\r\n   */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    int ssize = 1;\r\n    while (cinfo->min_DCT_h_scaled_size * ssize <=\r\n\t   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&\r\n\t   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {\r\n      ssize = ssize * 2;\r\n    }\r\n    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;\r\n    ssize = 1;\r\n    while (cinfo->min_DCT_v_scaled_size * ssize <=\r\n\t   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&\r\n\t   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {\r\n      ssize = ssize * 2;\r\n    }\r\n    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;\r\n\r\n    /* We don't support IDCT ratios larger than 2. */\r\n    if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)\r\n\tcompptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size * 2;\r\n    else if (compptr->DCT_v_scaled_size > compptr->DCT_h_scaled_size * 2)\r\n\tcompptr->DCT_v_scaled_size = compptr->DCT_h_scaled_size * 2;\r\n  }\r\n\r\n  /* Recompute downsampled dimensions of components;\r\n   * application needs to know these if using raw downsampled data.\r\n   */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Size in samples, after IDCT scaling */\r\n    compptr->downsampled_width = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_width *\r\n\t\t    (long) (compptr->h_samp_factor * compptr->DCT_h_scaled_size),\r\n\t\t    (long) (cinfo->max_h_samp_factor * cinfo->block_size));\r\n    compptr->downsampled_height = (JDIMENSION)\r\n      jdiv_round_up((long) cinfo->image_height *\r\n\t\t    (long) (compptr->v_samp_factor * compptr->DCT_v_scaled_size),\r\n\t\t    (long) (cinfo->max_v_samp_factor * cinfo->block_size));\r\n  }\r\n\r\n#endif /* IDCT_SCALING_SUPPORTED */\r\n\r\n  /* Report number of components in selected colorspace. */\r\n  /* Probably this should be in the color conversion module... */\r\n  switch (cinfo->out_color_space) {\r\n  case JCS_GRAYSCALE:\r\n    cinfo->out_color_components = 1;\r\n    break;\r\n  case JCS_RGB:\r\n  case JCS_BG_RGB:\r\n    cinfo->out_color_components = RGB_PIXELSIZE;\r\n    break;\r\n  case JCS_YCbCr:\r\n  case JCS_BG_YCC:\r\n    cinfo->out_color_components = 3;\r\n    break;\r\n  case JCS_CMYK:\r\n  case JCS_YCCK:\r\n    cinfo->out_color_components = 4;\r\n    break;\r\n  default:\t\t\t/* else must be same colorspace as in file */\r\n    cinfo->out_color_components = cinfo->num_components;\r\n    break;\r\n  }\r\n  cinfo->output_components = (cinfo->quantize_colors ? 1 :\r\n\t\t\t      cinfo->out_color_components);\r\n\r\n  /* See if upsampler will want to emit more than one row at a time */\r\n  if (use_merged_upsample(cinfo))\r\n    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;\r\n  else\r\n    cinfo->rec_outbuf_height = 1;\r\n}\r\n\r\n\r\n/*\r\n * Several decompression processes need to range-limit values to the range\r\n * 0..MAXJSAMPLE; the input value may fall somewhat outside this range\r\n * due to noise introduced by quantization, roundoff error, etc.  These\r\n * processes are inner loops and need to be as fast as possible.  On most\r\n * machines, particularly CPUs with pipelines or instruction prefetch,\r\n * a (subscript-check-less) C table lookup\r\n *\t\tx = sample_range_limit[x];\r\n * is faster than explicit tests\r\n *\t\tif (x < 0)  x = 0;\r\n *\t\telse if (x > MAXJSAMPLE)  x = MAXJSAMPLE;\r\n * These processes all use a common table prepared by the routine below.\r\n *\r\n * For most steps we can mathematically guarantee that the initial value\r\n * of x is within MAXJSAMPLE+1 of the legal range, so a table running from\r\n * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial\r\n * limiting step (just after the IDCT), a wildly out-of-range value is \r\n * possible if the input data is corrupt.  To avoid any chance of indexing\r\n * off the end of memory and getting a bad-pointer trap, we perform the\r\n * post-IDCT limiting thus:\r\n *\t\tx = range_limit[x & MASK];\r\n * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit\r\n * samples.  Under normal circumstances this is more than enough range and\r\n * a correct output will be generated; with bogus input data the mask will\r\n * cause wraparound, and we will safely generate a bogus-but-in-range output.\r\n * For the post-IDCT step, we want to convert the data from signed to unsigned\r\n * representation by adding CENTERJSAMPLE at the same time that we limit it.\r\n * So the post-IDCT limiting table ends up looking like this:\r\n *   CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,\r\n *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),\r\n *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),\r\n *   0,1,...,CENTERJSAMPLE-1\r\n * Negative inputs select values from the upper half of the table after\r\n * masking.\r\n *\r\n * We can save some space by overlapping the start of the post-IDCT table\r\n * with the simpler range limiting table.  The post-IDCT table begins at\r\n * sample_range_limit + CENTERJSAMPLE.\r\n *\r\n * Note that the table is allocated in near data space on PCs; it's small\r\n * enough and used often enough to justify this.\r\n */\r\n\r\nLOCAL(void)\r\nprepare_range_limit_table (j_decompress_ptr cinfo)\r\n/* Allocate and fill in the sample_range_limit table */\r\n{\r\n  JSAMPLE * table;\r\n  int i;\r\n\r\n  table = (JSAMPLE *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));\r\n  table += (MAXJSAMPLE+1);\t/* allow negative subscripts of simple table */\r\n  cinfo->sample_range_limit = table;\r\n  /* First segment of \"simple\" table: limit[x] = 0 for x < 0 */\r\n  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));\r\n  /* Main part of \"simple\" table: limit[x] = x */\r\n  for (i = 0; i <= MAXJSAMPLE; i++)\r\n    table[i] = (JSAMPLE) i;\r\n  table += CENTERJSAMPLE;\t/* Point to where post-IDCT table starts */\r\n  /* End of simple table, rest of first half of post-IDCT table */\r\n  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)\r\n    table[i] = MAXJSAMPLE;\r\n  /* Second half of post-IDCT table */\r\n  MEMZERO(table + (2 * (MAXJSAMPLE+1)),\r\n\t  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));\r\n  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),\r\n\t  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));\r\n}\r\n\r\n\r\n/*\r\n * Master selection of decompression modules.\r\n * This is done once at jpeg_start_decompress time.  We determine\r\n * which modules will be used and give them appropriate initialization calls.\r\n * We also initialize the decompressor input side to begin consuming data.\r\n *\r\n * Since jpeg_read_header has finished, we know what is in the SOF\r\n * and (first) SOS markers.  We also have all the application parameter\r\n * settings.\r\n */\r\n\r\nLOCAL(void)\r\nmaster_selection (j_decompress_ptr cinfo)\r\n{\r\n  my_master_ptr master = (my_master_ptr) cinfo->master;\r\n  boolean use_c_buffer;\r\n  long samplesperrow;\r\n  JDIMENSION jd_samplesperrow;\r\n\r\n  /* For now, precision must match compiled-in value... */\r\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\r\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\r\n\r\n  /* Initialize dimensions and other stuff */\r\n  jpeg_calc_output_dimensions(cinfo);\r\n  prepare_range_limit_table(cinfo);\r\n\r\n  /* Sanity check on image dimensions */\r\n  if (cinfo->output_height <= 0 || cinfo->output_width <= 0 ||\r\n      cinfo->out_color_components <= 0)\r\n    ERREXIT(cinfo, JERR_EMPTY_IMAGE);\r\n\r\n  /* Width of an output scanline must be representable as JDIMENSION. */\r\n  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;\r\n  jd_samplesperrow = (JDIMENSION) samplesperrow;\r\n  if ((long) jd_samplesperrow != samplesperrow)\r\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\r\n\r\n  /* Initialize my private state */\r\n  master->pass_number = 0;\r\n  master->using_merged_upsample = use_merged_upsample(cinfo);\r\n\r\n  /* Color quantizer selection */\r\n  master->quantizer_1pass = NULL;\r\n  master->quantizer_2pass = NULL;\r\n  /* No mode changes if not using buffered-image mode. */\r\n  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {\r\n    cinfo->enable_1pass_quant = FALSE;\r\n    cinfo->enable_external_quant = FALSE;\r\n    cinfo->enable_2pass_quant = FALSE;\r\n  }\r\n  if (cinfo->quantize_colors) {\r\n    if (cinfo->raw_data_out)\r\n      ERREXIT(cinfo, JERR_NOTIMPL);\r\n    /* 2-pass quantizer only works in 3-component color space. */\r\n    if (cinfo->out_color_components != 3) {\r\n      cinfo->enable_1pass_quant = TRUE;\r\n      cinfo->enable_external_quant = FALSE;\r\n      cinfo->enable_2pass_quant = FALSE;\r\n      cinfo->colormap = NULL;\r\n    } else if (cinfo->colormap != NULL) {\r\n      cinfo->enable_external_quant = TRUE;\r\n    } else if (cinfo->two_pass_quantize) {\r\n      cinfo->enable_2pass_quant = TRUE;\r\n    } else {\r\n      cinfo->enable_1pass_quant = TRUE;\r\n    }\r\n\r\n    if (cinfo->enable_1pass_quant) {\r\n#ifdef QUANT_1PASS_SUPPORTED\r\n      jinit_1pass_quantizer(cinfo);\r\n      master->quantizer_1pass = cinfo->cquantize;\r\n#else\r\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif\r\n    }\r\n\r\n    /* We use the 2-pass code to map to external colormaps. */\r\n    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n      jinit_2pass_quantizer(cinfo);\r\n      master->quantizer_2pass = cinfo->cquantize;\r\n#else\r\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif\r\n    }\r\n    /* If both quantizers are initialized, the 2-pass one is left active;\r\n     * this is necessary for starting with quantization to an external map.\r\n     */\r\n  }\r\n\r\n  /* Post-processing: in particular, color conversion first */\r\n  if (! cinfo->raw_data_out) {\r\n    if (master->using_merged_upsample) {\r\n#ifdef UPSAMPLE_MERGING_SUPPORTED\r\n      jinit_merged_upsampler(cinfo); /* does color conversion too */\r\n#else\r\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif\r\n    } else {\r\n      jinit_color_deconverter(cinfo);\r\n      jinit_upsampler(cinfo);\r\n    }\r\n    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);\r\n  }\r\n  /* Inverse DCT */\r\n  jinit_inverse_dct(cinfo);\r\n  /* Entropy decoding: either Huffman or arithmetic coding. */\r\n  if (cinfo->arith_code)\r\n    jinit_arith_decoder(cinfo);\r\n  else {\r\n    jinit_huff_decoder(cinfo);\r\n  }\r\n\r\n  /* Initialize principal buffer controllers. */\r\n  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;\r\n  jinit_d_coef_controller(cinfo, use_c_buffer);\r\n\r\n  if (! cinfo->raw_data_out)\r\n    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);\r\n\r\n  /* We can now tell the memory manager to allocate virtual arrays. */\r\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);\r\n\r\n  /* Initialize input side of decompressor to consume first scan. */\r\n  (*cinfo->inputctl->start_input_pass) (cinfo);\r\n\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n  /* If jpeg_start_decompress will read the whole file, initialize\r\n   * progress monitoring appropriately.  The input step is counted\r\n   * as one pass.\r\n   */\r\n  if (cinfo->progress != NULL && ! cinfo->buffered_image &&\r\n      cinfo->inputctl->has_multiple_scans) {\r\n    int nscans;\r\n    /* Estimate number of scans to set pass_limit. */\r\n    if (cinfo->progressive_mode) {\r\n      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */\r\n      nscans = 2 + 3 * cinfo->num_components;\r\n    } else {\r\n      /* For a nonprogressive multiscan file, estimate 1 scan per component. */\r\n      nscans = cinfo->num_components;\r\n    }\r\n    cinfo->progress->pass_counter = 0L;\r\n    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;\r\n    cinfo->progress->completed_passes = 0;\r\n    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);\r\n    /* Count the input pass as done */\r\n    master->pass_number++;\r\n  }\r\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\r\n}\r\n\r\n\r\n/*\r\n * Per-pass setup.\r\n * This is called at the beginning of each output pass.  We determine which\r\n * modules will be active during this pass and give them appropriate\r\n * start_pass calls.  We also set is_dummy_pass to indicate whether this\r\n * is a \"real\" output pass or a dummy pass for color quantization.\r\n * (In the latter case, jdapistd.c will crank the pass to completion.)\r\n */\r\n\r\nMETHODDEF(void)\r\nprepare_for_output_pass (j_decompress_ptr cinfo)\r\n{\r\n  my_master_ptr master = (my_master_ptr) cinfo->master;\r\n\r\n  if (master->pub.is_dummy_pass) {\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n    /* Final pass of 2-pass quantization */\r\n    master->pub.is_dummy_pass = FALSE;\r\n    (*cinfo->cquantize->start_pass) (cinfo, FALSE);\r\n    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);\r\n    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);\r\n#else\r\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n  } else {\r\n    if (cinfo->quantize_colors && cinfo->colormap == NULL) {\r\n      /* Select new quantization method */\r\n      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {\r\n\tcinfo->cquantize = master->quantizer_2pass;\r\n\tmaster->pub.is_dummy_pass = TRUE;\r\n      } else if (cinfo->enable_1pass_quant) {\r\n\tcinfo->cquantize = master->quantizer_1pass;\r\n      } else {\r\n\tERREXIT(cinfo, JERR_MODE_CHANGE);\r\n      }\r\n    }\r\n    (*cinfo->idct->start_pass) (cinfo);\r\n    (*cinfo->coef->start_output_pass) (cinfo);\r\n    if (! cinfo->raw_data_out) {\r\n      if (! master->using_merged_upsample)\r\n\t(*cinfo->cconvert->start_pass) (cinfo);\r\n      (*cinfo->upsample->start_pass) (cinfo);\r\n      if (cinfo->quantize_colors)\r\n\t(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);\r\n      (*cinfo->post->start_pass) (cinfo,\r\n\t    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));\r\n      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);\r\n    }\r\n  }\r\n\r\n  /* Set up progress monitor's pass info if present */\r\n  if (cinfo->progress != NULL) {\r\n    cinfo->progress->completed_passes = master->pass_number;\r\n    cinfo->progress->total_passes = master->pass_number +\r\n\t\t\t\t    (master->pub.is_dummy_pass ? 2 : 1);\r\n    /* In buffered-image mode, we assume one more output pass if EOI not\r\n     * yet reached, but no more passes if EOI has been reached.\r\n     */\r\n    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {\r\n      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Finish up at end of an output pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nfinish_output_pass (j_decompress_ptr cinfo)\r\n{\r\n  my_master_ptr master = (my_master_ptr) cinfo->master;\r\n\r\n  if (cinfo->quantize_colors)\r\n    (*cinfo->cquantize->finish_pass) (cinfo);\r\n  master->pass_number++;\r\n}\r\n\r\n\r\n#ifdef D_MULTISCAN_FILES_SUPPORTED\r\n\r\n/*\r\n * Switch to a new external colormap between output passes.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_new_colormap (j_decompress_ptr cinfo)\r\n{\r\n  my_master_ptr master = (my_master_ptr) cinfo->master;\r\n\r\n  /* Prevent application from calling me at wrong times */\r\n  if (cinfo->global_state != DSTATE_BUFIMAGE)\r\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\r\n\r\n  if (cinfo->quantize_colors && cinfo->enable_external_quant &&\r\n      cinfo->colormap != NULL) {\r\n    /* Select 2-pass quantizer for external colormap use */\r\n    cinfo->cquantize = master->quantizer_2pass;\r\n    /* Notify quantizer of colormap change */\r\n    (*cinfo->cquantize->new_color_map) (cinfo);\r\n    master->pub.is_dummy_pass = FALSE; /* just in case */\r\n  } else\r\n    ERREXIT(cinfo, JERR_MODE_CHANGE);\r\n}\r\n\r\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\r\n\r\n\r\n/*\r\n * Initialize master decompression control and select active modules.\r\n * This is performed at the start of jpeg_start_decompress.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_master_decompress (j_decompress_ptr cinfo)\r\n{\r\n  my_master_ptr master;\r\n\r\n  master = (my_master_ptr)\r\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t  SIZEOF(my_decomp_master));\r\n  cinfo->master = &master->pub;\r\n  master->pub.prepare_for_output_pass = prepare_for_output_pass;\r\n  master->pub.finish_output_pass = finish_output_pass;\r\n\r\n  master->pub.is_dummy_pass = FALSE;\r\n\r\n  master_selection(cinfo);\r\n}\r\n","/*\r\n * jdmerge.c\r\n *\r\n * Copyright (C) 1994-1996, Thomas G. Lane.\r\n * Modified 2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains code for merged upsampling/color conversion.\r\n *\r\n * This file combines functions from jdsample.c and jdcolor.c;\r\n * read those files first to understand what's going on.\r\n *\r\n * When the chroma components are to be upsampled by simple replication\r\n * (ie, box filtering), we can save some work in color conversion by\r\n * calculating all the output pixels corresponding to a pair of chroma\r\n * samples at one time.  In the conversion equations\r\n *\tR = Y           + K1 * Cr\r\n *\tG = Y + K2 * Cb + K3 * Cr\r\n *\tB = Y + K4 * Cb\r\n * only the Y term varies among the group of pixels corresponding to a pair\r\n * of chroma samples, so the rest of the terms can be calculated just once.\r\n * At typical sampling ratios, this eliminates half or three-quarters of the\r\n * multiplications needed for color conversion.\r\n *\r\n * This file currently provides implementations for the following cases:\r\n *\tYCbCr => RGB color conversion only.\r\n *\tSampling ratios of 2h1v or 2h2v.\r\n *\tNo scaling needed at upsample time.\r\n *\tCorner-aligned (non-CCIR601) sampling alignment.\r\n * Other special cases could be added, but in most applications these are\r\n * the only common cases.  (For uncommon cases we fall back on the more\r\n * general code in jdsample.c and jdcolor.c.)\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n#ifdef UPSAMPLE_MERGING_SUPPORTED\r\n\r\n\r\n/* Private subobject */\r\n\r\ntypedef struct {\r\n  struct jpeg_upsampler pub;\t/* public fields */\r\n\r\n  /* Pointer to routine to do actual upsampling/conversion of one row group */\r\n  JMETHOD(void, upmethod, (j_decompress_ptr cinfo,\r\n\t\t\t   JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\r\n\t\t\t   JSAMPARRAY output_buf));\r\n\r\n  /* Private state for YCC->RGB conversion */\r\n  int * Cr_r_tab;\t\t/* => table for Cr to R conversion */\r\n  int * Cb_b_tab;\t\t/* => table for Cb to B conversion */\r\n  INT32 * Cr_g_tab;\t\t/* => table for Cr to G conversion */\r\n  INT32 * Cb_g_tab;\t\t/* => table for Cb to G conversion */\r\n\r\n  /* For 2:1 vertical sampling, we produce two output rows at a time.\r\n   * We need a \"spare\" row buffer to hold the second output row if the\r\n   * application provides just a one-row buffer; we also use the spare\r\n   * to discard the dummy last row if the image height is odd.\r\n   */\r\n  JSAMPROW spare_row;\r\n  boolean spare_full;\t\t/* T if spare buffer is occupied */\r\n\r\n  JDIMENSION out_row_width;\t/* samples per output row */\r\n  JDIMENSION rows_to_go;\t/* counts rows remaining in image */\r\n} my_upsampler;\r\n\r\ntypedef my_upsampler * my_upsample_ptr;\r\n\r\n#define SCALEBITS\t16\t/* speediest right-shift on some machines */\r\n#define ONE_HALF\t((INT32) 1 << (SCALEBITS-1))\r\n#define FIX(x)\t\t((INT32) ((x) * (1L<<SCALEBITS) + 0.5))\r\n\r\n\r\n/*\r\n * Initialize tables for YCC->RGB colorspace conversion.\r\n * This is taken directly from jdcolor.c; see that file for more info.\r\n */\r\n\r\nLOCAL(void)\r\nbuild_ycc_rgb_table (j_decompress_ptr cinfo)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n  int i;\r\n  INT32 x;\r\n  SHIFT_TEMPS\r\n\r\n  upsample->Cr_r_tab = (int *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\r\n  upsample->Cb_b_tab = (int *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\r\n  upsample->Cr_g_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\r\n  upsample->Cb_g_tab = (INT32 *)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\r\n\r\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\r\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\r\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\r\n    /* Cr=>R value is nearest int to 1.402 * x */\r\n    upsample->Cr_r_tab[i] = (int)\r\n\t\t    RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);\r\n    /* Cb=>B value is nearest int to 1.772 * x */\r\n    upsample->Cb_b_tab[i] = (int)\r\n\t\t    RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);\r\n    /* Cr=>G value is scaled-up -0.714136286 * x */\r\n    upsample->Cr_g_tab[i] = (- FIX(0.714136286)) * x;\r\n    /* Cb=>G value is scaled-up -0.344136286 * x */\r\n    /* We also add in ONE_HALF so that need not do it in inner loop */\r\n    upsample->Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Initialize for an upsampling pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_merged_upsample (j_decompress_ptr cinfo)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n\r\n  /* Mark the spare buffer empty */\r\n  upsample->spare_full = FALSE;\r\n  /* Initialize total-height counter for detecting bottom of image */\r\n  upsample->rows_to_go = cinfo->output_height;\r\n}\r\n\r\n\r\n/*\r\n * Control routine to do upsampling (and color conversion).\r\n *\r\n * The control routine just handles the row buffering considerations.\r\n */\r\n\r\nMETHODDEF(void)\r\nmerged_2v_upsample (j_decompress_ptr cinfo,\r\n\t\t    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t\t    JDIMENSION in_row_groups_avail,\r\n\t\t    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t    JDIMENSION out_rows_avail)\r\n/* 2:1 vertical sampling case: may need a spare row. */\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n  JSAMPROW work_ptrs[2];\r\n  JDIMENSION num_rows;\t\t/* number of rows returned to caller */\r\n\r\n  if (upsample->spare_full) {\r\n    /* If we have a spare row saved from a previous cycle, just return it. */\r\n    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,\r\n\t\t      1, upsample->out_row_width);\r\n    num_rows = 1;\r\n    upsample->spare_full = FALSE;\r\n  } else {\r\n    /* Figure number of rows to return to caller. */\r\n    num_rows = 2;\r\n    /* Not more than the distance to the end of the image. */\r\n    if (num_rows > upsample->rows_to_go)\r\n      num_rows = upsample->rows_to_go;\r\n    /* And not more than what the client can accept: */\r\n    out_rows_avail -= *out_row_ctr;\r\n    if (num_rows > out_rows_avail)\r\n      num_rows = out_rows_avail;\r\n    /* Create output pointer array for upsampler. */\r\n    work_ptrs[0] = output_buf[*out_row_ctr];\r\n    if (num_rows > 1) {\r\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\r\n    } else {\r\n      work_ptrs[1] = upsample->spare_row;\r\n      upsample->spare_full = TRUE;\r\n    }\r\n    /* Now do the upsampling. */\r\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\r\n  }\r\n\r\n  /* Adjust counts */\r\n  *out_row_ctr += num_rows;\r\n  upsample->rows_to_go -= num_rows;\r\n  /* When the buffer is emptied, declare this input row group consumed */\r\n  if (! upsample->spare_full)\r\n    (*in_row_group_ctr)++;\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nmerged_1v_upsample (j_decompress_ptr cinfo,\r\n\t\t    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t\t    JDIMENSION in_row_groups_avail,\r\n\t\t    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t    JDIMENSION out_rows_avail)\r\n/* 1:1 vertical sampling case: much easier, never need a spare row. */\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n\r\n  /* Just do the upsampling. */\r\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\r\n\t\t\t output_buf + *out_row_ctr);\r\n  /* Adjust counts */\r\n  (*out_row_ctr)++;\r\n  (*in_row_group_ctr)++;\r\n}\r\n\r\n\r\n/*\r\n * These are the routines invoked by the control routines to do\r\n * the actual upsampling/conversion.  One row group is processed per call.\r\n *\r\n * Note: since we may be writing directly into application-supplied buffers,\r\n * we have to be honest about the output width; we can't assume the buffer\r\n * has been rounded up to an even width.\r\n */\r\n\r\n\r\n/*\r\n * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.\r\n */\r\n\r\nMETHODDEF(void)\r\nh2v1_merged_upsample (j_decompress_ptr cinfo,\r\n\t\t      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\r\n\t\t      JSAMPARRAY output_buf)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n  register int y, cred, cgreen, cblue;\r\n  int cb, cr;\r\n  register JSAMPROW outptr;\r\n  JSAMPROW inptr0, inptr1, inptr2;\r\n  JDIMENSION col;\r\n  /* copy these pointers into registers if possible */\r\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\r\n  int * Crrtab = upsample->Cr_r_tab;\r\n  int * Cbbtab = upsample->Cb_b_tab;\r\n  INT32 * Crgtab = upsample->Cr_g_tab;\r\n  INT32 * Cbgtab = upsample->Cb_g_tab;\r\n  SHIFT_TEMPS\r\n\r\n  inptr0 = input_buf[0][in_row_group_ctr];\r\n  inptr1 = input_buf[1][in_row_group_ctr];\r\n  inptr2 = input_buf[2][in_row_group_ctr];\r\n  outptr = output_buf[0];\r\n  /* Loop for each pair of output pixels */\r\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\r\n    /* Do the chroma part of the calculation */\r\n    cb = GETJSAMPLE(*inptr1++);\r\n    cr = GETJSAMPLE(*inptr2++);\r\n    cred = Crrtab[cr];\r\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\r\n    cblue = Cbbtab[cb];\r\n    /* Fetch 2 Y values and emit 2 pixels */\r\n    y  = GETJSAMPLE(*inptr0++);\r\n    outptr[RGB_RED] =   range_limit[y + cred];\r\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\r\n    outptr += RGB_PIXELSIZE;\r\n    y  = GETJSAMPLE(*inptr0++);\r\n    outptr[RGB_RED] =   range_limit[y + cred];\r\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\r\n    outptr += RGB_PIXELSIZE;\r\n  }\r\n  /* If image width is odd, do the last output column separately */\r\n  if (cinfo->output_width & 1) {\r\n    cb = GETJSAMPLE(*inptr1);\r\n    cr = GETJSAMPLE(*inptr2);\r\n    cred = Crrtab[cr];\r\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\r\n    cblue = Cbbtab[cb];\r\n    y  = GETJSAMPLE(*inptr0);\r\n    outptr[RGB_RED] =   range_limit[y + cred];\r\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.\r\n */\r\n\r\nMETHODDEF(void)\r\nh2v2_merged_upsample (j_decompress_ptr cinfo,\r\n\t\t      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\r\n\t\t      JSAMPARRAY output_buf)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n  register int y, cred, cgreen, cblue;\r\n  int cb, cr;\r\n  register JSAMPROW outptr0, outptr1;\r\n  JSAMPROW inptr00, inptr01, inptr1, inptr2;\r\n  JDIMENSION col;\r\n  /* copy these pointers into registers if possible */\r\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\r\n  int * Crrtab = upsample->Cr_r_tab;\r\n  int * Cbbtab = upsample->Cb_b_tab;\r\n  INT32 * Crgtab = upsample->Cr_g_tab;\r\n  INT32 * Cbgtab = upsample->Cb_g_tab;\r\n  SHIFT_TEMPS\r\n\r\n  inptr00 = input_buf[0][in_row_group_ctr*2];\r\n  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];\r\n  inptr1 = input_buf[1][in_row_group_ctr];\r\n  inptr2 = input_buf[2][in_row_group_ctr];\r\n  outptr0 = output_buf[0];\r\n  outptr1 = output_buf[1];\r\n  /* Loop for each group of output pixels */\r\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\r\n    /* Do the chroma part of the calculation */\r\n    cb = GETJSAMPLE(*inptr1++);\r\n    cr = GETJSAMPLE(*inptr2++);\r\n    cred = Crrtab[cr];\r\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\r\n    cblue = Cbbtab[cb];\r\n    /* Fetch 4 Y values and emit 4 pixels */\r\n    y  = GETJSAMPLE(*inptr00++);\r\n    outptr0[RGB_RED] =   range_limit[y + cred];\r\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\r\n    outptr0 += RGB_PIXELSIZE;\r\n    y  = GETJSAMPLE(*inptr00++);\r\n    outptr0[RGB_RED] =   range_limit[y + cred];\r\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\r\n    outptr0 += RGB_PIXELSIZE;\r\n    y  = GETJSAMPLE(*inptr01++);\r\n    outptr1[RGB_RED] =   range_limit[y + cred];\r\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\r\n    outptr1 += RGB_PIXELSIZE;\r\n    y  = GETJSAMPLE(*inptr01++);\r\n    outptr1[RGB_RED] =   range_limit[y + cred];\r\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\r\n    outptr1 += RGB_PIXELSIZE;\r\n  }\r\n  /* If image width is odd, do the last output column separately */\r\n  if (cinfo->output_width & 1) {\r\n    cb = GETJSAMPLE(*inptr1);\r\n    cr = GETJSAMPLE(*inptr2);\r\n    cred = Crrtab[cr];\r\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\r\n    cblue = Cbbtab[cb];\r\n    y  = GETJSAMPLE(*inptr00);\r\n    outptr0[RGB_RED] =   range_limit[y + cred];\r\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\r\n    y  = GETJSAMPLE(*inptr01);\r\n    outptr1[RGB_RED] =   range_limit[y + cred];\r\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\r\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for merged upsampling/color conversion.\r\n *\r\n * NB: this is called under the conditions determined by use_merged_upsample()\r\n * in jdmaster.c.  That routine MUST correspond to the actual capabilities\r\n * of this module; no safety checks are made here.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_merged_upsampler (j_decompress_ptr cinfo)\r\n{\r\n  my_upsample_ptr upsample;\r\n\r\n  upsample = (my_upsample_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_upsampler));\r\n  cinfo->upsample = (struct jpeg_upsampler *) upsample;\r\n  upsample->pub.start_pass = start_pass_merged_upsample;\r\n  upsample->pub.need_context_rows = FALSE;\r\n\r\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\r\n\r\n  if (cinfo->max_v_samp_factor == 2) {\r\n    upsample->pub.upsample = merged_2v_upsample;\r\n    upsample->upmethod = h2v2_merged_upsample;\r\n    /* Allocate a spare row buffer */\r\n    upsample->spare_row = (JSAMPROW)\r\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));\r\n  } else {\r\n    upsample->pub.upsample = merged_1v_upsample;\r\n    upsample->upmethod = h2v1_merged_upsample;\r\n    /* No spare row needed */\r\n    upsample->spare_row = NULL;\r\n  }\r\n\r\n  build_ycc_rgb_table(cinfo);\r\n}\r\n\r\n#endif /* UPSAMPLE_MERGING_SUPPORTED */\r\n","/*\r\n * jdpostct.c\r\n *\r\n * Copyright (C) 1994-1996, Thomas G. Lane.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains the decompression postprocessing controller.\r\n * This controller manages the upsampling, color conversion, and color\r\n * quantization/reduction steps; specifically, it controls the buffering\r\n * between upsample/color conversion and color quantization/reduction.\r\n *\r\n * If no color quantization/reduction is required, then this module has no\r\n * work to do, and it just hands off to the upsample/color conversion code.\r\n * An integrated upsample/convert/quantize process would replace this module\r\n * entirely.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Private buffer controller object */\r\n\r\ntypedef struct {\r\n  struct jpeg_d_post_controller pub; /* public fields */\r\n\r\n  /* Color quantization source buffer: this holds output data from\r\n   * the upsample/color conversion step to be passed to the quantizer.\r\n   * For two-pass color quantization, we need a full-image buffer;\r\n   * for one-pass operation, a strip buffer is sufficient.\r\n   */\r\n  jvirt_sarray_ptr whole_image;\t/* virtual array, or NULL if one-pass */\r\n  JSAMPARRAY buffer;\t\t/* strip buffer, or current strip of virtual */\r\n  JDIMENSION strip_height;\t/* buffer size in rows */\r\n  /* for two-pass mode only: */\r\n  JDIMENSION starting_row;\t/* row # of first row in current strip */\r\n  JDIMENSION next_row;\t\t/* index of next row to fill/empty in strip */\r\n} my_post_controller;\r\n\r\ntypedef my_post_controller * my_post_ptr;\r\n\r\n\r\n/* Forward declarations */\r\nMETHODDEF(void) post_process_1pass\r\n\tJPP((j_decompress_ptr cinfo,\r\n\t     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t     JDIMENSION in_row_groups_avail,\r\n\t     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t     JDIMENSION out_rows_avail));\r\n#ifdef QUANT_2PASS_SUPPORTED\r\nMETHODDEF(void) post_process_prepass\r\n\tJPP((j_decompress_ptr cinfo,\r\n\t     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t     JDIMENSION in_row_groups_avail,\r\n\t     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t     JDIMENSION out_rows_avail));\r\nMETHODDEF(void) post_process_2pass\r\n\tJPP((j_decompress_ptr cinfo,\r\n\t     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t     JDIMENSION in_row_groups_avail,\r\n\t     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t     JDIMENSION out_rows_avail));\r\n#endif\r\n\r\n\r\n/*\r\n * Initialize for a processing pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)\r\n{\r\n  my_post_ptr post = (my_post_ptr) cinfo->post;\r\n\r\n  switch (pass_mode) {\r\n  case JBUF_PASS_THRU:\r\n    if (cinfo->quantize_colors) {\r\n      /* Single-pass processing with color quantization. */\r\n      post->pub.post_process_data = post_process_1pass;\r\n      /* We could be doing buffered-image output before starting a 2-pass\r\n       * color quantization; in that case, jinit_d_post_controller did not\r\n       * allocate a strip buffer.  Use the virtual-array buffer as workspace.\r\n       */\r\n      if (post->buffer == NULL) {\r\n\tpost->buffer = (*cinfo->mem->access_virt_sarray)\r\n\t  ((j_common_ptr) cinfo, post->whole_image,\r\n\t   (JDIMENSION) 0, post->strip_height, TRUE);\r\n      }\r\n    } else {\r\n      /* For single-pass processing without color quantization,\r\n       * I have no work to do; just call the upsampler directly.\r\n       */\r\n      post->pub.post_process_data = cinfo->upsample->upsample;\r\n    }\r\n    break;\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n  case JBUF_SAVE_AND_PASS:\r\n    /* First pass of 2-pass quantization */\r\n    if (post->whole_image == NULL)\r\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\r\n    post->pub.post_process_data = post_process_prepass;\r\n    break;\r\n  case JBUF_CRANK_DEST:\r\n    /* Second pass of 2-pass quantization */\r\n    if (post->whole_image == NULL)\r\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\r\n    post->pub.post_process_data = post_process_2pass;\r\n    break;\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n  default:\r\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\r\n    break;\r\n  }\r\n  post->starting_row = post->next_row = 0;\r\n}\r\n\r\n\r\n/*\r\n * Process some data in the one-pass (strip buffer) case.\r\n * This is used for color precision reduction as well as one-pass quantization.\r\n */\r\n\r\nMETHODDEF(void)\r\npost_process_1pass (j_decompress_ptr cinfo,\r\n\t\t    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t\t    JDIMENSION in_row_groups_avail,\r\n\t\t    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t    JDIMENSION out_rows_avail)\r\n{\r\n  my_post_ptr post = (my_post_ptr) cinfo->post;\r\n  JDIMENSION num_rows, max_rows;\r\n\r\n  /* Fill the buffer, but not more than what we can dump out in one go. */\r\n  /* Note we rely on the upsampler to detect bottom of image. */\r\n  max_rows = out_rows_avail - *out_row_ctr;\r\n  if (max_rows > post->strip_height)\r\n    max_rows = post->strip_height;\r\n  num_rows = 0;\r\n  (*cinfo->upsample->upsample) (cinfo,\r\n\t\tinput_buf, in_row_group_ctr, in_row_groups_avail,\r\n\t\tpost->buffer, &num_rows, max_rows);\r\n  /* Quantize and emit data. */\r\n  (*cinfo->cquantize->color_quantize) (cinfo,\r\n\t\tpost->buffer, output_buf + *out_row_ctr, (int) num_rows);\r\n  *out_row_ctr += num_rows;\r\n}\r\n\r\n\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n\r\n/*\r\n * Process some data in the first pass of 2-pass quantization.\r\n */\r\n\r\nMETHODDEF(void)\r\npost_process_prepass (j_decompress_ptr cinfo,\r\n\t\t      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t\t      JDIMENSION in_row_groups_avail,\r\n\t\t      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t      JDIMENSION out_rows_avail)\r\n{\r\n  my_post_ptr post = (my_post_ptr) cinfo->post;\r\n  JDIMENSION old_next_row, num_rows;\r\n\r\n  /* Reposition virtual buffer if at start of strip. */\r\n  if (post->next_row == 0) {\r\n    post->buffer = (*cinfo->mem->access_virt_sarray)\r\n\t((j_common_ptr) cinfo, post->whole_image,\r\n\t post->starting_row, post->strip_height, TRUE);\r\n  }\r\n\r\n  /* Upsample some data (up to a strip height's worth). */\r\n  old_next_row = post->next_row;\r\n  (*cinfo->upsample->upsample) (cinfo,\r\n\t\tinput_buf, in_row_group_ctr, in_row_groups_avail,\r\n\t\tpost->buffer, &post->next_row, post->strip_height);\r\n\r\n  /* Allow quantizer to scan new data.  No data is emitted, */\r\n  /* but we advance out_row_ctr so outer loop can tell when we're done. */\r\n  if (post->next_row > old_next_row) {\r\n    num_rows = post->next_row - old_next_row;\r\n    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,\r\n\t\t\t\t\t (JSAMPARRAY) NULL, (int) num_rows);\r\n    *out_row_ctr += num_rows;\r\n  }\r\n\r\n  /* Advance if we filled the strip. */\r\n  if (post->next_row >= post->strip_height) {\r\n    post->starting_row += post->strip_height;\r\n    post->next_row = 0;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Process some data in the second pass of 2-pass quantization.\r\n */\r\n\r\nMETHODDEF(void)\r\npost_process_2pass (j_decompress_ptr cinfo,\r\n\t\t    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t\t    JDIMENSION in_row_groups_avail,\r\n\t\t    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t\t    JDIMENSION out_rows_avail)\r\n{\r\n  my_post_ptr post = (my_post_ptr) cinfo->post;\r\n  JDIMENSION num_rows, max_rows;\r\n\r\n  /* Reposition virtual buffer if at start of strip. */\r\n  if (post->next_row == 0) {\r\n    post->buffer = (*cinfo->mem->access_virt_sarray)\r\n\t((j_common_ptr) cinfo, post->whole_image,\r\n\t post->starting_row, post->strip_height, FALSE);\r\n  }\r\n\r\n  /* Determine number of rows to emit. */\r\n  num_rows = post->strip_height - post->next_row; /* available in strip */\r\n  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */\r\n  if (num_rows > max_rows)\r\n    num_rows = max_rows;\r\n  /* We have to check bottom of image here, can't depend on upsampler. */\r\n  max_rows = cinfo->output_height - post->starting_row;\r\n  if (num_rows > max_rows)\r\n    num_rows = max_rows;\r\n\r\n  /* Quantize and emit data. */\r\n  (*cinfo->cquantize->color_quantize) (cinfo,\r\n\t\tpost->buffer + post->next_row, output_buf + *out_row_ctr,\r\n\t\t(int) num_rows);\r\n  *out_row_ctr += num_rows;\r\n\r\n  /* Advance if we filled the strip. */\r\n  post->next_row += num_rows;\r\n  if (post->next_row >= post->strip_height) {\r\n    post->starting_row += post->strip_height;\r\n    post->next_row = 0;\r\n  }\r\n}\r\n\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n\r\n\r\n/*\r\n * Initialize postprocessing controller.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)\r\n{\r\n  my_post_ptr post;\r\n\r\n  post = (my_post_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_post_controller));\r\n  cinfo->post = (struct jpeg_d_post_controller *) post;\r\n  post->pub.start_pass = start_pass_dpost;\r\n  post->whole_image = NULL;\t/* flag for no virtual arrays */\r\n  post->buffer = NULL;\t\t/* flag for no strip buffer */\r\n\r\n  /* Create the quantization buffer, if needed */\r\n  if (cinfo->quantize_colors) {\r\n    /* The buffer strip height is max_v_samp_factor, which is typically\r\n     * an efficient number of rows for upsampling to return.\r\n     * (In the presence of output rescaling, we might want to be smarter?)\r\n     */\r\n    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;\r\n    if (need_full_buffer) {\r\n      /* Two-pass color quantization: need full-image storage. */\r\n      /* We round up the number of rows to a multiple of the strip height. */\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n      post->whole_image = (*cinfo->mem->request_virt_sarray)\r\n\t((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\r\n\t cinfo->output_width * cinfo->out_color_components,\r\n\t (JDIMENSION) jround_up((long) cinfo->output_height,\r\n\t\t\t\t(long) post->strip_height),\r\n\t post->strip_height);\r\n#else\r\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n    } else {\r\n      /* One-pass color quantization: just make a strip buffer. */\r\n      post->buffer = (*cinfo->mem->alloc_sarray)\r\n\t((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t cinfo->output_width * cinfo->out_color_components,\r\n\t post->strip_height);\r\n    }\r\n  }\r\n}\r\n","/*\r\n * jdsample.c\r\n *\r\n * Copyright (C) 1991-1996, Thomas G. Lane.\r\n * Modified 2002-2008 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains upsampling routines.\r\n *\r\n * Upsampling input data is counted in \"row groups\".  A row group\r\n * is defined to be (v_samp_factor * DCT_v_scaled_size / min_DCT_v_scaled_size)\r\n * sample rows of each component.  Upsampling will normally produce\r\n * max_v_samp_factor pixel rows from each row group (but this could vary\r\n * if the upsampler is applying a scale factor of its own).\r\n *\r\n * An excellent reference for image resampling is\r\n *   Digital Image Warping, George Wolberg, 1990.\r\n *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/* Pointer to routine to upsample a single component */\r\ntypedef JMETHOD(void, upsample1_ptr,\r\n\t\t(j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));\r\n\r\n/* Private subobject */\r\n\r\ntypedef struct {\r\n  struct jpeg_upsampler pub;\t/* public fields */\r\n\r\n  /* Color conversion buffer.  When using separate upsampling and color\r\n   * conversion steps, this buffer holds one upsampled row group until it\r\n   * has been color converted and output.\r\n   * Note: we do not allocate any storage for component(s) which are full-size,\r\n   * ie do not need rescaling.  The corresponding entry of color_buf[] is\r\n   * simply set to point to the input data array, thereby avoiding copying.\r\n   */\r\n  JSAMPARRAY color_buf[MAX_COMPONENTS];\r\n\r\n  /* Per-component upsampling method pointers */\r\n  upsample1_ptr methods[MAX_COMPONENTS];\r\n\r\n  int next_row_out;\t\t/* counts rows emitted from color_buf */\r\n  JDIMENSION rows_to_go;\t/* counts rows remaining in image */\r\n\r\n  /* Height of an input row group for each component. */\r\n  int rowgroup_height[MAX_COMPONENTS];\r\n\r\n  /* These arrays save pixel expansion factors so that int_expand need not\r\n   * recompute them each time.  They are unused for other upsampling methods.\r\n   */\r\n  UINT8 h_expand[MAX_COMPONENTS];\r\n  UINT8 v_expand[MAX_COMPONENTS];\r\n} my_upsampler;\r\n\r\ntypedef my_upsampler * my_upsample_ptr;\r\n\r\n\r\n/*\r\n * Initialize for an upsampling pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_upsample (j_decompress_ptr cinfo)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n\r\n  /* Mark the conversion buffer empty */\r\n  upsample->next_row_out = cinfo->max_v_samp_factor;\r\n  /* Initialize total-height counter for detecting bottom of image */\r\n  upsample->rows_to_go = cinfo->output_height;\r\n}\r\n\r\n\r\n/*\r\n * Control routine to do upsampling (and color conversion).\r\n *\r\n * In this version we upsample each component independently.\r\n * We upsample one row group into the conversion buffer, then apply\r\n * color conversion a row at a time.\r\n */\r\n\r\nMETHODDEF(void)\r\nsep_upsample (j_decompress_ptr cinfo,\r\n\t      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\r\n\t      JDIMENSION in_row_groups_avail,\r\n\t      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\r\n\t      JDIMENSION out_rows_avail)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n  int ci;\r\n  jpeg_component_info * compptr;\r\n  JDIMENSION num_rows;\r\n\r\n  /* Fill the conversion buffer, if it's empty */\r\n  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {\r\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n\t ci++, compptr++) {\r\n      /* Invoke per-component upsample method.  Notice we pass a POINTER\r\n       * to color_buf[ci], so that fullsize_upsample can change it.\r\n       */\r\n      (*upsample->methods[ci]) (cinfo, compptr,\r\n\tinput_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),\r\n\tupsample->color_buf + ci);\r\n    }\r\n    upsample->next_row_out = 0;\r\n  }\r\n\r\n  /* Color-convert and emit rows */\r\n\r\n  /* How many we have in the buffer: */\r\n  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);\r\n  /* Not more than the distance to the end of the image.  Need this test\r\n   * in case the image height is not a multiple of max_v_samp_factor:\r\n   */\r\n  if (num_rows > upsample->rows_to_go) \r\n    num_rows = upsample->rows_to_go;\r\n  /* And not more than what the client can accept: */\r\n  out_rows_avail -= *out_row_ctr;\r\n  if (num_rows > out_rows_avail)\r\n    num_rows = out_rows_avail;\r\n\r\n  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,\r\n\t\t\t\t     (JDIMENSION) upsample->next_row_out,\r\n\t\t\t\t     output_buf + *out_row_ctr,\r\n\t\t\t\t     (int) num_rows);\r\n\r\n  /* Adjust counts */\r\n  *out_row_ctr += num_rows;\r\n  upsample->rows_to_go -= num_rows;\r\n  upsample->next_row_out += num_rows;\r\n  /* When the buffer is emptied, declare this input row group consumed */\r\n  if (upsample->next_row_out >= cinfo->max_v_samp_factor)\r\n    (*in_row_group_ctr)++;\r\n}\r\n\r\n\r\n/*\r\n * These are the routines invoked by sep_upsample to upsample pixel values\r\n * of a single component.  One row group is processed per call.\r\n */\r\n\r\n\r\n/*\r\n * For full-size components, we just make color_buf[ci] point at the\r\n * input buffer, and thus avoid copying any data.  Note that this is\r\n * safe only because sep_upsample doesn't declare the input row group\r\n * \"consumed\" until we are done color converting and emitting it.\r\n */\r\n\r\nMETHODDEF(void)\r\nfullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\r\n{\r\n  *output_data_ptr = input_data;\r\n}\r\n\r\n\r\n/*\r\n * This is a no-op version used for \"uninteresting\" components.\r\n * These components will not be referenced by color conversion.\r\n */\r\n\r\nMETHODDEF(void)\r\nnoop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\r\n{\r\n  *output_data_ptr = NULL;\t/* safety check */\r\n}\r\n\r\n\r\n/*\r\n * This version handles any integral sampling ratios.\r\n * This is not used for typical JPEG files, so it need not be fast.\r\n * Nor, for that matter, is it particularly accurate: the algorithm is\r\n * simple replication of the input pixel onto the corresponding output\r\n * pixels.  The hi-falutin sampling literature refers to this as a\r\n * \"box filter\".  A box filter tends to introduce visible artifacts,\r\n * so if you are actually going to use 3:1 or 4:1 sampling ratios\r\n * you would be well advised to improve this code.\r\n */\r\n\r\nMETHODDEF(void)\r\nint_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\r\n{\r\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\r\n  JSAMPARRAY output_data = *output_data_ptr;\r\n  register JSAMPROW inptr, outptr;\r\n  register JSAMPLE invalue;\r\n  register int h;\r\n  JSAMPROW outend;\r\n  int h_expand, v_expand;\r\n  int inrow, outrow;\r\n\r\n  h_expand = upsample->h_expand[compptr->component_index];\r\n  v_expand = upsample->v_expand[compptr->component_index];\r\n\r\n  inrow = outrow = 0;\r\n  while (outrow < cinfo->max_v_samp_factor) {\r\n    /* Generate one output row with proper horizontal expansion */\r\n    inptr = input_data[inrow];\r\n    outptr = output_data[outrow];\r\n    outend = outptr + cinfo->output_width;\r\n    while (outptr < outend) {\r\n      invalue = *inptr++;\t/* don't need GETJSAMPLE() here */\r\n      for (h = h_expand; h > 0; h--) {\r\n\t*outptr++ = invalue;\r\n      }\r\n    }\r\n    /* Generate any additional output rows by duplicating the first one */\r\n    if (v_expand > 1) {\r\n      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,\r\n\t\t\tv_expand-1, cinfo->output_width);\r\n    }\r\n    inrow++;\r\n    outrow += v_expand;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.\r\n * It's still a box filter.\r\n */\r\n\r\nMETHODDEF(void)\r\nh2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\r\n{\r\n  JSAMPARRAY output_data = *output_data_ptr;\r\n  register JSAMPROW inptr, outptr;\r\n  register JSAMPLE invalue;\r\n  JSAMPROW outend;\r\n  int outrow;\r\n\r\n  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {\r\n    inptr = input_data[outrow];\r\n    outptr = output_data[outrow];\r\n    outend = outptr + cinfo->output_width;\r\n    while (outptr < outend) {\r\n      invalue = *inptr++;\t/* don't need GETJSAMPLE() here */\r\n      *outptr++ = invalue;\r\n      *outptr++ = invalue;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.\r\n * It's still a box filter.\r\n */\r\n\r\nMETHODDEF(void)\r\nh2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\r\n{\r\n  JSAMPARRAY output_data = *output_data_ptr;\r\n  register JSAMPROW inptr, outptr;\r\n  register JSAMPLE invalue;\r\n  JSAMPROW outend;\r\n  int inrow, outrow;\r\n\r\n  inrow = outrow = 0;\r\n  while (outrow < cinfo->max_v_samp_factor) {\r\n    inptr = input_data[inrow];\r\n    outptr = output_data[outrow];\r\n    outend = outptr + cinfo->output_width;\r\n    while (outptr < outend) {\r\n      invalue = *inptr++;\t/* don't need GETJSAMPLE() here */\r\n      *outptr++ = invalue;\r\n      *outptr++ = invalue;\r\n    }\r\n    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,\r\n\t\t      1, cinfo->output_width);\r\n    inrow++;\r\n    outrow += 2;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for upsampling.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_upsampler (j_decompress_ptr cinfo)\r\n{\r\n  my_upsample_ptr upsample;\r\n  int ci;\r\n  jpeg_component_info * compptr;\r\n  boolean need_buffer;\r\n  int h_in_group, v_in_group, h_out_group, v_out_group;\r\n\r\n  upsample = (my_upsample_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_upsampler));\r\n  cinfo->upsample = (struct jpeg_upsampler *) upsample;\r\n  upsample->pub.start_pass = start_pass_upsample;\r\n  upsample->pub.upsample = sep_upsample;\r\n  upsample->pub.need_context_rows = FALSE; /* until we find out differently */\r\n\r\n  if (cinfo->CCIR601_sampling)\t/* this isn't supported */\r\n    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);\r\n\r\n  /* Verify we can handle the sampling factors, select per-component methods,\r\n   * and create storage as needed.\r\n   */\r\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\r\n       ci++, compptr++) {\r\n    /* Compute size of an \"input group\" after IDCT scaling.  This many samples\r\n     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.\r\n     */\r\n    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /\r\n\t\t cinfo->min_DCT_h_scaled_size;\r\n    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\r\n\t\t cinfo->min_DCT_v_scaled_size;\r\n    h_out_group = cinfo->max_h_samp_factor;\r\n    v_out_group = cinfo->max_v_samp_factor;\r\n    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */\r\n    need_buffer = TRUE;\r\n    if (! compptr->component_needed) {\r\n      /* Don't bother to upsample an uninteresting component. */\r\n      upsample->methods[ci] = noop_upsample;\r\n      need_buffer = FALSE;\r\n    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {\r\n      /* Fullsize components can be processed without any work. */\r\n      upsample->methods[ci] = fullsize_upsample;\r\n      need_buffer = FALSE;\r\n    } else if (h_in_group * 2 == h_out_group &&\r\n\t       v_in_group == v_out_group) {\r\n      /* Special case for 2h1v upsampling */\r\n      upsample->methods[ci] = h2v1_upsample;\r\n    } else if (h_in_group * 2 == h_out_group &&\r\n\t       v_in_group * 2 == v_out_group) {\r\n      /* Special case for 2h2v upsampling */\r\n      upsample->methods[ci] = h2v2_upsample;\r\n    } else if ((h_out_group % h_in_group) == 0 &&\r\n\t       (v_out_group % v_in_group) == 0) {\r\n      /* Generic integral-factors upsampling method */\r\n      upsample->methods[ci] = int_upsample;\r\n      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);\r\n      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);\r\n    } else\r\n      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);\r\n    if (need_buffer) {\r\n      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)\r\n\t((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t (JDIMENSION) jround_up((long) cinfo->output_width,\r\n\t\t\t\t(long) cinfo->max_h_samp_factor),\r\n\t (JDIMENSION) cinfo->max_v_samp_factor);\r\n    }\r\n  }\r\n}\r\n","/*\r\n * jerror.c\r\n *\r\n * Copyright (C) 1991-1998, Thomas G. Lane.\r\n * Modified 2012 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains simple error-reporting and trace-message routines.\r\n * These are suitable for Unix-like systems and others where writing to\r\n * stderr is the right thing to do.  Many applications will want to replace\r\n * some or all of these routines.\r\n *\r\n * If you define USE_WINDOWS_MESSAGEBOX in jconfig.h or in the makefile,\r\n * you get a Windows-specific hack to display error messages in a dialog box.\r\n * It ain't much, but it beats dropping error messages into the bit bucket,\r\n * which is what happens to output to stderr under most Windows C compilers.\r\n *\r\n * These routines are used by both the compression and decompression code.\r\n */\r\n\r\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jversion.h\"\r\n#include \"jerror.h\"\r\n\r\n#ifdef USE_WINDOWS_MESSAGEBOX\r\n#include <windows.h>\r\n#endif\r\n\r\n#ifndef EXIT_FAILURE\t\t/* define exit() codes if not provided */\r\n#define EXIT_FAILURE  1\r\n#endif\r\n\r\n\r\n/*\r\n * Create the message string table.\r\n * We do this from the master message list in jerror.h by re-reading\r\n * jerror.h with a suitable definition for macro JMESSAGE.\r\n * The message table is made an external symbol just in case any applications\r\n * want to refer to it directly.\r\n */\r\n\r\n#ifdef NEED_SHORT_EXTERNAL_NAMES\r\n#define jpeg_std_message_table\tjMsgTable\r\n#endif\r\n\r\n#define JMESSAGE(code,string)\tstring ,\r\n\r\nconst char * const jpeg_std_message_table[] = {\r\n#include \"jerror.h\"\r\n  NULL\r\n};\r\n\r\n\r\n/*\r\n * Error exit handler: must not return to caller.\r\n *\r\n * Applications may override this if they want to get control back after\r\n * an error.  Typically one would longjmp somewhere instead of exiting.\r\n * The setjmp buffer can be made a private field within an expanded error\r\n * handler object.  Note that the info needed to generate an error message\r\n * is stored in the error object, so you can generate the message now or\r\n * later, at your convenience.\r\n * You should make sure that the JPEG object is cleaned up (with jpeg_abort\r\n * or jpeg_destroy) at some point.\r\n */\r\n\r\nMETHODDEF(noreturn_t)\r\nerror_exit (j_common_ptr cinfo)\r\n{\r\n  /* Always display the message */\r\n  (*cinfo->err->output_message) (cinfo);\r\n\r\n  /* Let the memory manager delete any temp files before we die */\r\n  jpeg_destroy(cinfo);\r\n\r\n  exit(EXIT_FAILURE);\r\n}\r\n\r\n\r\n/*\r\n * Actual output of an error or trace message.\r\n * Applications may override this method to send JPEG messages somewhere\r\n * other than stderr.\r\n *\r\n * On Windows, printing to stderr is generally completely useless,\r\n * so we provide optional code to produce an error-dialog popup.\r\n * Most Windows applications will still prefer to override this routine,\r\n * but if they don't, it'll do something at least marginally useful.\r\n *\r\n * NOTE: to use the library in an environment that doesn't support the\r\n * C stdio library, you may have to delete the call to fprintf() entirely,\r\n * not just not use this routine.\r\n */\r\n\r\nMETHODDEF(void)\r\noutput_message (j_common_ptr cinfo)\r\n{\r\n  char buffer[JMSG_LENGTH_MAX];\r\n\r\n  /* Create the message */\r\n  (*cinfo->err->format_message) (cinfo, buffer);\r\n\r\n#ifdef USE_WINDOWS_MESSAGEBOX\r\n  /* Display it in a message dialog box */\r\n  MessageBox(GetActiveWindow(), buffer, \"JPEG Library Error\",\r\n\t     MB_OK | MB_ICONERROR);\r\n#else\r\n  /* Send it to stderr, adding a newline */\r\n  fprintf(stderr, \"%s\\n\", buffer);\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n * Decide whether to emit a trace or warning message.\r\n * msg_level is one of:\r\n *   -1: recoverable corrupt-data warning, may want to abort.\r\n *    0: important advisory messages (always display to user).\r\n *    1: first level of tracing detail.\r\n *    2,3,...: successively more detailed tracing messages.\r\n * An application might override this method if it wanted to abort on warnings\r\n * or change the policy about which messages to display.\r\n */\r\n\r\nMETHODDEF(void)\r\nemit_message (j_common_ptr cinfo, int msg_level)\r\n{\r\n  struct jpeg_error_mgr * err = cinfo->err;\r\n\r\n  if (msg_level < 0) {\r\n    /* It's a warning message.  Since corrupt files may generate many warnings,\r\n     * the policy implemented here is to show only the first warning,\r\n     * unless trace_level >= 3.\r\n     */\r\n    if (err->num_warnings == 0 || err->trace_level >= 3)\r\n      (*err->output_message) (cinfo);\r\n    /* Always count warnings in num_warnings. */\r\n    err->num_warnings++;\r\n  } else {\r\n    /* It's a trace message.  Show it if trace_level >= msg_level. */\r\n    if (err->trace_level >= msg_level)\r\n      (*err->output_message) (cinfo);\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Format a message string for the most recent JPEG error or message.\r\n * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX\r\n * characters.  Note that no '\\n' character is added to the string.\r\n * Few applications should need to override this method.\r\n */\r\n\r\nMETHODDEF(void)\r\nformat_message (j_common_ptr cinfo, char * buffer)\r\n{\r\n  struct jpeg_error_mgr * err = cinfo->err;\r\n  int msg_code = err->msg_code;\r\n  const char * msgtext = NULL;\r\n  const char * msgptr;\r\n  char ch;\r\n  boolean isstring;\r\n\r\n  /* Look up message string in proper table */\r\n  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {\r\n    msgtext = err->jpeg_message_table[msg_code];\r\n  } else if (err->addon_message_table != NULL &&\r\n\t     msg_code >= err->first_addon_message &&\r\n\t     msg_code <= err->last_addon_message) {\r\n    msgtext = err->addon_message_table[msg_code - err->first_addon_message];\r\n  }\r\n\r\n  /* Defend against bogus message number */\r\n  if (msgtext == NULL) {\r\n    err->msg_parm.i[0] = msg_code;\r\n    msgtext = err->jpeg_message_table[0];\r\n  }\r\n\r\n  /* Check for string parameter, as indicated by %s in the message text */\r\n  isstring = FALSE;\r\n  msgptr = msgtext;\r\n  while ((ch = *msgptr++) != '\\0') {\r\n    if (ch == '%') {\r\n      if (*msgptr == 's') isstring = TRUE;\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Format the message into the passed buffer */\r\n  if (isstring)\r\n    sprintf(buffer, msgtext, err->msg_parm.s);\r\n  else\r\n    sprintf(buffer, msgtext,\r\n\t    err->msg_parm.i[0], err->msg_parm.i[1],\r\n\t    err->msg_parm.i[2], err->msg_parm.i[3],\r\n\t    err->msg_parm.i[4], err->msg_parm.i[5],\r\n\t    err->msg_parm.i[6], err->msg_parm.i[7]);\r\n}\r\n\r\n\r\n/*\r\n * Reset error state variables at start of a new image.\r\n * This is called during compression startup to reset trace/error\r\n * processing to default state, without losing any application-specific\r\n * method pointers.  An application might possibly want to override\r\n * this method if it has additional error processing state.\r\n */\r\n\r\nMETHODDEF(void)\r\nreset_error_mgr (j_common_ptr cinfo)\r\n{\r\n  cinfo->err->num_warnings = 0;\r\n  /* trace_level is not reset since it is an application-supplied parameter */\r\n  cinfo->err->msg_code = 0;\t/* may be useful as a flag for \"no error\" */\r\n}\r\n\r\n\r\n/*\r\n * Fill in the standard error-handling methods in a jpeg_error_mgr object.\r\n * Typical call is:\r\n *\tstruct jpeg_compress_struct cinfo;\r\n *\tstruct jpeg_error_mgr err;\r\n *\r\n *\tcinfo.err = jpeg_std_error(&err);\r\n * after which the application may override some of the methods.\r\n */\r\n\r\nGLOBAL(struct jpeg_error_mgr *)\r\njpeg_std_error (struct jpeg_error_mgr * err)\r\n{\r\n  err->error_exit = error_exit;\r\n  err->emit_message = emit_message;\r\n  err->output_message = output_message;\r\n  err->format_message = format_message;\r\n  err->reset_error_mgr = reset_error_mgr;\r\n\r\n  err->trace_level = 0;\t\t/* default = no tracing */\r\n  err->num_warnings = 0;\t/* no warnings emitted yet */\r\n  err->msg_code = 0;\t\t/* may be useful as a flag for \"no error\" */\r\n\r\n  /* Initialize message table pointers */\r\n  err->jpeg_message_table = jpeg_std_message_table;\r\n  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;\r\n\r\n  err->addon_message_table = NULL;\r\n  err->first_addon_message = 0;\t/* for safety */\r\n  err->last_addon_message = 0;\r\n\r\n  return err;\r\n}\r\n","/*\r\n * jidctflt.c\r\n *\r\n * Copyright (C) 1994-1998, Thomas G. Lane.\r\n * Modified 2010 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains a floating-point implementation of the\r\n * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine\r\n * must also perform dequantization of the input coefficients.\r\n *\r\n * This implementation should be more accurate than either of the integer\r\n * IDCT implementations.  However, it may not give the same results on all\r\n * machines because of differences in roundoff behavior.  Speed will depend\r\n * on the hardware's floating point capacity.\r\n *\r\n * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT\r\n * on each row (or vice versa, but it's more convenient to emit a row at\r\n * a time).  Direct algorithms are also available, but they are much more\r\n * complex and seem not to be any faster when reduced to code.\r\n *\r\n * This implementation is based on Arai, Agui, and Nakajima's algorithm for\r\n * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in\r\n * Japanese, but the algorithm is described in the Pennebaker & Mitchell\r\n * JPEG textbook (see REFERENCES section in file README).  The following code\r\n * is based directly on figure 4-8 in P&M.\r\n * While an 8-point DCT cannot be done in less than 11 multiplies, it is\r\n * possible to arrange the computation so that many of the multiplies are\r\n * simple scalings of the final outputs.  These multiplies can then be\r\n * folded into the multiplications or divisions by the JPEG quantization\r\n * table entries.  The AA&N method leaves only 5 multiplies and 29 adds\r\n * to be done in the DCT itself.\r\n * The primary disadvantage of this method is that with a fixed-point\r\n * implementation, accuracy is lost due to imprecise representation of the\r\n * scaled quantization values.  However, that problem does not arise if\r\n * we use floating point arithmetic.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jdct.h\"\t\t/* Private declarations for DCT subsystem */\r\n\r\n#ifdef DCT_FLOAT_SUPPORTED\r\n\r\n\r\n/*\r\n * This module is specialized to the case DCTSIZE = 8.\r\n */\r\n\r\n#if DCTSIZE != 8\r\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\r\n#endif\r\n\r\n\r\n/* Dequantize a coefficient by multiplying it by the multiplier-table\r\n * entry; produce a float result.\r\n */\r\n\r\n#define DEQUANTIZE(coef,quantval)  (((FAST_FLOAT) (coef)) * (quantval))\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\r\n  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;\r\n  FAST_FLOAT z5, z10, z11, z12, z13;\r\n  JCOEFPTR inptr;\r\n  FLOAT_MULT_TYPE * quantptr;\r\n  FAST_FLOAT * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = cinfo->sample_range_limit;\r\n  int ctr;\r\n  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\r\n    /* Due to quantization, we will usually find that many of the input\r\n     * coefficients are zero, especially the AC terms.  We can exploit this\r\n     * by short-circuiting the IDCT calculation for any column in which all\r\n     * the AC terms are zero.  In that case each output is equal to the\r\n     * DC coefficient (with scale factor as needed).\r\n     * With typical images and quantization tables, half or more of the\r\n     * column DCT calculations can be simplified this way.\r\n     */\r\n    \r\n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\r\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\r\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\r\n\tinptr[DCTSIZE*7] == 0) {\r\n      /* AC terms all zero */\r\n      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n      \r\n      wsptr[DCTSIZE*0] = dcval;\r\n      wsptr[DCTSIZE*1] = dcval;\r\n      wsptr[DCTSIZE*2] = dcval;\r\n      wsptr[DCTSIZE*3] = dcval;\r\n      wsptr[DCTSIZE*4] = dcval;\r\n      wsptr[DCTSIZE*5] = dcval;\r\n      wsptr[DCTSIZE*6] = dcval;\r\n      wsptr[DCTSIZE*7] = dcval;\r\n      \r\n      inptr++;\t\t\t/* advance pointers to next column */\r\n      quantptr++;\r\n      wsptr++;\r\n      continue;\r\n    }\r\n    \r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\r\n    tmp11 = tmp0 - tmp2;\r\n\r\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\r\n    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */\r\n\r\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\r\n    tmp3 = tmp10 - tmp13;\r\n    tmp1 = tmp11 + tmp12;\r\n    tmp2 = tmp11 - tmp12;\r\n    \r\n    /* Odd part */\r\n\r\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\r\n    z10 = tmp6 - tmp5;\r\n    z11 = tmp4 + tmp7;\r\n    z12 = tmp4 - tmp7;\r\n\r\n    tmp7 = z11 + z13;\t\t/* phase 5 */\r\n    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */\r\n\r\n    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */\r\n    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */\r\n    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */\r\n\r\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\r\n    tmp5 = tmp11 - tmp6;\r\n    tmp4 = tmp10 - tmp5;\r\n\r\n    wsptr[DCTSIZE*0] = tmp0 + tmp7;\r\n    wsptr[DCTSIZE*7] = tmp0 - tmp7;\r\n    wsptr[DCTSIZE*1] = tmp1 + tmp6;\r\n    wsptr[DCTSIZE*6] = tmp1 - tmp6;\r\n    wsptr[DCTSIZE*2] = tmp2 + tmp5;\r\n    wsptr[DCTSIZE*5] = tmp2 - tmp5;\r\n    wsptr[DCTSIZE*3] = tmp3 + tmp4;\r\n    wsptr[DCTSIZE*4] = tmp3 - tmp4;\r\n\r\n    inptr++;\t\t\t/* advance pointers to next column */\r\n    quantptr++;\r\n    wsptr++;\r\n  }\r\n  \r\n  /* Pass 2: process rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\r\n     * However, the column calculation has created many nonzero AC terms, so\r\n     * the simplification applies less often (typically 5% to 10% of the time).\r\n     * And testing floats for zero is relatively expensive, so we don't bother.\r\n     */\r\n    \r\n    /* Even part */\r\n\r\n    /* Apply signed->unsigned and prepare float->int conversion */\r\n    z5 = wsptr[0] + ((FAST_FLOAT) CENTERJSAMPLE + (FAST_FLOAT) 0.5);\r\n    tmp10 = z5 + wsptr[4];\r\n    tmp11 = z5 - wsptr[4];\r\n\r\n    tmp13 = wsptr[2] + wsptr[6];\r\n    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;\r\n\r\n    tmp0 = tmp10 + tmp13;\r\n    tmp3 = tmp10 - tmp13;\r\n    tmp1 = tmp11 + tmp12;\r\n    tmp2 = tmp11 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    z13 = wsptr[5] + wsptr[3];\r\n    z10 = wsptr[5] - wsptr[3];\r\n    z11 = wsptr[1] + wsptr[7];\r\n    z12 = wsptr[1] - wsptr[7];\r\n\r\n    tmp7 = z11 + z13;\r\n    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);\r\n\r\n    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */\r\n    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */\r\n    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */\r\n\r\n    tmp6 = tmp12 - tmp7;\r\n    tmp5 = tmp11 - tmp6;\r\n    tmp4 = tmp10 - tmp5;\r\n\r\n    /* Final output stage: float->int conversion and range-limit */\r\n\r\n    outptr[0] = range_limit[((int) (tmp0 + tmp7)) & RANGE_MASK];\r\n    outptr[7] = range_limit[((int) (tmp0 - tmp7)) & RANGE_MASK];\r\n    outptr[1] = range_limit[((int) (tmp1 + tmp6)) & RANGE_MASK];\r\n    outptr[6] = range_limit[((int) (tmp1 - tmp6)) & RANGE_MASK];\r\n    outptr[2] = range_limit[((int) (tmp2 + tmp5)) & RANGE_MASK];\r\n    outptr[5] = range_limit[((int) (tmp2 - tmp5)) & RANGE_MASK];\r\n    outptr[3] = range_limit[((int) (tmp3 + tmp4)) & RANGE_MASK];\r\n    outptr[4] = range_limit[((int) (tmp3 - tmp4)) & RANGE_MASK];\r\n    \r\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n#endif /* DCT_FLOAT_SUPPORTED */\r\n","/*\r\n * jidctfst.c\r\n *\r\n * Copyright (C) 1994-1998, Thomas G. Lane.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains a fast, not so accurate integer implementation of the\r\n * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine\r\n * must also perform dequantization of the input coefficients.\r\n *\r\n * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT\r\n * on each row (or vice versa, but it's more convenient to emit a row at\r\n * a time).  Direct algorithms are also available, but they are much more\r\n * complex and seem not to be any faster when reduced to code.\r\n *\r\n * This implementation is based on Arai, Agui, and Nakajima's algorithm for\r\n * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in\r\n * Japanese, but the algorithm is described in the Pennebaker & Mitchell\r\n * JPEG textbook (see REFERENCES section in file README).  The following code\r\n * is based directly on figure 4-8 in P&M.\r\n * While an 8-point DCT cannot be done in less than 11 multiplies, it is\r\n * possible to arrange the computation so that many of the multiplies are\r\n * simple scalings of the final outputs.  These multiplies can then be\r\n * folded into the multiplications or divisions by the JPEG quantization\r\n * table entries.  The AA&N method leaves only 5 multiplies and 29 adds\r\n * to be done in the DCT itself.\r\n * The primary disadvantage of this method is that with fixed-point math,\r\n * accuracy is lost due to imprecise representation of the scaled\r\n * quantization values.  The smaller the quantization table entry, the less\r\n * precise the scaled value, so this implementation does worse with high-\r\n * quality-setting files than with low-quality ones.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jdct.h\"\t\t/* Private declarations for DCT subsystem */\r\n\r\n#ifdef DCT_IFAST_SUPPORTED\r\n\r\n\r\n/*\r\n * This module is specialized to the case DCTSIZE = 8.\r\n */\r\n\r\n#if DCTSIZE != 8\r\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\r\n#endif\r\n\r\n\r\n/* Scaling decisions are generally the same as in the LL&M algorithm;\r\n * see jidctint.c for more details.  However, we choose to descale\r\n * (right shift) multiplication products as soon as they are formed,\r\n * rather than carrying additional fractional bits into subsequent additions.\r\n * This compromises accuracy slightly, but it lets us save a few shifts.\r\n * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)\r\n * everywhere except in the multiplications proper; this saves a good deal\r\n * of work on 16-bit-int machines.\r\n *\r\n * The dequantized coefficients are not integers because the AA&N scaling\r\n * factors have been incorporated.  We represent them scaled up by PASS1_BITS,\r\n * so that the first and second IDCT rounds have the same input scaling.\r\n * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to\r\n * avoid a descaling shift; this compromises accuracy rather drastically\r\n * for small quantization table entries, but it saves a lot of shifts.\r\n * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,\r\n * so we use a much larger scaling factor to preserve accuracy.\r\n *\r\n * A final compromise is to represent the multiplicative constants to only\r\n * 8 fractional bits, rather than 13.  This saves some shifting work on some\r\n * machines, and may also reduce the cost of multiplication (since there\r\n * are fewer one-bits in the constants).\r\n */\r\n\r\n#if BITS_IN_JSAMPLE == 8\r\n#define CONST_BITS  8\r\n#define PASS1_BITS  2\r\n#else\r\n#define CONST_BITS  8\r\n#define PASS1_BITS  1\t\t/* lose a little precision to avoid overflow */\r\n#endif\r\n\r\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\r\n * causing a lot of useless floating-point operations at run time.\r\n * To get around this we use the following pre-calculated constants.\r\n * If you change CONST_BITS you may want to add appropriate values.\r\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\r\n */\r\n\r\n#if CONST_BITS == 8\r\n#define FIX_1_082392200  ((INT32)  277)\t\t/* FIX(1.082392200) */\r\n#define FIX_1_414213562  ((INT32)  362)\t\t/* FIX(1.414213562) */\r\n#define FIX_1_847759065  ((INT32)  473)\t\t/* FIX(1.847759065) */\r\n#define FIX_2_613125930  ((INT32)  669)\t\t/* FIX(2.613125930) */\r\n#else\r\n#define FIX_1_082392200  FIX(1.082392200)\r\n#define FIX_1_414213562  FIX(1.414213562)\r\n#define FIX_1_847759065  FIX(1.847759065)\r\n#define FIX_2_613125930  FIX(2.613125930)\r\n#endif\r\n\r\n\r\n/* We can gain a little more speed, with a further compromise in accuracy,\r\n * by omitting the addition in a descaling shift.  This yields an incorrectly\r\n * rounded result half the time...\r\n */\r\n\r\n#ifndef USE_ACCURATE_ROUNDING\r\n#undef DESCALE\r\n#define DESCALE(x,n)  RIGHT_SHIFT(x, n)\r\n#endif\r\n\r\n\r\n/* Multiply a DCTELEM variable by an INT32 constant, and immediately\r\n * descale to yield a DCTELEM result.\r\n */\r\n\r\n#define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))\r\n\r\n\r\n/* Dequantize a coefficient by multiplying it by the multiplier-table\r\n * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16\r\n * multiplication will do.  For 12-bit data, the multiplier table is\r\n * declared INT32, so a 32-bit multiply will be used.\r\n */\r\n\r\n#if BITS_IN_JSAMPLE == 8\r\n#define DEQUANTIZE(coef,quantval)  (((IFAST_MULT_TYPE) (coef)) * (quantval))\r\n#else\r\n#define DEQUANTIZE(coef,quantval)  \\\r\n\tDESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)\r\n#endif\r\n\r\n\r\n/* Like DESCALE, but applies to a DCTELEM and produces an int.\r\n * We assume that int right shift is unsigned if INT32 right shift is.\r\n */\r\n\r\n#ifdef RIGHT_SHIFT_IS_UNSIGNED\r\n#define ISHIFT_TEMPS\tDCTELEM ishift_temp;\r\n#if BITS_IN_JSAMPLE == 8\r\n#define DCTELEMBITS  16\t\t/* DCTELEM may be 16 or 32 bits */\r\n#else\r\n#define DCTELEMBITS  32\t\t/* DCTELEM must be 32 bits */\r\n#endif\r\n#define IRIGHT_SHIFT(x,shft)  \\\r\n    ((ishift_temp = (x)) < 0 ? \\\r\n     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \\\r\n     (ishift_temp >> (shft)))\r\n#else\r\n#define ISHIFT_TEMPS\r\n#define IRIGHT_SHIFT(x,shft)\t((x) >> (shft))\r\n#endif\r\n\r\n#ifdef USE_ACCURATE_ROUNDING\r\n#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))\r\n#else\r\n#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT(x, n))\r\n#endif\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\r\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\r\n  DCTELEM z5, z10, z11, z12, z13;\r\n  JCOEFPTR inptr;\r\n  IFAST_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\t\t\t/* for DESCALE */\r\n  ISHIFT_TEMPS\t\t\t/* for IDESCALE */\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\r\n    /* Due to quantization, we will usually find that many of the input\r\n     * coefficients are zero, especially the AC terms.  We can exploit this\r\n     * by short-circuiting the IDCT calculation for any column in which all\r\n     * the AC terms are zero.  In that case each output is equal to the\r\n     * DC coefficient (with scale factor as needed).\r\n     * With typical images and quantization tables, half or more of the\r\n     * column DCT calculations can be simplified this way.\r\n     */\r\n    \r\n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\r\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\r\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\r\n\tinptr[DCTSIZE*7] == 0) {\r\n      /* AC terms all zero */\r\n      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n\r\n      wsptr[DCTSIZE*0] = dcval;\r\n      wsptr[DCTSIZE*1] = dcval;\r\n      wsptr[DCTSIZE*2] = dcval;\r\n      wsptr[DCTSIZE*3] = dcval;\r\n      wsptr[DCTSIZE*4] = dcval;\r\n      wsptr[DCTSIZE*5] = dcval;\r\n      wsptr[DCTSIZE*6] = dcval;\r\n      wsptr[DCTSIZE*7] = dcval;\r\n      \r\n      inptr++;\t\t\t/* advance pointers to next column */\r\n      quantptr++;\r\n      wsptr++;\r\n      continue;\r\n    }\r\n    \r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\r\n    tmp11 = tmp0 - tmp2;\r\n\r\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\r\n    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */\r\n\r\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\r\n    tmp3 = tmp10 - tmp13;\r\n    tmp1 = tmp11 + tmp12;\r\n    tmp2 = tmp11 - tmp12;\r\n    \r\n    /* Odd part */\r\n\r\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\r\n    z10 = tmp6 - tmp5;\r\n    z11 = tmp4 + tmp7;\r\n    z12 = tmp4 - tmp7;\r\n\r\n    tmp7 = z11 + z13;\t\t/* phase 5 */\r\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\r\n\r\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\r\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\r\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\r\n\r\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\r\n    tmp5 = tmp11 - tmp6;\r\n    tmp4 = tmp10 + tmp5;\r\n\r\n    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);\r\n    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);\r\n    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);\r\n    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);\r\n    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);\r\n    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);\r\n    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);\r\n    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);\r\n\r\n    inptr++;\t\t\t/* advance pointers to next column */\r\n    quantptr++;\r\n    wsptr++;\r\n  }\r\n  \r\n  /* Pass 2: process rows from work array, store into output array. */\r\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\r\n  /* and also undo the PASS1_BITS scaling. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\r\n     * However, the column calculation has created many nonzero AC terms, so\r\n     * the simplification applies less often (typically 5% to 10% of the time).\r\n     * On machines with very fast multiplication, it's possible that the\r\n     * test takes more time than it's worth.  In that case this section\r\n     * may be commented out.\r\n     */\r\n    \r\n#ifndef NO_ZERO_ROW_TEST\r\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\r\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\r\n      /* AC terms all zero */\r\n      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)\r\n\t\t\t\t  & RANGE_MASK];\r\n      \r\n      outptr[0] = dcval;\r\n      outptr[1] = dcval;\r\n      outptr[2] = dcval;\r\n      outptr[3] = dcval;\r\n      outptr[4] = dcval;\r\n      outptr[5] = dcval;\r\n      outptr[6] = dcval;\r\n      outptr[7] = dcval;\r\n\r\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n      continue;\r\n    }\r\n#endif\r\n    \r\n    /* Even part */\r\n\r\n    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);\r\n    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);\r\n\r\n    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);\r\n    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)\r\n\t    - tmp13;\r\n\r\n    tmp0 = tmp10 + tmp13;\r\n    tmp3 = tmp10 - tmp13;\r\n    tmp1 = tmp11 + tmp12;\r\n    tmp2 = tmp11 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];\r\n    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];\r\n    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];\r\n    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];\r\n\r\n    tmp7 = z11 + z13;\t\t/* phase 5 */\r\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\r\n\r\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\r\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\r\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\r\n\r\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\r\n    tmp5 = tmp11 - tmp6;\r\n    tmp4 = tmp10 + tmp5;\r\n\r\n    /* Final output stage: scale down by a factor of 8 and range-limit */\r\n\r\n    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n#endif /* DCT_IFAST_SUPPORTED */\r\n","/*\r\n * jidctint.c\r\n *\r\n * Copyright (C) 1991-1998, Thomas G. Lane.\r\n * Modification developed 2002-2013 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains a slow-but-accurate integer implementation of the\r\n * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine\r\n * must also perform dequantization of the input coefficients.\r\n *\r\n * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT\r\n * on each row (or vice versa, but it's more convenient to emit a row at\r\n * a time).  Direct algorithms are also available, but they are much more\r\n * complex and seem not to be any faster when reduced to code.\r\n *\r\n * This implementation is based on an algorithm described in\r\n *   C. Loeffler, A. Ligtenberg and G. Moschytz, \"Practical Fast 1-D DCT\r\n *   Algorithms with 11 Multiplications\", Proc. Int'l. Conf. on Acoustics,\r\n *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.\r\n * The primary algorithm described there uses 11 multiplies and 29 adds.\r\n * We use their alternate method with 12 multiplies and 32 adds.\r\n * The advantage of this method is that no data path contains more than one\r\n * multiplication; this allows a very simple and accurate implementation in\r\n * scaled fixed-point arithmetic, with a minimal number of shifts.\r\n *\r\n * We also provide IDCT routines with various output sample block sizes for\r\n * direct resolution reduction or enlargement and for direct resolving the\r\n * common 2x1 and 1x2 subsampling cases without additional resampling: NxN\r\n * (N=1...16), 2NxN, and Nx2N (N=1...8) pixels for one 8x8 input DCT block.\r\n *\r\n * For N<8 we simply take the corresponding low-frequency coefficients of\r\n * the 8x8 input DCT block and apply an NxN point IDCT on the sub-block\r\n * to yield the downscaled outputs.\r\n * This can be seen as direct low-pass downsampling from the DCT domain\r\n * point of view rather than the usual spatial domain point of view,\r\n * yielding significant computational savings and results at least\r\n * as good as common bilinear (averaging) spatial downsampling.\r\n *\r\n * For N>8 we apply a partial NxN IDCT on the 8 input coefficients as\r\n * lower frequencies and higher frequencies assumed to be zero.\r\n * It turns out that the computational effort is similar to the 8x8 IDCT\r\n * regarding the output size.\r\n * Furthermore, the scaling and descaling is the same for all IDCT sizes.\r\n *\r\n * CAUTION: We rely on the FIX() macro except for the N=1,2,4,8 cases\r\n * since there would be too many additional constants to pre-calculate.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jdct.h\"\t\t/* Private declarations for DCT subsystem */\r\n\r\n#ifdef DCT_ISLOW_SUPPORTED\r\n\r\n\r\n/*\r\n * This module is specialized to the case DCTSIZE = 8.\r\n */\r\n\r\n#if DCTSIZE != 8\r\n  Sorry, this code only copes with 8x8 DCT blocks. /* deliberate syntax err */\r\n#endif\r\n\r\n\r\n/*\r\n * The poop on this scaling stuff is as follows:\r\n *\r\n * Each 1-D IDCT step produces outputs which are a factor of sqrt(N)\r\n * larger than the true IDCT outputs.  The final outputs are therefore\r\n * a factor of N larger than desired; since N=8 this can be cured by\r\n * a simple right shift at the end of the algorithm.  The advantage of\r\n * this arrangement is that we save two multiplications per 1-D IDCT,\r\n * because the y0 and y4 inputs need not be divided by sqrt(N).\r\n *\r\n * We have to do addition and subtraction of the integer inputs, which\r\n * is no problem, and multiplication by fractional constants, which is\r\n * a problem to do in integer arithmetic.  We multiply all the constants\r\n * by CONST_SCALE and convert them to integer constants (thus retaining\r\n * CONST_BITS bits of precision in the constants).  After doing a\r\n * multiplication we have to divide the product by CONST_SCALE, with proper\r\n * rounding, to produce the correct output.  This division can be done\r\n * cheaply as a right shift of CONST_BITS bits.  We postpone shifting\r\n * as long as possible so that partial sums can be added together with\r\n * full fractional precision.\r\n *\r\n * The outputs of the first pass are scaled up by PASS1_BITS bits so that\r\n * they are represented to better-than-integral precision.  These outputs\r\n * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word\r\n * with the recommended scaling.  (To scale up 12-bit sample data further, an\r\n * intermediate INT32 array would be needed.)\r\n *\r\n * To avoid overflow of the 32-bit intermediate results in pass 2, we must\r\n * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis\r\n * shows that the values given below are the most effective.\r\n */\r\n\r\n#if BITS_IN_JSAMPLE == 8\r\n#define CONST_BITS  13\r\n#define PASS1_BITS  2\r\n#else\r\n#define CONST_BITS  13\r\n#define PASS1_BITS  1\t\t/* lose a little precision to avoid overflow */\r\n#endif\r\n\r\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\r\n * causing a lot of useless floating-point operations at run time.\r\n * To get around this we use the following pre-calculated constants.\r\n * If you change CONST_BITS you may want to add appropriate values.\r\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\r\n */\r\n\r\n#if CONST_BITS == 13\r\n#define FIX_0_298631336  ((INT32)  2446)\t/* FIX(0.298631336) */\r\n#define FIX_0_390180644  ((INT32)  3196)\t/* FIX(0.390180644) */\r\n#define FIX_0_541196100  ((INT32)  4433)\t/* FIX(0.541196100) */\r\n#define FIX_0_765366865  ((INT32)  6270)\t/* FIX(0.765366865) */\r\n#define FIX_0_899976223  ((INT32)  7373)\t/* FIX(0.899976223) */\r\n#define FIX_1_175875602  ((INT32)  9633)\t/* FIX(1.175875602) */\r\n#define FIX_1_501321110  ((INT32)  12299)\t/* FIX(1.501321110) */\r\n#define FIX_1_847759065  ((INT32)  15137)\t/* FIX(1.847759065) */\r\n#define FIX_1_961570560  ((INT32)  16069)\t/* FIX(1.961570560) */\r\n#define FIX_2_053119869  ((INT32)  16819)\t/* FIX(2.053119869) */\r\n#define FIX_2_562915447  ((INT32)  20995)\t/* FIX(2.562915447) */\r\n#define FIX_3_072711026  ((INT32)  25172)\t/* FIX(3.072711026) */\r\n#else\r\n#define FIX_0_298631336  FIX(0.298631336)\r\n#define FIX_0_390180644  FIX(0.390180644)\r\n#define FIX_0_541196100  FIX(0.541196100)\r\n#define FIX_0_765366865  FIX(0.765366865)\r\n#define FIX_0_899976223  FIX(0.899976223)\r\n#define FIX_1_175875602  FIX(1.175875602)\r\n#define FIX_1_501321110  FIX(1.501321110)\r\n#define FIX_1_847759065  FIX(1.847759065)\r\n#define FIX_1_961570560  FIX(1.961570560)\r\n#define FIX_2_053119869  FIX(2.053119869)\r\n#define FIX_2_562915447  FIX(2.562915447)\r\n#define FIX_3_072711026  FIX(3.072711026)\r\n#endif\r\n\r\n\r\n/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.\r\n * For 8-bit samples with the recommended scaling, all the variable\r\n * and constant values involved are no more than 16 bits wide, so a\r\n * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.\r\n * For 12-bit samples, a full 32-bit multiplication will be needed.\r\n */\r\n\r\n#if BITS_IN_JSAMPLE == 8\r\n#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)\r\n#else\r\n#define MULTIPLY(var,const)  ((var) * (const))\r\n#endif\r\n\r\n\r\n/* Dequantize a coefficient by multiplying it by the multiplier-table\r\n * entry; produce an int result.  In this module, both inputs and result\r\n * are 16 bits or less, so either int or short multiply will work.\r\n */\r\n\r\n#define DEQUANTIZE(coef,quantval)  (((ISLOW_MULT_TYPE) (coef)) * (quantval))\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients.\r\n *\r\n * cK represents sqrt(2) * cos(K*pi/16).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3;\r\n  INT32 tmp10, tmp11, tmp12, tmp13;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * Note results are scaled up by sqrt(8) compared to a true IDCT;\r\n   * furthermore, we scale the results by 2**PASS1_BITS.\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\r\n    /* Due to quantization, we will usually find that many of the input\r\n     * coefficients are zero, especially the AC terms.  We can exploit this\r\n     * by short-circuiting the IDCT calculation for any column in which all\r\n     * the AC terms are zero.  In that case each output is equal to the\r\n     * DC coefficient (with scale factor as needed).\r\n     * With typical images and quantization tables, half or more of the\r\n     * column DCT calculations can be simplified this way.\r\n     */\r\n\r\n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\r\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\r\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\r\n\tinptr[DCTSIZE*7] == 0) {\r\n      /* AC terms all zero */\r\n      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;\r\n\r\n      wsptr[DCTSIZE*0] = dcval;\r\n      wsptr[DCTSIZE*1] = dcval;\r\n      wsptr[DCTSIZE*2] = dcval;\r\n      wsptr[DCTSIZE*3] = dcval;\r\n      wsptr[DCTSIZE*4] = dcval;\r\n      wsptr[DCTSIZE*5] = dcval;\r\n      wsptr[DCTSIZE*6] = dcval;\r\n      wsptr[DCTSIZE*7] = dcval;\r\n\r\n      inptr++;\t\t\t/* advance pointers to next column */\r\n      quantptr++;\r\n      wsptr++;\r\n      continue;\r\n    }\r\n\r\n    /* Even part: reverse the even part of the forward DCT.\r\n     * The rotator is c(-6).\r\n     */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);       /* c6 */\r\n    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);     /* c2-c6 */\r\n    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);     /* c2+c6 */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z2 <<= CONST_BITS;\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z2 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    tmp0 = z2 + z3;\r\n    tmp1 = z2 - z3;\r\n\r\n    tmp10 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n    tmp11 = tmp1 + tmp3;\r\n    tmp12 = tmp1 - tmp3;\r\n\r\n    /* Odd part per figure 8; the matrix is unitary and hence its\r\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\r\n     */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n\r\n    z2 = tmp0 + tmp2;\r\n    z3 = tmp1 + tmp3;\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_1_175875602);       /*  c3 */\r\n    z2 = MULTIPLY(z2, - FIX_1_961570560);          /* -c3-c5 */\r\n    z3 = MULTIPLY(z3, - FIX_0_390180644);          /* -c3+c5 */\r\n    z2 += z1;\r\n    z3 += z1;\r\n\r\n    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* -c3+c7 */\r\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336);        /* -c1+c3+c5-c7 */\r\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110);        /*  c1+c3-c5-c7 */\r\n    tmp0 += z1 + z2;\r\n    tmp3 += z1 + z3;\r\n\r\n    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* -c1-c3 */\r\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869);        /*  c1+c3-c5+c7 */\r\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026);        /*  c1+c3+c5-c7 */\r\n    tmp1 += z1 + z3;\r\n    tmp2 += z1 + z2;\r\n\r\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n\r\n    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);\r\n\r\n    inptr++;\t\t\t/* advance pointers to next column */\r\n    quantptr++;\r\n    wsptr++;\r\n  }\r\n\r\n  /* Pass 2: process rows from work array, store into output array.\r\n   * Note that we must descale the results by a factor of 8 == 2**3,\r\n   * and also undo the PASS1_BITS scaling.\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\r\n     * However, the column calculation has created many nonzero AC terms, so\r\n     * the simplification applies less often (typically 5% to 10% of the time).\r\n     * On machines with very fast multiplication, it's possible that the\r\n     * test takes more time than it's worth.  In that case this section\r\n     * may be commented out.\r\n     */\r\n\r\n#ifndef NO_ZERO_ROW_TEST\r\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\r\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\r\n      /* AC terms all zero */\r\n      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)\r\n\t\t\t\t  & RANGE_MASK];\r\n\r\n      outptr[0] = dcval;\r\n      outptr[1] = dcval;\r\n      outptr[2] = dcval;\r\n      outptr[3] = dcval;\r\n      outptr[4] = dcval;\r\n      outptr[5] = dcval;\r\n      outptr[6] = dcval;\r\n      outptr[7] = dcval;\r\n\r\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n      continue;\r\n    }\r\n#endif\r\n\r\n    /* Even part: reverse the even part of the forward DCT.\r\n     * The rotator is c(-6).\r\n     */\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);       /* c6 */\r\n    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);     /* c2-c6 */\r\n    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);     /* c2+c6 */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 = (INT32) wsptr[4];\r\n\r\n    tmp0 = (z2 + z3) << CONST_BITS;\r\n    tmp1 = (z2 - z3) << CONST_BITS;\r\n\r\n    tmp10 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n    tmp11 = tmp1 + tmp3;\r\n    tmp12 = tmp1 - tmp3;\r\n\r\n    /* Odd part per figure 8; the matrix is unitary and hence its\r\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\r\n     */\r\n\r\n    tmp0 = (INT32) wsptr[7];\r\n    tmp1 = (INT32) wsptr[5];\r\n    tmp2 = (INT32) wsptr[3];\r\n    tmp3 = (INT32) wsptr[1];\r\n\r\n    z2 = tmp0 + tmp2;\r\n    z3 = tmp1 + tmp3;\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_1_175875602);       /*  c3 */\r\n    z2 = MULTIPLY(z2, - FIX_1_961570560);          /* -c3-c5 */\r\n    z3 = MULTIPLY(z3, - FIX_0_390180644);          /* -c3+c5 */\r\n    z2 += z1;\r\n    z3 += z1;\r\n\r\n    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* -c3+c7 */\r\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336);        /* -c1+c3+c5-c7 */\r\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110);        /*  c1+c3-c5-c7 */\r\n    tmp0 += z1 + z2;\r\n    tmp3 += z1 + z3;\r\n\r\n    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* -c1-c3 */\r\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869);        /*  c1+c3-c5+c7 */\r\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026);        /*  c1+c3+c5-c7 */\r\n    tmp1 += z1 + z3;\r\n    tmp2 += z1 + z2;\r\n\r\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n#ifdef IDCT_SCALING_SUPPORTED\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 7x7 output block.\r\n *\r\n * Optimized algorithm with 12 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/14).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_7x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12, tmp13;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[7*7];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp13 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp13 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp13 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */\r\n    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\r\n    tmp0 = z1 + z3;\r\n    z2 -= tmp0;\r\n    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */\r\n    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */\r\n    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */\r\n    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n\r\n    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */\r\n    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */\r\n    tmp0 = tmp1 - tmp2;\r\n    tmp1 += tmp2;\r\n    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */\r\n    tmp1 += tmp2;\r\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */\r\n    tmp0 += z2;\r\n    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[7*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*6] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*5] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*4] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*3] = (int) RIGHT_SHIFT(tmp13, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 7 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 7; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp13 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp13 <<= CONST_BITS;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[4];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */\r\n    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\r\n    tmp0 = z1 + z3;\r\n    z2 -= tmp0;\r\n    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */\r\n    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */\r\n    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */\r\n    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n\r\n    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */\r\n    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */\r\n    tmp0 = tmp1 - tmp2;\r\n    tmp1 += tmp2;\r\n    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */\r\n    tmp1 += tmp2;\r\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */\r\n    tmp0 += z2;\r\n    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 7;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 6x6 output block.\r\n *\r\n * Optimized algorithm with 3 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/12).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_6x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[6*6];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */\r\n    tmp1 = tmp0 + tmp10;\r\n    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);\r\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */\r\n    tmp10 = tmp1 + tmp0;\r\n    tmp12 = tmp1 - tmp0;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\r\n    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);\r\n    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);\r\n    tmp1 = (z1 - z2 - z3) << PASS1_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*1] = (int) (tmp11 + tmp1);\r\n    wsptr[6*4] = (int) (tmp11 - tmp1);\r\n    wsptr[6*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 6 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 6; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n    tmp2 = (INT32) wsptr[4];\r\n    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */\r\n    tmp1 = tmp0 + tmp10;\r\n    tmp11 = tmp0 - tmp10 - tmp10;\r\n    tmp10 = (INT32) wsptr[2];\r\n    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */\r\n    tmp10 = tmp1 + tmp0;\r\n    tmp12 = tmp1 - tmp0;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\r\n    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);\r\n    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);\r\n    tmp1 = (z1 - z2 - z3) << CONST_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 6;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 5x5 output block.\r\n *\r\n * Optimized algorithm with 5 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/10).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_5x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp10, tmp11, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[5*5];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp12 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */\r\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */\r\n    z3 = tmp12 + z2;\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z1;\r\n    tmp12 -= z2 << 2;\r\n\r\n    /* Odd part */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */\r\n    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */\r\n    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[5*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*4] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*3] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 5 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 5; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp12 <<= CONST_BITS;\r\n    tmp0 = (INT32) wsptr[2];\r\n    tmp1 = (INT32) wsptr[4];\r\n    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */\r\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */\r\n    z3 = tmp12 + z2;\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z1;\r\n    tmp12 -= z2 << 2;\r\n\r\n    /* Odd part */\r\n\r\n    z2 = (INT32) wsptr[1];\r\n    z3 = (INT32) wsptr[3];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */\r\n    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */\r\n    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 5;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 4x4 output block.\r\n *\r\n * Optimized algorithm with 3 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp2, tmp10, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[4*4];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    \r\n    tmp10 = (tmp0 + tmp2) << PASS1_BITS;\r\n    tmp12 = (tmp0 - tmp2) << PASS1_BITS;\r\n\r\n    /* Odd part */\r\n    /* Same rotation as in the even part of the 8x8 LL&M IDCT */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */\r\n    /* Add fudge factor here for final descale. */\r\n    z1 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */\r\n\t\t       CONST_BITS-PASS1_BITS);\r\n    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */\r\n\t\t       CONST_BITS-PASS1_BITS);\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[4*0] = (int) (tmp10 + tmp0);\r\n    wsptr[4*3] = (int) (tmp10 - tmp0);\r\n    wsptr[4*1] = (int) (tmp12 + tmp2);\r\n    wsptr[4*2] = (int) (tmp12 - tmp2);\r\n  }\r\n\r\n  /* Pass 2: process 4 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 4; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp2 = (INT32) wsptr[2];\r\n\r\n    tmp10 = (tmp0 + tmp2) << CONST_BITS;\r\n    tmp12 = (tmp0 - tmp2) << CONST_BITS;\r\n\r\n    /* Odd part */\r\n    /* Same rotation as in the even part of the 8x8 LL&M IDCT */\r\n\r\n    z2 = (INT32) wsptr[1];\r\n    z3 = (INT32) wsptr[3];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */\r\n    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */\r\n    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 4;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 3x3 output block.\r\n *\r\n * Optimized algorithm with 2 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/6).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_3x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp2, tmp10, tmp12;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[3*3];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\r\n    tmp10 = tmp0 + tmp12;\r\n    tmp2 = tmp0 - tmp12 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[3*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[3*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 3 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 3; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n    tmp2 = (INT32) wsptr[2];\r\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\r\n    tmp10 = tmp0 + tmp12;\r\n    tmp2 = tmp0 - tmp12 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    tmp12 = (INT32) wsptr[1];\r\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 3;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 2x2 output block.\r\n *\r\n * Multiplication-less algorithm.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input. */\r\n\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n\r\n  /* Column 0 */\r\n  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n  /* Add fudge factor here for final descale. */\r\n  tmp4 += ONE << 2;\r\n\r\n  tmp0 = tmp4 + tmp5;\r\n  tmp2 = tmp4 - tmp5;\r\n\r\n  /* Column 1 */\r\n  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0+1], quantptr[DCTSIZE*0+1]);\r\n  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1+1], quantptr[DCTSIZE*1+1]);\r\n\r\n  tmp1 = tmp4 + tmp5;\r\n  tmp3 = tmp4 - tmp5;\r\n\r\n  /* Pass 2: process 2 rows, store into output array. */\r\n\r\n  /* Row 0 */\r\n  outptr = output_buf[0] + output_col;\r\n\r\n  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp0 + tmp1, 3) & RANGE_MASK];\r\n  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp0 - tmp1, 3) & RANGE_MASK];\r\n\r\n  /* Row 1 */\r\n  outptr = output_buf[1] + output_col;\r\n\r\n  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp2 + tmp3, 3) & RANGE_MASK];\r\n  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2 - tmp3, 3) & RANGE_MASK];\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 1x1 output block.\r\n *\r\n * We hardly need an inverse DCT routine for this: just take the\r\n * average pixel value, which is one-eighth of the DC coefficient.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  int dcval;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  SHIFT_TEMPS\r\n\r\n  /* 1x1 is trivial: just take the DC coefficient divided by 8. */\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);\r\n  dcval = (int) DESCALE((INT32) dcval, 3);\r\n\r\n  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 9x9 output block.\r\n *\r\n * Optimized algorithm with 10 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/18).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_9x9 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13, tmp14;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*9];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */\r\n    tmp1 = tmp0 + tmp3;\r\n    tmp2 = tmp0 - tmp3 - tmp3;\r\n\r\n    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */\r\n    tmp11 = tmp2 + tmp0;\r\n    tmp14 = tmp2 - tmp0 - tmp0;\r\n\r\n    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */\r\n    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */\r\n    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */\r\n\r\n    tmp10 = tmp1 + tmp0 - tmp3;\r\n    tmp12 = tmp1 - tmp0 + tmp2;\r\n    tmp13 = tmp1 - tmp2 + tmp3;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */\r\n\r\n    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */\r\n    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */\r\n    tmp0 = tmp2 + tmp3 - z2;\r\n    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */\r\n    tmp2 += z2 - tmp1;\r\n    tmp3 += z2 + tmp1;\r\n    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3] = (int) RIGHT_SHIFT(tmp13 + tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5] = (int) RIGHT_SHIFT(tmp13 - tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4] = (int) RIGHT_SHIFT(tmp14, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 9 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 9; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[4];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */\r\n    tmp1 = tmp0 + tmp3;\r\n    tmp2 = tmp0 - tmp3 - tmp3;\r\n\r\n    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */\r\n    tmp11 = tmp2 + tmp0;\r\n    tmp14 = tmp2 - tmp0 - tmp0;\r\n\r\n    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */\r\n    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */\r\n    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */\r\n\r\n    tmp10 = tmp1 + tmp0 - tmp3;\r\n    tmp12 = tmp1 - tmp0 + tmp2;\r\n    tmp13 = tmp1 - tmp2 + tmp3;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */\r\n\r\n    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */\r\n    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */\r\n    tmp0 = tmp2 + tmp3 - z2;\r\n    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */\r\n    tmp2 += z2 - tmp1;\r\n    tmp3 += z2 + tmp1;\r\n    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 10x10 output block.\r\n *\r\n * Optimized algorithm with 12 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/20).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_10x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;\r\n  INT32 z1, z2, z3, z4, z5;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*10];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z3 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\r\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z2;\r\n\r\n    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */\r\n\t\t\tCONST_BITS-PASS1_BITS);\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\r\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\r\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp24 = tmp10 - tmp12;\r\n    tmp21 = tmp11 + tmp13;\r\n    tmp23 = tmp11 - tmp13;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = z2 + z4;\r\n    tmp13 = z2 - z4;\r\n\r\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\r\n    z5 = z3 << CONST_BITS;\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\r\n    z4 = z5 + tmp12;\r\n\r\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\r\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\r\n    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));\r\n\r\n    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;\r\n\r\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\r\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2] = (int) (tmp22 + tmp12);\r\n    wsptr[8*7] = (int) (tmp22 - tmp12);\r\n    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 10 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 10; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 <<= CONST_BITS;\r\n    z4 = (INT32) wsptr[4];\r\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\r\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z2;\r\n\r\n    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\r\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\r\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp24 = tmp10 - tmp12;\r\n    tmp21 = tmp11 + tmp13;\r\n    tmp23 = tmp11 - tmp13;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z3 <<= CONST_BITS;\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = z2 + z4;\r\n    tmp13 = z2 - z4;\r\n\r\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\r\n    z4 = z3 + tmp12;\r\n\r\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\r\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\r\n    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));\r\n\r\n    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;\r\n\r\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\r\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 11x11 output block.\r\n *\r\n * Optimized algorithm with 24 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/22).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_11x11 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*11];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp10 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */\r\n    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */\r\n    z4 = z1 + z3;\r\n    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */\r\n    z4 -= z2;\r\n    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */\r\n    tmp21 = tmp20 + tmp23 + tmp25 -\r\n\t    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */\r\n    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */\r\n    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */\r\n    tmp24 += tmp25;\r\n    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */\r\n    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */\r\n\t     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */\r\n    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = z1 + z2;\r\n    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */\r\n    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */\r\n    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */\r\n    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */\r\n    tmp10 = tmp11 + tmp12 + tmp13 -\r\n\t    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */\r\n    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */\r\n    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */\r\n    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */\r\n    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */\r\n    tmp11 += z1;\r\n    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */\r\n    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */\r\n\t     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */\r\n\t     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*10] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 11 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 11; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp10 <<= CONST_BITS;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[4];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */\r\n    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */\r\n    z4 = z1 + z3;\r\n    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */\r\n    z4 -= z2;\r\n    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */\r\n    tmp21 = tmp20 + tmp23 + tmp25 -\r\n\t    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */\r\n    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */\r\n    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */\r\n    tmp24 += tmp25;\r\n    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */\r\n    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */\r\n\t     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */\r\n    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = z1 + z2;\r\n    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */\r\n    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */\r\n    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */\r\n    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */\r\n    tmp10 = tmp11 + tmp12 + tmp13 -\r\n\t    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */\r\n    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */\r\n    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */\r\n    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */\r\n    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */\r\n    tmp11 += z1;\r\n    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */\r\n    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */\r\n\t     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */\r\n\t     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 12x12 output block.\r\n *\r\n * Optimized algorithm with 15 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/24).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_12x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*12];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z3 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\r\n\r\n    tmp10 = z3 + z4;\r\n    tmp11 = z3 - z4;\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\r\n    z1 <<= CONST_BITS;\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n    z2 <<= CONST_BITS;\r\n\r\n    tmp12 = z1 - z2;\r\n\r\n    tmp21 = z3 + tmp12;\r\n    tmp24 = z3 - tmp12;\r\n\r\n    tmp12 = z4 + z2;\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp25 = tmp10 - tmp12;\r\n\r\n    tmp12 = z4 - z1 - z2;\r\n\r\n    tmp22 = tmp11 + tmp12;\r\n    tmp23 = tmp11 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\r\n    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */\r\n\r\n    tmp10 = z1 + z3;\r\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\r\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\r\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\r\n    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */\r\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\r\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\r\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\r\n\t     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\r\n\r\n    z1 -= z4;\r\n    z2 -= z3;\r\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\r\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 12 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 12; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 <<= CONST_BITS;\r\n\r\n    z4 = (INT32) wsptr[4];\r\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\r\n\r\n    tmp10 = z3 + z4;\r\n    tmp11 = z3 - z4;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\r\n    z1 <<= CONST_BITS;\r\n    z2 = (INT32) wsptr[6];\r\n    z2 <<= CONST_BITS;\r\n\r\n    tmp12 = z1 - z2;\r\n\r\n    tmp21 = z3 + tmp12;\r\n    tmp24 = z3 - tmp12;\r\n\r\n    tmp12 = z4 + z2;\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp25 = tmp10 - tmp12;\r\n\r\n    tmp12 = z4 - z1 - z2;\r\n\r\n    tmp22 = tmp11 + tmp12;\r\n    tmp23 = tmp11 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\r\n    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */\r\n\r\n    tmp10 = z1 + z3;\r\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\r\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\r\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\r\n    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */\r\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\r\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\r\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\r\n\t     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\r\n\r\n    z1 -= z4;\r\n    z2 -= z3;\r\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\r\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 13x13 output block.\r\n *\r\n * Optimized algorithm with 29 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/26).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_13x13 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*13];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z1 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z1 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp10 = z3 + z4;\r\n    tmp11 = z3 - z4;\r\n\r\n    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */\r\n    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */\r\n\r\n    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */\r\n    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */\r\n\r\n    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */\r\n    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */\r\n\r\n    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */\r\n    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */\r\n\r\n    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */\r\n    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */\r\n\r\n    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */\r\n    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */\r\n\r\n    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */\r\n    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */\r\n    tmp15 = z1 + z4;\r\n    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */\r\n    tmp10 = tmp11 + tmp12 + tmp13 -\r\n\t    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */\r\n    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */\r\n    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */\r\n    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */\r\n    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */\r\n    tmp11 += tmp14;\r\n    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */\r\n    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */\r\n    tmp12 += tmp14;\r\n    tmp13 += tmp14;\r\n    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */\r\n    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */\r\n\t    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */\r\n    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */\r\n    tmp14 += z1;\r\n    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */\r\n\t     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*12] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*11] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*10] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 13 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 13; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z1 <<= CONST_BITS;\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[4];\r\n    z4 = (INT32) wsptr[6];\r\n\r\n    tmp10 = z3 + z4;\r\n    tmp11 = z3 - z4;\r\n\r\n    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */\r\n    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */\r\n\r\n    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */\r\n    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */\r\n\r\n    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */\r\n    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */\r\n\r\n    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */\r\n    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */\r\n\r\n    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */\r\n    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */\r\n\r\n    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */\r\n    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */\r\n\r\n    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */\r\n    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */\r\n    tmp15 = z1 + z4;\r\n    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */\r\n    tmp10 = tmp11 + tmp12 + tmp13 -\r\n\t    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */\r\n    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */\r\n    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */\r\n    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */\r\n    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */\r\n    tmp11 += tmp14;\r\n    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */\r\n    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */\r\n    tmp12 += tmp14;\r\n    tmp13 += tmp14;\r\n    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */\r\n    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */\r\n\t    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */\r\n    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */\r\n    tmp14 += z1;\r\n    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */\r\n\t     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 14x14 output block.\r\n *\r\n * Optimized algorithm with 20 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/28).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_14x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*14];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z1 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z1 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\r\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\r\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\r\n\r\n    tmp10 = z1 + z2;\r\n    tmp11 = z1 + z3;\r\n    tmp12 = z1 - z4;\r\n\r\n    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */\r\n\t\t\tCONST_BITS-PASS1_BITS);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\r\n\r\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\r\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\r\n\t    MULTIPLY(z2, FIX(1.378756276));      /* c2 */\r\n\r\n    tmp20 = tmp10 + tmp13;\r\n    tmp26 = tmp10 - tmp13;\r\n    tmp21 = tmp11 + tmp14;\r\n    tmp25 = tmp11 - tmp14;\r\n    tmp22 = tmp12 + tmp15;\r\n    tmp24 = tmp12 - tmp15;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n    tmp13 = z4 << CONST_BITS;\r\n\r\n    tmp14 = z1 + z3;\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\r\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\r\n    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\r\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\r\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\r\n    z1    -= z2;\r\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */\r\n    tmp16 += tmp15;\r\n    z1    += z4;\r\n    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */\r\n    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */\r\n    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */\r\n    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\r\n    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\r\n    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */\r\n\r\n    tmp13 = (z1 - z3) << PASS1_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) (tmp23 + tmp13);\r\n    wsptr[8*10] = (int) (tmp23 - tmp13);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 14 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 14; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z1 <<= CONST_BITS;\r\n    z4 = (INT32) wsptr[4];\r\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\r\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\r\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\r\n\r\n    tmp10 = z1 + z2;\r\n    tmp11 = z1 + z3;\r\n    tmp12 = z1 - z4;\r\n\r\n    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[6];\r\n\r\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\r\n\r\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\r\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\r\n\t    MULTIPLY(z2, FIX(1.378756276));      /* c2 */\r\n\r\n    tmp20 = tmp10 + tmp13;\r\n    tmp26 = tmp10 - tmp13;\r\n    tmp21 = tmp11 + tmp14;\r\n    tmp25 = tmp11 - tmp14;\r\n    tmp22 = tmp12 + tmp15;\r\n    tmp24 = tmp12 - tmp15;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n    z4 <<= CONST_BITS;\r\n\r\n    tmp14 = z1 + z3;\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\r\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\r\n    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\r\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\r\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\r\n    z1    -= z2;\r\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */\r\n    tmp16 += tmp15;\r\n    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */\r\n    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */\r\n    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */\r\n    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\r\n    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\r\n    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */\r\n\r\n    tmp13 = ((z1 - z3) << CONST_BITS) + z4;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 15x15 output block.\r\n *\r\n * Optimized algorithm with 22 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/30).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_15x15 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*15];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z1 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z1 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */\r\n    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */\r\n\r\n    tmp12 = z1 - tmp10;\r\n    tmp13 = z1 + tmp11;\r\n    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */\r\n\r\n    z4 = z2 - z3;\r\n    z3 += z2;\r\n    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */\r\n    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */\r\n    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */\r\n\r\n    tmp20 = tmp13 + tmp10 + tmp11;\r\n    tmp23 = tmp12 - tmp10 + tmp11 + z2;\r\n\r\n    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */\r\n    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */\r\n\r\n    tmp25 = tmp13 - tmp10 - tmp11;\r\n    tmp26 = tmp12 + tmp10 - tmp11 - z2;\r\n\r\n    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */\r\n    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */\r\n\r\n    tmp21 = tmp12 + tmp10 + tmp11;\r\n    tmp24 = tmp13 - tmp10 + tmp11;\r\n    tmp11 += tmp11;\r\n    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */\r\n    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp13 = z2 - z4;\r\n    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */\r\n    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */\r\n    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */\r\n\r\n    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */\r\n    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */\r\n    z2 = z1 - z4;\r\n    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */\r\n\r\n    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */\r\n    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */\r\n    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */\r\n    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */\r\n    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */\r\n    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*14] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*13] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*12] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*11] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*10] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 15 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 15; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z1 <<= CONST_BITS;\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[4];\r\n    z4 = (INT32) wsptr[6];\r\n\r\n    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */\r\n    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */\r\n\r\n    tmp12 = z1 - tmp10;\r\n    tmp13 = z1 + tmp11;\r\n    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */\r\n\r\n    z4 = z2 - z3;\r\n    z3 += z2;\r\n    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */\r\n    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */\r\n    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */\r\n\r\n    tmp20 = tmp13 + tmp10 + tmp11;\r\n    tmp23 = tmp12 - tmp10 + tmp11 + z2;\r\n\r\n    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */\r\n    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */\r\n\r\n    tmp25 = tmp13 - tmp10 - tmp11;\r\n    tmp26 = tmp12 + tmp10 - tmp11 - z2;\r\n\r\n    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */\r\n    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */\r\n\r\n    tmp21 = tmp12 + tmp10 + tmp11;\r\n    tmp24 = tmp13 - tmp10 + tmp11;\r\n    tmp11 += tmp11;\r\n    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */\r\n    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z4 = (INT32) wsptr[5];\r\n    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp13 = z2 - z4;\r\n    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */\r\n    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */\r\n    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */\r\n\r\n    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */\r\n    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */\r\n    z2 = z1 - z4;\r\n    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */\r\n\r\n    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */\r\n    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */\r\n    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */\r\n    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */\r\n    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */\r\n    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 16x16 output block.\r\n *\r\n * Optimized algorithm with 28 multiplications in the 1-D kernel.\r\n * cK represents sqrt(2) * cos(K*pi/32).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_16x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\t JCOEFPTR coef_block,\r\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*16];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += 1 << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\r\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\r\n\r\n    tmp10 = tmp0 + tmp1;\r\n    tmp11 = tmp0 - tmp1;\r\n    tmp12 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n    z3 = z1 - z2;\r\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\r\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\r\n\r\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\r\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\r\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\r\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\r\n\r\n    tmp20 = tmp10 + tmp0;\r\n    tmp27 = tmp10 - tmp0;\r\n    tmp21 = tmp12 + tmp1;\r\n    tmp26 = tmp12 - tmp1;\r\n    tmp22 = tmp13 + tmp2;\r\n    tmp25 = tmp13 - tmp2;\r\n    tmp23 = tmp11 + tmp3;\r\n    tmp24 = tmp11 - tmp3;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = z1 + z3;\r\n\r\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\r\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\r\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\r\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\r\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\r\n    tmp0  = tmp1 + tmp2 + tmp3 -\r\n\t    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\r\n    tmp13 = tmp10 + tmp11 + tmp12 -\r\n\t    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\r\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\r\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\r\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\r\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\r\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\r\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\r\n    z2    += z4;\r\n    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */\r\n    tmp1  += z1;\r\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\r\n    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */\r\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\r\n    tmp12 += z2;\r\n    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */\r\n    tmp2  += z2;\r\n    tmp3  += z2;\r\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\r\n    tmp10 += z2;\r\n    tmp11 += z2;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 16 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 16; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n\r\n    z1 = (INT32) wsptr[4];\r\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\r\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\r\n\r\n    tmp10 = tmp0 + tmp1;\r\n    tmp11 = tmp0 - tmp1;\r\n    tmp12 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[6];\r\n    z3 = z1 - z2;\r\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\r\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\r\n\r\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\r\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\r\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\r\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\r\n\r\n    tmp20 = tmp10 + tmp0;\r\n    tmp27 = tmp10 - tmp0;\r\n    tmp21 = tmp12 + tmp1;\r\n    tmp26 = tmp12 - tmp1;\r\n    tmp22 = tmp13 + tmp2;\r\n    tmp25 = tmp13 - tmp2;\r\n    tmp23 = tmp11 + tmp3;\r\n    tmp24 = tmp11 - tmp3;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = z1 + z3;\r\n\r\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\r\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\r\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\r\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\r\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\r\n    tmp0  = tmp1 + tmp2 + tmp3 -\r\n\t    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\r\n    tmp13 = tmp10 + tmp11 + tmp12 -\r\n\t    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\r\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\r\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\r\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\r\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\r\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\r\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\r\n    z2    += z4;\r\n    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */\r\n    tmp1  += z1;\r\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\r\n    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */\r\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\r\n    tmp12 += z2;\r\n    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */\r\n    tmp2  += z2;\r\n    tmp3  += z2;\r\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\r\n    tmp10 += z2;\r\n    tmp11 += z2;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 16x8 output block.\r\n *\r\n * 8-point IDCT in pass 1 (columns), 16-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_16x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*8];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * Note results are scaled up by sqrt(8) compared to a true IDCT;\r\n   * furthermore, we scale the results by 2**PASS1_BITS.\r\n   * 8-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\r\n    /* Due to quantization, we will usually find that many of the input\r\n     * coefficients are zero, especially the AC terms.  We can exploit this\r\n     * by short-circuiting the IDCT calculation for any column in which all\r\n     * the AC terms are zero.  In that case each output is equal to the\r\n     * DC coefficient (with scale factor as needed).\r\n     * With typical images and quantization tables, half or more of the\r\n     * column DCT calculations can be simplified this way.\r\n     */\r\n\r\n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\r\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\r\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\r\n\tinptr[DCTSIZE*7] == 0) {\r\n      /* AC terms all zero */\r\n      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;\r\n\r\n      wsptr[DCTSIZE*0] = dcval;\r\n      wsptr[DCTSIZE*1] = dcval;\r\n      wsptr[DCTSIZE*2] = dcval;\r\n      wsptr[DCTSIZE*3] = dcval;\r\n      wsptr[DCTSIZE*4] = dcval;\r\n      wsptr[DCTSIZE*5] = dcval;\r\n      wsptr[DCTSIZE*6] = dcval;\r\n      wsptr[DCTSIZE*7] = dcval;\r\n\r\n      inptr++;\t\t\t/* advance pointers to next column */\r\n      quantptr++;\r\n      wsptr++;\r\n      continue;\r\n    }\r\n\r\n    /* Even part: reverse the even part of the forward DCT.\r\n     * The rotator is c(-6).\r\n     */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);       /* c6 */\r\n    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);     /* c2-c6 */\r\n    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);     /* c2+c6 */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z2 <<= CONST_BITS;\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z2 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    tmp0 = z2 + z3;\r\n    tmp1 = z2 - z3;\r\n\r\n    tmp10 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n    tmp11 = tmp1 + tmp3;\r\n    tmp12 = tmp1 - tmp3;\r\n\r\n    /* Odd part per figure 8; the matrix is unitary and hence its\r\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\r\n     */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n\r\n    z2 = tmp0 + tmp2;\r\n    z3 = tmp1 + tmp3;\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_1_175875602);       /*  c3 */\r\n    z2 = MULTIPLY(z2, - FIX_1_961570560);          /* -c3-c5 */\r\n    z3 = MULTIPLY(z3, - FIX_0_390180644);          /* -c3+c5 */\r\n    z2 += z1;\r\n    z3 += z1;\r\n\r\n    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* -c3+c7 */\r\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336);        /* -c1+c3+c5-c7 */\r\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110);        /*  c1+c3-c5-c7 */\r\n    tmp0 += z1 + z2;\r\n    tmp3 += z1 + z3;\r\n\r\n    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* -c1-c3 */\r\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869);        /*  c1+c3-c5+c7 */\r\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026);        /*  c1+c3+c5-c7 */\r\n    tmp1 += z1 + z3;\r\n    tmp2 += z1 + z2;\r\n\r\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n\r\n    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);\r\n\r\n    inptr++;\t\t\t/* advance pointers to next column */\r\n    quantptr++;\r\n    wsptr++;\r\n  }\r\n\r\n  /* Pass 2: process 8 rows from work array, store into output array.\r\n   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n\r\n    z1 = (INT32) wsptr[4];\r\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\r\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\r\n\r\n    tmp10 = tmp0 + tmp1;\r\n    tmp11 = tmp0 - tmp1;\r\n    tmp12 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[6];\r\n    z3 = z1 - z2;\r\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\r\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\r\n\r\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\r\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\r\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\r\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\r\n\r\n    tmp20 = tmp10 + tmp0;\r\n    tmp27 = tmp10 - tmp0;\r\n    tmp21 = tmp12 + tmp1;\r\n    tmp26 = tmp12 - tmp1;\r\n    tmp22 = tmp13 + tmp2;\r\n    tmp25 = tmp13 - tmp2;\r\n    tmp23 = tmp11 + tmp3;\r\n    tmp24 = tmp11 - tmp3;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = z1 + z3;\r\n\r\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\r\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\r\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\r\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\r\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\r\n    tmp0  = tmp1 + tmp2 + tmp3 -\r\n\t    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\r\n    tmp13 = tmp10 + tmp11 + tmp12 -\r\n\t    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\r\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\r\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\r\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\r\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\r\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\r\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\r\n    z2    += z4;\r\n    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */\r\n    tmp1  += z1;\r\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\r\n    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */\r\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\r\n    tmp12 += z2;\r\n    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */\r\n    tmp2  += z2;\r\n    tmp3  += z2;\r\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\r\n    tmp10 += z2;\r\n    tmp11 += z2;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 14x7 output block.\r\n *\r\n * 7-point IDCT in pass 1 (columns), 14-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_14x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*7];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp23 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp23 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp23 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */\r\n    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */\r\n    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\r\n    tmp10 = z1 + z3;\r\n    z2 -= tmp10;\r\n    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */\r\n    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */\r\n    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */\r\n    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */\r\n    tmp10 = tmp11 - tmp12;\r\n    tmp11 += tmp12;\r\n    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */\r\n    tmp11 += tmp12;\r\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */\r\n    tmp10 += z2;\r\n    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 7 rows from work array, store into output array.\r\n   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 7; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z1 <<= CONST_BITS;\r\n    z4 = (INT32) wsptr[4];\r\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\r\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\r\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\r\n\r\n    tmp10 = z1 + z2;\r\n    tmp11 = z1 + z3;\r\n    tmp12 = z1 - z4;\r\n\r\n    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[6];\r\n\r\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\r\n\r\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\r\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\r\n\t    MULTIPLY(z2, FIX(1.378756276));      /* c2 */\r\n\r\n    tmp20 = tmp10 + tmp13;\r\n    tmp26 = tmp10 - tmp13;\r\n    tmp21 = tmp11 + tmp14;\r\n    tmp25 = tmp11 - tmp14;\r\n    tmp22 = tmp12 + tmp15;\r\n    tmp24 = tmp12 - tmp15;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n    z4 <<= CONST_BITS;\r\n\r\n    tmp14 = z1 + z3;\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\r\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\r\n    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\r\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\r\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\r\n    z1    -= z2;\r\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */\r\n    tmp16 += tmp15;\r\n    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */\r\n    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */\r\n    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */\r\n    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\r\n    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\r\n    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */\r\n\r\n    tmp13 = ((z1 - z3) << CONST_BITS) + z4;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 12x6 output block.\r\n *\r\n * 6-point IDCT in pass 1 (columns), 12-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_12x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*6];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp10 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */\r\n    tmp11 = tmp10 + tmp20;\r\n    tmp21 = RIGHT_SHIFT(tmp10 - tmp20 - tmp20, CONST_BITS-PASS1_BITS);\r\n    tmp20 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */\r\n    tmp20 = tmp11 + tmp10;\r\n    tmp22 = tmp11 - tmp10;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\r\n    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);\r\n    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);\r\n    tmp11 = (z1 - z2 - z3) << PASS1_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1] = (int) (tmp21 + tmp11);\r\n    wsptr[8*4] = (int) (tmp21 - tmp11);\r\n    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 6 rows from work array, store into output array.\r\n   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 6; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 <<= CONST_BITS;\r\n\r\n    z4 = (INT32) wsptr[4];\r\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\r\n\r\n    tmp10 = z3 + z4;\r\n    tmp11 = z3 - z4;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\r\n    z1 <<= CONST_BITS;\r\n    z2 = (INT32) wsptr[6];\r\n    z2 <<= CONST_BITS;\r\n\r\n    tmp12 = z1 - z2;\r\n\r\n    tmp21 = z3 + tmp12;\r\n    tmp24 = z3 - tmp12;\r\n\r\n    tmp12 = z4 + z2;\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp25 = tmp10 - tmp12;\r\n\r\n    tmp12 = z4 - z1 - z2;\r\n\r\n    tmp22 = tmp11 + tmp12;\r\n    tmp23 = tmp11 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\r\n    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */\r\n\r\n    tmp10 = z1 + z3;\r\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\r\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\r\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\r\n    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */\r\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\r\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\r\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\r\n\t     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\r\n\r\n    z1 -= z4;\r\n    z2 -= z3;\r\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\r\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,\r\n\t\t\t\t\t       CONST_BITS+PASS1_BITS+3)\r\n\t\t\t     & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 10x5 output block.\r\n *\r\n * 5-point IDCT in pass 1 (columns), 10-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_10x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*5];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp12 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp13 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp14 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */\r\n    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */\r\n    z3 = tmp12 + z2;\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z1;\r\n    tmp12 -= z2 << 2;\r\n\r\n    /* Odd part */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */\r\n    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */\r\n    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4] = (int) RIGHT_SHIFT(tmp10 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3] = (int) RIGHT_SHIFT(tmp11 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 5 rows from work array, store into output array.\r\n   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 5; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 <<= CONST_BITS;\r\n    z4 = (INT32) wsptr[4];\r\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\r\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z2;\r\n\r\n    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\r\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\r\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp24 = tmp10 - tmp12;\r\n    tmp21 = tmp11 + tmp13;\r\n    tmp23 = tmp11 - tmp13;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    z3 <<= CONST_BITS;\r\n    z4 = (INT32) wsptr[7];\r\n\r\n    tmp11 = z2 + z4;\r\n    tmp13 = z2 - z4;\r\n\r\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\r\n    z4 = z3 + tmp12;\r\n\r\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\r\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\r\n    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));\r\n\r\n    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;\r\n\r\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\r\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 8;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 8x4 output block.\r\n *\r\n * 4-point IDCT in pass 1 (columns), 8-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_8x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3;\r\n  INT32 tmp10, tmp11, tmp12, tmp13;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*4];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 4-point IDCT kernel,\r\n   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n\r\n    tmp10 = (tmp0 + tmp2) << PASS1_BITS;\r\n    tmp12 = (tmp0 - tmp2) << PASS1_BITS;\r\n\r\n    /* Odd part */\r\n    /* Same rotation as in the even part of the 8x8 LL&M IDCT */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */\r\n    /* Add fudge factor here for final descale. */\r\n    z1 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */\r\n\t\t       CONST_BITS-PASS1_BITS);\r\n    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */\r\n\t\t       CONST_BITS-PASS1_BITS);\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0] = (int) (tmp10 + tmp0);\r\n    wsptr[8*3] = (int) (tmp10 - tmp0);\r\n    wsptr[8*1] = (int) (tmp12 + tmp2);\r\n    wsptr[8*2] = (int) (tmp12 - tmp2);\r\n  }\r\n\r\n  /* Pass 2: process rows from work array, store into output array.\r\n   * Note that we must descale the results by a factor of 8 == 2**3,\r\n   * and also undo the PASS1_BITS scaling.\r\n   * 8-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 4; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part: reverse the even part of the forward DCT.\r\n     * The rotator is c(-6).\r\n     */\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);       /* c6 */\r\n    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);     /* c2-c6 */\r\n    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);     /* c2+c6 */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 = (INT32) wsptr[4];\r\n\r\n    tmp0 = (z2 + z3) << CONST_BITS;\r\n    tmp1 = (z2 - z3) << CONST_BITS;\r\n\r\n    tmp10 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n    tmp11 = tmp1 + tmp3;\r\n    tmp12 = tmp1 - tmp3;\r\n\r\n    /* Odd part per figure 8; the matrix is unitary and hence its\r\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\r\n     */\r\n\r\n    tmp0 = (INT32) wsptr[7];\r\n    tmp1 = (INT32) wsptr[5];\r\n    tmp2 = (INT32) wsptr[3];\r\n    tmp3 = (INT32) wsptr[1];\r\n\r\n    z2 = tmp0 + tmp2;\r\n    z3 = tmp1 + tmp3;\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_1_175875602);       /*  c3 */\r\n    z2 = MULTIPLY(z2, - FIX_1_961570560);          /* -c3-c5 */\r\n    z3 = MULTIPLY(z3, - FIX_0_390180644);          /* -c3+c5 */\r\n    z2 += z1;\r\n    z3 += z1;\r\n\r\n    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* -c3+c7 */\r\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336);        /* -c1+c3+c5-c7 */\r\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110);        /*  c1+c3-c5-c7 */\r\n    tmp0 += z1 + z2;\r\n    tmp3 += z1 + z3;\r\n\r\n    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* -c1-c3 */\r\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869);        /*  c1+c3-c5+c7 */\r\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026);        /*  c1+c3+c5-c7 */\r\n    tmp1 += z1 + z3;\r\n    tmp2 += z1 + z2;\r\n\r\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 6x3 output block.\r\n *\r\n * 3-point IDCT in pass 1 (columns), 6-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_6x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[6*3];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\r\n    tmp10 = tmp0 + tmp12;\r\n    tmp2 = tmp0 - tmp12 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);\r\n  }\r\n  \r\n  /* Pass 2: process 3 rows from work array, store into output array.\r\n   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 3; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n    tmp2 = (INT32) wsptr[4];\r\n    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */\r\n    tmp1 = tmp0 + tmp10;\r\n    tmp11 = tmp0 - tmp10 - tmp10;\r\n    tmp10 = (INT32) wsptr[2];\r\n    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */\r\n    tmp10 = tmp1 + tmp0;\r\n    tmp12 = tmp1 - tmp0;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\r\n    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);\r\n    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);\r\n    tmp1 = (z1 - z2 - z3) << CONST_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 6;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 4x2 output block.\r\n *\r\n * 2-point IDCT in pass 1 (columns), 4-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_4x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp2, tmp10, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  INT32 * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  INT32 workspace[4*2];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array. */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n\r\n    /* Odd part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[4*0] = tmp10 + tmp0;\r\n    wsptr[4*1] = tmp10 - tmp0;\r\n  }\r\n\r\n  /* Pass 2: process 2 rows from work array, store into output array.\r\n   * 4-point IDCT kernel,\r\n   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 2; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = wsptr[0] + (ONE << 2);\r\n    tmp2 = wsptr[2];\r\n\r\n    tmp10 = (tmp0 + tmp2) << CONST_BITS;\r\n    tmp12 = (tmp0 - tmp2) << CONST_BITS;\r\n\r\n    /* Odd part */\r\n    /* Same rotation as in the even part of the 8x8 LL&M IDCT */\r\n\r\n    z2 = wsptr[1];\r\n    z3 = wsptr[3];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */\r\n    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */\r\n    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 4;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 2x1 output block.\r\n *\r\n * 1-point IDCT in pass 1 (columns), 2-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_2x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: empty. */\r\n\r\n  /* Pass 2: process 1 row from input, store into output array. */\r\n\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  outptr = output_buf[0] + output_col;\r\n\r\n  /* Even part */\r\n\r\n  tmp0 = DEQUANTIZE(coef_block[0], quantptr[0]);\r\n  /* Add fudge factor here for final descale. */\r\n  tmp0 += ONE << 2;\r\n\r\n  /* Odd part */\r\n\r\n  tmp1 = DEQUANTIZE(coef_block[1], quantptr[1]);\r\n\r\n  /* Final output stage */\r\n\r\n  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp0 + tmp1, 3) & RANGE_MASK];\r\n  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp0 - tmp1, 3) & RANGE_MASK];\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 8x16 output block.\r\n *\r\n * 16-point IDCT in pass 1 (columns), 8-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_8x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[8*16];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\r\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\r\n\r\n    tmp10 = tmp0 + tmp1;\r\n    tmp11 = tmp0 - tmp1;\r\n    tmp12 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n    z3 = z1 - z2;\r\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\r\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\r\n\r\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\r\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\r\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\r\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\r\n\r\n    tmp20 = tmp10 + tmp0;\r\n    tmp27 = tmp10 - tmp0;\r\n    tmp21 = tmp12 + tmp1;\r\n    tmp26 = tmp12 - tmp1;\r\n    tmp22 = tmp13 + tmp2;\r\n    tmp25 = tmp13 - tmp2;\r\n    tmp23 = tmp11 + tmp3;\r\n    tmp24 = tmp11 - tmp3;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = z1 + z3;\r\n\r\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\r\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\r\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\r\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\r\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\r\n    tmp0  = tmp1 + tmp2 + tmp3 -\r\n\t    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\r\n    tmp13 = tmp10 + tmp11 + tmp12 -\r\n\t    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\r\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\r\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\r\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\r\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\r\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\r\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\r\n    z2    += z4;\r\n    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */\r\n    tmp1  += z1;\r\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\r\n    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */\r\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\r\n    tmp12 += z2;\r\n    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */\r\n    tmp2  += z2;\r\n    tmp3  += z2;\r\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\r\n    tmp10 += z2;\r\n    tmp11 += z2;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);\r\n    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process rows from work array, store into output array.\r\n   * Note that we must descale the results by a factor of 8 == 2**3,\r\n   * and also undo the PASS1_BITS scaling.\r\n   * 8-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 16; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part: reverse the even part of the forward DCT.\r\n     * The rotator is c(-6).\r\n     */\r\n\r\n    z2 = (INT32) wsptr[2];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);       /* c6 */\r\n    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);     /* c2-c6 */\r\n    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);     /* c2+c6 */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    z3 = (INT32) wsptr[4];\r\n\r\n    tmp0 = (z2 + z3) << CONST_BITS;\r\n    tmp1 = (z2 - z3) << CONST_BITS;\r\n\r\n    tmp10 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n    tmp11 = tmp1 + tmp3;\r\n    tmp12 = tmp1 - tmp3;\r\n\r\n    /* Odd part per figure 8; the matrix is unitary and hence its\r\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\r\n     */\r\n\r\n    tmp0 = (INT32) wsptr[7];\r\n    tmp1 = (INT32) wsptr[5];\r\n    tmp2 = (INT32) wsptr[3];\r\n    tmp3 = (INT32) wsptr[1];\r\n\r\n    z2 = tmp0 + tmp2;\r\n    z3 = tmp1 + tmp3;\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_1_175875602);       /*  c3 */\r\n    z2 = MULTIPLY(z2, - FIX_1_961570560);          /* -c3-c5 */\r\n    z3 = MULTIPLY(z3, - FIX_0_390180644);          /* -c3+c5 */\r\n    z2 += z1;\r\n    z3 += z1;\r\n\r\n    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* -c3+c7 */\r\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336);        /* -c1+c3+c5-c7 */\r\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110);        /*  c1+c3-c5-c7 */\r\n    tmp0 += z1 + z2;\r\n    tmp3 += z1 + z3;\r\n\r\n    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* -c1-c3 */\r\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869);        /*  c1+c3-c5+c7 */\r\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026);        /*  c1+c3+c5-c7 */\r\n    tmp1 += z1 + z3;\r\n    tmp2 += z1 + z2;\r\n\r\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 7x14 output block.\r\n *\r\n * 14-point IDCT in pass 1 (columns), 7-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_7x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[7*14];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z1 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z1 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\r\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\r\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\r\n\r\n    tmp10 = z1 + z2;\r\n    tmp11 = z1 + z3;\r\n    tmp12 = z1 - z4;\r\n\r\n    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */\r\n\t\t\tCONST_BITS-PASS1_BITS);\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\r\n\r\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\r\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\r\n\t    MULTIPLY(z2, FIX(1.378756276));      /* c2 */\r\n\r\n    tmp20 = tmp10 + tmp13;\r\n    tmp26 = tmp10 - tmp13;\r\n    tmp21 = tmp11 + tmp14;\r\n    tmp25 = tmp11 - tmp14;\r\n    tmp22 = tmp12 + tmp15;\r\n    tmp24 = tmp12 - tmp15;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n    tmp13 = z4 << CONST_BITS;\r\n\r\n    tmp14 = z1 + z3;\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\r\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\r\n    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\r\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\r\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\r\n    z1    -= z2;\r\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */\r\n    tmp16 += tmp15;\r\n    z1    += z4;\r\n    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */\r\n    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */\r\n    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */\r\n    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\r\n    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\r\n    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */\r\n\r\n    tmp13 = (z1 - z3) << PASS1_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[7*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*3]  = (int) (tmp23 + tmp13);\r\n    wsptr[7*10] = (int) (tmp23 - tmp13);\r\n    wsptr[7*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);\r\n    wsptr[7*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 14 rows from work array, store into output array.\r\n   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 14; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp23 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp23 <<= CONST_BITS;\r\n\r\n    z1 = (INT32) wsptr[2];\r\n    z2 = (INT32) wsptr[4];\r\n    z3 = (INT32) wsptr[6];\r\n\r\n    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */\r\n    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */\r\n    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\r\n    tmp10 = z1 + z3;\r\n    z2 -= tmp10;\r\n    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */\r\n    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */\r\n    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */\r\n    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n\r\n    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */\r\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */\r\n    tmp10 = tmp11 - tmp12;\r\n    tmp11 += tmp12;\r\n    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */\r\n    tmp11 += tmp12;\r\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */\r\n    tmp10 += z2;\r\n    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 7;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 6x12 output block.\r\n *\r\n * 12-point IDCT in pass 1 (columns), 6-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_6x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\r\n  INT32 z1, z2, z3, z4;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[6*12];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z3 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\r\n\r\n    tmp10 = z3 + z4;\r\n    tmp11 = z3 - z4;\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\r\n    z1 <<= CONST_BITS;\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n    z2 <<= CONST_BITS;\r\n\r\n    tmp12 = z1 - z2;\r\n\r\n    tmp21 = z3 + tmp12;\r\n    tmp24 = z3 - tmp12;\r\n\r\n    tmp12 = z4 + z2;\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp25 = tmp10 - tmp12;\r\n\r\n    tmp12 = z4 - z1 - z2;\r\n\r\n    tmp22 = tmp11 + tmp12;\r\n    tmp23 = tmp11 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\r\n    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */\r\n\r\n    tmp10 = z1 + z3;\r\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\r\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\r\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\r\n    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */\r\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\r\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\r\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\r\n\t     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\r\n\r\n    z1 -= z4;\r\n    z2 -= z3;\r\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\r\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\r\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[6*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);\r\n    wsptr[6*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 12 rows from work array, store into output array.\r\n   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 12; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp10 <<= CONST_BITS;\r\n    tmp12 = (INT32) wsptr[4];\r\n    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */\r\n    tmp11 = tmp10 + tmp20;\r\n    tmp21 = tmp10 - tmp20 - tmp20;\r\n    tmp20 = (INT32) wsptr[2];\r\n    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */\r\n    tmp20 = tmp11 + tmp10;\r\n    tmp22 = tmp11 - tmp10;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = (INT32) wsptr[1];\r\n    z2 = (INT32) wsptr[3];\r\n    z3 = (INT32) wsptr[5];\r\n    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\r\n    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);\r\n    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);\r\n    tmp11 = (z1 - z2 - z3) << CONST_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 6;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 5x10 output block.\r\n *\r\n * 10-point IDCT in pass 1 (columns), 5-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_5x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t\tJCOEFPTR coef_block,\r\n\t\tJSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;\r\n  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;\r\n  INT32 z1, z2, z3, z4, z5;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[5*10];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z3 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\r\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z2;\r\n\r\n    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */\r\n\t\t\tCONST_BITS-PASS1_BITS);\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\r\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\r\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\r\n\r\n    tmp20 = tmp10 + tmp12;\r\n    tmp24 = tmp10 - tmp12;\r\n    tmp21 = tmp11 + tmp13;\r\n    tmp23 = tmp11 - tmp13;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n\r\n    tmp11 = z2 + z4;\r\n    tmp13 = z2 - z4;\r\n\r\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\r\n    z5 = z3 << CONST_BITS;\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\r\n    z4 = z5 + tmp12;\r\n\r\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\r\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\r\n\r\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\r\n    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));\r\n\r\n    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;\r\n\r\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\r\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[5*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*2] = (int) (tmp22 + tmp12);\r\n    wsptr[5*7] = (int) (tmp22 - tmp12);\r\n    wsptr[5*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);\r\n    wsptr[5*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 10 rows from work array, store into output array.\r\n   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 10; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp12 <<= CONST_BITS;\r\n    tmp13 = (INT32) wsptr[2];\r\n    tmp14 = (INT32) wsptr[4];\r\n    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */\r\n    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */\r\n    z3 = tmp12 + z2;\r\n    tmp10 = z3 + z1;\r\n    tmp11 = z3 - z1;\r\n    tmp12 -= z2 << 2;\r\n\r\n    /* Odd part */\r\n\r\n    z2 = (INT32) wsptr[1];\r\n    z3 = (INT32) wsptr[3];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */\r\n    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */\r\n    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 5;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 4x8 output block.\r\n *\r\n * 8-point IDCT in pass 1 (columns), 4-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_4x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp3;\r\n  INT32 tmp10, tmp11, tmp12, tmp13;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[4*8];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * Note results are scaled up by sqrt(8) compared to a true IDCT;\r\n   * furthermore, we scale the results by 2**PASS1_BITS.\r\n   * 8-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 4; ctr > 0; ctr--) {\r\n    /* Due to quantization, we will usually find that many of the input\r\n     * coefficients are zero, especially the AC terms.  We can exploit this\r\n     * by short-circuiting the IDCT calculation for any column in which all\r\n     * the AC terms are zero.  In that case each output is equal to the\r\n     * DC coefficient (with scale factor as needed).\r\n     * With typical images and quantization tables, half or more of the\r\n     * column DCT calculations can be simplified this way.\r\n     */\r\n\r\n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\r\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\r\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\r\n\tinptr[DCTSIZE*7] == 0) {\r\n      /* AC terms all zero */\r\n      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;\r\n\r\n      wsptr[4*0] = dcval;\r\n      wsptr[4*1] = dcval;\r\n      wsptr[4*2] = dcval;\r\n      wsptr[4*3] = dcval;\r\n      wsptr[4*4] = dcval;\r\n      wsptr[4*5] = dcval;\r\n      wsptr[4*6] = dcval;\r\n      wsptr[4*7] = dcval;\r\n\r\n      inptr++;\t\t\t/* advance pointers to next column */\r\n      quantptr++;\r\n      wsptr++;\r\n      continue;\r\n    }\r\n\r\n    /* Even part: reverse the even part of the forward DCT.\r\n     * The rotator is c(-6).\r\n     */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);       /* c6 */\r\n    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);     /* c2-c6 */\r\n    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);     /* c2+c6 */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    z2 <<= CONST_BITS;\r\n    z3 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    z2 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n\r\n    tmp0 = z2 + z3;\r\n    tmp1 = z2 - z3;\r\n\r\n    tmp10 = tmp0 + tmp2;\r\n    tmp13 = tmp0 - tmp2;\r\n    tmp11 = tmp1 + tmp3;\r\n    tmp12 = tmp1 - tmp3;\r\n\r\n    /* Odd part per figure 8; the matrix is unitary and hence its\r\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\r\n     */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\r\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n\r\n    z2 = tmp0 + tmp2;\r\n    z3 = tmp1 + tmp3;\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_1_175875602);       /*  c3 */\r\n    z2 = MULTIPLY(z2, - FIX_1_961570560);          /* -c3-c5 */\r\n    z3 = MULTIPLY(z3, - FIX_0_390180644);          /* -c3+c5 */\r\n    z2 += z1;\r\n    z3 += z1;\r\n\r\n    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* -c3+c7 */\r\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336);        /* -c1+c3+c5-c7 */\r\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110);        /*  c1+c3-c5-c7 */\r\n    tmp0 += z1 + z2;\r\n    tmp3 += z1 + z3;\r\n\r\n    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* -c1-c3 */\r\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869);        /*  c1+c3-c5+c7 */\r\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026);        /*  c1+c3+c5-c7 */\r\n    tmp1 += z1 + z3;\r\n    tmp2 += z1 + z2;\r\n\r\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n\r\n    wsptr[4*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[4*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);\r\n\r\n    inptr++;\t\t\t/* advance pointers to next column */\r\n    quantptr++;\r\n    wsptr++;\r\n  }\r\n\r\n  /* Pass 2: process 8 rows from work array, store into output array.\r\n   * 4-point IDCT kernel,\r\n   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 8; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp2 = (INT32) wsptr[2];\r\n\r\n    tmp10 = (tmp0 + tmp2) << CONST_BITS;\r\n    tmp12 = (tmp0 - tmp2) << CONST_BITS;\r\n\r\n    /* Odd part */\r\n    /* Same rotation as in the even part of the 8x8 LL&M IDCT */\r\n\r\n    z2 = (INT32) wsptr[1];\r\n    z3 = (INT32) wsptr[3];\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */\r\n    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */\r\n    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 4;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a reduced-size 3x6 output block.\r\n *\r\n * 6-point IDCT in pass 1 (columns), 3-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_3x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  int * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  int workspace[3*6];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp0 <<= CONST_BITS;\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\r\n    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */\r\n    tmp1 = tmp0 + tmp10;\r\n    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);\r\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */\r\n    tmp10 = tmp1 + tmp0;\r\n    tmp12 = tmp1 - tmp0;\r\n\r\n    /* Odd part */\r\n\r\n    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\r\n    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\r\n    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);\r\n    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);\r\n    tmp1 = (z1 - z2 - z3) << PASS1_BITS;\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[3*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);\r\n    wsptr[3*1] = (int) (tmp11 + tmp1);\r\n    wsptr[3*4] = (int) (tmp11 - tmp1);\r\n    wsptr[3*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);\r\n    wsptr[3*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);\r\n  }\r\n\r\n  /* Pass 2: process 6 rows from work array, store into output array.\r\n   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).\r\n   */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 6; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));\r\n    tmp0 <<= CONST_BITS;\r\n    tmp2 = (INT32) wsptr[2];\r\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\r\n    tmp10 = tmp0 + tmp12;\r\n    tmp2 = tmp0 - tmp12 - tmp12;\r\n\r\n    /* Odd part */\r\n\r\n    tmp12 = (INT32) wsptr[1];\r\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,\r\n\t\t\t\t\t      CONST_BITS+PASS1_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 3;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 2x4 output block.\r\n *\r\n * 4-point IDCT in pass 1 (columns), 2-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_2x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp2, tmp10, tmp12;\r\n  INT32 z1, z2, z3;\r\n  JCOEFPTR inptr;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  INT32 * wsptr;\r\n  JSAMPROW outptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  int ctr;\r\n  INT32 workspace[2*4];\t/* buffers data between passes */\r\n  SHIFT_TEMPS\r\n\r\n  /* Pass 1: process columns from input, store into work array.\r\n   * 4-point IDCT kernel,\r\n   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].\r\n   */\r\n\r\n  inptr = coef_block;\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {\r\n    /* Even part */\r\n\r\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\r\n\r\n    tmp10 = (tmp0 + tmp2) << CONST_BITS;\r\n    tmp12 = (tmp0 - tmp2) << CONST_BITS;\r\n\r\n    /* Odd part */\r\n    /* Same rotation as in the even part of the 8x8 LL&M IDCT */\r\n\r\n    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\r\n\r\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */\r\n    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */\r\n    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */\r\n\r\n    /* Final output stage */\r\n\r\n    wsptr[2*0] = tmp10 + tmp0;\r\n    wsptr[2*3] = tmp10 - tmp0;\r\n    wsptr[2*1] = tmp12 + tmp2;\r\n    wsptr[2*2] = tmp12 - tmp2;\r\n  }\r\n\r\n  /* Pass 2: process 4 rows from work array, store into output array. */\r\n\r\n  wsptr = workspace;\r\n  for (ctr = 0; ctr < 4; ctr++) {\r\n    outptr = output_buf[ctr] + output_col;\r\n\r\n    /* Even part */\r\n\r\n    /* Add fudge factor here for final descale. */\r\n    tmp10 = wsptr[0] + (ONE << (CONST_BITS+2));\r\n\r\n    /* Odd part */\r\n\r\n    tmp0 = wsptr[1];\r\n\r\n    /* Final output stage */\r\n\r\n    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)\r\n\t\t\t    & RANGE_MASK];\r\n\r\n    wsptr += 2;\t\t/* advance pointer to next row */\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Perform dequantization and inverse DCT on one block of coefficients,\r\n * producing a 1x2 output block.\r\n *\r\n * 2-point IDCT in pass 1 (columns), 1-point in pass 2 (rows).\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_idct_1x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,\r\n\t       JCOEFPTR coef_block,\r\n\t       JSAMPARRAY output_buf, JDIMENSION output_col)\r\n{\r\n  INT32 tmp0, tmp1;\r\n  ISLOW_MULT_TYPE * quantptr;\r\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\r\n  SHIFT_TEMPS\r\n\r\n  /* Process 1 column from input, store into output array. */\r\n\r\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\r\n\r\n  /* Even part */\r\n    \r\n  tmp0 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);\r\n  /* Add fudge factor here for final descale. */\r\n  tmp0 += ONE << 2;\r\n\r\n  /* Odd part */\r\n\r\n  tmp1 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);\r\n\r\n  /* Final output stage */\r\n\r\n  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp0 + tmp1, 3)\r\n\t\t\t\t\t  & RANGE_MASK];\r\n  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp0 - tmp1, 3)\r\n\t\t\t\t\t  & RANGE_MASK];\r\n}\r\n\r\n#endif /* IDCT_SCALING_SUPPORTED */\r\n#endif /* DCT_ISLOW_SUPPORTED */\r\n","/*\r\n * jquant1.c\r\n *\r\n * Copyright (C) 1991-1996, Thomas G. Lane.\r\n * Modified 2011 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains 1-pass color quantization (color mapping) routines.\r\n * These routines provide mapping to a fixed color map using equally spaced\r\n * color values.  Optional Floyd-Steinberg or ordered dithering is available.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n#ifdef QUANT_1PASS_SUPPORTED\r\n\r\n\r\n/*\r\n * The main purpose of 1-pass quantization is to provide a fast, if not very\r\n * high quality, colormapped output capability.  A 2-pass quantizer usually\r\n * gives better visual quality; however, for quantized grayscale output this\r\n * quantizer is perfectly adequate.  Dithering is highly recommended with this\r\n * quantizer, though you can turn it off if you really want to.\r\n *\r\n * In 1-pass quantization the colormap must be chosen in advance of seeing the\r\n * image.  We use a map consisting of all combinations of Ncolors[i] color\r\n * values for the i'th component.  The Ncolors[] values are chosen so that\r\n * their product, the total number of colors, is no more than that requested.\r\n * (In most cases, the product will be somewhat less.)\r\n *\r\n * Since the colormap is orthogonal, the representative value for each color\r\n * component can be determined without considering the other components;\r\n * then these indexes can be combined into a colormap index by a standard\r\n * N-dimensional-array-subscript calculation.  Most of the arithmetic involved\r\n * can be precalculated and stored in the lookup table colorindex[].\r\n * colorindex[i][j] maps pixel value j in component i to the nearest\r\n * representative value (grid plane) for that component; this index is\r\n * multiplied by the array stride for component i, so that the\r\n * index of the colormap entry closest to a given pixel value is just\r\n *    sum( colorindex[component-number][pixel-component-value] )\r\n * Aside from being fast, this scheme allows for variable spacing between\r\n * representative values with no additional lookup cost.\r\n *\r\n * If gamma correction has been applied in color conversion, it might be wise\r\n * to adjust the color grid spacing so that the representative colors are\r\n * equidistant in linear space.  At this writing, gamma correction is not\r\n * implemented by jdcolor, so nothing is done here.\r\n */\r\n\r\n\r\n/* Declarations for ordered dithering.\r\n *\r\n * We use a standard 16x16 ordered dither array.  The basic concept of ordered\r\n * dithering is described in many references, for instance Dale Schumacher's\r\n * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).\r\n * In place of Schumacher's comparisons against a \"threshold\" value, we add a\r\n * \"dither\" value to the input pixel and then round the result to the nearest\r\n * output value.  The dither value is equivalent to (0.5 - threshold) times\r\n * the distance between output values.  For ordered dithering, we assume that\r\n * the output colors are equally spaced; if not, results will probably be\r\n * worse, since the dither may be too much or too little at a given point.\r\n *\r\n * The normal calculation would be to form pixel value + dither, range-limit\r\n * this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.\r\n * We can skip the separate range-limiting step by extending the colorindex\r\n * table in both directions.\r\n */\r\n\r\n#define ODITHER_SIZE  16\t/* dimension of dither matrix */\r\n/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */\r\n#define ODITHER_CELLS (ODITHER_SIZE*ODITHER_SIZE)\t/* # cells in matrix */\r\n#define ODITHER_MASK  (ODITHER_SIZE-1) /* mask for wrapping around counters */\r\n\r\ntypedef int ODITHER_MATRIX[ODITHER_SIZE][ODITHER_SIZE];\r\ntypedef int (*ODITHER_MATRIX_PTR)[ODITHER_SIZE];\r\n\r\nstatic const UINT8 base_dither_matrix[ODITHER_SIZE][ODITHER_SIZE] = {\r\n  /* Bayer's order-4 dither array.  Generated by the code given in\r\n   * Stephen Hawley's article \"Ordered Dithering\" in Graphics Gems I.\r\n   * The values in this array must range from 0 to ODITHER_CELLS-1.\r\n   */\r\n  {   0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255 },\r\n  { 128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127 },\r\n  {  32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223 },\r\n  { 160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95 },\r\n  {   8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247 },\r\n  { 136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119 },\r\n  {  40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215 },\r\n  { 168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87 },\r\n  {   2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253 },\r\n  { 130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125 },\r\n  {  34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221 },\r\n  { 162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93 },\r\n  {  10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245 },\r\n  { 138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117 },\r\n  {  42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213 },\r\n  { 170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85 }\r\n};\r\n\r\n\r\n/* Declarations for Floyd-Steinberg dithering.\r\n *\r\n * Errors are accumulated into the array fserrors[], at a resolution of\r\n * 1/16th of a pixel count.  The error at a given pixel is propagated\r\n * to its not-yet-processed neighbors using the standard F-S fractions,\r\n *\t\t...\t(here)\t7/16\r\n *\t\t3/16\t5/16\t1/16\r\n * We work left-to-right on even rows, right-to-left on odd rows.\r\n *\r\n * We can get away with a single array (holding one row's worth of errors)\r\n * by using it to store the current row's errors at pixel columns not yet\r\n * processed, but the next row's errors at columns already processed.  We\r\n * need only a few extra variables to hold the errors immediately around the\r\n * current column.  (If we are lucky, those variables are in registers, but\r\n * even if not, they're probably cheaper to access than array elements are.)\r\n *\r\n * The fserrors[] array is indexed [component#][position].\r\n * We provide (#columns + 2) entries per component; the extra entry at each\r\n * end saves us from special-casing the first and last pixels.\r\n *\r\n * Note: on a wide image, we might not have enough room in a PC's near data\r\n * segment to hold the error array; so it is allocated with alloc_large.\r\n */\r\n\r\n#if BITS_IN_JSAMPLE == 8\r\ntypedef INT16 FSERROR;\t\t/* 16 bits should be enough */\r\ntypedef int LOCFSERROR;\t\t/* use 'int' for calculation temps */\r\n#else\r\ntypedef INT32 FSERROR;\t\t/* may need more than 16 bits */\r\ntypedef INT32 LOCFSERROR;\t/* be sure calculation temps are big enough */\r\n#endif\r\n\r\ntypedef FSERROR FAR *FSERRPTR;\t/* pointer to error array (in FAR storage!) */\r\n\r\n\r\n/* Private subobject */\r\n\r\n#define MAX_Q_COMPS 4\t\t/* max components I can handle */\r\n\r\ntypedef struct {\r\n  struct jpeg_color_quantizer pub; /* public fields */\r\n\r\n  /* Initially allocated colormap is saved here */\r\n  JSAMPARRAY sv_colormap;\t/* The color map as a 2-D pixel array */\r\n  int sv_actual;\t\t/* number of entries in use */\r\n\r\n  JSAMPARRAY colorindex;\t/* Precomputed mapping for speed */\r\n  /* colorindex[i][j] = index of color closest to pixel value j in component i,\r\n   * premultiplied as described above.  Since colormap indexes must fit into\r\n   * JSAMPLEs, the entries of this array will too.\r\n   */\r\n  boolean is_padded;\t\t/* is the colorindex padded for odither? */\r\n\r\n  int Ncolors[MAX_Q_COMPS];\t/* # of values alloced to each component */\r\n\r\n  /* Variables for ordered dithering */\r\n  int row_index;\t\t/* cur row's vertical index in dither matrix */\r\n  ODITHER_MATRIX_PTR odither[MAX_Q_COMPS]; /* one dither array per component */\r\n\r\n  /* Variables for Floyd-Steinberg dithering */\r\n  FSERRPTR fserrors[MAX_Q_COMPS]; /* accumulated errors */\r\n  boolean on_odd_row;\t\t/* flag to remember which row we are on */\r\n} my_cquantizer;\r\n\r\ntypedef my_cquantizer * my_cquantize_ptr;\r\n\r\n\r\n/*\r\n * Policy-making subroutines for create_colormap and create_colorindex.\r\n * These routines determine the colormap to be used.  The rest of the module\r\n * only assumes that the colormap is orthogonal.\r\n *\r\n *  * select_ncolors decides how to divvy up the available colors\r\n *    among the components.\r\n *  * output_value defines the set of representative values for a component.\r\n *  * largest_input_value defines the mapping from input values to\r\n *    representative values for a component.\r\n * Note that the latter two routines may impose different policies for\r\n * different components, though this is not currently done.\r\n */\r\n\r\n\r\nLOCAL(int)\r\nselect_ncolors (j_decompress_ptr cinfo, int Ncolors[])\r\n/* Determine allocation of desired colors to components, */\r\n/* and fill in Ncolors[] array to indicate choice. */\r\n/* Return value is total number of colors (product of Ncolors[] values). */\r\n{\r\n  int nc = cinfo->out_color_components; /* number of color components */\r\n  int max_colors = cinfo->desired_number_of_colors;\r\n  int total_colors, iroot, i, j;\r\n  boolean changed;\r\n  long temp;\r\n  static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };\r\n\r\n  /* We can allocate at least the nc'th root of max_colors per component. */\r\n  /* Compute floor(nc'th root of max_colors). */\r\n  iroot = 1;\r\n  do {\r\n    iroot++;\r\n    temp = iroot;\t\t/* set temp = iroot ** nc */\r\n    for (i = 1; i < nc; i++)\r\n      temp *= iroot;\r\n  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */\r\n  iroot--;\t\t\t/* now iroot = floor(root) */\r\n\r\n  /* Must have at least 2 color values per component */\r\n  if (iroot < 2)\r\n    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);\r\n\r\n  /* Initialize to iroot color values for each component */\r\n  total_colors = 1;\r\n  for (i = 0; i < nc; i++) {\r\n    Ncolors[i] = iroot;\r\n    total_colors *= iroot;\r\n  }\r\n  /* We may be able to increment the count for one or more components without\r\n   * exceeding max_colors, though we know not all can be incremented.\r\n   * Sometimes, the first component can be incremented more than once!\r\n   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)\r\n   * In RGB colorspace, try to increment G first, then R, then B.\r\n   */\r\n  do {\r\n    changed = FALSE;\r\n    for (i = 0; i < nc; i++) {\r\n      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);\r\n      /* calculate new total_colors if Ncolors[j] is incremented */\r\n      temp = total_colors / Ncolors[j];\r\n      temp *= Ncolors[j]+1;\t/* done in long arith to avoid oflo */\r\n      if (temp > (long) max_colors)\r\n\tbreak;\t\t\t/* won't fit, done with this pass */\r\n      Ncolors[j]++;\t\t/* OK, apply the increment */\r\n      total_colors = (int) temp;\r\n      changed = TRUE;\r\n    }\r\n  } while (changed);\r\n\r\n  return total_colors;\r\n}\r\n\r\n\r\nLOCAL(int)\r\noutput_value (j_decompress_ptr cinfo, int ci, int j, int maxj)\r\n/* Return j'th output value, where j will range from 0 to maxj */\r\n/* The output values must fall in 0..MAXJSAMPLE in increasing order */\r\n{\r\n  /* We always provide values 0 and MAXJSAMPLE for each component;\r\n   * any additional values are equally spaced between these limits.\r\n   * (Forcing the upper and lower values to the limits ensures that\r\n   * dithering can't produce a color outside the selected gamut.)\r\n   */\r\n  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);\r\n}\r\n\r\n\r\nLOCAL(int)\r\nlargest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)\r\n/* Return largest input value that should map to j'th output value */\r\n/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */\r\n{\r\n  /* Breakpoints are halfway between values returned by output_value */\r\n  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));\r\n}\r\n\r\n\r\n/*\r\n * Create the colormap.\r\n */\r\n\r\nLOCAL(void)\r\ncreate_colormap (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  JSAMPARRAY colormap;\t\t/* Created colormap */\r\n  int total_colors;\t\t/* Number of distinct output colors */\r\n  int i,j,k, nci, blksize, blkdist, ptr, val;\r\n\r\n  /* Select number of colors for each component */\r\n  total_colors = select_ncolors(cinfo, cquantize->Ncolors);\r\n\r\n  /* Report selected color counts */\r\n  if (cinfo->out_color_components == 3)\r\n    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,\r\n\t     total_colors, cquantize->Ncolors[0],\r\n\t     cquantize->Ncolors[1], cquantize->Ncolors[2]);\r\n  else\r\n    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);\r\n\r\n  /* Allocate and fill in the colormap. */\r\n  /* The colors are ordered in the map in standard row-major order, */\r\n  /* i.e. rightmost (highest-indexed) color changes most rapidly. */\r\n\r\n  colormap = (*cinfo->mem->alloc_sarray)\r\n    ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);\r\n\r\n  /* blksize is number of adjacent repeated entries for a component */\r\n  /* blkdist is distance between groups of identical entries for a component */\r\n  blkdist = total_colors;\r\n\r\n  for (i = 0; i < cinfo->out_color_components; i++) {\r\n    /* fill in colormap entries for i'th color component */\r\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\r\n    blksize = blkdist / nci;\r\n    for (j = 0; j < nci; j++) {\r\n      /* Compute j'th output value (out of nci) for component */\r\n      val = output_value(cinfo, i, j, nci-1);\r\n      /* Fill in all colormap entries that have this value of this component */\r\n      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {\r\n\t/* fill in blksize entries beginning at ptr */\r\n\tfor (k = 0; k < blksize; k++)\r\n\t  colormap[i][ptr+k] = (JSAMPLE) val;\r\n      }\r\n    }\r\n    blkdist = blksize;\t\t/* blksize of this color is blkdist of next */\r\n  }\r\n\r\n  /* Save the colormap in private storage,\r\n   * where it will survive color quantization mode changes.\r\n   */\r\n  cquantize->sv_colormap = colormap;\r\n  cquantize->sv_actual = total_colors;\r\n}\r\n\r\n\r\n/*\r\n * Create the color index table.\r\n */\r\n\r\nLOCAL(void)\r\ncreate_colorindex (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  JSAMPROW indexptr;\r\n  int i,j,k, nci, blksize, val, pad;\r\n\r\n  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in\r\n   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).\r\n   * This is not necessary in the other dithering modes.  However, we\r\n   * flag whether it was done in case user changes dithering mode.\r\n   */\r\n  if (cinfo->dither_mode == JDITHER_ORDERED) {\r\n    pad = MAXJSAMPLE*2;\r\n    cquantize->is_padded = TRUE;\r\n  } else {\r\n    pad = 0;\r\n    cquantize->is_padded = FALSE;\r\n  }\r\n\r\n  cquantize->colorindex = (*cinfo->mem->alloc_sarray)\r\n    ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n     (JDIMENSION) (MAXJSAMPLE+1 + pad),\r\n     (JDIMENSION) cinfo->out_color_components);\r\n\r\n  /* blksize is number of adjacent repeated entries for a component */\r\n  blksize = cquantize->sv_actual;\r\n\r\n  for (i = 0; i < cinfo->out_color_components; i++) {\r\n    /* fill in colorindex entries for i'th color component */\r\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\r\n    blksize = blksize / nci;\r\n\r\n    /* adjust colorindex pointers to provide padding at negative indexes. */\r\n    if (pad)\r\n      cquantize->colorindex[i] += MAXJSAMPLE;\r\n\r\n    /* in loop, val = index of current output value, */\r\n    /* and k = largest j that maps to current val */\r\n    indexptr = cquantize->colorindex[i];\r\n    val = 0;\r\n    k = largest_input_value(cinfo, i, 0, nci-1);\r\n    for (j = 0; j <= MAXJSAMPLE; j++) {\r\n      while (j > k)\t\t/* advance val if past boundary */\r\n\tk = largest_input_value(cinfo, i, ++val, nci-1);\r\n      /* premultiply so that no multiplication needed in main processing */\r\n      indexptr[j] = (JSAMPLE) (val * blksize);\r\n    }\r\n    /* Pad at both ends if necessary */\r\n    if (pad)\r\n      for (j = 1; j <= MAXJSAMPLE; j++) {\r\n\tindexptr[-j] = indexptr[0];\r\n\tindexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];\r\n      }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Create an ordered-dither array for a component having ncolors\r\n * distinct output values.\r\n */\r\n\r\nLOCAL(ODITHER_MATRIX_PTR)\r\nmake_odither_array (j_decompress_ptr cinfo, int ncolors)\r\n{\r\n  ODITHER_MATRIX_PTR odither;\r\n  int j,k;\r\n  INT32 num,den;\r\n\r\n  odither = (ODITHER_MATRIX_PTR)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(ODITHER_MATRIX));\r\n  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).\r\n   * Hence the dither value for the matrix cell with fill order f\r\n   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).\r\n   * On 16-bit-int machine, be careful to avoid overflow.\r\n   */\r\n  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));\r\n  for (j = 0; j < ODITHER_SIZE; j++) {\r\n    for (k = 0; k < ODITHER_SIZE; k++) {\r\n      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))\r\n\t    * MAXJSAMPLE;\r\n      /* Ensure round towards zero despite C's lack of consistency\r\n       * about rounding negative values in integer division...\r\n       */\r\n      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);\r\n    }\r\n  }\r\n  return odither;\r\n}\r\n\r\n\r\n/*\r\n * Create the ordered-dither tables.\r\n * Components having the same number of representative colors may \r\n * share a dither table.\r\n */\r\n\r\nLOCAL(void)\r\ncreate_odither_tables (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  ODITHER_MATRIX_PTR odither;\r\n  int i, j, nci;\r\n\r\n  for (i = 0; i < cinfo->out_color_components; i++) {\r\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\r\n    odither = NULL;\t\t/* search for matching prior component */\r\n    for (j = 0; j < i; j++) {\r\n      if (nci == cquantize->Ncolors[j]) {\r\n\todither = cquantize->odither[j];\r\n\tbreak;\r\n      }\r\n    }\r\n    if (odither == NULL)\t/* need a new table? */\r\n      odither = make_odither_array(cinfo, nci);\r\n    cquantize->odither[i] = odither;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Map some rows of pixels to the output colormapped representation.\r\n */\r\n\r\nMETHODDEF(void)\r\ncolor_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\r\n\t\tJSAMPARRAY output_buf, int num_rows)\r\n/* General case, no dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  JSAMPARRAY colorindex = cquantize->colorindex;\r\n  register int pixcode, ci;\r\n  register JSAMPROW ptrin, ptrout;\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n  register int nc = cinfo->out_color_components;\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    ptrin = input_buf[row];\r\n    ptrout = output_buf[row];\r\n    for (col = width; col > 0; col--) {\r\n      pixcode = 0;\r\n      for (ci = 0; ci < nc; ci++) {\r\n\tpixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);\r\n      }\r\n      *ptrout++ = (JSAMPLE) pixcode;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\ncolor_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\r\n\t\t JSAMPARRAY output_buf, int num_rows)\r\n/* Fast path for out_color_components==3, no dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  register int pixcode;\r\n  register JSAMPROW ptrin, ptrout;\r\n  JSAMPROW colorindex0 = cquantize->colorindex[0];\r\n  JSAMPROW colorindex1 = cquantize->colorindex[1];\r\n  JSAMPROW colorindex2 = cquantize->colorindex[2];\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    ptrin = input_buf[row];\r\n    ptrout = output_buf[row];\r\n    for (col = width; col > 0; col--) {\r\n      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);\r\n      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);\r\n      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);\r\n      *ptrout++ = (JSAMPLE) pixcode;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nquantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\r\n\t\t     JSAMPARRAY output_buf, int num_rows)\r\n/* General case, with ordered dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  register JSAMPROW input_ptr;\r\n  register JSAMPROW output_ptr;\r\n  JSAMPROW colorindex_ci;\r\n  int * dither;\t\t\t/* points to active row of dither matrix */\r\n  int row_index, col_index;\t/* current indexes into dither matrix */\r\n  int nc = cinfo->out_color_components;\r\n  int ci;\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    /* Initialize output values to 0 so can process components separately */\r\n    FMEMZERO((void FAR *) output_buf[row],\r\n\t     (size_t) (width * SIZEOF(JSAMPLE)));\r\n    row_index = cquantize->row_index;\r\n    for (ci = 0; ci < nc; ci++) {\r\n      input_ptr = input_buf[row] + ci;\r\n      output_ptr = output_buf[row];\r\n      colorindex_ci = cquantize->colorindex[ci];\r\n      dither = cquantize->odither[ci][row_index];\r\n      col_index = 0;\r\n\r\n      for (col = width; col > 0; col--) {\r\n\t/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,\r\n\t * select output value, accumulate into output code for this pixel.\r\n\t * Range-limiting need not be done explicitly, as we have extended\r\n\t * the colorindex table to produce the right answers for out-of-range\r\n\t * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the\r\n\t * required amount of padding.\r\n\t */\r\n\t*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];\r\n\tinput_ptr += nc;\r\n\toutput_ptr++;\r\n\tcol_index = (col_index + 1) & ODITHER_MASK;\r\n      }\r\n    }\r\n    /* Advance row index for next row */\r\n    row_index = (row_index + 1) & ODITHER_MASK;\r\n    cquantize->row_index = row_index;\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nquantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\r\n\t\t      JSAMPARRAY output_buf, int num_rows)\r\n/* Fast path for out_color_components==3, with ordered dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  register int pixcode;\r\n  register JSAMPROW input_ptr;\r\n  register JSAMPROW output_ptr;\r\n  JSAMPROW colorindex0 = cquantize->colorindex[0];\r\n  JSAMPROW colorindex1 = cquantize->colorindex[1];\r\n  JSAMPROW colorindex2 = cquantize->colorindex[2];\r\n  int * dither0;\t\t/* points to active row of dither matrix */\r\n  int * dither1;\r\n  int * dither2;\r\n  int row_index, col_index;\t/* current indexes into dither matrix */\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    row_index = cquantize->row_index;\r\n    input_ptr = input_buf[row];\r\n    output_ptr = output_buf[row];\r\n    dither0 = cquantize->odither[0][row_index];\r\n    dither1 = cquantize->odither[1][row_index];\r\n    dither2 = cquantize->odither[2][row_index];\r\n    col_index = 0;\r\n\r\n    for (col = width; col > 0; col--) {\r\n      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +\r\n\t\t\t\t\tdither0[col_index]]);\r\n      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +\r\n\t\t\t\t\tdither1[col_index]]);\r\n      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +\r\n\t\t\t\t\tdither2[col_index]]);\r\n      *output_ptr++ = (JSAMPLE) pixcode;\r\n      col_index = (col_index + 1) & ODITHER_MASK;\r\n    }\r\n    row_index = (row_index + 1) & ODITHER_MASK;\r\n    cquantize->row_index = row_index;\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nquantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\r\n\t\t    JSAMPARRAY output_buf, int num_rows)\r\n/* General case, with Floyd-Steinberg dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  register LOCFSERROR cur;\t/* current error or pixel value */\r\n  LOCFSERROR belowerr;\t\t/* error for pixel below cur */\r\n  LOCFSERROR bpreverr;\t\t/* error for below/prev col */\r\n  LOCFSERROR bnexterr;\t\t/* error for below/next col */\r\n  LOCFSERROR delta;\r\n  register FSERRPTR errorptr;\t/* => fserrors[] at column before current */\r\n  register JSAMPROW input_ptr;\r\n  register JSAMPROW output_ptr;\r\n  JSAMPROW colorindex_ci;\r\n  JSAMPROW colormap_ci;\r\n  int pixcode;\r\n  int nc = cinfo->out_color_components;\r\n  int dir;\t\t\t/* 1 for left-to-right, -1 for right-to-left */\r\n  int dirnc;\t\t\t/* dir * nc */\r\n  int ci;\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n  JSAMPLE *range_limit = cinfo->sample_range_limit;\r\n  SHIFT_TEMPS\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    /* Initialize output values to 0 so can process components separately */\r\n    FMEMZERO((void FAR *) output_buf[row],\r\n\t     (size_t) (width * SIZEOF(JSAMPLE)));\r\n    for (ci = 0; ci < nc; ci++) {\r\n      input_ptr = input_buf[row] + ci;\r\n      output_ptr = output_buf[row];\r\n      if (cquantize->on_odd_row) {\r\n\t/* work right to left in this row */\r\n\tinput_ptr += (width-1) * nc; /* so point to rightmost pixel */\r\n\toutput_ptr += width-1;\r\n\tdir = -1;\r\n\tdirnc = -nc;\r\n\terrorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */\r\n      } else {\r\n\t/* work left to right in this row */\r\n\tdir = 1;\r\n\tdirnc = nc;\r\n\terrorptr = cquantize->fserrors[ci]; /* => entry before first column */\r\n      }\r\n      colorindex_ci = cquantize->colorindex[ci];\r\n      colormap_ci = cquantize->sv_colormap[ci];\r\n      /* Preset error values: no error propagated to first pixel from left */\r\n      cur = 0;\r\n      /* and no error propagated to row below yet */\r\n      belowerr = bpreverr = 0;\r\n\r\n      for (col = width; col > 0; col--) {\r\n\t/* cur holds the error propagated from the previous pixel on the\r\n\t * current line.  Add the error propagated from the previous line\r\n\t * to form the complete error correction term for this pixel, and\r\n\t * round the error term (which is expressed * 16) to an integer.\r\n\t * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct\r\n\t * for either sign of the error value.\r\n\t * Note: errorptr points to *previous* column's array entry.\r\n\t */\r\n\tcur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);\r\n\t/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.\r\n\t * The maximum error is +- MAXJSAMPLE; this sets the required size\r\n\t * of the range_limit array.\r\n\t */\r\n\tcur += GETJSAMPLE(*input_ptr);\r\n\tcur = GETJSAMPLE(range_limit[cur]);\r\n\t/* Select output value, accumulate into output code for this pixel */\r\n\tpixcode = GETJSAMPLE(colorindex_ci[cur]);\r\n\t*output_ptr += (JSAMPLE) pixcode;\r\n\t/* Compute actual representation error at this pixel */\r\n\t/* Note: we can do this even though we don't have the final */\r\n\t/* pixel code, because the colormap is orthogonal. */\r\n\tcur -= GETJSAMPLE(colormap_ci[pixcode]);\r\n\t/* Compute error fractions to be propagated to adjacent pixels.\r\n\t * Add these into the running sums, and simultaneously shift the\r\n\t * next-line error sums left by 1 column.\r\n\t */\r\n\tbnexterr = cur;\r\n\tdelta = cur * 2;\r\n\tcur += delta;\t\t/* form error * 3 */\r\n\terrorptr[0] = (FSERROR) (bpreverr + cur);\r\n\tcur += delta;\t\t/* form error * 5 */\r\n\tbpreverr = belowerr + cur;\r\n\tbelowerr = bnexterr;\r\n\tcur += delta;\t\t/* form error * 7 */\r\n\t/* At this point cur contains the 7/16 error value to be propagated\r\n\t * to the next pixel on the current line, and all the errors for the\r\n\t * next line have been shifted over. We are therefore ready to move on.\r\n\t */\r\n\tinput_ptr += dirnc;\t/* advance input ptr to next column */\r\n\toutput_ptr += dir;\t/* advance output ptr to next column */\r\n\terrorptr += dir;\t/* advance errorptr to current column */\r\n      }\r\n      /* Post-loop cleanup: we must unload the final error value into the\r\n       * final fserrors[] entry.  Note we need not unload belowerr because\r\n       * it is for the dummy column before or after the actual array.\r\n       */\r\n      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */\r\n    }\r\n    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Allocate workspace for Floyd-Steinberg errors.\r\n */\r\n\r\nLOCAL(void)\r\nalloc_fs_workspace (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  size_t arraysize;\r\n  int i;\r\n\r\n  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));\r\n  for (i = 0; i < cinfo->out_color_components; i++) {\r\n    cquantize->fserrors[i] = (FSERRPTR)\r\n      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Initialize for one-pass color quantization.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  size_t arraysize;\r\n  int i;\r\n\r\n  /* Install my colormap. */\r\n  cinfo->colormap = cquantize->sv_colormap;\r\n  cinfo->actual_number_of_colors = cquantize->sv_actual;\r\n\r\n  /* Initialize for desired dithering mode. */\r\n  switch (cinfo->dither_mode) {\r\n  case JDITHER_NONE:\r\n    if (cinfo->out_color_components == 3)\r\n      cquantize->pub.color_quantize = color_quantize3;\r\n    else\r\n      cquantize->pub.color_quantize = color_quantize;\r\n    break;\r\n  case JDITHER_ORDERED:\r\n    if (cinfo->out_color_components == 3)\r\n      cquantize->pub.color_quantize = quantize3_ord_dither;\r\n    else\r\n      cquantize->pub.color_quantize = quantize_ord_dither;\r\n    cquantize->row_index = 0;\t/* initialize state for ordered dither */\r\n    /* If user changed to ordered dither from another mode,\r\n     * we must recreate the color index table with padding.\r\n     * This will cost extra space, but probably isn't very likely.\r\n     */\r\n    if (! cquantize->is_padded)\r\n      create_colorindex(cinfo);\r\n    /* Create ordered-dither tables if we didn't already. */\r\n    if (cquantize->odither[0] == NULL)\r\n      create_odither_tables(cinfo);\r\n    break;\r\n  case JDITHER_FS:\r\n    cquantize->pub.color_quantize = quantize_fs_dither;\r\n    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */\r\n    /* Allocate Floyd-Steinberg workspace if didn't already. */\r\n    if (cquantize->fserrors[0] == NULL)\r\n      alloc_fs_workspace(cinfo);\r\n    /* Initialize the propagated errors to zero. */\r\n    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));\r\n    for (i = 0; i < cinfo->out_color_components; i++)\r\n      FMEMZERO((void FAR *) cquantize->fserrors[i], arraysize);\r\n    break;\r\n  default:\r\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\r\n    break;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Finish up at the end of the pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nfinish_pass_1_quant (j_decompress_ptr cinfo)\r\n{\r\n  /* no work in 1-pass case */\r\n}\r\n\r\n\r\n/*\r\n * Switch to a new external colormap between output passes.\r\n * Shouldn't get to this module!\r\n */\r\n\r\nMETHODDEF(void)\r\nnew_color_map_1_quant (j_decompress_ptr cinfo)\r\n{\r\n  ERREXIT(cinfo, JERR_MODE_CHANGE);\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for 1-pass color quantization.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_1pass_quantizer (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize;\r\n\r\n  cquantize = (my_cquantize_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_cquantizer));\r\n  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;\r\n  cquantize->pub.start_pass = start_pass_1_quant;\r\n  cquantize->pub.finish_pass = finish_pass_1_quant;\r\n  cquantize->pub.new_color_map = new_color_map_1_quant;\r\n  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */\r\n  cquantize->odither[0] = NULL;\t/* Also flag odither arrays not allocated */\r\n\r\n  /* Make sure my internal arrays won't overflow */\r\n  if (cinfo->out_color_components > MAX_Q_COMPS)\r\n    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);\r\n  /* Make sure colormap indexes can be represented by JSAMPLEs */\r\n  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))\r\n    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);\r\n\r\n  /* Create the colormap and color index table. */\r\n  create_colormap(cinfo);\r\n  create_colorindex(cinfo);\r\n\r\n  /* Allocate Floyd-Steinberg workspace now if requested.\r\n   * We do this now since it is FAR storage and may affect the memory\r\n   * manager's space calculations.  If the user changes to FS dither\r\n   * mode in a later pass, we will allocate the space then, and will\r\n   * possibly overrun the max_memory_to_use setting.\r\n   */\r\n  if (cinfo->dither_mode == JDITHER_FS)\r\n    alloc_fs_workspace(cinfo);\r\n}\r\n\r\n#endif /* QUANT_1PASS_SUPPORTED */\r\n","/*\r\n * jquant2.c\r\n *\r\n * Copyright (C) 1991-1996, Thomas G. Lane.\r\n * Modified 2011 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains 2-pass color quantization (color mapping) routines.\r\n * These routines provide selection of a custom color map for an image,\r\n * followed by mapping of the image to that color map, with optional\r\n * Floyd-Steinberg dithering.\r\n * It is also possible to use just the second pass to map to an arbitrary\r\n * externally-given color map.\r\n *\r\n * Note: ordered dithering is not supported, since there isn't any fast\r\n * way to compute intercolor distances; it's unclear that ordered dither's\r\n * fundamental assumptions even hold with an irregularly spaced color map.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n#ifdef QUANT_2PASS_SUPPORTED\r\n\r\n\r\n/*\r\n * This module implements the well-known Heckbert paradigm for color\r\n * quantization.  Most of the ideas used here can be traced back to\r\n * Heckbert's seminal paper\r\n *   Heckbert, Paul.  \"Color Image Quantization for Frame Buffer Display\",\r\n *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.\r\n *\r\n * In the first pass over the image, we accumulate a histogram showing the\r\n * usage count of each possible color.  To keep the histogram to a reasonable\r\n * size, we reduce the precision of the input; typical practice is to retain\r\n * 5 or 6 bits per color, so that 8 or 4 different input values are counted\r\n * in the same histogram cell.\r\n *\r\n * Next, the color-selection step begins with a box representing the whole\r\n * color space, and repeatedly splits the \"largest\" remaining box until we\r\n * have as many boxes as desired colors.  Then the mean color in each\r\n * remaining box becomes one of the possible output colors.\r\n * \r\n * The second pass over the image maps each input pixel to the closest output\r\n * color (optionally after applying a Floyd-Steinberg dithering correction).\r\n * This mapping is logically trivial, but making it go fast enough requires\r\n * considerable care.\r\n *\r\n * Heckbert-style quantizers vary a good deal in their policies for choosing\r\n * the \"largest\" box and deciding where to cut it.  The particular policies\r\n * used here have proved out well in experimental comparisons, but better ones\r\n * may yet be found.\r\n *\r\n * In earlier versions of the IJG code, this module quantized in YCbCr color\r\n * space, processing the raw upsampled data without a color conversion step.\r\n * This allowed the color conversion math to be done only once per colormap\r\n * entry, not once per pixel.  However, that optimization precluded other\r\n * useful optimizations (such as merging color conversion with upsampling)\r\n * and it also interfered with desired capabilities such as quantizing to an\r\n * externally-supplied colormap.  We have therefore abandoned that approach.\r\n * The present code works in the post-conversion color space, typically RGB.\r\n *\r\n * To improve the visual quality of the results, we actually work in scaled\r\n * RGB space, giving G distances more weight than R, and R in turn more than\r\n * B.  To do everything in integer math, we must use integer scale factors.\r\n * The 2/3/1 scale factors used here correspond loosely to the relative\r\n * weights of the colors in the NTSC grayscale equation.\r\n * If you want to use this code to quantize a non-RGB color space, you'll\r\n * probably need to change these scale factors.\r\n */\r\n\r\n#define R_SCALE 2\t\t/* scale R distances by this much */\r\n#define G_SCALE 3\t\t/* scale G distances by this much */\r\n#define B_SCALE 1\t\t/* and B by this much */\r\n\r\n/* Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined\r\n * in jmorecfg.h.  As the code stands, it will do the right thing for R,G,B\r\n * and B,G,R orders.  If you define some other weird order in jmorecfg.h,\r\n * you'll get compile errors until you extend this logic.  In that case\r\n * you'll probably want to tweak the histogram sizes too.\r\n */\r\n\r\n#if RGB_RED == 0\r\n#define C0_SCALE R_SCALE\r\n#endif\r\n#if RGB_BLUE == 0\r\n#define C0_SCALE B_SCALE\r\n#endif\r\n#if RGB_GREEN == 1\r\n#define C1_SCALE G_SCALE\r\n#endif\r\n#if RGB_RED == 2\r\n#define C2_SCALE R_SCALE\r\n#endif\r\n#if RGB_BLUE == 2\r\n#define C2_SCALE B_SCALE\r\n#endif\r\n\r\n\r\n/*\r\n * First we have the histogram data structure and routines for creating it.\r\n *\r\n * The number of bits of precision can be adjusted by changing these symbols.\r\n * We recommend keeping 6 bits for G and 5 each for R and B.\r\n * If you have plenty of memory and cycles, 6 bits all around gives marginally\r\n * better results; if you are short of memory, 5 bits all around will save\r\n * some space but degrade the results.\r\n * To maintain a fully accurate histogram, we'd need to allocate a \"long\"\r\n * (preferably unsigned long) for each cell.  In practice this is overkill;\r\n * we can get by with 16 bits per cell.  Few of the cell counts will overflow,\r\n * and clamping those that do overflow to the maximum value will give close-\r\n * enough results.  This reduces the recommended histogram size from 256Kb\r\n * to 128Kb, which is a useful savings on PC-class machines.\r\n * (In the second pass the histogram space is re-used for pixel mapping data;\r\n * in that capacity, each cell must be able to store zero to the number of\r\n * desired colors.  16 bits/cell is plenty for that too.)\r\n * Since the JPEG code is intended to run in small memory model on 80x86\r\n * machines, we can't just allocate the histogram in one chunk.  Instead\r\n * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each\r\n * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and\r\n * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that\r\n * on 80x86 machines, the pointer row is in near memory but the actual\r\n * arrays are in far memory (same arrangement as we use for image arrays).\r\n */\r\n\r\n#define MAXNUMCOLORS  (MAXJSAMPLE+1) /* maximum size of colormap */\r\n\r\n/* These will do the right thing for either R,G,B or B,G,R color order,\r\n * but you may not like the results for other color orders.\r\n */\r\n#define HIST_C0_BITS  5\t\t/* bits of precision in R/B histogram */\r\n#define HIST_C1_BITS  6\t\t/* bits of precision in G histogram */\r\n#define HIST_C2_BITS  5\t\t/* bits of precision in B/R histogram */\r\n\r\n/* Number of elements along histogram axes. */\r\n#define HIST_C0_ELEMS  (1<<HIST_C0_BITS)\r\n#define HIST_C1_ELEMS  (1<<HIST_C1_BITS)\r\n#define HIST_C2_ELEMS  (1<<HIST_C2_BITS)\r\n\r\n/* These are the amounts to shift an input value to get a histogram index. */\r\n#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)\r\n#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)\r\n#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)\r\n\r\n\r\ntypedef UINT16 histcell;\t/* histogram cell; prefer an unsigned type */\r\n\r\ntypedef histcell FAR * histptr;\t/* for pointers to histogram cells */\r\n\r\ntypedef histcell hist1d[HIST_C2_ELEMS]; /* typedefs for the array */\r\ntypedef hist1d FAR * hist2d;\t/* type for the 2nd-level pointers */\r\ntypedef hist2d * hist3d;\t/* type for top-level pointer */\r\n\r\n\r\n/* Declarations for Floyd-Steinberg dithering.\r\n *\r\n * Errors are accumulated into the array fserrors[], at a resolution of\r\n * 1/16th of a pixel count.  The error at a given pixel is propagated\r\n * to its not-yet-processed neighbors using the standard F-S fractions,\r\n *\t\t...\t(here)\t7/16\r\n *\t\t3/16\t5/16\t1/16\r\n * We work left-to-right on even rows, right-to-left on odd rows.\r\n *\r\n * We can get away with a single array (holding one row's worth of errors)\r\n * by using it to store the current row's errors at pixel columns not yet\r\n * processed, but the next row's errors at columns already processed.  We\r\n * need only a few extra variables to hold the errors immediately around the\r\n * current column.  (If we are lucky, those variables are in registers, but\r\n * even if not, they're probably cheaper to access than array elements are.)\r\n *\r\n * The fserrors[] array has (#columns + 2) entries; the extra entry at\r\n * each end saves us from special-casing the first and last pixels.\r\n * Each entry is three values long, one value for each color component.\r\n *\r\n * Note: on a wide image, we might not have enough room in a PC's near data\r\n * segment to hold the error array; so it is allocated with alloc_large.\r\n */\r\n\r\n#if BITS_IN_JSAMPLE == 8\r\ntypedef INT16 FSERROR;\t\t/* 16 bits should be enough */\r\ntypedef int LOCFSERROR;\t\t/* use 'int' for calculation temps */\r\n#else\r\ntypedef INT32 FSERROR;\t\t/* may need more than 16 bits */\r\ntypedef INT32 LOCFSERROR;\t/* be sure calculation temps are big enough */\r\n#endif\r\n\r\ntypedef FSERROR FAR *FSERRPTR;\t/* pointer to error array (in FAR storage!) */\r\n\r\n\r\n/* Private subobject */\r\n\r\ntypedef struct {\r\n  struct jpeg_color_quantizer pub; /* public fields */\r\n\r\n  /* Space for the eventually created colormap is stashed here */\r\n  JSAMPARRAY sv_colormap;\t/* colormap allocated at init time */\r\n  int desired;\t\t\t/* desired # of colors = size of colormap */\r\n\r\n  /* Variables for accumulating image statistics */\r\n  hist3d histogram;\t\t/* pointer to the histogram */\r\n\r\n  boolean needs_zeroed;\t\t/* TRUE if next pass must zero histogram */\r\n\r\n  /* Variables for Floyd-Steinberg dithering */\r\n  FSERRPTR fserrors;\t\t/* accumulated errors */\r\n  boolean on_odd_row;\t\t/* flag to remember which row we are on */\r\n  int * error_limiter;\t\t/* table for clamping the applied error */\r\n} my_cquantizer;\r\n\r\ntypedef my_cquantizer * my_cquantize_ptr;\r\n\r\n\r\n/*\r\n * Prescan some rows of pixels.\r\n * In this module the prescan simply updates the histogram, which has been\r\n * initialized to zeroes by start_pass.\r\n * An output_buf parameter is required by the method signature, but no data\r\n * is actually output (in fact the buffer controller is probably passing a\r\n * NULL pointer).\r\n */\r\n\r\nMETHODDEF(void)\r\nprescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\r\n\t\t  JSAMPARRAY output_buf, int num_rows)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  register JSAMPROW ptr;\r\n  register histptr histp;\r\n  register hist3d histogram = cquantize->histogram;\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    ptr = input_buf[row];\r\n    for (col = width; col > 0; col--) {\r\n      /* get pixel value and index into the histogram */\r\n      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]\r\n\t\t\t [GETJSAMPLE(ptr[1]) >> C1_SHIFT]\r\n\t\t\t [GETJSAMPLE(ptr[2]) >> C2_SHIFT];\r\n      /* increment, check for overflow and undo increment if so. */\r\n      if (++(*histp) <= 0)\r\n\t(*histp)--;\r\n      ptr += 3;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Next we have the really interesting routines: selection of a colormap\r\n * given the completed histogram.\r\n * These routines work with a list of \"boxes\", each representing a rectangular\r\n * subset of the input color space (to histogram precision).\r\n */\r\n\r\ntypedef struct {\r\n  /* The bounds of the box (inclusive); expressed as histogram indexes */\r\n  int c0min, c0max;\r\n  int c1min, c1max;\r\n  int c2min, c2max;\r\n  /* The volume (actually 2-norm) of the box */\r\n  INT32 volume;\r\n  /* The number of nonzero histogram cells within this box */\r\n  long colorcount;\r\n} box;\r\n\r\ntypedef box * boxptr;\r\n\r\n\r\nLOCAL(boxptr)\r\nfind_biggest_color_pop (boxptr boxlist, int numboxes)\r\n/* Find the splittable box with the largest color population */\r\n/* Returns NULL if no splittable boxes remain */\r\n{\r\n  register boxptr boxp;\r\n  register int i;\r\n  register long maxc = 0;\r\n  boxptr which = NULL;\r\n  \r\n  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {\r\n    if (boxp->colorcount > maxc && boxp->volume > 0) {\r\n      which = boxp;\r\n      maxc = boxp->colorcount;\r\n    }\r\n  }\r\n  return which;\r\n}\r\n\r\n\r\nLOCAL(boxptr)\r\nfind_biggest_volume (boxptr boxlist, int numboxes)\r\n/* Find the splittable box with the largest (scaled) volume */\r\n/* Returns NULL if no splittable boxes remain */\r\n{\r\n  register boxptr boxp;\r\n  register int i;\r\n  register INT32 maxv = 0;\r\n  boxptr which = NULL;\r\n  \r\n  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {\r\n    if (boxp->volume > maxv) {\r\n      which = boxp;\r\n      maxv = boxp->volume;\r\n    }\r\n  }\r\n  return which;\r\n}\r\n\r\n\r\nLOCAL(void)\r\nupdate_box (j_decompress_ptr cinfo, boxptr boxp)\r\n/* Shrink the min/max bounds of a box to enclose only nonzero elements, */\r\n/* and recompute its volume and population */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  hist3d histogram = cquantize->histogram;\r\n  histptr histp;\r\n  int c0,c1,c2;\r\n  int c0min,c0max,c1min,c1max,c2min,c2max;\r\n  INT32 dist0,dist1,dist2;\r\n  long ccount;\r\n  \r\n  c0min = boxp->c0min;  c0max = boxp->c0max;\r\n  c1min = boxp->c1min;  c1max = boxp->c1max;\r\n  c2min = boxp->c2min;  c2max = boxp->c2max;\r\n  \r\n  if (c0max > c0min)\r\n    for (c0 = c0min; c0 <= c0max; c0++)\r\n      for (c1 = c1min; c1 <= c1max; c1++) {\r\n\thistp = & histogram[c0][c1][c2min];\r\n\tfor (c2 = c2min; c2 <= c2max; c2++)\r\n\t  if (*histp++ != 0) {\r\n\t    boxp->c0min = c0min = c0;\r\n\t    goto have_c0min;\r\n\t  }\r\n      }\r\n have_c0min:\r\n  if (c0max > c0min)\r\n    for (c0 = c0max; c0 >= c0min; c0--)\r\n      for (c1 = c1min; c1 <= c1max; c1++) {\r\n\thistp = & histogram[c0][c1][c2min];\r\n\tfor (c2 = c2min; c2 <= c2max; c2++)\r\n\t  if (*histp++ != 0) {\r\n\t    boxp->c0max = c0max = c0;\r\n\t    goto have_c0max;\r\n\t  }\r\n      }\r\n have_c0max:\r\n  if (c1max > c1min)\r\n    for (c1 = c1min; c1 <= c1max; c1++)\r\n      for (c0 = c0min; c0 <= c0max; c0++) {\r\n\thistp = & histogram[c0][c1][c2min];\r\n\tfor (c2 = c2min; c2 <= c2max; c2++)\r\n\t  if (*histp++ != 0) {\r\n\t    boxp->c1min = c1min = c1;\r\n\t    goto have_c1min;\r\n\t  }\r\n      }\r\n have_c1min:\r\n  if (c1max > c1min)\r\n    for (c1 = c1max; c1 >= c1min; c1--)\r\n      for (c0 = c0min; c0 <= c0max; c0++) {\r\n\thistp = & histogram[c0][c1][c2min];\r\n\tfor (c2 = c2min; c2 <= c2max; c2++)\r\n\t  if (*histp++ != 0) {\r\n\t    boxp->c1max = c1max = c1;\r\n\t    goto have_c1max;\r\n\t  }\r\n      }\r\n have_c1max:\r\n  if (c2max > c2min)\r\n    for (c2 = c2min; c2 <= c2max; c2++)\r\n      for (c0 = c0min; c0 <= c0max; c0++) {\r\n\thistp = & histogram[c0][c1min][c2];\r\n\tfor (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)\r\n\t  if (*histp != 0) {\r\n\t    boxp->c2min = c2min = c2;\r\n\t    goto have_c2min;\r\n\t  }\r\n      }\r\n have_c2min:\r\n  if (c2max > c2min)\r\n    for (c2 = c2max; c2 >= c2min; c2--)\r\n      for (c0 = c0min; c0 <= c0max; c0++) {\r\n\thistp = & histogram[c0][c1min][c2];\r\n\tfor (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)\r\n\t  if (*histp != 0) {\r\n\t    boxp->c2max = c2max = c2;\r\n\t    goto have_c2max;\r\n\t  }\r\n      }\r\n have_c2max:\r\n\r\n  /* Update box volume.\r\n   * We use 2-norm rather than real volume here; this biases the method\r\n   * against making long narrow boxes, and it has the side benefit that\r\n   * a box is splittable iff norm > 0.\r\n   * Since the differences are expressed in histogram-cell units,\r\n   * we have to shift back to JSAMPLE units to get consistent distances;\r\n   * after which, we scale according to the selected distance scale factors.\r\n   */\r\n  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;\r\n  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;\r\n  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;\r\n  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;\r\n  \r\n  /* Now scan remaining volume of box and compute population */\r\n  ccount = 0;\r\n  for (c0 = c0min; c0 <= c0max; c0++)\r\n    for (c1 = c1min; c1 <= c1max; c1++) {\r\n      histp = & histogram[c0][c1][c2min];\r\n      for (c2 = c2min; c2 <= c2max; c2++, histp++)\r\n\tif (*histp != 0) {\r\n\t  ccount++;\r\n\t}\r\n    }\r\n  boxp->colorcount = ccount;\r\n}\r\n\r\n\r\nLOCAL(int)\r\nmedian_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,\r\n\t    int desired_colors)\r\n/* Repeatedly select and split the largest box until we have enough boxes */\r\n{\r\n  int n,lb;\r\n  int c0,c1,c2,cmax;\r\n  register boxptr b1,b2;\r\n\r\n  while (numboxes < desired_colors) {\r\n    /* Select box to split.\r\n     * Current algorithm: by population for first half, then by volume.\r\n     */\r\n    if (numboxes*2 <= desired_colors) {\r\n      b1 = find_biggest_color_pop(boxlist, numboxes);\r\n    } else {\r\n      b1 = find_biggest_volume(boxlist, numboxes);\r\n    }\r\n    if (b1 == NULL)\t\t/* no splittable boxes left! */\r\n      break;\r\n    b2 = &boxlist[numboxes];\t/* where new box will go */\r\n    /* Copy the color bounds to the new box. */\r\n    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;\r\n    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;\r\n    /* Choose which axis to split the box on.\r\n     * Current algorithm: longest scaled axis.\r\n     * See notes in update_box about scaling distances.\r\n     */\r\n    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;\r\n    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;\r\n    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;\r\n    /* We want to break any ties in favor of green, then red, blue last.\r\n     * This code does the right thing for R,G,B or B,G,R color orders only.\r\n     */\r\n#if RGB_RED == 0\r\n    cmax = c1; n = 1;\r\n    if (c0 > cmax) { cmax = c0; n = 0; }\r\n    if (c2 > cmax) { n = 2; }\r\n#else\r\n    cmax = c1; n = 1;\r\n    if (c2 > cmax) { cmax = c2; n = 2; }\r\n    if (c0 > cmax) { n = 0; }\r\n#endif\r\n    /* Choose split point along selected axis, and update box bounds.\r\n     * Current algorithm: split at halfway point.\r\n     * (Since the box has been shrunk to minimum volume,\r\n     * any split will produce two nonempty subboxes.)\r\n     * Note that lb value is max for lower box, so must be < old max.\r\n     */\r\n    switch (n) {\r\n    case 0:\r\n      lb = (b1->c0max + b1->c0min) / 2;\r\n      b1->c0max = lb;\r\n      b2->c0min = lb+1;\r\n      break;\r\n    case 1:\r\n      lb = (b1->c1max + b1->c1min) / 2;\r\n      b1->c1max = lb;\r\n      b2->c1min = lb+1;\r\n      break;\r\n    case 2:\r\n      lb = (b1->c2max + b1->c2min) / 2;\r\n      b1->c2max = lb;\r\n      b2->c2min = lb+1;\r\n      break;\r\n    }\r\n    /* Update stats for boxes */\r\n    update_box(cinfo, b1);\r\n    update_box(cinfo, b2);\r\n    numboxes++;\r\n  }\r\n  return numboxes;\r\n}\r\n\r\n\r\nLOCAL(void)\r\ncompute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)\r\n/* Compute representative color for a box, put it in colormap[icolor] */\r\n{\r\n  /* Current algorithm: mean weighted by pixels (not colors) */\r\n  /* Note it is important to get the rounding correct! */\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  hist3d histogram = cquantize->histogram;\r\n  histptr histp;\r\n  int c0,c1,c2;\r\n  int c0min,c0max,c1min,c1max,c2min,c2max;\r\n  long count;\r\n  long total = 0;\r\n  long c0total = 0;\r\n  long c1total = 0;\r\n  long c2total = 0;\r\n  \r\n  c0min = boxp->c0min;  c0max = boxp->c0max;\r\n  c1min = boxp->c1min;  c1max = boxp->c1max;\r\n  c2min = boxp->c2min;  c2max = boxp->c2max;\r\n  \r\n  for (c0 = c0min; c0 <= c0max; c0++)\r\n    for (c1 = c1min; c1 <= c1max; c1++) {\r\n      histp = & histogram[c0][c1][c2min];\r\n      for (c2 = c2min; c2 <= c2max; c2++) {\r\n\tif ((count = *histp++) != 0) {\r\n\t  total += count;\r\n\t  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;\r\n\t  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;\r\n\t  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;\r\n\t}\r\n      }\r\n    }\r\n  \r\n  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);\r\n  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);\r\n  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);\r\n}\r\n\r\n\r\nLOCAL(void)\r\nselect_colors (j_decompress_ptr cinfo, int desired_colors)\r\n/* Master routine for color selection */\r\n{\r\n  boxptr boxlist;\r\n  int numboxes;\r\n  int i;\r\n\r\n  /* Allocate workspace for box list */\r\n  boxlist = (boxptr) (*cinfo->mem->alloc_small)\r\n    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));\r\n  /* Initialize one box containing whole space */\r\n  numboxes = 1;\r\n  boxlist[0].c0min = 0;\r\n  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;\r\n  boxlist[0].c1min = 0;\r\n  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;\r\n  boxlist[0].c2min = 0;\r\n  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;\r\n  /* Shrink it to actually-used volume and set its statistics */\r\n  update_box(cinfo, & boxlist[0]);\r\n  /* Perform median-cut to produce final box list */\r\n  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);\r\n  /* Compute the representative color for each box, fill colormap */\r\n  for (i = 0; i < numboxes; i++)\r\n    compute_color(cinfo, & boxlist[i], i);\r\n  cinfo->actual_number_of_colors = numboxes;\r\n  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);\r\n}\r\n\r\n\r\n/*\r\n * These routines are concerned with the time-critical task of mapping input\r\n * colors to the nearest color in the selected colormap.\r\n *\r\n * We re-use the histogram space as an \"inverse color map\", essentially a\r\n * cache for the results of nearest-color searches.  All colors within a\r\n * histogram cell will be mapped to the same colormap entry, namely the one\r\n * closest to the cell's center.  This may not be quite the closest entry to\r\n * the actual input color, but it's almost as good.  A zero in the cache\r\n * indicates we haven't found the nearest color for that cell yet; the array\r\n * is cleared to zeroes before starting the mapping pass.  When we find the\r\n * nearest color for a cell, its colormap index plus one is recorded in the\r\n * cache for future use.  The pass2 scanning routines call fill_inverse_cmap\r\n * when they need to use an unfilled entry in the cache.\r\n *\r\n * Our method of efficiently finding nearest colors is based on the \"locally\r\n * sorted search\" idea described by Heckbert and on the incremental distance\r\n * calculation described by Spencer W. Thomas in chapter III.1 of Graphics\r\n * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that\r\n * the distances from a given colormap entry to each cell of the histogram can\r\n * be computed quickly using an incremental method: the differences between\r\n * distances to adjacent cells themselves differ by a constant.  This allows a\r\n * fairly fast implementation of the \"brute force\" approach of computing the\r\n * distance from every colormap entry to every histogram cell.  Unfortunately,\r\n * it needs a work array to hold the best-distance-so-far for each histogram\r\n * cell (because the inner loop has to be over cells, not colormap entries).\r\n * The work array elements have to be INT32s, so the work array would need\r\n * 256Kb at our recommended precision.  This is not feasible in DOS machines.\r\n *\r\n * To get around these problems, we apply Thomas' method to compute the\r\n * nearest colors for only the cells within a small subbox of the histogram.\r\n * The work array need be only as big as the subbox, so the memory usage\r\n * problem is solved.  Furthermore, we need not fill subboxes that are never\r\n * referenced in pass2; many images use only part of the color gamut, so a\r\n * fair amount of work is saved.  An additional advantage of this\r\n * approach is that we can apply Heckbert's locality criterion to quickly\r\n * eliminate colormap entries that are far away from the subbox; typically\r\n * three-fourths of the colormap entries are rejected by Heckbert's criterion,\r\n * and we need not compute their distances to individual cells in the subbox.\r\n * The speed of this approach is heavily influenced by the subbox size: too\r\n * small means too much overhead, too big loses because Heckbert's criterion\r\n * can't eliminate as many colormap entries.  Empirically the best subbox\r\n * size seems to be about 1/512th of the histogram (1/8th in each direction).\r\n *\r\n * Thomas' article also describes a refined method which is asymptotically\r\n * faster than the brute-force method, but it is also far more complex and\r\n * cannot efficiently be applied to small subboxes.  It is therefore not\r\n * useful for programs intended to be portable to DOS machines.  On machines\r\n * with plenty of memory, filling the whole histogram in one shot with Thomas'\r\n * refined method might be faster than the present code --- but then again,\r\n * it might not be any faster, and it's certainly more complicated.\r\n */\r\n\r\n\r\n/* log2(histogram cells in update box) for each axis; this can be adjusted */\r\n#define BOX_C0_LOG  (HIST_C0_BITS-3)\r\n#define BOX_C1_LOG  (HIST_C1_BITS-3)\r\n#define BOX_C2_LOG  (HIST_C2_BITS-3)\r\n\r\n#define BOX_C0_ELEMS  (1<<BOX_C0_LOG) /* # of hist cells in update box */\r\n#define BOX_C1_ELEMS  (1<<BOX_C1_LOG)\r\n#define BOX_C2_ELEMS  (1<<BOX_C2_LOG)\r\n\r\n#define BOX_C0_SHIFT  (C0_SHIFT + BOX_C0_LOG)\r\n#define BOX_C1_SHIFT  (C1_SHIFT + BOX_C1_LOG)\r\n#define BOX_C2_SHIFT  (C2_SHIFT + BOX_C2_LOG)\r\n\r\n\r\n/*\r\n * The next three routines implement inverse colormap filling.  They could\r\n * all be folded into one big routine, but splitting them up this way saves\r\n * some stack space (the mindist[] and bestdist[] arrays need not coexist)\r\n * and may allow some compilers to produce better code by registerizing more\r\n * inner-loop variables.\r\n */\r\n\r\nLOCAL(int)\r\nfind_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,\r\n\t\t    JSAMPLE colorlist[])\r\n/* Locate the colormap entries close enough to an update box to be candidates\r\n * for the nearest entry to some cell(s) in the update box.  The update box\r\n * is specified by the center coordinates of its first cell.  The number of\r\n * candidate colormap entries is returned, and their colormap indexes are\r\n * placed in colorlist[].\r\n * This routine uses Heckbert's \"locally sorted search\" criterion to select\r\n * the colors that need further consideration.\r\n */\r\n{\r\n  int numcolors = cinfo->actual_number_of_colors;\r\n  int maxc0, maxc1, maxc2;\r\n  int centerc0, centerc1, centerc2;\r\n  int i, x, ncolors;\r\n  INT32 minmaxdist, min_dist, max_dist, tdist;\r\n  INT32 mindist[MAXNUMCOLORS];\t/* min distance to colormap entry i */\r\n\r\n  /* Compute true coordinates of update box's upper corner and center.\r\n   * Actually we compute the coordinates of the center of the upper-corner\r\n   * histogram cell, which are the upper bounds of the volume we care about.\r\n   * Note that since \">>\" rounds down, the \"center\" values may be closer to\r\n   * min than to max; hence comparisons to them must be \"<=\", not \"<\".\r\n   */\r\n  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));\r\n  centerc0 = (minc0 + maxc0) >> 1;\r\n  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));\r\n  centerc1 = (minc1 + maxc1) >> 1;\r\n  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));\r\n  centerc2 = (minc2 + maxc2) >> 1;\r\n\r\n  /* For each color in colormap, find:\r\n   *  1. its minimum squared-distance to any point in the update box\r\n   *     (zero if color is within update box);\r\n   *  2. its maximum squared-distance to any point in the update box.\r\n   * Both of these can be found by considering only the corners of the box.\r\n   * We save the minimum distance for each color in mindist[];\r\n   * only the smallest maximum distance is of interest.\r\n   */\r\n  minmaxdist = 0x7FFFFFFFL;\r\n\r\n  for (i = 0; i < numcolors; i++) {\r\n    /* We compute the squared-c0-distance term, then add in the other two. */\r\n    x = GETJSAMPLE(cinfo->colormap[0][i]);\r\n    if (x < minc0) {\r\n      tdist = (x - minc0) * C0_SCALE;\r\n      min_dist = tdist*tdist;\r\n      tdist = (x - maxc0) * C0_SCALE;\r\n      max_dist = tdist*tdist;\r\n    } else if (x > maxc0) {\r\n      tdist = (x - maxc0) * C0_SCALE;\r\n      min_dist = tdist*tdist;\r\n      tdist = (x - minc0) * C0_SCALE;\r\n      max_dist = tdist*tdist;\r\n    } else {\r\n      /* within cell range so no contribution to min_dist */\r\n      min_dist = 0;\r\n      if (x <= centerc0) {\r\n\ttdist = (x - maxc0) * C0_SCALE;\r\n\tmax_dist = tdist*tdist;\r\n      } else {\r\n\ttdist = (x - minc0) * C0_SCALE;\r\n\tmax_dist = tdist*tdist;\r\n      }\r\n    }\r\n\r\n    x = GETJSAMPLE(cinfo->colormap[1][i]);\r\n    if (x < minc1) {\r\n      tdist = (x - minc1) * C1_SCALE;\r\n      min_dist += tdist*tdist;\r\n      tdist = (x - maxc1) * C1_SCALE;\r\n      max_dist += tdist*tdist;\r\n    } else if (x > maxc1) {\r\n      tdist = (x - maxc1) * C1_SCALE;\r\n      min_dist += tdist*tdist;\r\n      tdist = (x - minc1) * C1_SCALE;\r\n      max_dist += tdist*tdist;\r\n    } else {\r\n      /* within cell range so no contribution to min_dist */\r\n      if (x <= centerc1) {\r\n\ttdist = (x - maxc1) * C1_SCALE;\r\n\tmax_dist += tdist*tdist;\r\n      } else {\r\n\ttdist = (x - minc1) * C1_SCALE;\r\n\tmax_dist += tdist*tdist;\r\n      }\r\n    }\r\n\r\n    x = GETJSAMPLE(cinfo->colormap[2][i]);\r\n    if (x < minc2) {\r\n      tdist = (x - minc2) * C2_SCALE;\r\n      min_dist += tdist*tdist;\r\n      tdist = (x - maxc2) * C2_SCALE;\r\n      max_dist += tdist*tdist;\r\n    } else if (x > maxc2) {\r\n      tdist = (x - maxc2) * C2_SCALE;\r\n      min_dist += tdist*tdist;\r\n      tdist = (x - minc2) * C2_SCALE;\r\n      max_dist += tdist*tdist;\r\n    } else {\r\n      /* within cell range so no contribution to min_dist */\r\n      if (x <= centerc2) {\r\n\ttdist = (x - maxc2) * C2_SCALE;\r\n\tmax_dist += tdist*tdist;\r\n      } else {\r\n\ttdist = (x - minc2) * C2_SCALE;\r\n\tmax_dist += tdist*tdist;\r\n      }\r\n    }\r\n\r\n    mindist[i] = min_dist;\t/* save away the results */\r\n    if (max_dist < minmaxdist)\r\n      minmaxdist = max_dist;\r\n  }\r\n\r\n  /* Now we know that no cell in the update box is more than minmaxdist\r\n   * away from some colormap entry.  Therefore, only colors that are\r\n   * within minmaxdist of some part of the box need be considered.\r\n   */\r\n  ncolors = 0;\r\n  for (i = 0; i < numcolors; i++) {\r\n    if (mindist[i] <= minmaxdist)\r\n      colorlist[ncolors++] = (JSAMPLE) i;\r\n  }\r\n  return ncolors;\r\n}\r\n\r\n\r\nLOCAL(void)\r\nfind_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,\r\n\t\t  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])\r\n/* Find the closest colormap entry for each cell in the update box,\r\n * given the list of candidate colors prepared by find_nearby_colors.\r\n * Return the indexes of the closest entries in the bestcolor[] array.\r\n * This routine uses Thomas' incremental distance calculation method to\r\n * find the distance from a colormap entry to successive cells in the box.\r\n */\r\n{\r\n  int ic0, ic1, ic2;\r\n  int i, icolor;\r\n  register INT32 * bptr;\t/* pointer into bestdist[] array */\r\n  JSAMPLE * cptr;\t\t/* pointer into bestcolor[] array */\r\n  INT32 dist0, dist1;\t\t/* initial distance values */\r\n  register INT32 dist2;\t\t/* current distance in inner loop */\r\n  INT32 xx0, xx1;\t\t/* distance increments */\r\n  register INT32 xx2;\r\n  INT32 inc0, inc1, inc2;\t/* initial values for increments */\r\n  /* This array holds the distance to the nearest-so-far color for each cell */\r\n  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];\r\n\r\n  /* Initialize best-distance for each cell of the update box */\r\n  bptr = bestdist;\r\n  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)\r\n    *bptr++ = 0x7FFFFFFFL;\r\n  \r\n  /* For each color selected by find_nearby_colors,\r\n   * compute its distance to the center of each cell in the box.\r\n   * If that's less than best-so-far, update best distance and color number.\r\n   */\r\n  \r\n  /* Nominal steps between cell centers (\"x\" in Thomas article) */\r\n#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)\r\n#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)\r\n#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)\r\n  \r\n  for (i = 0; i < numcolors; i++) {\r\n    icolor = GETJSAMPLE(colorlist[i]);\r\n    /* Compute (square of) distance from minc0/c1/c2 to this color */\r\n    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;\r\n    dist0 = inc0*inc0;\r\n    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;\r\n    dist0 += inc1*inc1;\r\n    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;\r\n    dist0 += inc2*inc2;\r\n    /* Form the initial difference increments */\r\n    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;\r\n    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;\r\n    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;\r\n    /* Now loop over all cells in box, updating distance per Thomas method */\r\n    bptr = bestdist;\r\n    cptr = bestcolor;\r\n    xx0 = inc0;\r\n    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {\r\n      dist1 = dist0;\r\n      xx1 = inc1;\r\n      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {\r\n\tdist2 = dist1;\r\n\txx2 = inc2;\r\n\tfor (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {\r\n\t  if (dist2 < *bptr) {\r\n\t    *bptr = dist2;\r\n\t    *cptr = (JSAMPLE) icolor;\r\n\t  }\r\n\t  dist2 += xx2;\r\n\t  xx2 += 2 * STEP_C2 * STEP_C2;\r\n\t  bptr++;\r\n\t  cptr++;\r\n\t}\r\n\tdist1 += xx1;\r\n\txx1 += 2 * STEP_C1 * STEP_C1;\r\n      }\r\n      dist0 += xx0;\r\n      xx0 += 2 * STEP_C0 * STEP_C0;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\nfill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)\r\n/* Fill the inverse-colormap entries in the update box that contains */\r\n/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */\r\n/* we can fill as many others as we wish.) */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  hist3d histogram = cquantize->histogram;\r\n  int minc0, minc1, minc2;\t/* lower left corner of update box */\r\n  int ic0, ic1, ic2;\r\n  register JSAMPLE * cptr;\t/* pointer into bestcolor[] array */\r\n  register histptr cachep;\t/* pointer into main cache array */\r\n  /* This array lists the candidate colormap indexes. */\r\n  JSAMPLE colorlist[MAXNUMCOLORS];\r\n  int numcolors;\t\t/* number of candidate colors */\r\n  /* This array holds the actually closest colormap index for each cell. */\r\n  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];\r\n\r\n  /* Convert cell coordinates to update box ID */\r\n  c0 >>= BOX_C0_LOG;\r\n  c1 >>= BOX_C1_LOG;\r\n  c2 >>= BOX_C2_LOG;\r\n\r\n  /* Compute true coordinates of update box's origin corner.\r\n   * Actually we compute the coordinates of the center of the corner\r\n   * histogram cell, which are the lower bounds of the volume we care about.\r\n   */\r\n  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);\r\n  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);\r\n  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);\r\n  \r\n  /* Determine which colormap entries are close enough to be candidates\r\n   * for the nearest entry to some cell in the update box.\r\n   */\r\n  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);\r\n\r\n  /* Determine the actually nearest colors. */\r\n  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,\r\n\t\t   bestcolor);\r\n\r\n  /* Save the best color numbers (plus 1) in the main cache array */\r\n  c0 <<= BOX_C0_LOG;\t\t/* convert ID back to base cell indexes */\r\n  c1 <<= BOX_C1_LOG;\r\n  c2 <<= BOX_C2_LOG;\r\n  cptr = bestcolor;\r\n  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {\r\n    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {\r\n      cachep = & histogram[c0+ic0][c1+ic1][c2];\r\n      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {\r\n\t*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Map some rows of pixels to the output colormapped representation.\r\n */\r\n\r\nMETHODDEF(void)\r\npass2_no_dither (j_decompress_ptr cinfo,\r\n\t\t JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)\r\n/* This version performs no dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  hist3d histogram = cquantize->histogram;\r\n  register JSAMPROW inptr, outptr;\r\n  register histptr cachep;\r\n  register int c0, c1, c2;\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    inptr = input_buf[row];\r\n    outptr = output_buf[row];\r\n    for (col = width; col > 0; col--) {\r\n      /* get pixel value and index into the cache */\r\n      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;\r\n      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;\r\n      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;\r\n      cachep = & histogram[c0][c1][c2];\r\n      /* If we have not seen this color before, find nearest colormap entry */\r\n      /* and update the cache */\r\n      if (*cachep == 0)\r\n\tfill_inverse_cmap(cinfo, c0,c1,c2);\r\n      /* Now emit the colormap index for this cell */\r\n      *outptr++ = (JSAMPLE) (*cachep - 1);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\npass2_fs_dither (j_decompress_ptr cinfo,\r\n\t\t JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)\r\n/* This version performs Floyd-Steinberg dithering */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  hist3d histogram = cquantize->histogram;\r\n  register LOCFSERROR cur0, cur1, cur2;\t/* current error or pixel value */\r\n  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */\r\n  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */\r\n  register FSERRPTR errorptr;\t/* => fserrors[] at column before current */\r\n  JSAMPROW inptr;\t\t/* => current input pixel */\r\n  JSAMPROW outptr;\t\t/* => current output pixel */\r\n  histptr cachep;\r\n  int dir;\t\t\t/* +1 or -1 depending on direction */\r\n  int dir3;\t\t\t/* 3*dir, for advancing inptr & errorptr */\r\n  int row;\r\n  JDIMENSION col;\r\n  JDIMENSION width = cinfo->output_width;\r\n  JSAMPLE *range_limit = cinfo->sample_range_limit;\r\n  int *error_limit = cquantize->error_limiter;\r\n  JSAMPROW colormap0 = cinfo->colormap[0];\r\n  JSAMPROW colormap1 = cinfo->colormap[1];\r\n  JSAMPROW colormap2 = cinfo->colormap[2];\r\n  SHIFT_TEMPS\r\n\r\n  for (row = 0; row < num_rows; row++) {\r\n    inptr = input_buf[row];\r\n    outptr = output_buf[row];\r\n    if (cquantize->on_odd_row) {\r\n      /* work right to left in this row */\r\n      inptr += (width-1) * 3;\t/* so point to rightmost pixel */\r\n      outptr += width-1;\r\n      dir = -1;\r\n      dir3 = -3;\r\n      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */\r\n      cquantize->on_odd_row = FALSE; /* flip for next time */\r\n    } else {\r\n      /* work left to right in this row */\r\n      dir = 1;\r\n      dir3 = 3;\r\n      errorptr = cquantize->fserrors; /* => entry before first real column */\r\n      cquantize->on_odd_row = TRUE; /* flip for next time */\r\n    }\r\n    /* Preset error values: no error propagated to first pixel from left */\r\n    cur0 = cur1 = cur2 = 0;\r\n    /* and no error propagated to row below yet */\r\n    belowerr0 = belowerr1 = belowerr2 = 0;\r\n    bpreverr0 = bpreverr1 = bpreverr2 = 0;\r\n\r\n    for (col = width; col > 0; col--) {\r\n      /* curN holds the error propagated from the previous pixel on the\r\n       * current line.  Add the error propagated from the previous line\r\n       * to form the complete error correction term for this pixel, and\r\n       * round the error term (which is expressed * 16) to an integer.\r\n       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct\r\n       * for either sign of the error value.\r\n       * Note: errorptr points to *previous* column's array entry.\r\n       */\r\n      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);\r\n      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);\r\n      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);\r\n      /* Limit the error using transfer function set by init_error_limit.\r\n       * See comments with init_error_limit for rationale.\r\n       */\r\n      cur0 = error_limit[cur0];\r\n      cur1 = error_limit[cur1];\r\n      cur2 = error_limit[cur2];\r\n      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.\r\n       * The maximum error is +- MAXJSAMPLE (or less with error limiting);\r\n       * this sets the required size of the range_limit array.\r\n       */\r\n      cur0 += GETJSAMPLE(inptr[0]);\r\n      cur1 += GETJSAMPLE(inptr[1]);\r\n      cur2 += GETJSAMPLE(inptr[2]);\r\n      cur0 = GETJSAMPLE(range_limit[cur0]);\r\n      cur1 = GETJSAMPLE(range_limit[cur1]);\r\n      cur2 = GETJSAMPLE(range_limit[cur2]);\r\n      /* Index into the cache with adjusted pixel value */\r\n      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];\r\n      /* If we have not seen this color before, find nearest colormap */\r\n      /* entry and update the cache */\r\n      if (*cachep == 0)\r\n\tfill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);\r\n      /* Now emit the colormap index for this cell */\r\n      { register int pixcode = *cachep - 1;\r\n\t*outptr = (JSAMPLE) pixcode;\r\n\t/* Compute representation error for this pixel */\r\n\tcur0 -= GETJSAMPLE(colormap0[pixcode]);\r\n\tcur1 -= GETJSAMPLE(colormap1[pixcode]);\r\n\tcur2 -= GETJSAMPLE(colormap2[pixcode]);\r\n      }\r\n      /* Compute error fractions to be propagated to adjacent pixels.\r\n       * Add these into the running sums, and simultaneously shift the\r\n       * next-line error sums left by 1 column.\r\n       */\r\n      { register LOCFSERROR bnexterr, delta;\r\n\r\n\tbnexterr = cur0;\t/* Process component 0 */\r\n\tdelta = cur0 * 2;\r\n\tcur0 += delta;\t\t/* form error * 3 */\r\n\terrorptr[0] = (FSERROR) (bpreverr0 + cur0);\r\n\tcur0 += delta;\t\t/* form error * 5 */\r\n\tbpreverr0 = belowerr0 + cur0;\r\n\tbelowerr0 = bnexterr;\r\n\tcur0 += delta;\t\t/* form error * 7 */\r\n\tbnexterr = cur1;\t/* Process component 1 */\r\n\tdelta = cur1 * 2;\r\n\tcur1 += delta;\t\t/* form error * 3 */\r\n\terrorptr[1] = (FSERROR) (bpreverr1 + cur1);\r\n\tcur1 += delta;\t\t/* form error * 5 */\r\n\tbpreverr1 = belowerr1 + cur1;\r\n\tbelowerr1 = bnexterr;\r\n\tcur1 += delta;\t\t/* form error * 7 */\r\n\tbnexterr = cur2;\t/* Process component 2 */\r\n\tdelta = cur2 * 2;\r\n\tcur2 += delta;\t\t/* form error * 3 */\r\n\terrorptr[2] = (FSERROR) (bpreverr2 + cur2);\r\n\tcur2 += delta;\t\t/* form error * 5 */\r\n\tbpreverr2 = belowerr2 + cur2;\r\n\tbelowerr2 = bnexterr;\r\n\tcur2 += delta;\t\t/* form error * 7 */\r\n      }\r\n      /* At this point curN contains the 7/16 error value to be propagated\r\n       * to the next pixel on the current line, and all the errors for the\r\n       * next line have been shifted over.  We are therefore ready to move on.\r\n       */\r\n      inptr += dir3;\t\t/* Advance pixel pointers to next column */\r\n      outptr += dir;\r\n      errorptr += dir3;\t\t/* advance errorptr to current column */\r\n    }\r\n    /* Post-loop cleanup: we must unload the final error values into the\r\n     * final fserrors[] entry.  Note we need not unload belowerrN because\r\n     * it is for the dummy column before or after the actual array.\r\n     */\r\n    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */\r\n    errorptr[1] = (FSERROR) bpreverr1;\r\n    errorptr[2] = (FSERROR) bpreverr2;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Initialize the error-limiting transfer function (lookup table).\r\n * The raw F-S error computation can potentially compute error values of up to\r\n * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be\r\n * much less, otherwise obviously wrong pixels will be created.  (Typical\r\n * effects include weird fringes at color-area boundaries, isolated bright\r\n * pixels in a dark area, etc.)  The standard advice for avoiding this problem\r\n * is to ensure that the \"corners\" of the color cube are allocated as output\r\n * colors; then repeated errors in the same direction cannot cause cascading\r\n * error buildup.  However, that only prevents the error from getting\r\n * completely out of hand; Aaron Giles reports that error limiting improves\r\n * the results even with corner colors allocated.\r\n * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty\r\n * well, but the smoother transfer function used below is even better.  Thanks\r\n * to Aaron Giles for this idea.\r\n */\r\n\r\nLOCAL(void)\r\ninit_error_limit (j_decompress_ptr cinfo)\r\n/* Allocate and fill in the error_limiter table */\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  int * table;\r\n  int in, out;\r\n\r\n  table = (int *) (*cinfo->mem->alloc_small)\r\n    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));\r\n  table += MAXJSAMPLE;\t\t/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */\r\n  cquantize->error_limiter = table;\r\n\r\n#define STEPSIZE ((MAXJSAMPLE+1)/16)\r\n  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */\r\n  out = 0;\r\n  for (in = 0; in < STEPSIZE; in++, out++) {\r\n    table[in] = out; table[-in] = -out;\r\n  }\r\n  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */\r\n  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {\r\n    table[in] = out; table[-in] = -out;\r\n  }\r\n  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */\r\n  for (; in <= MAXJSAMPLE; in++) {\r\n    table[in] = out; table[-in] = -out;\r\n  }\r\n#undef STEPSIZE\r\n}\r\n\r\n\r\n/*\r\n * Finish up at the end of each pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nfinish_pass1 (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n\r\n  /* Select the representative colors and fill in cinfo->colormap */\r\n  cinfo->colormap = cquantize->sv_colormap;\r\n  select_colors(cinfo, cquantize->desired);\r\n  /* Force next pass to zero the color index table */\r\n  cquantize->needs_zeroed = TRUE;\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nfinish_pass2 (j_decompress_ptr cinfo)\r\n{\r\n  /* no work */\r\n}\r\n\r\n\r\n/*\r\n * Initialize for each processing pass.\r\n */\r\n\r\nMETHODDEF(void)\r\nstart_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n  hist3d histogram = cquantize->histogram;\r\n  int i;\r\n\r\n  /* Only F-S dithering or no dithering is supported. */\r\n  /* If user asks for ordered dither, give him F-S. */\r\n  if (cinfo->dither_mode != JDITHER_NONE)\r\n    cinfo->dither_mode = JDITHER_FS;\r\n\r\n  if (is_pre_scan) {\r\n    /* Set up method pointers */\r\n    cquantize->pub.color_quantize = prescan_quantize;\r\n    cquantize->pub.finish_pass = finish_pass1;\r\n    cquantize->needs_zeroed = TRUE; /* Always zero histogram */\r\n  } else {\r\n    /* Set up method pointers */\r\n    if (cinfo->dither_mode == JDITHER_FS)\r\n      cquantize->pub.color_quantize = pass2_fs_dither;\r\n    else\r\n      cquantize->pub.color_quantize = pass2_no_dither;\r\n    cquantize->pub.finish_pass = finish_pass2;\r\n\r\n    /* Make sure color count is acceptable */\r\n    i = cinfo->actual_number_of_colors;\r\n    if (i < 1)\r\n      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);\r\n    if (i > MAXNUMCOLORS)\r\n      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);\r\n\r\n    if (cinfo->dither_mode == JDITHER_FS) {\r\n      size_t arraysize = (size_t) ((cinfo->output_width + 2) *\r\n\t\t\t\t   (3 * SIZEOF(FSERROR)));\r\n      /* Allocate Floyd-Steinberg workspace if we didn't already. */\r\n      if (cquantize->fserrors == NULL)\r\n\tcquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)\r\n\t  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);\r\n      /* Initialize the propagated errors to zero. */\r\n      FMEMZERO((void FAR *) cquantize->fserrors, arraysize);\r\n      /* Make the error-limit table if we didn't already. */\r\n      if (cquantize->error_limiter == NULL)\r\n\tinit_error_limit(cinfo);\r\n      cquantize->on_odd_row = FALSE;\r\n    }\r\n\r\n  }\r\n  /* Zero the histogram or inverse color map, if necessary */\r\n  if (cquantize->needs_zeroed) {\r\n    for (i = 0; i < HIST_C0_ELEMS; i++) {\r\n      FMEMZERO((void FAR *) histogram[i],\r\n\t       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));\r\n    }\r\n    cquantize->needs_zeroed = FALSE;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Switch to a new external colormap between output passes.\r\n */\r\n\r\nMETHODDEF(void)\r\nnew_color_map_2_quant (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\r\n\r\n  /* Reset the inverse color map */\r\n  cquantize->needs_zeroed = TRUE;\r\n}\r\n\r\n\r\n/*\r\n * Module initialization routine for 2-pass color quantization.\r\n */\r\n\r\nGLOBAL(void)\r\njinit_2pass_quantizer (j_decompress_ptr cinfo)\r\n{\r\n  my_cquantize_ptr cquantize;\r\n  int i;\r\n\r\n  cquantize = (my_cquantize_ptr)\r\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n\t\t\t\tSIZEOF(my_cquantizer));\r\n  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;\r\n  cquantize->pub.start_pass = start_pass_2_quant;\r\n  cquantize->pub.new_color_map = new_color_map_2_quant;\r\n  cquantize->fserrors = NULL;\t/* flag optional arrays not allocated */\r\n  cquantize->error_limiter = NULL;\r\n\r\n  /* Make sure jdmaster didn't give me a case I can't handle */\r\n  if (cinfo->out_color_components != 3)\r\n    ERREXIT(cinfo, JERR_NOTIMPL);\r\n\r\n  /* Allocate the histogram/inverse colormap storage */\r\n  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)\r\n    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));\r\n  for (i = 0; i < HIST_C0_ELEMS; i++) {\r\n    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)\r\n      ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));\r\n  }\r\n  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */\r\n\r\n  /* Allocate storage for the completed colormap, if required.\r\n   * We do this now since it is FAR storage and may affect\r\n   * the memory manager's space calculations.\r\n   */\r\n  if (cinfo->enable_2pass_quant) {\r\n    /* Make sure color count is acceptable */\r\n    int desired = cinfo->desired_number_of_colors;\r\n    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */\r\n    if (desired < 8)\r\n      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);\r\n    /* Make sure colormap indexes can be represented by JSAMPLEs */\r\n    if (desired > MAXNUMCOLORS)\r\n      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);\r\n    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)\r\n      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);\r\n    cquantize->desired = desired;\r\n  } else\r\n    cquantize->sv_colormap = NULL;\r\n\r\n  /* Only F-S dithering or no dithering is supported. */\r\n  /* If user asks for ordered dither, give him F-S. */\r\n  if (cinfo->dither_mode != JDITHER_NONE)\r\n    cinfo->dither_mode = JDITHER_FS;\r\n\r\n  /* Allocate Floyd-Steinberg workspace if necessary.\r\n   * This isn't really needed until pass 2, but again it is FAR storage.\r\n   * Although we will cope with a later change in dither_mode,\r\n   * we do not promise to honor max_memory_to_use if dither_mode changes.\r\n   */\r\n  if (cinfo->dither_mode == JDITHER_FS) {\r\n    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)\r\n      ((j_common_ptr) cinfo, JPOOL_IMAGE,\r\n       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));\r\n    /* Might as well create the error-limiting table too. */\r\n    init_error_limit(cinfo);\r\n  }\r\n}\r\n\r\n#endif /* QUANT_2PASS_SUPPORTED */\r\n","/*\r\n * jutils.c\r\n *\r\n * Copyright (C) 1991-1996, Thomas G. Lane.\r\n * Modified 2009-2011 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains tables and miscellaneous utility routines needed\r\n * for both compression and decompression.\r\n * Note we prefix all global names with \"j\" to minimize conflicts with\r\n * a surrounding application.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n\r\n\r\n/*\r\n * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element\r\n * of a DCT block read in natural order (left to right, top to bottom).\r\n */\r\n\r\n#if 0\t\t\t\t/* This table is not actually needed in v6a */\r\n\r\nconst int jpeg_zigzag_order[DCTSIZE2] = {\r\n   0,  1,  5,  6, 14, 15, 27, 28,\r\n   2,  4,  7, 13, 16, 26, 29, 42,\r\n   3,  8, 12, 17, 25, 30, 41, 43,\r\n   9, 11, 18, 24, 31, 40, 44, 53,\r\n  10, 19, 23, 32, 39, 45, 52, 54,\r\n  20, 22, 33, 38, 46, 51, 55, 60,\r\n  21, 34, 37, 47, 50, 56, 59, 61,\r\n  35, 36, 48, 49, 57, 58, 62, 63\r\n};\r\n\r\n#endif\r\n\r\n/*\r\n * jpeg_natural_order[i] is the natural-order position of the i'th element\r\n * of zigzag order.\r\n *\r\n * When reading corrupted data, the Huffman decoders could attempt\r\n * to reference an entry beyond the end of this array (if the decoded\r\n * zero run length reaches past the end of the block).  To prevent\r\n * wild stores without adding an inner-loop test, we put some extra\r\n * \"63\"s after the real entries.  This will cause the extra coefficient\r\n * to be stored in location 63 of the block, not somewhere random.\r\n * The worst case would be a run-length of 15, which means we need 16\r\n * fake entries.\r\n */\r\n\r\nconst int jpeg_natural_order[DCTSIZE2+16] = {\r\n  0,  1,  8, 16,  9,  2,  3, 10,\r\n 17, 24, 32, 25, 18, 11,  4,  5,\r\n 12, 19, 26, 33, 40, 48, 41, 34,\r\n 27, 20, 13,  6,  7, 14, 21, 28,\r\n 35, 42, 49, 56, 57, 50, 43, 36,\r\n 29, 22, 15, 23, 30, 37, 44, 51,\r\n 58, 59, 52, 45, 38, 31, 39, 46,\r\n 53, 60, 61, 54, 47, 55, 62, 63,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int jpeg_natural_order7[7*7+16] = {\r\n  0,  1,  8, 16,  9,  2,  3, 10,\r\n 17, 24, 32, 25, 18, 11,  4,  5,\r\n 12, 19, 26, 33, 40, 48, 41, 34,\r\n 27, 20, 13,  6, 14, 21, 28, 35,\r\n 42, 49, 50, 43, 36, 29, 22, 30,\r\n 37, 44, 51, 52, 45, 38, 46, 53,\r\n 54,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int jpeg_natural_order6[6*6+16] = {\r\n  0,  1,  8, 16,  9,  2,  3, 10,\r\n 17, 24, 32, 25, 18, 11,  4,  5,\r\n 12, 19, 26, 33, 40, 41, 34, 27,\r\n 20, 13, 21, 28, 35, 42, 43, 36,\r\n 29, 37, 44, 45,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int jpeg_natural_order5[5*5+16] = {\r\n  0,  1,  8, 16,  9,  2,  3, 10,\r\n 17, 24, 32, 25, 18, 11,  4, 12,\r\n 19, 26, 33, 34, 27, 20, 28, 35,\r\n 36,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int jpeg_natural_order4[4*4+16] = {\r\n  0,  1,  8, 16,  9,  2,  3, 10,\r\n 17, 24, 25, 18, 11, 19, 26, 27,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int jpeg_natural_order3[3*3+16] = {\r\n  0,  1,  8, 16,  9,  2, 10, 17,\r\n 18,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int jpeg_natural_order2[2*2+16] = {\r\n  0,  1,  8,  9,\r\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\r\n 63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\n\r\n/*\r\n * Arithmetic utilities\r\n */\r\n\r\nGLOBAL(long)\r\njdiv_round_up (long a, long b)\r\n/* Compute a/b rounded up to next integer, ie, ceil(a/b) */\r\n/* Assumes a >= 0, b > 0 */\r\n{\r\n  return (a + b - 1L) / b;\r\n}\r\n\r\n\r\nGLOBAL(long)\r\njround_up (long a, long b)\r\n/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */\r\n/* Assumes a >= 0, b > 0 */\r\n{\r\n  a += b - 1L;\r\n  return a - (a % b);\r\n}\r\n\r\n\r\n/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays\r\n * and coefficient-block arrays.  This won't work on 80x86 because the arrays\r\n * are FAR and we're assuming a small-pointer memory model.  However, some\r\n * DOS compilers provide far-pointer versions of memcpy() and memset() even\r\n * in the small-model libraries.  These will be used if USE_FMEM is defined.\r\n * Otherwise, the routines below do it the hard way.  (The performance cost\r\n * is not all that great, because these routines aren't very heavily used.)\r\n */\r\n\r\n#ifndef NEED_FAR_POINTERS\t/* normal case, same as regular macro */\r\n#define FMEMCOPY(dest,src,size)\tMEMCOPY(dest,src,size)\r\n#else\t\t\t\t/* 80x86 case, define if we can */\r\n#ifdef USE_FMEM\r\n#define FMEMCOPY(dest,src,size)\t_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))\r\n#else\r\n/* This function is for use by the FMEMZERO macro defined in jpegint.h.\r\n * Do not call this function directly, use the FMEMZERO macro instead.\r\n */\r\nGLOBAL(void)\r\njzero_far (void FAR * target, size_t bytestozero)\r\n/* Zero out a chunk of FAR memory. */\r\n/* This might be sample-array data, block-array data, or alloc_large data. */\r\n{\r\n  register char FAR * ptr = (char FAR *) target;\r\n  register size_t count;\r\n\r\n  for (count = bytestozero; count > 0; count--) {\r\n    *ptr++ = 0;\r\n  }\r\n}\r\n#endif\r\n#endif\r\n\r\n\r\nGLOBAL(void)\r\njcopy_sample_rows (JSAMPARRAY input_array, int source_row,\r\n\t\t   JSAMPARRAY output_array, int dest_row,\r\n\t\t   int num_rows, JDIMENSION num_cols)\r\n/* Copy some rows of samples from one place to another.\r\n * num_rows rows are copied from input_array[source_row++]\r\n * to output_array[dest_row++]; these areas may overlap for duplication.\r\n * The source and destination arrays must be at least as wide as num_cols.\r\n */\r\n{\r\n  register JSAMPROW inptr, outptr;\r\n#ifdef FMEMCOPY\r\n  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));\r\n#else\r\n  register JDIMENSION count;\r\n#endif\r\n  register int row;\r\n\r\n  input_array += source_row;\r\n  output_array += dest_row;\r\n\r\n  for (row = num_rows; row > 0; row--) {\r\n    inptr = *input_array++;\r\n    outptr = *output_array++;\r\n#ifdef FMEMCOPY\r\n    FMEMCOPY(outptr, inptr, count);\r\n#else\r\n    for (count = num_cols; count > 0; count--)\r\n      *outptr++ = *inptr++;\t/* needn't bother with GETJSAMPLE() here */\r\n#endif\r\n  }\r\n}\r\n\r\n\r\nGLOBAL(void)\r\njcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,\r\n\t\t JDIMENSION num_blocks)\r\n/* Copy a row of coefficient blocks from one place to another. */\r\n{\r\n#ifdef FMEMCOPY\r\n  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));\r\n#else\r\n  register JCOEFPTR inptr, outptr;\r\n  register long count;\r\n\r\n  inptr = (JCOEFPTR) input_row;\r\n  outptr = (JCOEFPTR) output_row;\r\n  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {\r\n    *outptr++ = *inptr++;\r\n  }\r\n#endif\r\n}\r\n","/*\r\n * jmemmgr.c\r\n *\r\n * Copyright (C) 1991-1997, Thomas G. Lane.\r\n * Modified 2011-2012 by Guido Vollbeding.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file contains the JPEG system-independent memory management\r\n * routines.  This code is usable across a wide variety of machines; most\r\n * of the system dependencies have been isolated in a separate file.\r\n * The major functions provided here are:\r\n *   * pool-based allocation and freeing of memory;\r\n *   * policy decisions about how to divide available memory among the\r\n *     virtual arrays;\r\n *   * control logic for swapping virtual arrays between main memory and\r\n *     backing storage.\r\n * The separate system-dependent file provides the actual backing-storage\r\n * access code, and it contains the policy decision about how much total\r\n * main memory to use.\r\n * This file is system-dependent in the sense that some of its functions\r\n * are unnecessary in some systems.  For example, if there is enough virtual\r\n * memory so that backing storage will never be used, much of the virtual\r\n * array control logic could be removed.  (Of course, if you have that much\r\n * memory then you shouldn't care about a little bit of unused code...)\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#define AM_MEMORY_MANAGER\t/* we define jvirt_Xarray_control structs */\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jmemsys.h\"\t\t/* import the system-dependent declarations */\r\n\r\n#ifndef NO_GETENV\r\n#ifndef HAVE_STDLIB_H\t\t/* <stdlib.h> should declare getenv() */\r\nextern char * getenv JPP((const char * name));\r\n#endif\r\n#endif\r\n\r\n\r\n/*\r\n * Some important notes:\r\n *   The allocation routines provided here must never return NULL.\r\n *   They should exit to error_exit if unsuccessful.\r\n *\r\n *   It's not a good idea to try to merge the sarray and barray routines,\r\n *   even though they are textually almost the same, because samples are\r\n *   usually stored as bytes while coefficients are shorts or ints.  Thus,\r\n *   in machines where byte pointers have a different representation from\r\n *   word pointers, the resulting machine code could not be the same.\r\n */\r\n\r\n\r\n/*\r\n * Many machines require storage alignment: longs must start on 4-byte\r\n * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()\r\n * always returns pointers that are multiples of the worst-case alignment\r\n * requirement, and we had better do so too.\r\n * There isn't any really portable way to determine the worst-case alignment\r\n * requirement.  This module assumes that the alignment requirement is\r\n * multiples of sizeof(ALIGN_TYPE).\r\n * By default, we define ALIGN_TYPE as double.  This is necessary on some\r\n * workstations (where doubles really do need 8-byte alignment) and will work\r\n * fine on nearly everything.  If your machine has lesser alignment needs,\r\n * you can save a few bytes by making ALIGN_TYPE smaller.\r\n * The only place I know of where this will NOT work is certain Macintosh\r\n * 680x0 compilers that define double as a 10-byte IEEE extended float.\r\n * Doing 10-byte alignment is counterproductive because longwords won't be\r\n * aligned well.  Put \"#define ALIGN_TYPE long\" in jconfig.h if you have\r\n * such a compiler.\r\n */\r\n\r\n#ifndef ALIGN_TYPE\t\t/* so can override from jconfig.h */\r\n#define ALIGN_TYPE  double\r\n#endif\r\n\r\n\r\n/*\r\n * We allocate objects from \"pools\", where each pool is gotten with a single\r\n * request to jpeg_get_small() or jpeg_get_large().  There is no per-object\r\n * overhead within a pool, except for alignment padding.  Each pool has a\r\n * header with a link to the next pool of the same class.\r\n * Small and large pool headers are identical except that the latter's\r\n * link pointer must be FAR on 80x86 machines.\r\n * Notice that the \"real\" header fields are union'ed with a dummy ALIGN_TYPE\r\n * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple\r\n * of the alignment requirement of ALIGN_TYPE.\r\n */\r\n\r\ntypedef union small_pool_struct * small_pool_ptr;\r\n\r\ntypedef union small_pool_struct {\r\n  struct {\r\n    small_pool_ptr next;\t/* next in list of pools */\r\n    size_t bytes_used;\t\t/* how many bytes already used within pool */\r\n    size_t bytes_left;\t\t/* bytes still available in this pool */\r\n  } hdr;\r\n  ALIGN_TYPE dummy;\t\t/* included in union to ensure alignment */\r\n} small_pool_hdr;\r\n\r\ntypedef union large_pool_struct FAR * large_pool_ptr;\r\n\r\ntypedef union large_pool_struct {\r\n  struct {\r\n    large_pool_ptr next;\t/* next in list of pools */\r\n    size_t bytes_used;\t\t/* how many bytes already used within pool */\r\n    size_t bytes_left;\t\t/* bytes still available in this pool */\r\n  } hdr;\r\n  ALIGN_TYPE dummy;\t\t/* included in union to ensure alignment */\r\n} large_pool_hdr;\r\n\r\n\r\n/*\r\n * Here is the full definition of a memory manager object.\r\n */\r\n\r\ntypedef struct {\r\n  struct jpeg_memory_mgr pub;\t/* public fields */\r\n\r\n  /* Each pool identifier (lifetime class) names a linked list of pools. */\r\n  small_pool_ptr small_list[JPOOL_NUMPOOLS];\r\n  large_pool_ptr large_list[JPOOL_NUMPOOLS];\r\n\r\n  /* Since we only have one lifetime class of virtual arrays, only one\r\n   * linked list is necessary (for each datatype).  Note that the virtual\r\n   * array control blocks being linked together are actually stored somewhere\r\n   * in the small-pool list.\r\n   */\r\n  jvirt_sarray_ptr virt_sarray_list;\r\n  jvirt_barray_ptr virt_barray_list;\r\n\r\n  /* This counts total space obtained from jpeg_get_small/large */\r\n  long total_space_allocated;\r\n\r\n  /* alloc_sarray and alloc_barray set this value for use by virtual\r\n   * array routines.\r\n   */\r\n  JDIMENSION last_rowsperchunk;\t/* from most recent alloc_sarray/barray */\r\n} my_memory_mgr;\r\n\r\ntypedef my_memory_mgr * my_mem_ptr;\r\n\r\n\r\n/*\r\n * The control blocks for virtual arrays.\r\n * Note that these blocks are allocated in the \"small\" pool area.\r\n * System-dependent info for the associated backing store (if any) is hidden\r\n * inside the backing_store_info struct.\r\n */\r\n\r\nstruct jvirt_sarray_control {\r\n  JSAMPARRAY mem_buffer;\t/* => the in-memory buffer */\r\n  JDIMENSION rows_in_array;\t/* total virtual array height */\r\n  JDIMENSION samplesperrow;\t/* width of array (and of memory buffer) */\r\n  JDIMENSION maxaccess;\t\t/* max rows accessed by access_virt_sarray */\r\n  JDIMENSION rows_in_mem;\t/* height of memory buffer */\r\n  JDIMENSION rowsperchunk;\t/* allocation chunk size in mem_buffer */\r\n  JDIMENSION cur_start_row;\t/* first logical row # in the buffer */\r\n  JDIMENSION first_undef_row;\t/* row # of first uninitialized row */\r\n  boolean pre_zero;\t\t/* pre-zero mode requested? */\r\n  boolean dirty;\t\t/* do current buffer contents need written? */\r\n  boolean b_s_open;\t\t/* is backing-store data valid? */\r\n  jvirt_sarray_ptr next;\t/* link to next virtual sarray control block */\r\n  backing_store_info b_s_info;\t/* System-dependent control info */\r\n};\r\n\r\nstruct jvirt_barray_control {\r\n  JBLOCKARRAY mem_buffer;\t/* => the in-memory buffer */\r\n  JDIMENSION rows_in_array;\t/* total virtual array height */\r\n  JDIMENSION blocksperrow;\t/* width of array (and of memory buffer) */\r\n  JDIMENSION maxaccess;\t\t/* max rows accessed by access_virt_barray */\r\n  JDIMENSION rows_in_mem;\t/* height of memory buffer */\r\n  JDIMENSION rowsperchunk;\t/* allocation chunk size in mem_buffer */\r\n  JDIMENSION cur_start_row;\t/* first logical row # in the buffer */\r\n  JDIMENSION first_undef_row;\t/* row # of first uninitialized row */\r\n  boolean pre_zero;\t\t/* pre-zero mode requested? */\r\n  boolean dirty;\t\t/* do current buffer contents need written? */\r\n  boolean b_s_open;\t\t/* is backing-store data valid? */\r\n  jvirt_barray_ptr next;\t/* link to next virtual barray control block */\r\n  backing_store_info b_s_info;\t/* System-dependent control info */\r\n};\r\n\r\n\r\n#ifdef MEM_STATS\t\t/* optional extra stuff for statistics */\r\n\r\nLOCAL(void)\r\nprint_mem_stats (j_common_ptr cinfo, int pool_id)\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  small_pool_ptr shdr_ptr;\r\n  large_pool_ptr lhdr_ptr;\r\n\r\n  /* Since this is only a debugging stub, we can cheat a little by using\r\n   * fprintf directly rather than going through the trace message code.\r\n   * This is helpful because message parm array can't handle longs.\r\n   */\r\n  fprintf(stderr, \"Freeing pool %d, total space = %ld\\n\",\r\n\t  pool_id, mem->total_space_allocated);\r\n\r\n  for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;\r\n       lhdr_ptr = lhdr_ptr->hdr.next) {\r\n    fprintf(stderr, \"  Large chunk used %ld\\n\",\r\n\t    (long) lhdr_ptr->hdr.bytes_used);\r\n  }\r\n\r\n  for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;\r\n       shdr_ptr = shdr_ptr->hdr.next) {\r\n    fprintf(stderr, \"  Small chunk used %ld free %ld\\n\",\r\n\t    (long) shdr_ptr->hdr.bytes_used,\r\n\t    (long) shdr_ptr->hdr.bytes_left);\r\n  }\r\n}\r\n\r\n#endif /* MEM_STATS */\r\n\r\n\r\nLOCAL(noreturn_t)\r\nout_of_memory (j_common_ptr cinfo, int which)\r\n/* Report an out-of-memory error and stop execution */\r\n/* If we compiled MEM_STATS support, report alloc requests before dying */\r\n{\r\n#ifdef MEM_STATS\r\n  cinfo->err->trace_level = 2;\t/* force self_destruct to report stats */\r\n#endif\r\n  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);\r\n}\r\n\r\n\r\n/*\r\n * Allocation of \"small\" objects.\r\n *\r\n * For these, we use pooled storage.  When a new pool must be created,\r\n * we try to get enough space for the current request plus a \"slop\" factor,\r\n * where the slop will be the amount of leftover space in the new pool.\r\n * The speed vs. space tradeoff is largely determined by the slop values.\r\n * A different slop value is provided for each pool class (lifetime),\r\n * and we also distinguish the first pool of a class from later ones.\r\n * NOTE: the values given work fairly well on both 16- and 32-bit-int\r\n * machines, but may be too small if longs are 64 bits or more.\r\n */\r\n\r\nstatic const size_t first_pool_slop[JPOOL_NUMPOOLS] = \r\n{\r\n\t1600,\t\t\t/* first PERMANENT pool */\r\n\t16000\t\t\t/* first IMAGE pool */\r\n};\r\n\r\nstatic const size_t extra_pool_slop[JPOOL_NUMPOOLS] = \r\n{\r\n\t0,\t\t\t/* additional PERMANENT pools */\r\n\t5000\t\t\t/* additional IMAGE pools */\r\n};\r\n\r\n#define MIN_SLOP  50\t\t/* greater than 0 to avoid futile looping */\r\n\r\n\r\nMETHODDEF(void *)\r\nalloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)\r\n/* Allocate a \"small\" object */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  small_pool_ptr hdr_ptr, prev_hdr_ptr;\r\n  char * data_ptr;\r\n  size_t odd_bytes, min_request, slop;\r\n\r\n  /* Check for unsatisfiable request (do now to ensure no overflow below) */\r\n  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))\r\n    out_of_memory(cinfo, 1);\t/* request exceeds malloc's ability */\r\n\r\n  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */\r\n  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);\r\n  if (odd_bytes > 0)\r\n    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;\r\n\r\n  /* See if space is available in any existing pool */\r\n  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)\r\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);\t/* safety check */\r\n  prev_hdr_ptr = NULL;\r\n  hdr_ptr = mem->small_list[pool_id];\r\n  while (hdr_ptr != NULL) {\r\n    if (hdr_ptr->hdr.bytes_left >= sizeofobject)\r\n      break;\t\t\t/* found pool with enough space */\r\n    prev_hdr_ptr = hdr_ptr;\r\n    hdr_ptr = hdr_ptr->hdr.next;\r\n  }\r\n\r\n  /* Time to make a new pool? */\r\n  if (hdr_ptr == NULL) {\r\n    /* min_request is what we need now, slop is what will be leftover */\r\n    min_request = sizeofobject + SIZEOF(small_pool_hdr);\r\n    if (prev_hdr_ptr == NULL)\t/* first pool in class? */\r\n      slop = first_pool_slop[pool_id];\r\n    else\r\n      slop = extra_pool_slop[pool_id];\r\n    /* Don't ask for more than MAX_ALLOC_CHUNK */\r\n    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))\r\n      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);\r\n    /* Try to get space, if fail reduce slop and try again */\r\n    for (;;) {\r\n      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);\r\n      if (hdr_ptr != NULL)\r\n\tbreak;\r\n      slop /= 2;\r\n      if (slop < MIN_SLOP)\t/* give up when it gets real small */\r\n\tout_of_memory(cinfo, 2); /* jpeg_get_small failed */\r\n    }\r\n    mem->total_space_allocated += min_request + slop;\r\n    /* Success, initialize the new pool header and add to end of list */\r\n    hdr_ptr->hdr.next = NULL;\r\n    hdr_ptr->hdr.bytes_used = 0;\r\n    hdr_ptr->hdr.bytes_left = sizeofobject + slop;\r\n    if (prev_hdr_ptr == NULL)\t/* first pool in class? */\r\n      mem->small_list[pool_id] = hdr_ptr;\r\n    else\r\n      prev_hdr_ptr->hdr.next = hdr_ptr;\r\n  }\r\n\r\n  /* OK, allocate the object from the current pool */\r\n  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */\r\n  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */\r\n  hdr_ptr->hdr.bytes_used += sizeofobject;\r\n  hdr_ptr->hdr.bytes_left -= sizeofobject;\r\n\r\n  return (void *) data_ptr;\r\n}\r\n\r\n\r\n/*\r\n * Allocation of \"large\" objects.\r\n *\r\n * The external semantics of these are the same as \"small\" objects,\r\n * except that FAR pointers are used on 80x86.  However the pool\r\n * management heuristics are quite different.  We assume that each\r\n * request is large enough that it may as well be passed directly to\r\n * jpeg_get_large; the pool management just links everything together\r\n * so that we can free it all on demand.\r\n * Note: the major use of \"large\" objects is in JSAMPARRAY and JBLOCKARRAY\r\n * structures.  The routines that create these structures (see below)\r\n * deliberately bunch rows together to ensure a large request size.\r\n */\r\n\r\nMETHODDEF(void FAR *)\r\nalloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)\r\n/* Allocate a \"large\" object */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  large_pool_ptr hdr_ptr;\r\n  size_t odd_bytes;\r\n\r\n  /* Check for unsatisfiable request (do now to ensure no overflow below) */\r\n  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))\r\n    out_of_memory(cinfo, 3);\t/* request exceeds malloc's ability */\r\n\r\n  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */\r\n  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);\r\n  if (odd_bytes > 0)\r\n    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;\r\n\r\n  /* Always make a new pool */\r\n  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)\r\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);\t/* safety check */\r\n\r\n  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +\r\n\t\t\t\t\t    SIZEOF(large_pool_hdr));\r\n  if (hdr_ptr == NULL)\r\n    out_of_memory(cinfo, 4);\t/* jpeg_get_large failed */\r\n  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);\r\n\r\n  /* Success, initialize the new pool header and add to list */\r\n  hdr_ptr->hdr.next = mem->large_list[pool_id];\r\n  /* We maintain space counts in each pool header for statistical purposes,\r\n   * even though they are not needed for allocation.\r\n   */\r\n  hdr_ptr->hdr.bytes_used = sizeofobject;\r\n  hdr_ptr->hdr.bytes_left = 0;\r\n  mem->large_list[pool_id] = hdr_ptr;\r\n\r\n  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */\r\n}\r\n\r\n\r\n/*\r\n * Creation of 2-D sample arrays.\r\n * The pointers are in near heap, the samples themselves in FAR heap.\r\n *\r\n * To minimize allocation overhead and to allow I/O of large contiguous\r\n * blocks, we allocate the sample rows in groups of as many rows as possible\r\n * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.\r\n * NB: the virtual array control routines, later in this file, know about\r\n * this chunking of rows.  The rowsperchunk value is left in the mem manager\r\n * object so that it can be saved away if this sarray is the workspace for\r\n * a virtual array.\r\n */\r\n\r\nMETHODDEF(JSAMPARRAY)\r\nalloc_sarray (j_common_ptr cinfo, int pool_id,\r\n\t      JDIMENSION samplesperrow, JDIMENSION numrows)\r\n/* Allocate a 2-D sample array */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  JSAMPARRAY result;\r\n  JSAMPROW workspace;\r\n  JDIMENSION rowsperchunk, currow, i;\r\n  long ltemp;\r\n\r\n  /* Calculate max # of rows allowed in one allocation chunk */\r\n  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /\r\n\t  ((long) samplesperrow * SIZEOF(JSAMPLE));\r\n  if (ltemp <= 0)\r\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\r\n  if (ltemp < (long) numrows)\r\n    rowsperchunk = (JDIMENSION) ltemp;\r\n  else\r\n    rowsperchunk = numrows;\r\n  mem->last_rowsperchunk = rowsperchunk;\r\n\r\n  /* Get space for row pointers (small object) */\r\n  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,\r\n\t\t\t\t    (size_t) (numrows * SIZEOF(JSAMPROW)));\r\n\r\n  /* Get the rows themselves (large objects) */\r\n  currow = 0;\r\n  while (currow < numrows) {\r\n    rowsperchunk = MIN(rowsperchunk, numrows - currow);\r\n    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,\r\n\t(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow\r\n\t\t  * SIZEOF(JSAMPLE)));\r\n    for (i = rowsperchunk; i > 0; i--) {\r\n      result[currow++] = workspace;\r\n      workspace += samplesperrow;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\n/*\r\n * Creation of 2-D coefficient-block arrays.\r\n * This is essentially the same as the code for sample arrays, above.\r\n */\r\n\r\nMETHODDEF(JBLOCKARRAY)\r\nalloc_barray (j_common_ptr cinfo, int pool_id,\r\n\t      JDIMENSION blocksperrow, JDIMENSION numrows)\r\n/* Allocate a 2-D coefficient-block array */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  JBLOCKARRAY result;\r\n  JBLOCKROW workspace;\r\n  JDIMENSION rowsperchunk, currow, i;\r\n  long ltemp;\r\n\r\n  /* Calculate max # of rows allowed in one allocation chunk */\r\n  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /\r\n\t  ((long) blocksperrow * SIZEOF(JBLOCK));\r\n  if (ltemp <= 0)\r\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\r\n  if (ltemp < (long) numrows)\r\n    rowsperchunk = (JDIMENSION) ltemp;\r\n  else\r\n    rowsperchunk = numrows;\r\n  mem->last_rowsperchunk = rowsperchunk;\r\n\r\n  /* Get space for row pointers (small object) */\r\n  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,\r\n\t\t\t\t     (size_t) (numrows * SIZEOF(JBLOCKROW)));\r\n\r\n  /* Get the rows themselves (large objects) */\r\n  currow = 0;\r\n  while (currow < numrows) {\r\n    rowsperchunk = MIN(rowsperchunk, numrows - currow);\r\n    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,\r\n\t(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow\r\n\t\t  * SIZEOF(JBLOCK)));\r\n    for (i = rowsperchunk; i > 0; i--) {\r\n      result[currow++] = workspace;\r\n      workspace += blocksperrow;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\n/*\r\n * About virtual array management:\r\n *\r\n * The above \"normal\" array routines are only used to allocate strip buffers\r\n * (as wide as the image, but just a few rows high).  Full-image-sized buffers\r\n * are handled as \"virtual\" arrays.  The array is still accessed a strip at a\r\n * time, but the memory manager must save the whole array for repeated\r\n * accesses.  The intended implementation is that there is a strip buffer in\r\n * memory (as high as is possible given the desired memory limit), plus a\r\n * backing file that holds the rest of the array.\r\n *\r\n * The request_virt_array routines are told the total size of the image and\r\n * the maximum number of rows that will be accessed at once.  The in-memory\r\n * buffer must be at least as large as the maxaccess value.\r\n *\r\n * The request routines create control blocks but not the in-memory buffers.\r\n * That is postponed until realize_virt_arrays is called.  At that time the\r\n * total amount of space needed is known (approximately, anyway), so free\r\n * memory can be divided up fairly.\r\n *\r\n * The access_virt_array routines are responsible for making a specific strip\r\n * area accessible (after reading or writing the backing file, if necessary).\r\n * Note that the access routines are told whether the caller intends to modify\r\n * the accessed strip; during a read-only pass this saves having to rewrite\r\n * data to disk.  The access routines are also responsible for pre-zeroing\r\n * any newly accessed rows, if pre-zeroing was requested.\r\n *\r\n * In current usage, the access requests are usually for nonoverlapping\r\n * strips; that is, successive access start_row numbers differ by exactly\r\n * num_rows = maxaccess.  This means we can get good performance with simple\r\n * buffer dump/reload logic, by making the in-memory buffer be a multiple\r\n * of the access height; then there will never be accesses across bufferload\r\n * boundaries.  The code will still work with overlapping access requests,\r\n * but it doesn't handle bufferload overlaps very efficiently.\r\n */\r\n\r\n\r\nMETHODDEF(jvirt_sarray_ptr)\r\nrequest_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,\r\n\t\t     JDIMENSION samplesperrow, JDIMENSION numrows,\r\n\t\t     JDIMENSION maxaccess)\r\n/* Request a virtual 2-D sample array */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  jvirt_sarray_ptr result;\r\n\r\n  /* Only IMAGE-lifetime virtual arrays are currently supported */\r\n  if (pool_id != JPOOL_IMAGE)\r\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);\t/* safety check */\r\n\r\n  /* get control block */\r\n  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,\r\n\t\t\t\t\t  SIZEOF(struct jvirt_sarray_control));\r\n\r\n  result->mem_buffer = NULL;\t/* marks array not yet realized */\r\n  result->rows_in_array = numrows;\r\n  result->samplesperrow = samplesperrow;\r\n  result->maxaccess = maxaccess;\r\n  result->pre_zero = pre_zero;\r\n  result->b_s_open = FALSE;\t/* no associated backing-store object */\r\n  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */\r\n  mem->virt_sarray_list = result;\r\n\r\n  return result;\r\n}\r\n\r\n\r\nMETHODDEF(jvirt_barray_ptr)\r\nrequest_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,\r\n\t\t     JDIMENSION blocksperrow, JDIMENSION numrows,\r\n\t\t     JDIMENSION maxaccess)\r\n/* Request a virtual 2-D coefficient-block array */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  jvirt_barray_ptr result;\r\n\r\n  /* Only IMAGE-lifetime virtual arrays are currently supported */\r\n  if (pool_id != JPOOL_IMAGE)\r\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);\t/* safety check */\r\n\r\n  /* get control block */\r\n  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,\r\n\t\t\t\t\t  SIZEOF(struct jvirt_barray_control));\r\n\r\n  result->mem_buffer = NULL;\t/* marks array not yet realized */\r\n  result->rows_in_array = numrows;\r\n  result->blocksperrow = blocksperrow;\r\n  result->maxaccess = maxaccess;\r\n  result->pre_zero = pre_zero;\r\n  result->b_s_open = FALSE;\t/* no associated backing-store object */\r\n  result->next = mem->virt_barray_list; /* add to list of virtual arrays */\r\n  mem->virt_barray_list = result;\r\n\r\n  return result;\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nrealize_virt_arrays (j_common_ptr cinfo)\r\n/* Allocate the in-memory buffers for any unrealized virtual arrays */\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  long space_per_minheight, maximum_space, avail_mem;\r\n  long minheights, max_minheights;\r\n  jvirt_sarray_ptr sptr;\r\n  jvirt_barray_ptr bptr;\r\n\r\n  /* Compute the minimum space needed (maxaccess rows in each buffer)\r\n   * and the maximum space needed (full image height in each buffer).\r\n   * These may be of use to the system-dependent jpeg_mem_available routine.\r\n   */\r\n  space_per_minheight = 0;\r\n  maximum_space = 0;\r\n  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {\r\n    if (sptr->mem_buffer == NULL) { /* if not realized yet */\r\n      space_per_minheight += (long) sptr->maxaccess *\r\n\t\t\t     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);\r\n      maximum_space += (long) sptr->rows_in_array *\r\n\t\t       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);\r\n    }\r\n  }\r\n  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {\r\n    if (bptr->mem_buffer == NULL) { /* if not realized yet */\r\n      space_per_minheight += (long) bptr->maxaccess *\r\n\t\t\t     (long) bptr->blocksperrow * SIZEOF(JBLOCK);\r\n      maximum_space += (long) bptr->rows_in_array *\r\n\t\t       (long) bptr->blocksperrow * SIZEOF(JBLOCK);\r\n    }\r\n  }\r\n\r\n  if (space_per_minheight <= 0)\r\n    return;\t\t\t/* no unrealized arrays, no work */\r\n\r\n  /* Determine amount of memory to actually use; this is system-dependent. */\r\n  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,\r\n\t\t\t\t mem->total_space_allocated);\r\n\r\n  /* If the maximum space needed is available, make all the buffers full\r\n   * height; otherwise parcel it out with the same number of minheights\r\n   * in each buffer.\r\n   */\r\n  if (avail_mem >= maximum_space)\r\n    max_minheights = 1000000000L;\r\n  else {\r\n    max_minheights = avail_mem / space_per_minheight;\r\n    /* If there doesn't seem to be enough space, try to get the minimum\r\n     * anyway.  This allows a \"stub\" implementation of jpeg_mem_available().\r\n     */\r\n    if (max_minheights <= 0)\r\n      max_minheights = 1;\r\n  }\r\n\r\n  /* Allocate the in-memory buffers and initialize backing store as needed. */\r\n\r\n  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {\r\n    if (sptr->mem_buffer == NULL) { /* if not realized yet */\r\n      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;\r\n      if (minheights <= max_minheights) {\r\n\t/* This buffer fits in memory */\r\n\tsptr->rows_in_mem = sptr->rows_in_array;\r\n      } else {\r\n\t/* It doesn't fit in memory, create backing store. */\r\n\tsptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);\r\n\tjpeg_open_backing_store(cinfo, & sptr->b_s_info,\r\n\t\t\t\t(long) sptr->rows_in_array *\r\n\t\t\t\t(long) sptr->samplesperrow *\r\n\t\t\t\t(long) SIZEOF(JSAMPLE));\r\n\tsptr->b_s_open = TRUE;\r\n      }\r\n      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,\r\n\t\t\t\t      sptr->samplesperrow, sptr->rows_in_mem);\r\n      sptr->rowsperchunk = mem->last_rowsperchunk;\r\n      sptr->cur_start_row = 0;\r\n      sptr->first_undef_row = 0;\r\n      sptr->dirty = FALSE;\r\n    }\r\n  }\r\n\r\n  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {\r\n    if (bptr->mem_buffer == NULL) { /* if not realized yet */\r\n      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;\r\n      if (minheights <= max_minheights) {\r\n\t/* This buffer fits in memory */\r\n\tbptr->rows_in_mem = bptr->rows_in_array;\r\n      } else {\r\n\t/* It doesn't fit in memory, create backing store. */\r\n\tbptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);\r\n\tjpeg_open_backing_store(cinfo, & bptr->b_s_info,\r\n\t\t\t\t(long) bptr->rows_in_array *\r\n\t\t\t\t(long) bptr->blocksperrow *\r\n\t\t\t\t(long) SIZEOF(JBLOCK));\r\n\tbptr->b_s_open = TRUE;\r\n      }\r\n      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,\r\n\t\t\t\t      bptr->blocksperrow, bptr->rows_in_mem);\r\n      bptr->rowsperchunk = mem->last_rowsperchunk;\r\n      bptr->cur_start_row = 0;\r\n      bptr->first_undef_row = 0;\r\n      bptr->dirty = FALSE;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\ndo_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)\r\n/* Do backing store read or write of a virtual sample array */\r\n{\r\n  long bytesperrow, file_offset, byte_count, rows, thisrow, i;\r\n\r\n  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);\r\n  file_offset = ptr->cur_start_row * bytesperrow;\r\n  /* Loop to read or write each allocation chunk in mem_buffer */\r\n  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {\r\n    /* One chunk, but check for short chunk at end of buffer */\r\n    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);\r\n    /* Transfer no more than is currently defined */\r\n    thisrow = (long) ptr->cur_start_row + i;\r\n    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);\r\n    /* Transfer no more than fits in file */\r\n    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);\r\n    if (rows <= 0)\t\t/* this chunk might be past end of file! */\r\n      break;\r\n    byte_count = rows * bytesperrow;\r\n    if (writing)\r\n      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,\r\n\t\t\t\t\t    (void FAR *) ptr->mem_buffer[i],\r\n\t\t\t\t\t    file_offset, byte_count);\r\n    else\r\n      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,\r\n\t\t\t\t\t   (void FAR *) ptr->mem_buffer[i],\r\n\t\t\t\t\t   file_offset, byte_count);\r\n    file_offset += byte_count;\r\n  }\r\n}\r\n\r\n\r\nLOCAL(void)\r\ndo_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)\r\n/* Do backing store read or write of a virtual coefficient-block array */\r\n{\r\n  long bytesperrow, file_offset, byte_count, rows, thisrow, i;\r\n\r\n  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);\r\n  file_offset = ptr->cur_start_row * bytesperrow;\r\n  /* Loop to read or write each allocation chunk in mem_buffer */\r\n  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {\r\n    /* One chunk, but check for short chunk at end of buffer */\r\n    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);\r\n    /* Transfer no more than is currently defined */\r\n    thisrow = (long) ptr->cur_start_row + i;\r\n    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);\r\n    /* Transfer no more than fits in file */\r\n    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);\r\n    if (rows <= 0)\t\t/* this chunk might be past end of file! */\r\n      break;\r\n    byte_count = rows * bytesperrow;\r\n    if (writing)\r\n      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,\r\n\t\t\t\t\t    (void FAR *) ptr->mem_buffer[i],\r\n\t\t\t\t\t    file_offset, byte_count);\r\n    else\r\n      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,\r\n\t\t\t\t\t   (void FAR *) ptr->mem_buffer[i],\r\n\t\t\t\t\t   file_offset, byte_count);\r\n    file_offset += byte_count;\r\n  }\r\n}\r\n\r\n\r\nMETHODDEF(JSAMPARRAY)\r\naccess_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,\r\n\t\t    JDIMENSION start_row, JDIMENSION num_rows,\r\n\t\t    boolean writable)\r\n/* Access the part of a virtual sample array starting at start_row */\r\n/* and extending for num_rows rows.  writable is true if  */\r\n/* caller intends to modify the accessed area. */\r\n{\r\n  JDIMENSION end_row = start_row + num_rows;\r\n  JDIMENSION undef_row;\r\n\r\n  /* debugging check */\r\n  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||\r\n      ptr->mem_buffer == NULL)\r\n    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\r\n\r\n  /* Make the desired part of the virtual array accessible */\r\n  if (start_row < ptr->cur_start_row ||\r\n      end_row > ptr->cur_start_row+ptr->rows_in_mem) {\r\n    if (! ptr->b_s_open)\r\n      ERREXIT(cinfo, JERR_VIRTUAL_BUG);\r\n    /* Flush old buffer contents if necessary */\r\n    if (ptr->dirty) {\r\n      do_sarray_io(cinfo, ptr, TRUE);\r\n      ptr->dirty = FALSE;\r\n    }\r\n    /* Decide what part of virtual array to access.\r\n     * Algorithm: if target address > current window, assume forward scan,\r\n     * load starting at target address.  If target address < current window,\r\n     * assume backward scan, load so that target area is top of window.\r\n     * Note that when switching from forward write to forward read, will have\r\n     * start_row = 0, so the limiting case applies and we load from 0 anyway.\r\n     */\r\n    if (start_row > ptr->cur_start_row) {\r\n      ptr->cur_start_row = start_row;\r\n    } else {\r\n      /* use long arithmetic here to avoid overflow & unsigned problems */\r\n      long ltemp;\r\n\r\n      ltemp = (long) end_row - (long) ptr->rows_in_mem;\r\n      if (ltemp < 0)\r\n\tltemp = 0;\t\t/* don't fall off front end of file */\r\n      ptr->cur_start_row = (JDIMENSION) ltemp;\r\n    }\r\n    /* Read in the selected part of the array.\r\n     * During the initial write pass, we will do no actual read\r\n     * because the selected part is all undefined.\r\n     */\r\n    do_sarray_io(cinfo, ptr, FALSE);\r\n  }\r\n  /* Ensure the accessed part of the array is defined; prezero if needed.\r\n   * To improve locality of access, we only prezero the part of the array\r\n   * that the caller is about to access, not the entire in-memory array.\r\n   */\r\n  if (ptr->first_undef_row < end_row) {\r\n    if (ptr->first_undef_row < start_row) {\r\n      if (writable)\t\t/* writer skipped over a section of array */\r\n\tERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\r\n      undef_row = start_row;\t/* but reader is allowed to read ahead */\r\n    } else {\r\n      undef_row = ptr->first_undef_row;\r\n    }\r\n    if (writable)\r\n      ptr->first_undef_row = end_row;\r\n    if (ptr->pre_zero) {\r\n      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);\r\n      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */\r\n      end_row -= ptr->cur_start_row;\r\n      while (undef_row < end_row) {\r\n\tFMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);\r\n\tundef_row++;\r\n      }\r\n    } else {\r\n      if (! writable)\t\t/* reader looking at undefined data */\r\n\tERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\r\n    }\r\n  }\r\n  /* Flag the buffer dirty if caller will write in it */\r\n  if (writable)\r\n    ptr->dirty = TRUE;\r\n  /* Return address of proper part of the buffer */\r\n  return ptr->mem_buffer + (start_row - ptr->cur_start_row);\r\n}\r\n\r\n\r\nMETHODDEF(JBLOCKARRAY)\r\naccess_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,\r\n\t\t    JDIMENSION start_row, JDIMENSION num_rows,\r\n\t\t    boolean writable)\r\n/* Access the part of a virtual block array starting at start_row */\r\n/* and extending for num_rows rows.  writable is true if  */\r\n/* caller intends to modify the accessed area. */\r\n{\r\n  JDIMENSION end_row = start_row + num_rows;\r\n  JDIMENSION undef_row;\r\n\r\n  /* debugging check */\r\n  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||\r\n      ptr->mem_buffer == NULL)\r\n    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\r\n\r\n  /* Make the desired part of the virtual array accessible */\r\n  if (start_row < ptr->cur_start_row ||\r\n      end_row > ptr->cur_start_row+ptr->rows_in_mem) {\r\n    if (! ptr->b_s_open)\r\n      ERREXIT(cinfo, JERR_VIRTUAL_BUG);\r\n    /* Flush old buffer contents if necessary */\r\n    if (ptr->dirty) {\r\n      do_barray_io(cinfo, ptr, TRUE);\r\n      ptr->dirty = FALSE;\r\n    }\r\n    /* Decide what part of virtual array to access.\r\n     * Algorithm: if target address > current window, assume forward scan,\r\n     * load starting at target address.  If target address < current window,\r\n     * assume backward scan, load so that target area is top of window.\r\n     * Note that when switching from forward write to forward read, will have\r\n     * start_row = 0, so the limiting case applies and we load from 0 anyway.\r\n     */\r\n    if (start_row > ptr->cur_start_row) {\r\n      ptr->cur_start_row = start_row;\r\n    } else {\r\n      /* use long arithmetic here to avoid overflow & unsigned problems */\r\n      long ltemp;\r\n\r\n      ltemp = (long) end_row - (long) ptr->rows_in_mem;\r\n      if (ltemp < 0)\r\n\tltemp = 0;\t\t/* don't fall off front end of file */\r\n      ptr->cur_start_row = (JDIMENSION) ltemp;\r\n    }\r\n    /* Read in the selected part of the array.\r\n     * During the initial write pass, we will do no actual read\r\n     * because the selected part is all undefined.\r\n     */\r\n    do_barray_io(cinfo, ptr, FALSE);\r\n  }\r\n  /* Ensure the accessed part of the array is defined; prezero if needed.\r\n   * To improve locality of access, we only prezero the part of the array\r\n   * that the caller is about to access, not the entire in-memory array.\r\n   */\r\n  if (ptr->first_undef_row < end_row) {\r\n    if (ptr->first_undef_row < start_row) {\r\n      if (writable)\t\t/* writer skipped over a section of array */\r\n\tERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\r\n      undef_row = start_row;\t/* but reader is allowed to read ahead */\r\n    } else {\r\n      undef_row = ptr->first_undef_row;\r\n    }\r\n    if (writable)\r\n      ptr->first_undef_row = end_row;\r\n    if (ptr->pre_zero) {\r\n      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);\r\n      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */\r\n      end_row -= ptr->cur_start_row;\r\n      while (undef_row < end_row) {\r\n\tFMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);\r\n\tundef_row++;\r\n      }\r\n    } else {\r\n      if (! writable)\t\t/* reader looking at undefined data */\r\n\tERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\r\n    }\r\n  }\r\n  /* Flag the buffer dirty if caller will write in it */\r\n  if (writable)\r\n    ptr->dirty = TRUE;\r\n  /* Return address of proper part of the buffer */\r\n  return ptr->mem_buffer + (start_row - ptr->cur_start_row);\r\n}\r\n\r\n\r\n/*\r\n * Release all objects belonging to a specified pool.\r\n */\r\n\r\nMETHODDEF(void)\r\nfree_pool (j_common_ptr cinfo, int pool_id)\r\n{\r\n  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;\r\n  small_pool_ptr shdr_ptr;\r\n  large_pool_ptr lhdr_ptr;\r\n  size_t space_freed;\r\n\r\n  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)\r\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);\t/* safety check */\r\n\r\n#ifdef MEM_STATS\r\n  if (cinfo->err->trace_level > 1)\r\n    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */\r\n#endif\r\n\r\n  /* If freeing IMAGE pool, close any virtual arrays first */\r\n  if (pool_id == JPOOL_IMAGE) {\r\n    jvirt_sarray_ptr sptr;\r\n    jvirt_barray_ptr bptr;\r\n\r\n    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {\r\n      if (sptr->b_s_open) {\t/* there may be no backing store */\r\n\tsptr->b_s_open = FALSE;\t/* prevent recursive close if error */\r\n\t(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);\r\n      }\r\n    }\r\n    mem->virt_sarray_list = NULL;\r\n    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {\r\n      if (bptr->b_s_open) {\t/* there may be no backing store */\r\n\tbptr->b_s_open = FALSE;\t/* prevent recursive close if error */\r\n\t(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);\r\n      }\r\n    }\r\n    mem->virt_barray_list = NULL;\r\n  }\r\n\r\n  /* Release large objects */\r\n  lhdr_ptr = mem->large_list[pool_id];\r\n  mem->large_list[pool_id] = NULL;\r\n\r\n  while (lhdr_ptr != NULL) {\r\n    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;\r\n    space_freed = lhdr_ptr->hdr.bytes_used +\r\n\t\t  lhdr_ptr->hdr.bytes_left +\r\n\t\t  SIZEOF(large_pool_hdr);\r\n    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);\r\n    mem->total_space_allocated -= space_freed;\r\n    lhdr_ptr = next_lhdr_ptr;\r\n  }\r\n\r\n  /* Release small objects */\r\n  shdr_ptr = mem->small_list[pool_id];\r\n  mem->small_list[pool_id] = NULL;\r\n\r\n  while (shdr_ptr != NULL) {\r\n    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;\r\n    space_freed = shdr_ptr->hdr.bytes_used +\r\n\t\t  shdr_ptr->hdr.bytes_left +\r\n\t\t  SIZEOF(small_pool_hdr);\r\n    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);\r\n    mem->total_space_allocated -= space_freed;\r\n    shdr_ptr = next_shdr_ptr;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Close up shop entirely.\r\n * Note that this cannot be called unless cinfo->mem is non-NULL.\r\n */\r\n\r\nMETHODDEF(void)\r\nself_destruct (j_common_ptr cinfo)\r\n{\r\n  int pool;\r\n\r\n  /* Close all backing store, release all memory.\r\n   * Releasing pools in reverse order might help avoid fragmentation\r\n   * with some (brain-damaged) malloc libraries.\r\n   */\r\n  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {\r\n    free_pool(cinfo, pool);\r\n  }\r\n\r\n  /* Release the memory manager control block too. */\r\n  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));\r\n  cinfo->mem = NULL;\t\t/* ensures I will be called only once */\r\n\r\n  jpeg_mem_term(cinfo);\t\t/* system-dependent cleanup */\r\n}\r\n\r\n\r\n/*\r\n * Memory manager initialization.\r\n * When this is called, only the error manager pointer is valid in cinfo!\r\n */\r\n\r\nGLOBAL(void)\r\njinit_memory_mgr (j_common_ptr cinfo)\r\n{\r\n  my_mem_ptr mem;\r\n  long max_to_use;\r\n  int pool;\r\n  size_t test_mac;\r\n\r\n  cinfo->mem = NULL;\t\t/* for safety if init fails */\r\n\r\n  /* Check for configuration errors.\r\n   * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably\r\n   * doesn't reflect any real hardware alignment requirement.\r\n   * The test is a little tricky: for X>0, X and X-1 have no one-bits\r\n   * in common if and only if X is a power of 2, ie has only one one-bit.\r\n   * Some compilers may give an \"unreachable code\" warning here; ignore it.\r\n   */\r\n  if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)\r\n    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);\r\n  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be\r\n   * a multiple of SIZEOF(ALIGN_TYPE).\r\n   * Again, an \"unreachable code\" warning may be ignored here.\r\n   * But a \"constant too large\" warning means you need to fix MAX_ALLOC_CHUNK.\r\n   */\r\n  test_mac = (size_t) MAX_ALLOC_CHUNK;\r\n  if ((long) test_mac != MAX_ALLOC_CHUNK ||\r\n      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)\r\n    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);\r\n\r\n  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */\r\n\r\n  /* Attempt to allocate memory manager's control block */\r\n  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));\r\n\r\n  if (mem == NULL) {\r\n    jpeg_mem_term(cinfo);\t/* system-dependent cleanup */\r\n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);\r\n  }\r\n\r\n  /* OK, fill in the method pointers */\r\n  mem->pub.alloc_small = alloc_small;\r\n  mem->pub.alloc_large = alloc_large;\r\n  mem->pub.alloc_sarray = alloc_sarray;\r\n  mem->pub.alloc_barray = alloc_barray;\r\n  mem->pub.request_virt_sarray = request_virt_sarray;\r\n  mem->pub.request_virt_barray = request_virt_barray;\r\n  mem->pub.realize_virt_arrays = realize_virt_arrays;\r\n  mem->pub.access_virt_sarray = access_virt_sarray;\r\n  mem->pub.access_virt_barray = access_virt_barray;\r\n  mem->pub.free_pool = free_pool;\r\n  mem->pub.self_destruct = self_destruct;\r\n\r\n  /* Make MAX_ALLOC_CHUNK accessible to other modules */\r\n  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;\r\n\r\n  /* Initialize working state */\r\n  mem->pub.max_memory_to_use = max_to_use;\r\n\r\n  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {\r\n    mem->small_list[pool] = NULL;\r\n    mem->large_list[pool] = NULL;\r\n  }\r\n  mem->virt_sarray_list = NULL;\r\n  mem->virt_barray_list = NULL;\r\n\r\n  mem->total_space_allocated = SIZEOF(my_memory_mgr);\r\n\r\n  /* Declare ourselves open for business */\r\n  cinfo->mem = & mem->pub;\r\n\r\n  /* Check for an environment variable JPEGMEM; if found, override the\r\n   * default max_memory setting from jpeg_mem_init.  Note that the\r\n   * surrounding application may again override this value.\r\n   * If your system doesn't support getenv(), define NO_GETENV to disable\r\n   * this feature.\r\n   */\r\n#ifndef NO_GETENV\r\n  { char * memenv;\r\n\r\n    if ((memenv = getenv(\"JPEGMEM\")) != NULL) {\r\n      char ch = 'x';\r\n\r\n      if (sscanf(memenv, \"%ld%c\", &max_to_use, &ch) > 0) {\r\n\tif (ch == 'm' || ch == 'M')\r\n\t  max_to_use *= 1000L;\r\n\tmem->pub.max_memory_to_use = max_to_use * 1000L;\r\n      }\r\n    }\r\n  }\r\n#endif\r\n\r\n}\r\n","/*\r\n * jmemansi.c\r\n *\r\n * Copyright (C) 1992-1996, Thomas G. Lane.\r\n * This file is part of the Independent JPEG Group's software.\r\n * For conditions of distribution and use, see the accompanying README file.\r\n *\r\n * This file provides a simple generic implementation of the system-\r\n * dependent portion of the JPEG memory manager.  This implementation\r\n * assumes that you have the ANSI-standard library routine tmpfile().\r\n * Also, the problem of determining the amount of memory available\r\n * is shoved onto the user.\r\n */\r\n\r\n#define JPEG_INTERNALS\r\n#include \"jinclude.h\"\r\n#include \"jpeglib.h\"\r\n#include \"jmemsys.h\"\t\t/* import the system-dependent declarations */\r\n\r\n#ifndef HAVE_STDLIB_H\t\t/* <stdlib.h> should declare malloc(),free() */\r\nextern void * malloc JPP((size_t size));\r\nextern void free JPP((void *ptr));\r\n#endif\r\n\r\n#ifndef SEEK_SET\t\t/* pre-ANSI systems may not define this; */\r\n#define SEEK_SET  0\t\t/* if not, assume 0 is correct */\r\n#endif\r\n\r\n\r\n/*\r\n * Memory allocation and freeing are controlled by the regular library\r\n * routines malloc() and free().\r\n */\r\n\r\nGLOBAL(void *)\r\njpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)\r\n{\r\n  return (void *) malloc(sizeofobject);\r\n}\r\n\r\nGLOBAL(void)\r\njpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)\r\n{\r\n  free(object);\r\n}\r\n\r\n\r\n/*\r\n * \"Large\" objects are treated the same as \"small\" ones.\r\n * NB: although we include FAR keywords in the routine declarations,\r\n * this file won't actually work in 80x86 small/medium model; at least,\r\n * you probably won't be able to process useful-size images in only 64KB.\r\n */\r\n\r\nGLOBAL(void FAR *)\r\njpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)\r\n{\r\n  return (void FAR *) malloc(sizeofobject);\r\n}\r\n\r\nGLOBAL(void)\r\njpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)\r\n{\r\n  free(object);\r\n}\r\n\r\n\r\n/*\r\n * This routine computes the total memory space available for allocation.\r\n * It's impossible to do this in a portable way; our current solution is\r\n * to make the user tell us (with a default value set at compile time).\r\n * If you can actually get the available space, it's a good idea to subtract\r\n * a slop factor of 5% or so.\r\n */\r\n\r\n#ifndef DEFAULT_MAX_MEM\t\t/* so can override from makefile */\r\n#define DEFAULT_MAX_MEM\t\t1000000L /* default: one megabyte */\r\n#endif\r\n\r\nGLOBAL(long)\r\njpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,\r\n\t\t    long max_bytes_needed, long already_allocated)\r\n{\r\n  return cinfo->mem->max_memory_to_use - already_allocated;\r\n}\r\n\r\n\r\n/*\r\n * Backing store (temporary file) management.\r\n * Backing store objects are only used when the value returned by\r\n * jpeg_mem_available is less than the total space needed.  You can dispense\r\n * with these routines if you have plenty of virtual memory; see jmemnobs.c.\r\n */\r\n\r\n\r\nMETHODDEF(void)\r\nread_backing_store (j_common_ptr cinfo, backing_store_ptr info,\r\n\t\t    void FAR * buffer_address,\r\n\t\t    long file_offset, long byte_count)\r\n{\r\n  if (fseek(info->temp_file, file_offset, SEEK_SET))\r\n    ERREXIT(cinfo, JERR_TFILE_SEEK);\r\n  if (JFREAD(info->temp_file, buffer_address, byte_count)\r\n      != (size_t) byte_count)\r\n    ERREXIT(cinfo, JERR_TFILE_READ);\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nwrite_backing_store (j_common_ptr cinfo, backing_store_ptr info,\r\n\t\t     void FAR * buffer_address,\r\n\t\t     long file_offset, long byte_count)\r\n{\r\n  if (fseek(info->temp_file, file_offset, SEEK_SET))\r\n    ERREXIT(cinfo, JERR_TFILE_SEEK);\r\n  if (JFWRITE(info->temp_file, buffer_address, byte_count)\r\n      != (size_t) byte_count)\r\n    ERREXIT(cinfo, JERR_TFILE_WRITE);\r\n}\r\n\r\n\r\nMETHODDEF(void)\r\nclose_backing_store (j_common_ptr cinfo, backing_store_ptr info)\r\n{\r\n  fclose(info->temp_file);\r\n  /* Since this implementation uses tmpfile() to create the file,\r\n   * no explicit file deletion is needed.\r\n   */\r\n}\r\n\r\n\r\n/*\r\n * Initial opening of a backing-store object.\r\n *\r\n * This version uses tmpfile(), which constructs a suitable file name\r\n * behind the scenes.  We don't have to use info->temp_name[] at all;\r\n * indeed, we can't even find out the actual name of the temp file.\r\n */\r\n\r\nGLOBAL(void)\r\njpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,\r\n\t\t\t long total_bytes_needed)\r\n{\r\n  if ((info->temp_file = tmpfile()) == NULL)\r\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"\");\r\n  info->read_backing_store = read_backing_store;\r\n  info->write_backing_store = write_backing_store;\r\n  info->close_backing_store = close_backing_store;\r\n}\r\n\r\n\r\n/*\r\n * These routines take care of any system-dependent initialization and\r\n * cleanup required.\r\n */\r\n\r\nGLOBAL(long)\r\njpeg_mem_init (j_common_ptr cinfo)\r\n{\r\n  return DEFAULT_MAX_MEM;\t/* default for max_memory_to_use */\r\n}\r\n\r\nGLOBAL(void)\r\njpeg_mem_term (j_common_ptr cinfo)\r\n{\r\n  /* no work */\r\n}\r\n","\r\n/* png.c - location for general purpose libpng functions\r\n *\r\n * Last changed in libpng 1.6.9 [February 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n/* Generate a compiler error if there is an old png.h in the search path. */\r\ntypedef png_libpng_version_1_6_10 Your_png_h_is_not_version_1_6_10;\r\n\r\n/* Tells libpng that we have already handled the first \"num_bytes\" bytes\r\n * of the PNG file signature.  If the PNG data is embedded into another\r\n * stream we can set num_bytes = 8 so that libpng will not attempt to read\r\n * or write any of the magic bytes before it starts on the IHDR.\r\n */\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sig_bytes(png_structrp png_ptr, int num_bytes)\r\n{\r\n   png_debug(1, \"in png_set_sig_bytes\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   if (num_bytes > 8)\r\n      png_error(png_ptr, \"Too many bytes for PNG signature\");\r\n\r\n   png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);\r\n}\r\n\r\n/* Checks whether the supplied bytes match the PNG signature.  We allow\r\n * checking less than the full 8-byte signature so that those apps that\r\n * already read the first few bytes of a file to determine the file type\r\n * can simply check the remaining bytes for extra assurance.  Returns\r\n * an integer less than, equal to, or greater than zero if sig is found,\r\n * respectively, to be less than, to match, or be greater than the correct\r\n * PNG signature (this is the same behavior as strcmp, memcmp, etc).\r\n */\r\nint PNGAPI\r\npng_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)\r\n{\r\n   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\r\n\r\n   if (num_to_check > 8)\r\n      num_to_check = 8;\r\n\r\n   else if (num_to_check < 1)\r\n      return (-1);\r\n\r\n   if (start > 7)\r\n      return (-1);\r\n\r\n   if (start + num_to_check > 8)\r\n      num_to_check = 8 - start;\r\n\r\n   return ((int)(memcmp(&sig[start], &png_signature[start], num_to_check)));\r\n}\r\n\r\n#endif /* PNG_READ_SUPPORTED */\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n/* Function to allocate memory for zlib */\r\nPNG_FUNCTION(voidpf /* PRIVATE */,\r\npng_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)\r\n{\r\n   png_alloc_size_t num_bytes = size;\r\n\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   if (items >= (~(png_alloc_size_t)0)/size)\r\n   {\r\n      png_warning (png_voidcast(png_structrp, png_ptr),\r\n         \"Potential overflow in png_zalloc()\");\r\n      return NULL;\r\n   }\r\n\r\n   num_bytes *= items;\r\n   return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);\r\n}\r\n\r\n/* Function to free memory for zlib */\r\nvoid /* PRIVATE */\r\npng_zfree(voidpf png_ptr, voidpf ptr)\r\n{\r\n   png_free(png_voidcast(png_const_structrp,png_ptr), ptr);\r\n}\r\n\r\n/* Reset the CRC variable to 32 bits of 1's.  Care must be taken\r\n * in case CRC is > 32 bits to leave the top bits 0.\r\n */\r\nvoid /* PRIVATE */\r\npng_reset_crc(png_structrp png_ptr)\r\n{\r\n   /* The cast is safe because the crc is a 32 bit value. */\r\n   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);\r\n}\r\n\r\n/* Calculate the CRC over a section of data.  We can only pass as\r\n * much data to this routine as the largest single buffer size.  We\r\n * also check that this data will actually be used before going to the\r\n * trouble of calculating it.\r\n */\r\nvoid /* PRIVATE */\r\npng_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, png_size_t length)\r\n{\r\n   int need_crc = 1;\r\n\r\n   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name))\r\n   {\r\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\r\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\r\n         need_crc = 0;\r\n   }\r\n\r\n   else /* critical */\r\n   {\r\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\r\n         need_crc = 0;\r\n   }\r\n\r\n   /* 'uLong' is defined in zlib.h as unsigned long; this means that on some\r\n    * systems it is a 64 bit value.  crc32, however, returns 32 bits so the\r\n    * following cast is safe.  'uInt' may be no more than 16 bits, so it is\r\n    * necessary to perform a loop here.\r\n    */\r\n   if (need_crc && length > 0)\r\n   {\r\n      uLong crc = png_ptr->crc; /* Should never issue a warning */\r\n\r\n      do\r\n      {\r\n         uInt safe_length = (uInt)length;\r\n         if (safe_length == 0)\r\n            safe_length = (uInt)-1; /* evil, but safe */\r\n\r\n         crc = crc32(crc, ptr, safe_length);\r\n\r\n         /* The following should never issue compiler warnings; if they do the\r\n          * target system has characteristics that will probably violate other\r\n          * assumptions within the libpng code.\r\n          */\r\n         ptr += safe_length;\r\n         length -= safe_length;\r\n      }\r\n      while (length > 0);\r\n\r\n      /* And the following is always safe because the crc is only 32 bits. */\r\n      png_ptr->crc = (png_uint_32)crc;\r\n   }\r\n}\r\n\r\n/* Check a user supplied version number, called from both read and write\r\n * functions that create a png_struct.\r\n */\r\nint\r\npng_user_version_check(png_structrp png_ptr, png_const_charp user_png_ver)\r\n{\r\n   if (user_png_ver)\r\n   {\r\n      int i = 0;\r\n\r\n      do\r\n      {\r\n         if (user_png_ver[i] != png_libpng_ver[i])\r\n            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\r\n      } while (png_libpng_ver[i++]);\r\n   }\r\n\r\n   else\r\n      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\r\n\r\n   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)\r\n   {\r\n     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so\r\n      * we must recompile any applications that use any older library version.\r\n      * For versions after libpng 1.0, we will be compatible, so we need\r\n      * only check the first and third digits (note that when we reach version\r\n      * 1.10 we will need to check the fourth symbol, namely user_png_ver[3]).\r\n      */\r\n      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||\r\n          (user_png_ver[0] == '1' && (user_png_ver[2] != png_libpng_ver[2] ||\r\n          user_png_ver[3] != png_libpng_ver[3])) ||\r\n          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))\r\n      {\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\n         size_t pos = 0;\r\n         char m[128];\r\n\r\n         pos = png_safecat(m, (sizeof m), pos,\r\n             \"Application built with libpng-\");\r\n         pos = png_safecat(m, (sizeof m), pos, user_png_ver);\r\n         pos = png_safecat(m, (sizeof m), pos, \" but running with \");\r\n         pos = png_safecat(m, (sizeof m), pos, png_libpng_ver);\r\n         PNG_UNUSED(pos)\r\n\r\n         png_warning(png_ptr, m);\r\n#endif\r\n\r\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\r\n         png_ptr->flags = 0;\r\n#endif\r\n\r\n         return 0;\r\n      }\r\n   }\r\n\r\n   /* Success return. */\r\n   return 1;\r\n}\r\n\r\n/* Generic function to create a png_struct for either read or write - this\r\n * contains the common initialization.\r\n */\r\nPNG_FUNCTION(png_structp /* PRIVATE */,\r\npng_create_png_struct,(png_const_charp user_png_ver, png_voidp error_ptr,\r\n    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,\r\n    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)\r\n{\r\n   png_struct create_struct;\r\n#  ifdef PNG_SETJMP_SUPPORTED\r\n      jmp_buf create_jmp_buf;\r\n#  endif\r\n\r\n   /* This temporary stack-allocated structure is used to provide a place to\r\n    * build enough context to allow the user provided memory allocator (if any)\r\n    * to be called.\r\n    */\r\n   memset(&create_struct, 0, (sizeof create_struct));\r\n\r\n   /* Added at libpng-1.2.6 */\r\n#  ifdef PNG_USER_LIMITS_SUPPORTED\r\n      create_struct.user_width_max = PNG_USER_WIDTH_MAX;\r\n      create_struct.user_height_max = PNG_USER_HEIGHT_MAX;\r\n\r\n#     ifdef PNG_USER_CHUNK_CACHE_MAX\r\n         /* Added at libpng-1.2.43 and 1.4.0 */\r\n         create_struct.user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;\r\n#     endif\r\n\r\n#     ifdef PNG_USER_CHUNK_MALLOC_MAX\r\n         /* Added at libpng-1.2.43 and 1.4.1, required only for read but exists\r\n          * in png_struct regardless.\r\n          */\r\n         create_struct.user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;\r\n#     endif\r\n#  endif\r\n\r\n   /* The following two API calls simply set fields in png_struct, so it is safe\r\n    * to do them now even though error handling is not yet set up.\r\n    */\r\n#  ifdef PNG_USER_MEM_SUPPORTED\r\n      png_set_mem_fn(&create_struct, mem_ptr, malloc_fn, free_fn);\r\n#  else\r\n      PNG_UNUSED(mem_ptr)\r\n      PNG_UNUSED(malloc_fn)\r\n      PNG_UNUSED(free_fn)\r\n#  endif\r\n\r\n   /* (*error_fn) can return control to the caller after the error_ptr is set,\r\n    * this will result in a memory leak unless the error_fn does something\r\n    * extremely sophisticated.  The design lacks merit but is implicit in the\r\n    * API.\r\n    */\r\n   png_set_error_fn(&create_struct, error_ptr, error_fn, warn_fn);\r\n\r\n#  ifdef PNG_SETJMP_SUPPORTED\r\n      if (!setjmp(create_jmp_buf))\r\n      {\r\n         /* Temporarily fake out the longjmp information until we have\r\n          * successfully completed this function.  This only works if we have\r\n          * setjmp() support compiled in, but it is safe - this stuff should\r\n          * never happen.\r\n          */\r\n         create_struct.jmp_buf_ptr = &create_jmp_buf;\r\n         create_struct.jmp_buf_size = 0; /*stack allocation*/\r\n         create_struct.longjmp_fn = longjmp;\r\n#  else\r\n      {\r\n#  endif\r\n         /* Call the general version checker (shared with read and write code):\r\n          */\r\n         if (png_user_version_check(&create_struct, user_png_ver))\r\n         {\r\n            png_structrp png_ptr = png_voidcast(png_structrp,\r\n               png_malloc_warn(&create_struct, (sizeof *png_ptr)));\r\n\r\n            if (png_ptr != NULL)\r\n            {\r\n               /* png_ptr->zstream holds a back-pointer to the png_struct, so\r\n                * this can only be done now:\r\n                */\r\n               create_struct.zstream.zalloc = png_zalloc;\r\n               create_struct.zstream.zfree = png_zfree;\r\n               create_struct.zstream.opaque = png_ptr;\r\n\r\n#              ifdef PNG_SETJMP_SUPPORTED\r\n                  /* Eliminate the local error handling: */\r\n                  create_struct.jmp_buf_ptr = NULL;\r\n                  create_struct.jmp_buf_size = 0;\r\n                  create_struct.longjmp_fn = 0;\r\n#              endif\r\n\r\n               *png_ptr = create_struct;\r\n\r\n               /* This is the successful return point */\r\n               return png_ptr;\r\n            }\r\n         }\r\n      }\r\n\r\n   /* A longjmp because of a bug in the application storage allocator or a\r\n    * simple failure to allocate the png_struct.\r\n    */\r\n   return NULL;\r\n}\r\n\r\n/* Allocate the memory for an info_struct for the application. */\r\nPNG_FUNCTION(png_infop,PNGAPI\r\npng_create_info_struct,(png_const_structrp png_ptr),PNG_ALLOCATED)\r\n{\r\n   png_inforp info_ptr;\r\n\r\n   png_debug(1, \"in png_create_info_struct\");\r\n\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   /* Use the internal API that does not (or at least should not) error out, so\r\n    * that this call always returns ok.  The application typically sets up the\r\n    * error handling *after* creating the info_struct because this is the way it\r\n    * has always been done in 'example.c'.\r\n    */\r\n   info_ptr = png_voidcast(png_inforp, png_malloc_base(png_ptr,\r\n      (sizeof *info_ptr)));\r\n\r\n   if (info_ptr != NULL)\r\n      memset(info_ptr, 0, (sizeof *info_ptr));\r\n\r\n   return info_ptr;\r\n}\r\n\r\n/* This function frees the memory associated with a single info struct.\r\n * Normally, one would use either png_destroy_read_struct() or\r\n * png_destroy_write_struct() to free an info struct, but this may be\r\n * useful for some applications.  From libpng 1.6.0 this function is also used\r\n * internally to implement the png_info release part of the 'struct' destroy\r\n * APIs.  This ensures that all possible approaches free the same data (all of\r\n * it).\r\n */\r\nvoid PNGAPI\r\npng_destroy_info_struct(png_const_structrp png_ptr, png_infopp info_ptr_ptr)\r\n{\r\n   png_inforp info_ptr = NULL;\r\n\r\n   png_debug(1, \"in png_destroy_info_struct\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   if (info_ptr_ptr != NULL)\r\n      info_ptr = *info_ptr_ptr;\r\n\r\n   if (info_ptr != NULL)\r\n   {\r\n      /* Do this first in case of an error below; if the app implements its own\r\n       * memory management this can lead to png_free calling png_error, which\r\n       * will abort this routine and return control to the app error handler.\r\n       * An infinite loop may result if it then tries to free the same info\r\n       * ptr.\r\n       */\r\n      *info_ptr_ptr = NULL;\r\n\r\n      png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);\r\n      memset(info_ptr, 0, (sizeof *info_ptr));\r\n      png_free(png_ptr, info_ptr);\r\n   }\r\n}\r\n\r\n/* Initialize the info structure.  This is now an internal function (0.89)\r\n * and applications using it are urged to use png_create_info_struct()\r\n * instead.  Use deprecated in 1.6.0, internal use removed (used internally it\r\n * is just a memset).\r\n *\r\n * NOTE: it is almost inconceivable that this API is used because it bypasses\r\n * the user-memory mechanism and the user error handling/warning mechanisms in\r\n * those cases where it does anything other than a memset.\r\n */\r\nPNG_FUNCTION(void,PNGAPI\r\npng_info_init_3,(png_infopp ptr_ptr, png_size_t png_info_struct_size),\r\n   PNG_DEPRECATED)\r\n{\r\n   png_inforp info_ptr = *ptr_ptr;\r\n\r\n   png_debug(1, \"in png_info_init_3\");\r\n\r\n   if (info_ptr == NULL)\r\n      return;\r\n\r\n   if ((sizeof (png_info)) > png_info_struct_size)\r\n   {\r\n      *ptr_ptr = NULL;\r\n      /* The following line is why this API should not be used: */\r\n      free(info_ptr);\r\n      info_ptr = png_voidcast(png_inforp, png_malloc_base(NULL,\r\n         (sizeof *info_ptr)));\r\n      *ptr_ptr = info_ptr;\r\n   }\r\n\r\n   /* Set everything to 0 */\r\n   memset(info_ptr, 0, (sizeof *info_ptr));\r\n}\r\n\r\n/* The following API is not called internally */\r\nvoid PNGAPI\r\npng_data_freer(png_const_structrp png_ptr, png_inforp info_ptr,\r\n   int freer, png_uint_32 mask)\r\n{\r\n   png_debug(1, \"in png_data_freer\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   if (freer == PNG_DESTROY_WILL_FREE_DATA)\r\n      info_ptr->free_me |= mask;\r\n\r\n   else if (freer == PNG_USER_WILL_FREE_DATA)\r\n      info_ptr->free_me &= ~mask;\r\n\r\n   else\r\n      png_error(png_ptr, \"Unknown freer parameter in png_data_freer\");\r\n}\r\n\r\nvoid PNGAPI\r\npng_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask,\r\n   int num)\r\n{\r\n   png_debug(1, \"in png_free_data\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n#ifdef PNG_TEXT_SUPPORTED\r\n   /* Free text item num or (if num == -1) all text items */\r\n   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)\r\n   {\r\n      if (num != -1)\r\n      {\r\n         if (info_ptr->text && info_ptr->text[num].key)\r\n         {\r\n            png_free(png_ptr, info_ptr->text[num].key);\r\n            info_ptr->text[num].key = NULL;\r\n         }\r\n      }\r\n\r\n      else\r\n      {\r\n         int i;\r\n         for (i = 0; i < info_ptr->num_text; i++)\r\n             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);\r\n         png_free(png_ptr, info_ptr->text);\r\n         info_ptr->text = NULL;\r\n         info_ptr->num_text=0;\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_tRNS_SUPPORTED\r\n   /* Free any tRNS entry */\r\n   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)\r\n   {\r\n      png_free(png_ptr, info_ptr->trans_alpha);\r\n      info_ptr->trans_alpha = NULL;\r\n      info_ptr->valid &= ~PNG_INFO_tRNS;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_sCAL_SUPPORTED\r\n   /* Free any sCAL entry */\r\n   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)\r\n   {\r\n      png_free(png_ptr, info_ptr->scal_s_width);\r\n      png_free(png_ptr, info_ptr->scal_s_height);\r\n      info_ptr->scal_s_width = NULL;\r\n      info_ptr->scal_s_height = NULL;\r\n      info_ptr->valid &= ~PNG_INFO_sCAL;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_pCAL_SUPPORTED\r\n   /* Free any pCAL entry */\r\n   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)\r\n   {\r\n      png_free(png_ptr, info_ptr->pcal_purpose);\r\n      png_free(png_ptr, info_ptr->pcal_units);\r\n      info_ptr->pcal_purpose = NULL;\r\n      info_ptr->pcal_units = NULL;\r\n      if (info_ptr->pcal_params != NULL)\r\n         {\r\n            unsigned int i;\r\n            for (i = 0; i < info_ptr->pcal_nparams; i++)\r\n            {\r\n               png_free(png_ptr, info_ptr->pcal_params[i]);\r\n               info_ptr->pcal_params[i] = NULL;\r\n            }\r\n            png_free(png_ptr, info_ptr->pcal_params);\r\n            info_ptr->pcal_params = NULL;\r\n         }\r\n      info_ptr->valid &= ~PNG_INFO_pCAL;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_iCCP_SUPPORTED\r\n   /* Free any profile entry */\r\n   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)\r\n   {\r\n      png_free(png_ptr, info_ptr->iccp_name);\r\n      png_free(png_ptr, info_ptr->iccp_profile);\r\n      info_ptr->iccp_name = NULL;\r\n      info_ptr->iccp_profile = NULL;\r\n      info_ptr->valid &= ~PNG_INFO_iCCP;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_sPLT_SUPPORTED\r\n   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */\r\n   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)\r\n   {\r\n      if (num != -1)\r\n      {\r\n         if (info_ptr->splt_palettes)\r\n         {\r\n            png_free(png_ptr, info_ptr->splt_palettes[num].name);\r\n            png_free(png_ptr, info_ptr->splt_palettes[num].entries);\r\n            info_ptr->splt_palettes[num].name = NULL;\r\n            info_ptr->splt_palettes[num].entries = NULL;\r\n         }\r\n      }\r\n\r\n      else\r\n      {\r\n         if (info_ptr->splt_palettes_num)\r\n         {\r\n            int i;\r\n            for (i = 0; i < info_ptr->splt_palettes_num; i++)\r\n               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, (int)i);\r\n\r\n            png_free(png_ptr, info_ptr->splt_palettes);\r\n            info_ptr->splt_palettes = NULL;\r\n            info_ptr->splt_palettes_num = 0;\r\n         }\r\n         info_ptr->valid &= ~PNG_INFO_sPLT;\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\r\n   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)\r\n   {\r\n      if (num != -1)\r\n      {\r\n          if (info_ptr->unknown_chunks)\r\n          {\r\n             png_free(png_ptr, info_ptr->unknown_chunks[num].data);\r\n             info_ptr->unknown_chunks[num].data = NULL;\r\n          }\r\n      }\r\n\r\n      else\r\n      {\r\n         int i;\r\n\r\n         if (info_ptr->unknown_chunks_num)\r\n         {\r\n            for (i = 0; i < info_ptr->unknown_chunks_num; i++)\r\n               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, (int)i);\r\n\r\n            png_free(png_ptr, info_ptr->unknown_chunks);\r\n            info_ptr->unknown_chunks = NULL;\r\n            info_ptr->unknown_chunks_num = 0;\r\n         }\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_hIST_SUPPORTED\r\n   /* Free any hIST entry */\r\n   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)\r\n   {\r\n      png_free(png_ptr, info_ptr->hist);\r\n      info_ptr->hist = NULL;\r\n      info_ptr->valid &= ~PNG_INFO_hIST;\r\n   }\r\n#endif\r\n\r\n   /* Free any PLTE entry that was internally allocated */\r\n   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)\r\n   {\r\n      png_free(png_ptr, info_ptr->palette);\r\n      info_ptr->palette = NULL;\r\n      info_ptr->valid &= ~PNG_INFO_PLTE;\r\n      info_ptr->num_palette = 0;\r\n   }\r\n\r\n#ifdef PNG_INFO_IMAGE_SUPPORTED\r\n   /* Free any image bits attached to the info structure */\r\n   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)\r\n   {\r\n      if (info_ptr->row_pointers)\r\n      {\r\n         png_uint_32 row;\r\n         for (row = 0; row < info_ptr->height; row++)\r\n         {\r\n            png_free(png_ptr, info_ptr->row_pointers[row]);\r\n            info_ptr->row_pointers[row] = NULL;\r\n         }\r\n         png_free(png_ptr, info_ptr->row_pointers);\r\n         info_ptr->row_pointers = NULL;\r\n      }\r\n      info_ptr->valid &= ~PNG_INFO_IDAT;\r\n   }\r\n#endif\r\n\r\n   if (num != -1)\r\n      mask &= ~PNG_FREE_MUL;\r\n\r\n   info_ptr->free_me &= ~mask;\r\n}\r\n#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */\r\n\r\n/* This function returns a pointer to the io_ptr associated with the user\r\n * functions.  The application should free any memory associated with this\r\n * pointer before png_write_destroy() or png_read_destroy() are called.\r\n */\r\npng_voidp PNGAPI\r\npng_get_io_ptr(png_const_structrp png_ptr)\r\n{\r\n   if (png_ptr == NULL)\r\n      return (NULL);\r\n\r\n   return (png_ptr->io_ptr);\r\n}\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n#  ifdef PNG_STDIO_SUPPORTED\r\n/* Initialize the default input/output functions for the PNG file.  If you\r\n * use your own read or write routines, you can call either png_set_read_fn()\r\n * or png_set_write_fn() instead of png_init_io().  If you have defined\r\n * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a\r\n * function of your own because \"FILE *\" isn't necessarily available.\r\n */\r\nvoid PNGAPI\r\npng_init_io(png_structrp png_ptr, png_FILE_p fp)\r\n{\r\n   png_debug(1, \"in png_init_io\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->io_ptr = (png_voidp)fp;\r\n}\r\n#  endif\r\n\r\n#ifdef PNG_SAVE_INT_32_SUPPORTED\r\n/* The png_save_int_32 function assumes integers are stored in two's\r\n * complement format.  If this isn't the case, then this routine needs to\r\n * be modified to write data in two's complement format.  Note that,\r\n * the following works correctly even if png_int_32 has more than 32 bits\r\n * (compare the more complex code required on read for sign extension.)\r\n */\r\nvoid PNGAPI\r\npng_save_int_32(png_bytep buf, png_int_32 i)\r\n{\r\n   buf[0] = (png_byte)((i >> 24) & 0xff);\r\n   buf[1] = (png_byte)((i >> 16) & 0xff);\r\n   buf[2] = (png_byte)((i >> 8) & 0xff);\r\n   buf[3] = (png_byte)(i & 0xff);\r\n}\r\n#endif\r\n\r\n#  ifdef PNG_TIME_RFC1123_SUPPORTED\r\n/* Convert the supplied time into an RFC 1123 string suitable for use in\r\n * a \"Creation Time\" or other text-based time string.\r\n */\r\nint PNGAPI\r\npng_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)\r\n{\r\n   static PNG_CONST char short_months[12][4] =\r\n        {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\r\n         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\r\n\r\n   if (out == NULL)\r\n      return 0;\r\n\r\n   if (ptime->year > 9999 /* RFC1123 limitation */ ||\r\n       ptime->month == 0    ||  ptime->month > 12  ||\r\n       ptime->day   == 0    ||  ptime->day   > 31  ||\r\n       ptime->hour  > 23    ||  ptime->minute > 59 ||\r\n       ptime->second > 60)\r\n      return 0;\r\n\r\n   {\r\n      size_t pos = 0;\r\n      char number_buf[5]; /* enough for a four-digit year */\r\n\r\n#     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))\r\n#     define APPEND_NUMBER(format, value)\\\r\n         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))\r\n#     define APPEND(ch) if (pos < 28) out[pos++] = (ch)\r\n\r\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);\r\n      APPEND(' ');\r\n      APPEND_STRING(short_months[(ptime->month - 1)]);\r\n      APPEND(' ');\r\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);\r\n      APPEND(' ');\r\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);\r\n      APPEND(':');\r\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);\r\n      APPEND(':');\r\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);\r\n      APPEND_STRING(\" +0000\"); /* This reliably terminates the buffer */\r\n\r\n#     undef APPEND\r\n#     undef APPEND_NUMBER\r\n#     undef APPEND_STRING\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n#     if PNG_LIBPNG_VER < 10700\r\n/* To do: remove the following from libpng-1.7 */\r\n/* Original API that uses a private buffer in png_struct.\r\n * Deprecated because it causes png_struct to carry a spurious temporary\r\n * buffer (png_struct::time_buffer), better to have the caller pass this in.\r\n */\r\npng_const_charp PNGAPI\r\npng_convert_to_rfc1123(png_structrp png_ptr, png_const_timep ptime)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      /* The only failure above if png_ptr != NULL is from an invalid ptime */\r\n      if (!png_convert_to_rfc1123_buffer(png_ptr->time_buffer, ptime))\r\n         png_warning(png_ptr, \"Ignoring invalid time value\");\r\n\r\n      else\r\n         return png_ptr->time_buffer;\r\n   }\r\n\r\n   return NULL;\r\n}\r\n#     endif\r\n#  endif /* PNG_TIME_RFC1123_SUPPORTED */\r\n\r\n#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */\r\n\r\npng_const_charp PNGAPI\r\npng_get_copyright(png_const_structrp png_ptr)\r\n{\r\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\r\n#ifdef PNG_STRING_COPYRIGHT\r\n   return PNG_STRING_COPYRIGHT\r\n#else\r\n#  ifdef __STDC__\r\n   return PNG_STRING_NEWLINE \\\r\n     \"libpng version 1.6.10 - March 6, 2014\" PNG_STRING_NEWLINE \\\r\n     \"Copyright (c) 1998-2014 Glenn Randers-Pehrson\" PNG_STRING_NEWLINE \\\r\n     \"Copyright (c) 1996-1997 Andreas Dilger\" PNG_STRING_NEWLINE \\\r\n     \"Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\" \\\r\n     PNG_STRING_NEWLINE;\r\n#  else\r\n      return \"libpng version 1.6.10 - March 6, 2014\\\r\n      Copyright (c) 1998-2014 Glenn Randers-Pehrson\\\r\n      Copyright (c) 1996-1997 Andreas Dilger\\\r\n      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\";\r\n#  endif\r\n#endif\r\n}\r\n\r\n/* The following return the library version as a short string in the\r\n * format 1.0.0 through 99.99.99zz.  To get the version of *.h files\r\n * used with your application, print out PNG_LIBPNG_VER_STRING, which\r\n * is defined in png.h.\r\n * Note: now there is no difference between png_get_libpng_ver() and\r\n * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,\r\n * it is guaranteed that png.c uses the correct version of png.h.\r\n */\r\npng_const_charp PNGAPI\r\npng_get_libpng_ver(png_const_structrp png_ptr)\r\n{\r\n   /* Version of *.c files used when building libpng */\r\n   return png_get_header_ver(png_ptr);\r\n}\r\n\r\npng_const_charp PNGAPI\r\npng_get_header_ver(png_const_structrp png_ptr)\r\n{\r\n   /* Version of *.h files used when building libpng */\r\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\r\n   return PNG_LIBPNG_VER_STRING;\r\n}\r\n\r\npng_const_charp PNGAPI\r\npng_get_header_version(png_const_structrp png_ptr)\r\n{\r\n   /* Returns longer string containing both version and date */\r\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\r\n#ifdef __STDC__\r\n   return PNG_HEADER_VERSION_STRING\r\n#  ifndef PNG_READ_SUPPORTED\r\n   \"     (NO READ SUPPORT)\"\r\n#  endif\r\n   PNG_STRING_NEWLINE;\r\n#else\r\n   return PNG_HEADER_VERSION_STRING;\r\n#endif\r\n}\r\n\r\n#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED\r\n/* NOTE: this routine is not used internally! */\r\n/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth\r\n * large of png_color.  This lets grayscale images be treated as\r\n * paletted.  Most useful for gamma correction and simplification\r\n * of code.  This API is not used internally.\r\n */\r\nvoid PNGAPI\r\npng_build_grayscale_palette(int bit_depth, png_colorp palette)\r\n{\r\n   int num_palette;\r\n   int color_inc;\r\n   int i;\r\n   int v;\r\n\r\n   png_debug(1, \"in png_do_build_grayscale_palette\");\r\n\r\n   if (palette == NULL)\r\n      return;\r\n\r\n   switch (bit_depth)\r\n   {\r\n      case 1:\r\n         num_palette = 2;\r\n         color_inc = 0xff;\r\n         break;\r\n\r\n      case 2:\r\n         num_palette = 4;\r\n         color_inc = 0x55;\r\n         break;\r\n\r\n      case 4:\r\n         num_palette = 16;\r\n         color_inc = 0x11;\r\n         break;\r\n\r\n      case 8:\r\n         num_palette = 256;\r\n         color_inc = 1;\r\n         break;\r\n\r\n      default:\r\n         num_palette = 0;\r\n         color_inc = 0;\r\n         break;\r\n   }\r\n\r\n   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)\r\n   {\r\n      palette[i].red = (png_byte)v;\r\n      palette[i].green = (png_byte)v;\r\n      palette[i].blue = (png_byte)v;\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\r\nint PNGAPI\r\npng_handle_as_unknown(png_const_structrp png_ptr, png_const_bytep chunk_name)\r\n{\r\n   /* Check chunk_name and return \"keep\" value if it's on the list, else 0 */\r\n   png_const_bytep p, p_end;\r\n\r\n   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list == 0)\r\n      return PNG_HANDLE_CHUNK_AS_DEFAULT;\r\n\r\n   p_end = png_ptr->chunk_list;\r\n   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */\r\n\r\n   /* The code is the fifth byte after each four byte string.  Historically this\r\n    * code was always searched from the end of the list, this is no longer\r\n    * necessary because the 'set' routine handles duplicate entries correcty.\r\n    */\r\n   do /* num_chunk_list > 0, so at least one */\r\n   {\r\n      p -= 5;\r\n\r\n      if (!memcmp(chunk_name, p, 4))\r\n         return p[4];\r\n   }\r\n   while (p > p_end);\r\n\r\n   /* This means that known chunks should be processed and unknown chunks should\r\n    * be handled according to the value of png_ptr->unknown_default; this can be\r\n    * confusing because, as a result, there are two levels of defaulting for\r\n    * unknown chunks.\r\n    */\r\n   return PNG_HANDLE_CHUNK_AS_DEFAULT;\r\n}\r\n\r\n#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) ||\\\r\n   defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)\r\nint /* PRIVATE */\r\npng_chunk_unknown_handling(png_const_structrp png_ptr, png_uint_32 chunk_name)\r\n{\r\n   png_byte chunk_string[5];\r\n\r\n   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);\r\n   return png_handle_as_unknown(png_ptr, chunk_string);\r\n}\r\n#endif /* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */\r\n#endif /* SET_UNKNOWN_CHUNKS */\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\n/* This function, added to libpng-1.0.6g, is untested. */\r\nint PNGAPI\r\npng_reset_zstream(png_structrp png_ptr)\r\n{\r\n   if (png_ptr == NULL)\r\n      return Z_STREAM_ERROR;\r\n\r\n   /* WARNING: this resets the window bits to the maximum! */\r\n   return (inflateReset(&png_ptr->zstream));\r\n}\r\n#endif /* PNG_READ_SUPPORTED */\r\n\r\n/* This function was added to libpng-1.0.7 */\r\npng_uint_32 PNGAPI\r\npng_access_version_number(void)\r\n{\r\n   /* Version of *.c files used when building libpng */\r\n   return((png_uint_32)PNG_LIBPNG_VER);\r\n}\r\n\r\n\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.\r\n * If it doesn't 'ret' is used to set it to something appropriate, even in cases\r\n * like Z_OK or Z_STREAM_END where the error code is apparently a success code.\r\n */\r\nvoid /* PRIVATE */\r\npng_zstream_error(png_structrp png_ptr, int ret)\r\n{\r\n   /* Translate 'ret' into an appropriate error string, priority is given to the\r\n    * one in zstream if set.  This always returns a string, even in cases like\r\n    * Z_OK or Z_STREAM_END where the error code is a success code.\r\n    */\r\n   if (png_ptr->zstream.msg == NULL) switch (ret)\r\n   {\r\n      default:\r\n      case Z_OK:\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected zlib return code\");\r\n         break;\r\n\r\n      case Z_STREAM_END:\r\n         /* Normal exit */\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected end of LZ stream\");\r\n         break;\r\n\r\n      case Z_NEED_DICT:\r\n         /* This means the deflate stream did not have a dictionary; this\r\n          * indicates a bogus PNG.\r\n          */\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"missing LZ dictionary\");\r\n         break;\r\n\r\n      case Z_ERRNO:\r\n         /* gz APIs only: should not happen */\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zlib IO error\");\r\n         break;\r\n\r\n      case Z_STREAM_ERROR:\r\n         /* internal libpng error */\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"bad parameters to zlib\");\r\n         break;\r\n\r\n      case Z_DATA_ERROR:\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"damaged LZ stream\");\r\n         break;\r\n\r\n      case Z_MEM_ERROR:\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"insufficient memory\");\r\n         break;\r\n\r\n      case Z_BUF_ERROR:\r\n         /* End of input or output; not a problem if the caller is doing\r\n          * incremental read or write.\r\n          */\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"truncated\");\r\n         break;\r\n\r\n      case Z_VERSION_ERROR:\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unsupported zlib version\");\r\n         break;\r\n\r\n      case PNG_UNEXPECTED_ZLIB_RETURN:\r\n         /* Compile errors here mean that zlib now uses the value co-opted in\r\n          * pngpriv.h for PNG_UNEXPECTED_ZLIB_RETURN; update the switch above\r\n          * and change pngpriv.h.  Note that this message is \"... return\",\r\n          * whereas the default/Z_OK one is \"... return code\".\r\n          */\r\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected zlib return\");\r\n         break;\r\n   }\r\n}\r\n\r\n/* png_convert_size: a PNGAPI but no longer in png.h, so deleted\r\n * at libpng 1.5.5!\r\n */\r\n\r\n/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */\r\n#ifdef PNG_GAMMA_SUPPORTED /* always set if COLORSPACE */\r\nstatic int\r\npng_colorspace_check_gamma(png_const_structrp png_ptr,\r\n   png_colorspacerp colorspace, png_fixed_point gAMA, int from)\r\n   /* This is called to check a new gamma value against an existing one.  The\r\n    * routine returns false if the new gamma value should not be written.\r\n    *\r\n    * 'from' says where the new gamma value comes from:\r\n    *\r\n    *    0: the new gamma value is the libpng estimate for an ICC profile\r\n    *    1: the new gamma value comes from a gAMA chunk\r\n    *    2: the new gamma value comes from an sRGB chunk\r\n    */\r\n{\r\n   png_fixed_point gtest;\r\n\r\n   if ((colorspace->flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\r\n      (!png_muldiv(&gtest, colorspace->gamma, PNG_FP_1, gAMA) ||\r\n      png_gamma_significant(gtest)))\r\n   {\r\n      /* Either this is an sRGB image, in which case the calculated gamma\r\n       * approximation should match, or this is an image with a profile and the\r\n       * value libpng calculates for the gamma of the profile does not match the\r\n       * value recorded in the file.  The former, sRGB, case is an error, the\r\n       * latter is just a warning.\r\n       */\r\n      if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0 || from == 2)\r\n      {\r\n         png_chunk_report(png_ptr, \"gamma value does not match sRGB\",\r\n            PNG_CHUNK_ERROR);\r\n         /* Do not overwrite an sRGB value */\r\n         return from == 2;\r\n      }\r\n\r\n      else /* sRGB tag not involved */\r\n      {\r\n         png_chunk_report(png_ptr, \"gamma value does not match libpng estimate\",\r\n            PNG_CHUNK_WARNING);\r\n         return from == 1;\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_colorspace_set_gamma(png_const_structrp png_ptr,\r\n   png_colorspacerp colorspace, png_fixed_point gAMA)\r\n{\r\n   /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't\r\n    * occur.  Since the fixed point representation is assymetrical it is\r\n    * possible for 1/gamma to overflow the limit of 21474 and this means the\r\n    * gamma value must be at least 5/100000 and hence at most 20000.0.  For\r\n    * safety the limits here are a little narrower.  The values are 0.00016 to\r\n    * 6250.0, which are truly ridiculous gamma values (and will produce\r\n    * displays that are all black or all white.)\r\n    *\r\n    * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk\r\n    * handling code, which only required the value to be >0.\r\n    */\r\n   png_const_charp errmsg;\r\n\r\n   if (gAMA < 16 || gAMA > 625000000)\r\n      errmsg = \"gamma value out of range\";\r\n\r\n#  ifdef PNG_READ_gAMA_SUPPORTED\r\n      /* Allow the application to set the gamma value more than once */\r\n      else if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\r\n         (colorspace->flags & PNG_COLORSPACE_FROM_gAMA) != 0)\r\n         errmsg = \"duplicate\";\r\n#  endif\r\n\r\n   /* Do nothing if the colorspace is already invalid */\r\n   else if (colorspace->flags & PNG_COLORSPACE_INVALID)\r\n      return;\r\n\r\n   else\r\n   {\r\n      if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA, 1/*from gAMA*/))\r\n      {\r\n         /* Store this gamma value. */\r\n         colorspace->gamma = gAMA;\r\n         colorspace->flags |=\r\n            (PNG_COLORSPACE_HAVE_GAMMA | PNG_COLORSPACE_FROM_gAMA);\r\n      }\r\n\r\n      /* At present if the check_gamma test fails the gamma of the colorspace is\r\n       * not updated however the colorspace is not invalidated.  This\r\n       * corresponds to the case where the existing gamma comes from an sRGB\r\n       * chunk or profile.  An error message has already been output.\r\n       */\r\n      return;\r\n   }\r\n\r\n   /* Error exit - errmsg has been set. */\r\n   colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n   png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_colorspace_sync_info(png_const_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n   if (info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID)\r\n   {\r\n      /* Everything is invalid */\r\n      info_ptr->valid &= ~(PNG_INFO_gAMA|PNG_INFO_cHRM|PNG_INFO_sRGB|\r\n         PNG_INFO_iCCP);\r\n\r\n#     ifdef PNG_COLORSPACE_SUPPORTED\r\n         /* Clean up the iCCP profile now if it won't be used. */\r\n         png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, -1/*not used*/);\r\n#     else\r\n         PNG_UNUSED(png_ptr)\r\n#     endif\r\n   }\r\n\r\n   else\r\n   {\r\n#     ifdef PNG_COLORSPACE_SUPPORTED\r\n         /* Leave the INFO_iCCP flag set if the pngset.c code has already set\r\n          * it; this allows a PNG to contain a profile which matches sRGB and\r\n          * yet still have that profile retrievable by the application.\r\n          */\r\n         if (info_ptr->colorspace.flags & PNG_COLORSPACE_MATCHES_sRGB)\r\n            info_ptr->valid |= PNG_INFO_sRGB;\r\n\r\n         else\r\n            info_ptr->valid &= ~PNG_INFO_sRGB;\r\n\r\n         if (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS)\r\n            info_ptr->valid |= PNG_INFO_cHRM;\r\n\r\n         else\r\n            info_ptr->valid &= ~PNG_INFO_cHRM;\r\n#     endif\r\n\r\n      if (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA)\r\n         info_ptr->valid |= PNG_INFO_gAMA;\r\n\r\n      else\r\n         info_ptr->valid &= ~PNG_INFO_gAMA;\r\n   }\r\n}\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_colorspace_sync(png_const_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n   if (info_ptr == NULL) /* reduce code size; check here not in the caller */\r\n      return;\r\n\r\n   info_ptr->colorspace = png_ptr->colorspace;\r\n   png_colorspace_sync_info(png_ptr, info_ptr);\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifdef PNG_COLORSPACE_SUPPORTED\r\n/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for\r\n * cHRM, as opposed to using chromaticities.  These internal APIs return\r\n * non-zero on a parameter error.  The X, Y and Z values are required to be\r\n * positive and less than 1.0.\r\n */\r\nstatic int\r\npng_xy_from_XYZ(png_xy *xy, const png_XYZ *XYZ)\r\n{\r\n   png_int_32 d, dwhite, whiteX, whiteY;\r\n\r\n   d = XYZ->red_X + XYZ->red_Y + XYZ->red_Z;\r\n   if (!png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, d)) return 1;\r\n   if (!png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, d)) return 1;\r\n   dwhite = d;\r\n   whiteX = XYZ->red_X;\r\n   whiteY = XYZ->red_Y;\r\n\r\n   d = XYZ->green_X + XYZ->green_Y + XYZ->green_Z;\r\n   if (!png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, d)) return 1;\r\n   if (!png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, d)) return 1;\r\n   dwhite += d;\r\n   whiteX += XYZ->green_X;\r\n   whiteY += XYZ->green_Y;\r\n\r\n   d = XYZ->blue_X + XYZ->blue_Y + XYZ->blue_Z;\r\n   if (!png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, d)) return 1;\r\n   if (!png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, d)) return 1;\r\n   dwhite += d;\r\n   whiteX += XYZ->blue_X;\r\n   whiteY += XYZ->blue_Y;\r\n\r\n   /* The reference white is simply the sum of the end-point (X,Y,Z) vectors,\r\n    * thus:\r\n    */\r\n   if (!png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite)) return 1;\r\n   if (!png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite)) return 1;\r\n\r\n   return 0;\r\n}\r\n\r\nstatic int\r\npng_XYZ_from_xy(png_XYZ *XYZ, const png_xy *xy)\r\n{\r\n   png_fixed_point red_inverse, green_inverse, blue_scale;\r\n   png_fixed_point left, right, denominator;\r\n\r\n   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically\r\n    * have end points with 0 tristimulus values (these are impossible end\r\n    * points, but they are used to cover the possible colors.)\r\n    */\r\n   if (xy->redx < 0 || xy->redx > PNG_FP_1) return 1;\r\n   if (xy->redy < 0 || xy->redy > PNG_FP_1-xy->redx) return 1;\r\n   if (xy->greenx < 0 || xy->greenx > PNG_FP_1) return 1;\r\n   if (xy->greeny < 0 || xy->greeny > PNG_FP_1-xy->greenx) return 1;\r\n   if (xy->bluex < 0 || xy->bluex > PNG_FP_1) return 1;\r\n   if (xy->bluey < 0 || xy->bluey > PNG_FP_1-xy->bluex) return 1;\r\n   if (xy->whitex < 0 || xy->whitex > PNG_FP_1) return 1;\r\n   if (xy->whitey < 0 || xy->whitey > PNG_FP_1-xy->whitex) return 1;\r\n\r\n   /* The reverse calculation is more difficult because the original tristimulus\r\n    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8\r\n    * derived values were recorded in the cHRM chunk;\r\n    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and\r\n    * therefore an arbitrary ninth value has to be introduced to undo the\r\n    * original transformations.\r\n    *\r\n    * Think of the original end-points as points in (X,Y,Z) space.  The\r\n    * chromaticity values (c) have the property:\r\n    *\r\n    *           C\r\n    *   c = ---------\r\n    *       X + Y + Z\r\n    *\r\n    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the\r\n    * three chromaticity values (x,y,z) for each end-point obey the\r\n    * relationship:\r\n    *\r\n    *   x + y + z = 1\r\n    *\r\n    * This describes the plane in (X,Y,Z) space that intersects each axis at the\r\n    * value 1.0; call this the chromaticity plane.  Thus the chromaticity\r\n    * calculation has scaled each end-point so that it is on the x+y+z=1 plane\r\n    * and chromaticity is the intersection of the vector from the origin to the\r\n    * (X,Y,Z) value with the chromaticity plane.\r\n    *\r\n    * To fully invert the chromaticity calculation we would need the three\r\n    * end-point scale factors, (red-scale, green-scale, blue-scale), but these\r\n    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and\r\n    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have\r\n    * given all three of the scale factors since:\r\n    *\r\n    *    color-C = color-c * color-scale\r\n    *    white-C = red-C + green-C + blue-C\r\n    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale\r\n    *\r\n    * But cHRM records only white-x and white-y, so we have lost the white scale\r\n    * factor:\r\n    *\r\n    *    white-C = white-c*white-scale\r\n    *\r\n    * To handle this the inverse transformation makes an arbitrary assumption\r\n    * about white-scale:\r\n    *\r\n    *    Assume: white-Y = 1.0\r\n    *    Hence:  white-scale = 1/white-y\r\n    *    Or:     red-Y + green-Y + blue-Y = 1.0\r\n    *\r\n    * Notice the last statement of the assumption gives an equation in three of\r\n    * the nine values we want to calculate.  8 more equations come from the\r\n    * above routine as summarised at the top above (the chromaticity\r\n    * calculation):\r\n    *\r\n    *    Given: color-x = color-X / (color-X + color-Y + color-Z)\r\n    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0\r\n    *\r\n    * This is 9 simultaneous equations in the 9 variables \"color-C\" and can be\r\n    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix\r\n    * determinants, however this is not as bad as it seems because only 28 of\r\n    * the total of 90 terms in the various matrices are non-zero.  Nevertheless\r\n    * Cramer's rule is notoriously numerically unstable because the determinant\r\n    * calculation involves the difference of large, but similar, numbers.  It is\r\n    * difficult to be sure that the calculation is stable for real world values\r\n    * and it is certain that it becomes unstable where the end points are close\r\n    * together.\r\n    *\r\n    * So this code uses the perhaps slightly less optimal but more\r\n    * understandable and totally obvious approach of calculating color-scale.\r\n    *\r\n    * This algorithm depends on the precision in white-scale and that is\r\n    * (1/white-y), so we can immediately see that as white-y approaches 0 the\r\n    * accuracy inherent in the cHRM chunk drops off substantially.\r\n    *\r\n    * libpng arithmetic: a simple invertion of the above equations\r\n    * ------------------------------------------------------------\r\n    *\r\n    *    white_scale = 1/white-y\r\n    *    white-X = white-x * white-scale\r\n    *    white-Y = 1.0\r\n    *    white-Z = (1 - white-x - white-y) * white_scale\r\n    *\r\n    *    white-C = red-C + green-C + blue-C\r\n    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale\r\n    *\r\n    * This gives us three equations in (red-scale,green-scale,blue-scale) where\r\n    * all the coefficients are now known:\r\n    *\r\n    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale\r\n    *       = white-x/white-y\r\n    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1\r\n    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale\r\n    *       = (1 - white-x - white-y)/white-y\r\n    *\r\n    * In the last equation color-z is (1 - color-x - color-y) so we can add all\r\n    * three equations together to get an alternative third:\r\n    *\r\n    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale\r\n    *\r\n    * So now we have a Cramer's rule solution where the determinants are just\r\n    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve\r\n    * multiplication of three coefficients so we can't guarantee to avoid\r\n    * overflow in the libpng fixed point representation.  Using Cramer's rule in\r\n    * floating point is probably a good choice here, but it's not an option for\r\n    * fixed point.  Instead proceed to simplify the first two equations by\r\n    * eliminating what is likely to be the largest value, blue-scale:\r\n    *\r\n    *    blue-scale = white-scale - red-scale - green-scale\r\n    *\r\n    * Hence:\r\n    *\r\n    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =\r\n    *                (white-x - blue-x)*white-scale\r\n    *\r\n    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =\r\n    *                1 - blue-y*white-scale\r\n    *\r\n    * And now we can trivially solve for (red-scale,green-scale):\r\n    *\r\n    *    green-scale =\r\n    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale\r\n    *                -----------------------------------------------------------\r\n    *                                  green-x - blue-x\r\n    *\r\n    *    red-scale =\r\n    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale\r\n    *                ---------------------------------------------------------\r\n    *                                  red-y - blue-y\r\n    *\r\n    * Hence:\r\n    *\r\n    *    red-scale =\r\n    *          ( (green-x - blue-x) * (white-y - blue-y) -\r\n    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y\r\n    * -------------------------------------------------------------------------\r\n    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)\r\n    *\r\n    *    green-scale =\r\n    *          ( (red-y - blue-y) * (white-x - blue-x) -\r\n    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y\r\n    * -------------------------------------------------------------------------\r\n    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)\r\n    *\r\n    * Accuracy:\r\n    * The input values have 5 decimal digits of accuracy.  The values are all in\r\n    * the range 0 < value < 1, so simple products are in the same range but may\r\n    * need up to 10 decimal digits to preserve the original precision and avoid\r\n    * underflow.  Because we are using a 32-bit signed representation we cannot\r\n    * match this; the best is a little over 9 decimal digits, less than 10.\r\n    *\r\n    * The approach used here is to preserve the maximum precision within the\r\n    * signed representation.  Because the red-scale calculation above uses the\r\n    * difference between two products of values that must be in the range -1..+1\r\n    * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The\r\n    * factor is irrelevant in the calculation because it is applied to both\r\n    * numerator and denominator.\r\n    *\r\n    * Note that the values of the differences of the products of the\r\n    * chromaticities in the above equations tend to be small, for example for\r\n    * the sRGB chromaticities they are:\r\n    *\r\n    * red numerator:    -0.04751\r\n    * green numerator:  -0.08788\r\n    * denominator:      -0.2241 (without white-y multiplication)\r\n    *\r\n    *  The resultant Y coefficients from the chromaticities of some widely used\r\n    *  color space definitions are (to 15 decimal places):\r\n    *\r\n    *  sRGB\r\n    *    0.212639005871510 0.715168678767756 0.072192315360734\r\n    *  Kodak ProPhoto\r\n    *    0.288071128229293 0.711843217810102 0.000085653960605\r\n    *  Adobe RGB\r\n    *    0.297344975250536 0.627363566255466 0.075291458493998\r\n    *  Adobe Wide Gamut RGB\r\n    *    0.258728243040113 0.724682314948566 0.016589442011321\r\n    */\r\n   /* By the argument, above overflow should be impossible here. The return\r\n    * value of 2 indicates an internal error to the caller.\r\n    */\r\n   if (!png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 7))\r\n      return 2;\r\n   if (!png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 7))\r\n      return 2;\r\n   denominator = left - right;\r\n\r\n   /* Now find the red numerator. */\r\n   if (!png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 7))\r\n      return 2;\r\n   if (!png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 7))\r\n      return 2;\r\n\r\n   /* Overflow is possible here and it indicates an extreme set of PNG cHRM\r\n    * chunk values.  This calculation actually returns the reciprocal of the\r\n    * scale value because this allows us to delay the multiplication of white-y\r\n    * into the denominator, which tends to produce a small number.\r\n    */\r\n   if (!png_muldiv(&red_inverse, xy->whitey, denominator, left-right) ||\r\n       red_inverse <= xy->whitey /* r+g+b scales = white scale */)\r\n      return 1;\r\n\r\n   /* Similarly for green_inverse: */\r\n   if (!png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 7))\r\n      return 2;\r\n   if (!png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 7))\r\n      return 2;\r\n   if (!png_muldiv(&green_inverse, xy->whitey, denominator, left-right) ||\r\n       green_inverse <= xy->whitey)\r\n      return 1;\r\n\r\n   /* And the blue scale, the checks above guarantee this can't overflow but it\r\n    * can still produce 0 for extreme cHRM values.\r\n    */\r\n   blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -\r\n      png_reciprocal(green_inverse);\r\n   if (blue_scale <= 0) return 1;\r\n\r\n\r\n   /* And fill in the png_XYZ: */\r\n   if (!png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, red_inverse)) return 1;\r\n   if (!png_muldiv(&XYZ->red_Y, xy->redy, PNG_FP_1, red_inverse)) return 1;\r\n   if (!png_muldiv(&XYZ->red_Z, PNG_FP_1 - xy->redx - xy->redy, PNG_FP_1,\r\n      red_inverse))\r\n      return 1;\r\n\r\n   if (!png_muldiv(&XYZ->green_X, xy->greenx, PNG_FP_1, green_inverse))\r\n      return 1;\r\n   if (!png_muldiv(&XYZ->green_Y, xy->greeny, PNG_FP_1, green_inverse))\r\n      return 1;\r\n   if (!png_muldiv(&XYZ->green_Z, PNG_FP_1 - xy->greenx - xy->greeny, PNG_FP_1,\r\n      green_inverse))\r\n      return 1;\r\n\r\n   if (!png_muldiv(&XYZ->blue_X, xy->bluex, blue_scale, PNG_FP_1)) return 1;\r\n   if (!png_muldiv(&XYZ->blue_Y, xy->bluey, blue_scale, PNG_FP_1)) return 1;\r\n   if (!png_muldiv(&XYZ->blue_Z, PNG_FP_1 - xy->bluex - xy->bluey, blue_scale,\r\n      PNG_FP_1))\r\n      return 1;\r\n\r\n   return 0; /*success*/\r\n}\r\n\r\nstatic int\r\npng_XYZ_normalize(png_XYZ *XYZ)\r\n{\r\n   png_int_32 Y;\r\n\r\n   if (XYZ->red_Y < 0 || XYZ->green_Y < 0 || XYZ->blue_Y < 0 ||\r\n      XYZ->red_X < 0 || XYZ->green_X < 0 || XYZ->blue_X < 0 ||\r\n      XYZ->red_Z < 0 || XYZ->green_Z < 0 || XYZ->blue_Z < 0)\r\n      return 1;\r\n\r\n   /* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.\r\n    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\r\n    * relying on addition of two positive values producing a negative one is not\r\n    * safe.\r\n    */\r\n   Y = XYZ->red_Y;\r\n   if (0x7fffffff - Y < XYZ->green_X) return 1;\r\n   Y += XYZ->green_Y;\r\n   if (0x7fffffff - Y < XYZ->blue_X) return 1;\r\n   Y += XYZ->blue_Y;\r\n\r\n   if (Y != PNG_FP_1)\r\n   {\r\n      if (!png_muldiv(&XYZ->red_X, XYZ->red_X, PNG_FP_1, Y)) return 1;\r\n      if (!png_muldiv(&XYZ->red_Y, XYZ->red_Y, PNG_FP_1, Y)) return 1;\r\n      if (!png_muldiv(&XYZ->red_Z, XYZ->red_Z, PNG_FP_1, Y)) return 1;\r\n\r\n      if (!png_muldiv(&XYZ->green_X, XYZ->green_X, PNG_FP_1, Y)) return 1;\r\n      if (!png_muldiv(&XYZ->green_Y, XYZ->green_Y, PNG_FP_1, Y)) return 1;\r\n      if (!png_muldiv(&XYZ->green_Z, XYZ->green_Z, PNG_FP_1, Y)) return 1;\r\n\r\n      if (!png_muldiv(&XYZ->blue_X, XYZ->blue_X, PNG_FP_1, Y)) return 1;\r\n      if (!png_muldiv(&XYZ->blue_Y, XYZ->blue_Y, PNG_FP_1, Y)) return 1;\r\n      if (!png_muldiv(&XYZ->blue_Z, XYZ->blue_Z, PNG_FP_1, Y)) return 1;\r\n   }\r\n\r\n   return 0;\r\n}\r\n\r\nstatic int\r\npng_colorspace_endpoints_match(const png_xy *xy1, const png_xy *xy2, int delta)\r\n{\r\n   /* Allow an error of +/-0.01 (absolute value) on each chromaticity */\r\n   return !(PNG_OUT_OF_RANGE(xy1->whitex, xy2->whitex,delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->whitey, xy2->whitey,delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->redx,   xy2->redx,  delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->redy,   xy2->redy,  delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->greenx, xy2->greenx,delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->greeny, xy2->greeny,delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->bluex,  xy2->bluex, delta) ||\r\n      PNG_OUT_OF_RANGE(xy1->bluey,  xy2->bluey, delta));\r\n}\r\n\r\n/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM\r\n * chunk chromaticities.  Earlier checks used to simply look for the overflow\r\n * condition (where the determinant of the matrix to solve for XYZ ends up zero\r\n * because the chromaticity values are not all distinct.)  Despite this it is\r\n * theoretically possible to produce chromaticities that are apparently valid\r\n * but that rapidly degrade to invalid, potentially crashing, sets because of\r\n * arithmetic inaccuracies when calculations are performed on them.  The new\r\n * check is to round-trip xy -> XYZ -> xy and then check that the result is\r\n * within a small percentage of the original.\r\n */\r\nstatic int\r\npng_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)\r\n{\r\n   int result;\r\n   png_xy xy_test;\r\n\r\n   /* As a side-effect this routine also returns the XYZ endpoints. */\r\n   result = png_XYZ_from_xy(XYZ, xy);\r\n   if (result) return result;\r\n\r\n   result = png_xy_from_XYZ(&xy_test, XYZ);\r\n   if (result) return result;\r\n\r\n   if (png_colorspace_endpoints_match(xy, &xy_test,\r\n      5/*actually, the math is pretty accurate*/))\r\n      return 0;\r\n\r\n   /* Too much slip */\r\n   return 1;\r\n}\r\n\r\n/* This is the check going the other way.  The XYZ is modified to normalize it\r\n * (another side-effect) and the xy chromaticities are returned.\r\n */\r\nstatic int\r\npng_colorspace_check_XYZ(png_xy *xy, png_XYZ *XYZ)\r\n{\r\n   int result;\r\n   png_XYZ XYZtemp;\r\n\r\n   result = png_XYZ_normalize(XYZ);\r\n   if (result) return result;\r\n\r\n   result = png_xy_from_XYZ(xy, XYZ);\r\n   if (result) return result;\r\n\r\n   XYZtemp = *XYZ;\r\n   return png_colorspace_check_xy(&XYZtemp, xy);\r\n}\r\n\r\n/* Used to check for an endpoint match against sRGB */\r\nstatic const png_xy sRGB_xy = /* From ITU-R BT.709-3 */\r\n{\r\n   /* color      x       y */\r\n   /* red   */ 64000, 33000,\r\n   /* green */ 30000, 60000,\r\n   /* blue  */ 15000,  6000,\r\n   /* white */ 31270, 32900\r\n};\r\n\r\nstatic int\r\npng_colorspace_set_xy_and_XYZ(png_const_structrp png_ptr,\r\n   png_colorspacerp colorspace, const png_xy *xy, const png_XYZ *XYZ,\r\n   int preferred)\r\n{\r\n   if (colorspace->flags & PNG_COLORSPACE_INVALID)\r\n      return 0;\r\n\r\n   /* The consistency check is performed on the chromaticities; this factors out\r\n    * variations because of the normalization (or not) of the end point Y\r\n    * values.\r\n    */\r\n   if (preferred < 2 && (colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS))\r\n   {\r\n      /* The end points must be reasonably close to any we already have.  The\r\n       * following allows an error of up to +/-.001\r\n       */\r\n      if (!png_colorspace_endpoints_match(xy, &colorspace->end_points_xy, 100))\r\n      {\r\n         colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n         png_benign_error(png_ptr, \"inconsistent chromaticities\");\r\n         return 0; /* failed */\r\n      }\r\n\r\n      /* Only overwrite with preferred values */\r\n      if (!preferred)\r\n         return 1; /* ok, but no change */\r\n   }\r\n\r\n   colorspace->end_points_xy = *xy;\r\n   colorspace->end_points_XYZ = *XYZ;\r\n   colorspace->flags |= PNG_COLORSPACE_HAVE_ENDPOINTS;\r\n\r\n   /* The end points are normally quoted to two decimal digits, so allow +/-0.01\r\n    * on this test.\r\n    */\r\n   if (png_colorspace_endpoints_match(xy, &sRGB_xy, 1000))\r\n      colorspace->flags |= PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB;\r\n\r\n   else\r\n      colorspace->flags &= PNG_COLORSPACE_CANCEL(\r\n         PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);\r\n\r\n   return 2; /* ok and changed */\r\n}\r\n\r\nint /* PRIVATE */\r\npng_colorspace_set_chromaticities(png_const_structrp png_ptr,\r\n   png_colorspacerp colorspace, const png_xy *xy, int preferred)\r\n{\r\n   /* We must check the end points to ensure they are reasonable - in the past\r\n    * color management systems have crashed as a result of getting bogus\r\n    * colorant values, while this isn't the fault of libpng it is the\r\n    * responsibility of libpng because PNG carries the bomb and libpng is in a\r\n    * position to protect against it.\r\n    */\r\n   png_XYZ XYZ;\r\n\r\n   switch (png_colorspace_check_xy(&XYZ, xy))\r\n   {\r\n      case 0: /* success */\r\n         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, xy, &XYZ,\r\n            preferred);\r\n\r\n      case 1:\r\n         /* We can't invert the chromaticities so we can't produce value XYZ\r\n          * values.  Likely as not a color management system will fail too.\r\n          */\r\n         colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n         png_benign_error(png_ptr, \"invalid chromaticities\");\r\n         break;\r\n\r\n      default:\r\n         /* libpng is broken; this should be a warning but if it happens we\r\n          * want error reports so for the moment it is an error.\r\n          */\r\n         colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n         png_error(png_ptr, \"internal error checking chromaticities\");\r\n         break;\r\n   }\r\n\r\n   return 0; /* failed */\r\n}\r\n\r\nint /* PRIVATE */\r\npng_colorspace_set_endpoints(png_const_structrp png_ptr,\r\n   png_colorspacerp colorspace, const png_XYZ *XYZ_in, int preferred)\r\n{\r\n   png_XYZ XYZ = *XYZ_in;\r\n   png_xy xy;\r\n\r\n   switch (png_colorspace_check_XYZ(&xy, &XYZ))\r\n   {\r\n      case 0:\r\n         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, &xy, &XYZ,\r\n            preferred);\r\n\r\n      case 1:\r\n         /* End points are invalid. */\r\n         colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n         png_benign_error(png_ptr, \"invalid end points\");\r\n         break;\r\n\r\n      default:\r\n         colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n         png_error(png_ptr, \"internal error checking chromaticities\");\r\n         break;\r\n   }\r\n\r\n   return 0; /* failed */\r\n}\r\n\r\n#if defined(PNG_sRGB_SUPPORTED) || defined(PNG_iCCP_SUPPORTED)\r\n/* Error message generation */\r\nstatic char\r\npng_icc_tag_char(png_uint_32 byte)\r\n{\r\n   byte &= 0xff;\r\n   if (byte >= 32 && byte <= 126)\r\n      return (char)byte;\r\n   else\r\n      return '?';\r\n}\r\n\r\nstatic void\r\npng_icc_tag_name(char *name, png_uint_32 tag)\r\n{\r\n   name[0] = '\\'';\r\n   name[1] = png_icc_tag_char(tag >> 24);\r\n   name[2] = png_icc_tag_char(tag >> 16);\r\n   name[3] = png_icc_tag_char(tag >>  8);\r\n   name[4] = png_icc_tag_char(tag      );\r\n   name[5] = '\\'';\r\n}\r\n\r\nstatic int\r\nis_ICC_signature_char(png_alloc_size_t it)\r\n{\r\n   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||\r\n      (it >= 97 && it <= 122);\r\n}\r\n\r\nstatic int\r\nis_ICC_signature(png_alloc_size_t it)\r\n{\r\n   return is_ICC_signature_char(it >> 24) /* checks all the top bits */ &&\r\n      is_ICC_signature_char((it >> 16) & 0xff) &&\r\n      is_ICC_signature_char((it >> 8) & 0xff) &&\r\n      is_ICC_signature_char(it & 0xff);\r\n}\r\n\r\nstatic int\r\npng_icc_profile_error(png_const_structrp png_ptr, png_colorspacerp colorspace,\r\n   png_const_charp name, png_alloc_size_t value, png_const_charp reason)\r\n{\r\n   size_t pos;\r\n   char message[196]; /* see below for calculation */\r\n\r\n   if (colorspace != NULL)\r\n      colorspace->flags |= PNG_COLORSPACE_INVALID;\r\n\r\n   pos = png_safecat(message, (sizeof message), 0, \"profile '\"); /* 9 chars */\r\n   pos = png_safecat(message, pos+79, pos, name); /* Truncate to 79 chars */\r\n   pos = png_safecat(message, (sizeof message), pos, \"': \"); /* +2 = 90 */\r\n   if (is_ICC_signature(value))\r\n   {\r\n      /* So 'value' is at most 4 bytes and the following cast is safe */\r\n      png_icc_tag_name(message+pos, (png_uint_32)value);\r\n      pos += 6; /* total +8; less than the else clause */\r\n      message[pos++] = ':';\r\n      message[pos++] = ' ';\r\n   }\r\n#  ifdef PNG_WARNINGS_SUPPORTED\r\n   else\r\n      {\r\n         char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114*/\r\n\r\n         pos = png_safecat(message, (sizeof message), pos,\r\n            png_format_number(number, number+(sizeof number),\r\n               PNG_NUMBER_FORMAT_x, value));\r\n         pos = png_safecat(message, (sizeof message), pos, \"h: \"); /*+2 = 116*/\r\n      }\r\n#  endif\r\n   /* The 'reason' is an arbitrary message, allow +79 maximum 195 */\r\n   pos = png_safecat(message, (sizeof message), pos, reason);\r\n   PNG_UNUSED(pos)\r\n\r\n   /* This is recoverable, but make it unconditionally an app_error on write to\r\n    * avoid writing invalid ICC profiles into PNG files.  (I.e.  we handle them\r\n    * on read, with a warning, but on write unless the app turns off\r\n    * application errors the PNG won't be written.)\r\n    */\r\n   png_chunk_report(png_ptr, message,\r\n      (colorspace != NULL) ? PNG_CHUNK_ERROR : PNG_CHUNK_WRITE_ERROR);\r\n\r\n   return 0;\r\n}\r\n#endif /* sRGB || iCCP */\r\n\r\n#ifdef PNG_sRGB_SUPPORTED\r\nint /* PRIVATE */\r\npng_colorspace_set_sRGB(png_const_structrp png_ptr, png_colorspacerp colorspace,\r\n   int intent)\r\n{\r\n   /* sRGB sets known gamma, end points and (from the chunk) intent. */\r\n   /* IMPORTANT: these are not necessarily the values found in an ICC profile\r\n    * because ICC profiles store values adapted to a D50 environment; it is\r\n    * expected that the ICC profile mediaWhitePointTag will be D50, see the\r\n    * checks and code elsewhere to understand this better.\r\n    *\r\n    * These XYZ values, which are accurate to 5dp, produce rgb to gray\r\n    * coefficients of (6968,23435,2366), which are reduced (because they add up\r\n    * to 32769 not 32768) to (6968,23434,2366).  These are the values that\r\n    * libpng has traditionally used (and are the best values given the 15bit\r\n    * algorithm used by the rgb to gray code.)\r\n    */\r\n   static const png_XYZ sRGB_XYZ = /* D65 XYZ (*not* the D50 adapted values!) */\r\n   {\r\n      /* color      X      Y      Z */\r\n      /* red   */ 41239, 21264,  1933,\r\n      /* green */ 35758, 71517, 11919,\r\n      /* blue  */ 18048,  7219, 95053\r\n   };\r\n\r\n   /* Do nothing if the colorspace is already invalidated. */\r\n   if (colorspace->flags & PNG_COLORSPACE_INVALID)\r\n      return 0;\r\n\r\n   /* Check the intent, then check for existing settings.  It is valid for the\r\n    * PNG file to have cHRM or gAMA chunks along with sRGB, but the values must\r\n    * be consistent with the correct values.  If, however, this function is\r\n    * called below because an iCCP chunk matches sRGB then it is quite\r\n    * conceivable that an older app recorded incorrect gAMA and cHRM because of\r\n    * an incorrect calculation based on the values in the profile - this does\r\n    * *not* invalidate the profile (though it still produces an error, which can\r\n    * be ignored.)\r\n    */\r\n   if (intent < 0 || intent >= PNG_sRGB_INTENT_LAST)\r\n      return png_icc_profile_error(png_ptr, colorspace, \"sRGB\",\r\n         (unsigned)intent, \"invalid sRGB rendering intent\");\r\n\r\n   if ((colorspace->flags & PNG_COLORSPACE_HAVE_INTENT) != 0 &&\r\n      colorspace->rendering_intent != intent)\r\n      return png_icc_profile_error(png_ptr, colorspace, \"sRGB\",\r\n         (unsigned)intent, \"inconsistent rendering intents\");\r\n\r\n   if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0)\r\n   {\r\n      png_benign_error(png_ptr, \"duplicate sRGB information ignored\");\r\n      return 0;\r\n   }\r\n\r\n   /* If the standard sRGB cHRM chunk does not match the one from the PNG file\r\n    * warn but overwrite the value with the correct one.\r\n    */\r\n   if ((colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0 &&\r\n      !png_colorspace_endpoints_match(&sRGB_xy, &colorspace->end_points_xy,\r\n         100))\r\n      png_chunk_report(png_ptr, \"cHRM chunk does not match sRGB\",\r\n         PNG_CHUNK_ERROR);\r\n\r\n   /* This check is just done for the error reporting - the routine always\r\n    * returns true when the 'from' argument corresponds to sRGB (2).\r\n    */\r\n   (void)png_colorspace_check_gamma(png_ptr, colorspace, PNG_GAMMA_sRGB_INVERSE,\r\n      2/*from sRGB*/);\r\n\r\n   /* intent: bugs in GCC force 'int' to be used as the parameter type. */\r\n   colorspace->rendering_intent = (png_uint_16)intent;\r\n   colorspace->flags |= PNG_COLORSPACE_HAVE_INTENT;\r\n\r\n   /* endpoints */\r\n   colorspace->end_points_xy = sRGB_xy;\r\n   colorspace->end_points_XYZ = sRGB_XYZ;\r\n   colorspace->flags |=\r\n      (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);\r\n\r\n   /* gamma */\r\n   colorspace->gamma = PNG_GAMMA_sRGB_INVERSE;\r\n   colorspace->flags |= PNG_COLORSPACE_HAVE_GAMMA;\r\n\r\n   /* Finally record that we have an sRGB profile */\r\n   colorspace->flags |=\r\n      (PNG_COLORSPACE_MATCHES_sRGB|PNG_COLORSPACE_FROM_sRGB);\r\n\r\n   return 1; /* set */\r\n}\r\n#endif /* sRGB */\r\n\r\n#ifdef PNG_iCCP_SUPPORTED\r\n/* Encoded value of D50 as an ICC XYZNumber.  From the ICC 2010 spec the value\r\n * is XYZ(0.9642,1.0,0.8249), which scales to:\r\n *\r\n *    (63189.8112, 65536, 54060.6464)\r\n */\r\nstatic const png_byte D50_nCIEXYZ[12] =\r\n   { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };\r\n\r\nint /* PRIVATE */\r\npng_icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,\r\n   png_const_charp name, png_uint_32 profile_length)\r\n{\r\n   if (profile_length < 132)\r\n      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\r\n         \"too short\");\r\n\r\n   if (profile_length & 3)\r\n      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\r\n         \"invalid length\");\r\n\r\n   return 1;\r\n}\r\n\r\nint /* PRIVATE */\r\npng_icc_check_header(png_const_structrp png_ptr, png_colorspacerp colorspace,\r\n   png_const_charp name, png_uint_32 profile_length,\r\n   png_const_bytep profile/* first 132 bytes only */, int color_type)\r\n{\r\n   png_uint_32 temp;\r\n\r\n   /* Length check; this cannot be ignored in this code because profile_length\r\n    * is used later to check the tag table, so even if the profile seems over\r\n    * long profile_length from the caller must be correct.  The caller can fix\r\n    * this up on read or write by just passing in the profile header length.\r\n    */\r\n   temp = png_get_uint_32(profile);\r\n   if (temp != profile_length)\r\n      return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n         \"length does not match profile\");\r\n\r\n   temp = png_get_uint_32(profile+128); /* tag count: 12 bytes/tag */\r\n   if (temp > 357913930 || /* (2^32-4-132)/12: maximum possible tag count */\r\n      profile_length < 132+12*temp) /* truncated tag table */\r\n      return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n         \"tag count too large\");\r\n\r\n   /* The 'intent' must be valid or we can't store it, ICC limits the intent to\r\n    * 16 bits.\r\n    */\r\n   temp = png_get_uint_32(profile+64);\r\n   if (temp >= 0xffff) /* The ICC limit */\r\n      return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n         \"invalid rendering intent\");\r\n\r\n   /* This is just a warning because the profile may be valid in future\r\n    * versions.\r\n    */\r\n   if (temp >= PNG_sRGB_INTENT_LAST)\r\n      (void)png_icc_profile_error(png_ptr, NULL, name, temp,\r\n         \"intent outside defined range\");\r\n\r\n   /* At this point the tag table can't be checked because it hasn't necessarily\r\n    * been loaded; however, various header fields can be checked.  These checks\r\n    * are for values permitted by the PNG spec in an ICC profile; the PNG spec\r\n    * restricts the profiles that can be passed in an iCCP chunk (they must be\r\n    * appropriate to processing PNG data!)\r\n    */\r\n\r\n   /* Data checks (could be skipped).  These checks must be independent of the\r\n    * version number; however, the version number doesn't accomodate changes in\r\n    * the header fields (just the known tags and the interpretation of the\r\n    * data.)\r\n    */\r\n   temp = png_get_uint_32(profile+36); /* signature 'ascp' */\r\n   if (temp != 0x61637370)\r\n      return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n         \"invalid signature\");\r\n\r\n   /* Currently the PCS illuminant/adopted white point (the computational\r\n    * white point) are required to be D50,\r\n    * however the profile contains a record of the illuminant so perhaps ICC\r\n    * expects to be able to change this in the future (despite the rationale in\r\n    * the introduction for using a fixed PCS adopted white.)  Consequently the\r\n    * following is just a warning.\r\n    */\r\n   if (memcmp(profile+68, D50_nCIEXYZ, 12) != 0)\r\n      (void)png_icc_profile_error(png_ptr, NULL, name, 0/*no tag value*/,\r\n         \"PCS illuminant is not D50\");\r\n\r\n   /* The PNG spec requires this:\r\n    * \"If the iCCP chunk is present, the image samples conform to the colour\r\n    * space represented by the embedded ICC profile as defined by the\r\n    * International Color Consortium [ICC]. The colour space of the ICC profile\r\n    * shall be an RGB colour space for colour images (PNG colour types 2, 3, and\r\n    * 6), or a greyscale colour space for greyscale images (PNG colour types 0\r\n    * and 4).\"\r\n    *\r\n    * This checking code ensures the embedded profile (on either read or write)\r\n    * conforms to the specification requirements.  Notice that an ICC 'gray'\r\n    * color-space profile contains the information to transform the monochrome\r\n    * data to XYZ or L*a*b (according to which PCS the profile uses) and this\r\n    * should be used in preference to the standard libpng K channel replication\r\n    * into R, G and B channels.\r\n    *\r\n    * Previously it was suggested that an RGB profile on grayscale data could be\r\n    * handled.  However it it is clear that using an RGB profile in this context\r\n    * must be an error - there is no specification of what it means.  Thus it is\r\n    * almost certainly more correct to ignore the profile.\r\n    */\r\n   temp = png_get_uint_32(profile+16); /* data colour space field */\r\n   switch (temp)\r\n   {\r\n      case 0x52474220: /* 'RGB ' */\r\n         if (!(color_type & PNG_COLOR_MASK_COLOR))\r\n            return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n               \"RGB color space not permitted on grayscale PNG\");\r\n         break;\r\n\r\n      case 0x47524159: /* 'GRAY' */\r\n         if (color_type & PNG_COLOR_MASK_COLOR)\r\n            return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n               \"Gray color space not permitted on RGB PNG\");\r\n         break;\r\n\r\n      default:\r\n         return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n            \"invalid ICC profile color space\");\r\n   }\r\n\r\n   /* It is up to the application to check that the profile class matches the\r\n    * application requirements; the spec provides no guidance, but it's pretty\r\n    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer\r\n    * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these\r\n    * cases.  Issue an error for device link or abstract profiles - these don't\r\n    * contain the records necessary to transform the color-space to anything\r\n    * other than the target device (and not even that for an abstract profile).\r\n    * Profiles of these classes may not be embedded in images.\r\n    */\r\n   temp = png_get_uint_32(profile+12); /* profile/device class */\r\n   switch (temp)\r\n   {\r\n      case 0x73636E72: /* 'scnr' */\r\n      case 0x6D6E7472: /* 'mntr' */\r\n      case 0x70727472: /* 'prtr' */\r\n      case 0x73706163: /* 'spac' */\r\n         /* All supported */\r\n         break;\r\n\r\n      case 0x61627374: /* 'abst' */\r\n         /* May not be embedded in an image */\r\n         return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n            \"invalid embedded Abstract ICC profile\");\r\n\r\n      case 0x6C696E6B: /* 'link' */\r\n         /* DeviceLink profiles cannnot be interpreted in a non-device specific\r\n          * fashion, if an app uses the AToB0Tag in the profile the results are\r\n          * undefined unless the result is sent to the intended device,\r\n          * therefore a DeviceLink profile should not be found embedded in a\r\n          * PNG.\r\n          */\r\n         return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n            \"unexpected DeviceLink ICC profile class\");\r\n\r\n      case 0x6E6D636C: /* 'nmcl' */\r\n         /* A NamedColor profile is also device specific, however it doesn't\r\n          * contain an AToB0 tag that is open to misintrepretation.  Almost\r\n          * certainly it will fail the tests below.\r\n          */\r\n         (void)png_icc_profile_error(png_ptr, NULL, name, temp,\r\n            \"unexpected NamedColor ICC profile class\");\r\n         break;\r\n\r\n      default:\r\n         /* To allow for future enhancements to the profile accept unrecognized\r\n          * profile classes with a warning, these then hit the test below on the\r\n          * tag content to ensure they are backward compatible with one of the\r\n          * understood profiles.\r\n          */\r\n         (void)png_icc_profile_error(png_ptr, NULL, name, temp,\r\n            \"unrecognized ICC profile class\");\r\n         break;\r\n   }\r\n\r\n   /* For any profile other than a device link one the PCS must be encoded\r\n    * either in XYZ or Lab.\r\n    */\r\n   temp = png_get_uint_32(profile+20);\r\n   switch (temp)\r\n   {\r\n      case 0x58595A20: /* 'XYZ ' */\r\n      case 0x4C616220: /* 'Lab ' */\r\n         break;\r\n\r\n      default:\r\n         return png_icc_profile_error(png_ptr, colorspace, name, temp,\r\n            \"unexpected ICC PCS encoding\");\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nint /* PRIVATE */\r\npng_icc_check_tag_table(png_const_structrp png_ptr, png_colorspacerp colorspace,\r\n   png_const_charp name, png_uint_32 profile_length,\r\n   png_const_bytep profile /* header plus whole tag table */)\r\n{\r\n   png_uint_32 tag_count = png_get_uint_32(profile+128);\r\n   png_uint_32 itag;\r\n   png_const_bytep tag = profile+132; /* The first tag */\r\n\r\n   /* First scan all the tags in the table and add bits to the icc_info value\r\n    * (temporarily in 'tags').\r\n    */\r\n   for (itag=0; itag < tag_count; ++itag, tag += 12)\r\n   {\r\n      png_uint_32 tag_id = png_get_uint_32(tag+0);\r\n      png_uint_32 tag_start = png_get_uint_32(tag+4); /* must be aligned */\r\n      png_uint_32 tag_length = png_get_uint_32(tag+8);/* not padded */\r\n\r\n      /* The ICC specification does not exclude zero length tags, therefore the\r\n       * start might actually be anywhere if there is no data, but this would be\r\n       * a clear abuse of the intent of the standard so the start is checked for\r\n       * being in range.  All defined tag types have an 8 byte header - a 4 byte\r\n       * type signature then 0.\r\n       */\r\n      if ((tag_start & 3) != 0)\r\n      {\r\n         /* CNHP730S.icc shipped with Microsoft Windows 64 violates this, it is\r\n          * only a warning here because libpng does not care about the\r\n          * alignment.\r\n          */\r\n         (void)png_icc_profile_error(png_ptr, NULL, name, tag_id,\r\n            \"ICC profile tag start not a multiple of 4\");\r\n      }\r\n\r\n      /* This is a hard error; potentially it can cause read outside the\r\n       * profile.\r\n       */\r\n      if (tag_start > profile_length || tag_length > profile_length - tag_start)\r\n         return png_icc_profile_error(png_ptr, colorspace, name, tag_id,\r\n            \"ICC profile tag outside profile\");\r\n   }\r\n\r\n   return 1; /* success, maybe with warnings */\r\n}\r\n\r\n#ifdef PNG_sRGB_SUPPORTED\r\n/* Information about the known ICC sRGB profiles */\r\nstatic const struct\r\n{\r\n   png_uint_32 adler, crc, length;\r\n   png_uint_32 md5[4];\r\n   png_byte    have_md5;\r\n   png_byte    is_broken;\r\n   png_uint_16 intent;\r\n\r\n#  define PNG_MD5(a,b,c,d) { a, b, c, d }, (a!=0)||(b!=0)||(c!=0)||(d!=0)\r\n#  define PNG_ICC_CHECKSUM(adler, crc, md5, intent, broke, date, length, fname)\\\r\n      { adler, crc, length, md5, broke, intent },\r\n\r\n} png_sRGB_checks[] =\r\n{\r\n   /* This data comes from contrib/tools/checksum-icc run on downloads of\r\n    * all four ICC sRGB profiles from www.color.org.\r\n    */\r\n   /* adler32, crc32, MD5[4], intent, date, length, file-name */\r\n   PNG_ICC_CHECKSUM(0x0a3fd9f6, 0x3b8772b9,\r\n      PNG_MD5(0x29f83dde, 0xaff255ae, 0x7842fae4, 0xca83390d), 0, 0,\r\n      \"2009/03/27 21:36:31\", 3048, \"sRGB_IEC61966-2-1_black_scaled.icc\")\r\n\r\n   /* ICC sRGB v2 perceptual no black-compensation: */\r\n   PNG_ICC_CHECKSUM(0x4909e5e1, 0x427ebb21,\r\n      PNG_MD5(0xc95bd637, 0xe95d8a3b, 0x0df38f99, 0xc1320389), 1, 0,\r\n      \"2009/03/27 21:37:45\", 3052, \"sRGB_IEC61966-2-1_no_black_scaling.icc\")\r\n\r\n   PNG_ICC_CHECKSUM(0xfd2144a1, 0x306fd8ae,\r\n      PNG_MD5(0xfc663378, 0x37e2886b, 0xfd72e983, 0x8228f1b8), 0, 0,\r\n      \"2009/08/10 17:28:01\", 60988, \"sRGB_v4_ICC_preference_displayclass.icc\")\r\n\r\n   /* ICC sRGB v4 perceptual */\r\n   PNG_ICC_CHECKSUM(0x209c35d2, 0xbbef7812,\r\n      PNG_MD5(0x34562abf, 0x994ccd06, 0x6d2c5721, 0xd0d68c5d), 0, 0,\r\n      \"2007/07/25 00:05:37\", 60960, \"sRGB_v4_ICC_preference.icc\")\r\n\r\n   /* The following profiles have no known MD5 checksum. If there is a match\r\n    * on the (empty) MD5 the other fields are used to attempt a match and\r\n    * a warning is produced.  The first two of these profiles have a 'cprt' tag\r\n    * which suggests that they were also made by Hewlett Packard.\r\n    */\r\n   PNG_ICC_CHECKSUM(0xa054d762, 0x5d5129ce,\r\n      PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 0,\r\n      \"2004/07/21 18:57:42\", 3024, \"sRGB_IEC61966-2-1_noBPC.icc\")\r\n\r\n   /* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not\r\n    * match the D50 PCS illuminant in the header (it is in fact the D65 values,\r\n    * so the white point is recorded as the un-adapted value.)  The profiles\r\n    * below only differ in one byte - the intent - and are basically the same as\r\n    * the previous profile except for the mediaWhitePointTag error and a missing\r\n    * chromaticAdaptationTag.\r\n    */\r\n   PNG_ICC_CHECKSUM(0xf784f3fb, 0x182ea552,\r\n      PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 0, 1/*broken*/,\r\n      \"1998/02/09 06:49:00\", 3144, \"HP-Microsoft sRGB v2 perceptual\")\r\n\r\n   PNG_ICC_CHECKSUM(0x0398f3fc, 0xf29e526d,\r\n      PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 1/*broken*/,\r\n      \"1998/02/09 06:49:00\", 3144, \"HP-Microsoft sRGB v2 media-relative\")\r\n};\r\n\r\nstatic int\r\npng_compare_ICC_profile_with_sRGB(png_const_structrp png_ptr,\r\n   png_const_bytep profile, uLong adler)\r\n{\r\n   /* The quick check is to verify just the MD5 signature and trust the\r\n    * rest of the data.  Because the profile has already been verified for\r\n    * correctness this is safe.  png_colorspace_set_sRGB will check the 'intent'\r\n    * field too, so if the profile has been edited with an intent not defined\r\n    * by sRGB (but maybe defined by a later ICC specification) the read of\r\n    * the profile will fail at that point.\r\n    */\r\n   png_uint_32 length = 0;\r\n   png_uint_32 intent = 0x10000; /* invalid */\r\n#if PNG_sRGB_PROFILE_CHECKS > 1\r\n   uLong crc = 0; /* the value for 0 length data */\r\n#endif\r\n   unsigned int i;\r\n\r\n   for (i=0; i < (sizeof png_sRGB_checks) / (sizeof png_sRGB_checks[0]); ++i)\r\n   {\r\n      if (png_get_uint_32(profile+84) == png_sRGB_checks[i].md5[0] &&\r\n         png_get_uint_32(profile+88) == png_sRGB_checks[i].md5[1] &&\r\n         png_get_uint_32(profile+92) == png_sRGB_checks[i].md5[2] &&\r\n         png_get_uint_32(profile+96) == png_sRGB_checks[i].md5[3])\r\n      {\r\n         /* This may be one of the old HP profiles without an MD5, in that\r\n          * case we can only use the length and Adler32 (note that these\r\n          * are not used by default if there is an MD5!)\r\n          */\r\n#        if PNG_sRGB_PROFILE_CHECKS == 0\r\n            if (png_sRGB_checks[i].have_md5)\r\n               return 1+png_sRGB_checks[i].is_broken;\r\n#        endif\r\n\r\n         /* Profile is unsigned or more checks have been configured in. */\r\n         if (length == 0)\r\n         {\r\n            length = png_get_uint_32(profile);\r\n            intent = png_get_uint_32(profile+64);\r\n         }\r\n\r\n         /* Length *and* intent must match */\r\n         if (length == png_sRGB_checks[i].length &&\r\n            intent == png_sRGB_checks[i].intent)\r\n         {\r\n            /* Now calculate the adler32 if not done already. */\r\n            if (adler == 0)\r\n            {\r\n               adler = adler32(0, NULL, 0);\r\n               adler = adler32(adler, profile, length);\r\n            }\r\n\r\n            if (adler == png_sRGB_checks[i].adler)\r\n            {\r\n               /* These basic checks suggest that the data has not been\r\n                * modified, but if the check level is more than 1 perform\r\n                * our own crc32 checksum on the data.\r\n                */\r\n#              if PNG_sRGB_PROFILE_CHECKS > 1\r\n                  if (crc == 0)\r\n                  {\r\n                     crc = crc32(0, NULL, 0);\r\n                     crc = crc32(crc, profile, length);\r\n                  }\r\n\r\n                  /* So this check must pass for the 'return' below to happen.\r\n                   */\r\n                  if (crc == png_sRGB_checks[i].crc)\r\n#              endif\r\n               {\r\n                  if (png_sRGB_checks[i].is_broken)\r\n                  {\r\n                     /* These profiles are known to have bad data that may cause\r\n                      * problems if they are used, therefore attempt to\r\n                      * discourage their use, skip the 'have_md5' warning below,\r\n                      * which is made irrelevant by this error.\r\n                      */\r\n                     png_chunk_report(png_ptr, \"known incorrect sRGB profile\",\r\n                        PNG_CHUNK_ERROR);\r\n                  }\r\n\r\n                  /* Warn that this being done; this isn't even an error since\r\n                   * the profile is perfectly valid, but it would be nice if\r\n                   * people used the up-to-date ones.\r\n                   */\r\n                  else if (!png_sRGB_checks[i].have_md5)\r\n                  {\r\n                     png_chunk_report(png_ptr,\r\n                        \"out-of-date sRGB profile with no signature\",\r\n                        PNG_CHUNK_WARNING);\r\n                  }\r\n\r\n                  return 1+png_sRGB_checks[i].is_broken;\r\n               }\r\n            }\r\n         }\r\n\r\n# if PNG_sRGB_PROFILE_CHECKS > 0\r\n         /* The signature matched, but the profile had been changed in some\r\n          * way.  This probably indicates a data error or uninformed hacking.\r\n          * Fall through to \"no match\".\r\n          */\r\n         png_chunk_report(png_ptr,\r\n             \"Not recognizing known sRGB profile that has been edited\", \r\n             PNG_CHUNK_WARNING);\r\n         break;\r\n# endif\r\n      }\r\n   }\r\n\r\n   return 0; /* no match */\r\n}\r\n#endif\r\n\r\n#ifdef PNG_sRGB_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_icc_set_sRGB(png_const_structrp png_ptr,\r\n   png_colorspacerp colorspace, png_const_bytep profile, uLong adler)\r\n{\r\n   /* Is this profile one of the known ICC sRGB profiles?  If it is, just set\r\n    * the sRGB information.\r\n    */\r\n   if (png_compare_ICC_profile_with_sRGB(png_ptr, profile, adler))\r\n      (void)png_colorspace_set_sRGB(png_ptr, colorspace,\r\n         (int)/*already checked*/png_get_uint_32(profile+64));\r\n}\r\n#endif /* PNG_READ_sRGB_SUPPORTED */\r\n\r\nint /* PRIVATE */\r\npng_colorspace_set_ICC(png_const_structrp png_ptr, png_colorspacerp colorspace,\r\n   png_const_charp name, png_uint_32 profile_length, png_const_bytep profile,\r\n   int color_type)\r\n{\r\n   if (colorspace->flags & PNG_COLORSPACE_INVALID)\r\n      return 0;\r\n\r\n   if (png_icc_check_length(png_ptr, colorspace, name, profile_length) &&\r\n      png_icc_check_header(png_ptr, colorspace, name, profile_length, profile,\r\n         color_type) &&\r\n      png_icc_check_tag_table(png_ptr, colorspace, name, profile_length,\r\n         profile))\r\n   {\r\n#     ifdef PNG_sRGB_SUPPORTED\r\n         /* If no sRGB support, don't try storing sRGB information */\r\n         png_icc_set_sRGB(png_ptr, colorspace, profile, 0);\r\n#     endif\r\n      return 1;\r\n   }\r\n\r\n   /* Failure case */\r\n   return 0;\r\n}\r\n#endif /* iCCP */\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_colorspace_set_rgb_coefficients(png_structrp png_ptr)\r\n{\r\n   /* Set the rgb_to_gray coefficients from the colorspace. */\r\n   if (!png_ptr->rgb_to_gray_coefficients_set &&\r\n      (png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\r\n   {\r\n      /* png_set_background has not been called, get the coefficients from the Y\r\n       * values of the colorspace colorants.\r\n       */\r\n      png_fixed_point r = png_ptr->colorspace.end_points_XYZ.red_Y;\r\n      png_fixed_point g = png_ptr->colorspace.end_points_XYZ.green_Y;\r\n      png_fixed_point b = png_ptr->colorspace.end_points_XYZ.blue_Y;\r\n      png_fixed_point total = r+g+b;\r\n\r\n      if (total > 0 &&\r\n         r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\r\n         g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\r\n         b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\r\n         r+g+b <= 32769)\r\n      {\r\n         /* We allow 0 coefficients here.  r+g+b may be 32769 if two or\r\n          * all of the coefficients were rounded up.  Handle this by\r\n          * reducing the *largest* coefficient by 1; this matches the\r\n          * approach used for the default coefficients in pngrtran.c\r\n          */\r\n         int add = 0;\r\n\r\n         if (r+g+b > 32768)\r\n            add = -1;\r\n         else if (r+g+b < 32768)\r\n            add = 1;\r\n\r\n         if (add != 0)\r\n         {\r\n            if (g >= r && g >= b)\r\n               g += add;\r\n            else if (r >= g && r >= b)\r\n               r += add;\r\n            else\r\n               b += add;\r\n         }\r\n\r\n         /* Check for an internal error. */\r\n         if (r+g+b != 32768)\r\n            png_error(png_ptr,\r\n               \"internal error handling cHRM coefficients\");\r\n\r\n         else\r\n         {\r\n            png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\r\n            png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\r\n         }\r\n      }\r\n\r\n      /* This is a png_error at present even though it could be ignored -\r\n       * it should never happen, but it is important that if it does, the\r\n       * bug is fixed.\r\n       */\r\n      else\r\n         png_error(png_ptr, \"internal error handling cHRM->XYZ\");\r\n   }\r\n}\r\n#endif\r\n\r\n#endif /* COLORSPACE */\r\n\r\nvoid /* PRIVATE */\r\npng_check_IHDR(png_const_structrp png_ptr,\r\n   png_uint_32 width, png_uint_32 height, int bit_depth,\r\n   int color_type, int interlace_type, int compression_type,\r\n   int filter_type)\r\n{\r\n   int error = 0;\r\n\r\n   /* Check for width and height valid values */\r\n   if (width == 0)\r\n   {\r\n      png_warning(png_ptr, \"Image width is zero in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (height == 0)\r\n   {\r\n      png_warning(png_ptr, \"Image height is zero in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\r\n   if (width > png_ptr->user_width_max)\r\n\r\n#  else\r\n   if (width > PNG_USER_WIDTH_MAX)\r\n#  endif\r\n   {\r\n      png_warning(png_ptr, \"Image width exceeds user limit in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\r\n   if (height > png_ptr->user_height_max)\r\n#  else\r\n   if (height > PNG_USER_HEIGHT_MAX)\r\n#  endif\r\n   {\r\n      png_warning(png_ptr, \"Image height exceeds user limit in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (width > PNG_UINT_31_MAX)\r\n   {\r\n      png_warning(png_ptr, \"Invalid image width in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (height > PNG_UINT_31_MAX)\r\n   {\r\n      png_warning(png_ptr, \"Invalid image height in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   /* Check other values */\r\n   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&\r\n       bit_depth != 8 && bit_depth != 16)\r\n   {\r\n      png_warning(png_ptr, \"Invalid bit depth in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (color_type < 0 || color_type == 1 ||\r\n       color_type == 5 || color_type > 6)\r\n   {\r\n      png_warning(png_ptr, \"Invalid color type in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||\r\n       ((color_type == PNG_COLOR_TYPE_RGB ||\r\n         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\r\n         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))\r\n   {\r\n      png_warning(png_ptr, \"Invalid color type/bit depth combination in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (interlace_type >= PNG_INTERLACE_LAST)\r\n   {\r\n      png_warning(png_ptr, \"Unknown interlace method in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\r\n   {\r\n      png_warning(png_ptr, \"Unknown compression method in IHDR\");\r\n      error = 1;\r\n   }\r\n\r\n#  ifdef PNG_MNG_FEATURES_SUPPORTED\r\n   /* Accept filter_method 64 (intrapixel differencing) only if\r\n    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and\r\n    * 2. Libpng did not read a PNG signature (this filter_method is only\r\n    *    used in PNG datastreams that are embedded in MNG datastreams) and\r\n    * 3. The application called png_permit_mng_features with a mask that\r\n    *    included PNG_FLAG_MNG_FILTER_64 and\r\n    * 4. The filter_method is 64 and\r\n    * 5. The color_type is RGB or RGBA\r\n    */\r\n   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&\r\n       png_ptr->mng_features_permitted)\r\n      png_warning(png_ptr, \"MNG features are not allowed in a PNG datastream\");\r\n\r\n   if (filter_type != PNG_FILTER_TYPE_BASE)\r\n   {\r\n      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&\r\n          (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&\r\n          ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&\r\n          (color_type == PNG_COLOR_TYPE_RGB ||\r\n          color_type == PNG_COLOR_TYPE_RGB_ALPHA)))\r\n      {\r\n         png_warning(png_ptr, \"Unknown filter method in IHDR\");\r\n         error = 1;\r\n      }\r\n\r\n      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)\r\n      {\r\n         png_warning(png_ptr, \"Invalid filter method in IHDR\");\r\n         error = 1;\r\n      }\r\n   }\r\n\r\n#  else\r\n   if (filter_type != PNG_FILTER_TYPE_BASE)\r\n   {\r\n      png_warning(png_ptr, \"Unknown filter method in IHDR\");\r\n      error = 1;\r\n   }\r\n#  endif\r\n\r\n   if (error == 1)\r\n      png_error(png_ptr, \"Invalid IHDR data\");\r\n}\r\n\r\n#if defined(PNG_sCAL_SUPPORTED) || defined(PNG_pCAL_SUPPORTED)\r\n/* ASCII to fp functions */\r\n/* Check an ASCII formated floating point value, see the more detailed\r\n * comments in pngpriv.h\r\n */\r\n/* The following is used internally to preserve the sticky flags */\r\n#define png_fp_add(state, flags) ((state) |= (flags))\r\n#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))\r\n\r\nint /* PRIVATE */\r\npng_check_fp_number(png_const_charp string, png_size_t size, int *statep,\r\n   png_size_tp whereami)\r\n{\r\n   int state = *statep;\r\n   png_size_t i = *whereami;\r\n\r\n   while (i < size)\r\n   {\r\n      int type;\r\n      /* First find the type of the next character */\r\n      switch (string[i])\r\n      {\r\n      case 43:  type = PNG_FP_SAW_SIGN;                   break;\r\n      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;\r\n      case 46:  type = PNG_FP_SAW_DOT;                    break;\r\n      case 48:  type = PNG_FP_SAW_DIGIT;                  break;\r\n      case 49: case 50: case 51: case 52:\r\n      case 53: case 54: case 55: case 56:\r\n      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;\r\n      case 69:\r\n      case 101: type = PNG_FP_SAW_E;                      break;\r\n      default:  goto PNG_FP_End;\r\n      }\r\n\r\n      /* Now deal with this type according to the current\r\n       * state, the type is arranged to not overlap the\r\n       * bits of the PNG_FP_STATE.\r\n       */\r\n      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))\r\n      {\r\n      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:\r\n         if (state & PNG_FP_SAW_ANY)\r\n            goto PNG_FP_End; /* not a part of the number */\r\n\r\n         png_fp_add(state, type);\r\n         break;\r\n\r\n      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:\r\n         /* Ok as trailer, ok as lead of fraction. */\r\n         if (state & PNG_FP_SAW_DOT) /* two dots */\r\n            goto PNG_FP_End;\r\n\r\n         else if (state & PNG_FP_SAW_DIGIT) /* trailing dot? */\r\n            png_fp_add(state, type);\r\n\r\n         else\r\n            png_fp_set(state, PNG_FP_FRACTION | type);\r\n\r\n         break;\r\n\r\n      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:\r\n         if (state & PNG_FP_SAW_DOT) /* delayed fraction */\r\n            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);\r\n\r\n         png_fp_add(state, type | PNG_FP_WAS_VALID);\r\n\r\n         break;\r\n\r\n      case PNG_FP_INTEGER + PNG_FP_SAW_E:\r\n         if ((state & PNG_FP_SAW_DIGIT) == 0)\r\n            goto PNG_FP_End;\r\n\r\n         png_fp_set(state, PNG_FP_EXPONENT);\r\n\r\n         break;\r\n\r\n   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:\r\n         goto PNG_FP_End; ** no sign in fraction */\r\n\r\n   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:\r\n         goto PNG_FP_End; ** Because SAW_DOT is always set */\r\n\r\n      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:\r\n         png_fp_add(state, type | PNG_FP_WAS_VALID);\r\n         break;\r\n\r\n      case PNG_FP_FRACTION + PNG_FP_SAW_E:\r\n         /* This is correct because the trailing '.' on an\r\n          * integer is handled above - so we can only get here\r\n          * with the sequence \".E\" (with no preceding digits).\r\n          */\r\n         if ((state & PNG_FP_SAW_DIGIT) == 0)\r\n            goto PNG_FP_End;\r\n\r\n         png_fp_set(state, PNG_FP_EXPONENT);\r\n\r\n         break;\r\n\r\n      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:\r\n         if (state & PNG_FP_SAW_ANY)\r\n            goto PNG_FP_End; /* not a part of the number */\r\n\r\n         png_fp_add(state, PNG_FP_SAW_SIGN);\r\n\r\n         break;\r\n\r\n   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:\r\n         goto PNG_FP_End; */\r\n\r\n      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:\r\n         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);\r\n\r\n         break;\r\n\r\n   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:\r\n         goto PNG_FP_End; */\r\n\r\n      default: goto PNG_FP_End; /* I.e. break 2 */\r\n      }\r\n\r\n      /* The character seems ok, continue. */\r\n      ++i;\r\n   }\r\n\r\nPNG_FP_End:\r\n   /* Here at the end, update the state and return the correct\r\n    * return code.\r\n    */\r\n   *statep = state;\r\n   *whereami = i;\r\n\r\n   return (state & PNG_FP_SAW_DIGIT) != 0;\r\n}\r\n\r\n\r\n/* The same but for a complete string. */\r\nint\r\npng_check_fp_string(png_const_charp string, png_size_t size)\r\n{\r\n   int        state=0;\r\n   png_size_t char_index=0;\r\n\r\n   if (png_check_fp_number(string, size, &state, &char_index) &&\r\n      (char_index == size || string[char_index] == 0))\r\n      return state /* must be non-zero - see above */;\r\n\r\n   return 0; /* i.e. fail */\r\n}\r\n#endif /* pCAL or sCAL */\r\n\r\n#ifdef PNG_sCAL_SUPPORTED\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\n/* Utility used below - a simple accurate power of ten from an integral\r\n * exponent.\r\n */\r\nstatic double\r\npng_pow10(int power)\r\n{\r\n   int recip = 0;\r\n   double d = 1;\r\n\r\n   /* Handle negative exponent with a reciprocal at the end because\r\n    * 10 is exact whereas .1 is inexact in base 2\r\n    */\r\n   if (power < 0)\r\n   {\r\n      if (power < DBL_MIN_10_EXP) return 0;\r\n      recip = 1, power = -power;\r\n   }\r\n\r\n   if (power > 0)\r\n   {\r\n      /* Decompose power bitwise. */\r\n      double mult = 10;\r\n      do\r\n      {\r\n         if (power & 1) d *= mult;\r\n         mult *= mult;\r\n         power >>= 1;\r\n      }\r\n      while (power > 0);\r\n\r\n      if (recip) d = 1/d;\r\n   }\r\n   /* else power is 0 and d is 1 */\r\n\r\n   return d;\r\n}\r\n\r\n/* Function to format a floating point value in ASCII with a given\r\n * precision.\r\n */\r\nvoid /* PRIVATE */\r\npng_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, png_size_t size,\r\n    double fp, unsigned int precision)\r\n{\r\n   /* We use standard functions from math.h, but not printf because\r\n    * that would require stdio.  The caller must supply a buffer of\r\n    * sufficient size or we will png_error.  The tests on size and\r\n    * the space in ascii[] consumed are indicated below.\r\n    */\r\n   if (precision < 1)\r\n      precision = DBL_DIG;\r\n\r\n   /* Enforce the limit of the implementation precision too. */\r\n   if (precision > DBL_DIG+1)\r\n      precision = DBL_DIG+1;\r\n\r\n   /* Basic sanity checks */\r\n   if (size >= precision+5) /* See the requirements below. */\r\n   {\r\n      if (fp < 0)\r\n      {\r\n         fp = -fp;\r\n         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */\r\n         --size;\r\n      }\r\n\r\n      if (fp >= DBL_MIN && fp <= DBL_MAX)\r\n      {\r\n         int exp_b10;       /* A base 10 exponent */\r\n         double base;   /* 10^exp_b10 */\r\n\r\n         /* First extract a base 10 exponent of the number,\r\n          * the calculation below rounds down when converting\r\n          * from base 2 to base 10 (multiply by log10(2) -\r\n          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to\r\n          * be increased.  Note that the arithmetic shift\r\n          * performs a floor() unlike C arithmetic - using a\r\n          * C multiply would break the following for negative\r\n          * exponents.\r\n          */\r\n         (void)frexp(fp, &exp_b10); /* exponent to base 2 */\r\n\r\n         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */\r\n\r\n         /* Avoid underflow here. */\r\n         base = png_pow10(exp_b10); /* May underflow */\r\n\r\n         while (base < DBL_MIN || base < fp)\r\n         {\r\n            /* And this may overflow. */\r\n            double test = png_pow10(exp_b10+1);\r\n\r\n            if (test <= DBL_MAX)\r\n               ++exp_b10, base = test;\r\n\r\n            else\r\n               break;\r\n         }\r\n\r\n         /* Normalize fp and correct exp_b10, after this fp is in the\r\n          * range [.1,1) and exp_b10 is both the exponent and the digit\r\n          * *before* which the decimal point should be inserted\r\n          * (starting with 0 for the first digit).  Note that this\r\n          * works even if 10^exp_b10 is out of range because of the\r\n          * test on DBL_MAX above.\r\n          */\r\n         fp /= base;\r\n         while (fp >= 1) fp /= 10, ++exp_b10;\r\n\r\n         /* Because of the code above fp may, at this point, be\r\n          * less than .1, this is ok because the code below can\r\n          * handle the leading zeros this generates, so no attempt\r\n          * is made to correct that here.\r\n          */\r\n\r\n         {\r\n            int czero, clead, cdigits;\r\n            char exponent[10];\r\n\r\n            /* Allow up to two leading zeros - this will not lengthen\r\n             * the number compared to using E-n.\r\n             */\r\n            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */\r\n            {\r\n               czero = -exp_b10; /* PLUS 2 digits: TOTAL 3 */\r\n               exp_b10 = 0;      /* Dot added below before first output. */\r\n            }\r\n            else\r\n               czero = 0;    /* No zeros to add */\r\n\r\n            /* Generate the digit list, stripping trailing zeros and\r\n             * inserting a '.' before a digit if the exponent is 0.\r\n             */\r\n            clead = czero; /* Count of leading zeros */\r\n            cdigits = 0;   /* Count of digits in list. */\r\n\r\n            do\r\n            {\r\n               double d;\r\n\r\n               fp *= 10;\r\n               /* Use modf here, not floor and subtract, so that\r\n                * the separation is done in one step.  At the end\r\n                * of the loop don't break the number into parts so\r\n                * that the final digit is rounded.\r\n                */\r\n               if (cdigits+czero-clead+1 < (int)precision)\r\n                  fp = modf(fp, &d);\r\n\r\n               else\r\n               {\r\n                  d = floor(fp + .5);\r\n\r\n                  if (d > 9)\r\n                  {\r\n                     /* Rounding up to 10, handle that here. */\r\n                     if (czero > 0)\r\n                     {\r\n                        --czero, d = 1;\r\n                        if (cdigits == 0) --clead;\r\n                     }\r\n                     else\r\n                     {\r\n                        while (cdigits > 0 && d > 9)\r\n                        {\r\n                           int ch = *--ascii;\r\n\r\n                           if (exp_b10 != (-1))\r\n                              ++exp_b10;\r\n\r\n                           else if (ch == 46)\r\n                           {\r\n                              ch = *--ascii, ++size;\r\n                              /* Advance exp_b10 to '1', so that the\r\n                               * decimal point happens after the\r\n                               * previous digit.\r\n                               */\r\n                              exp_b10 = 1;\r\n                           }\r\n\r\n                           --cdigits;\r\n                           d = ch - 47;  /* I.e. 1+(ch-48) */\r\n                        }\r\n\r\n                        /* Did we reach the beginning? If so adjust the\r\n                         * exponent but take into account the leading\r\n                         * decimal point.\r\n                         */\r\n                        if (d > 9)  /* cdigits == 0 */\r\n                        {\r\n                           if (exp_b10 == (-1))\r\n                           {\r\n                              /* Leading decimal point (plus zeros?), if\r\n                               * we lose the decimal point here it must\r\n                               * be reentered below.\r\n                               */\r\n                              int ch = *--ascii;\r\n\r\n                              if (ch == 46)\r\n                                 ++size, exp_b10 = 1;\r\n\r\n                              /* Else lost a leading zero, so 'exp_b10' is\r\n                               * still ok at (-1)\r\n                               */\r\n                           }\r\n                           else\r\n                              ++exp_b10;\r\n\r\n                           /* In all cases we output a '1' */\r\n                           d = 1;\r\n                        }\r\n                     }\r\n                  }\r\n                  fp = 0; /* Guarantees termination below. */\r\n               }\r\n\r\n               if (d == 0)\r\n               {\r\n                  ++czero;\r\n                  if (cdigits == 0) ++clead;\r\n               }\r\n               else\r\n               {\r\n                  /* Included embedded zeros in the digit count. */\r\n                  cdigits += czero - clead;\r\n                  clead = 0;\r\n\r\n                  while (czero > 0)\r\n                  {\r\n                     /* exp_b10 == (-1) means we just output the decimal\r\n                      * place - after the DP don't adjust 'exp_b10' any\r\n                      * more!\r\n                      */\r\n                     if (exp_b10 != (-1))\r\n                     {\r\n                        if (exp_b10 == 0) *ascii++ = 46, --size;\r\n                        /* PLUS 1: TOTAL 4 */\r\n                        --exp_b10;\r\n                     }\r\n                     *ascii++ = 48, --czero;\r\n                  }\r\n\r\n                  if (exp_b10 != (-1))\r\n                  {\r\n                     if (exp_b10 == 0) *ascii++ = 46, --size; /* counted\r\n                                                                 above */\r\n                     --exp_b10;\r\n                  }\r\n                  *ascii++ = (char)(48 + (int)d), ++cdigits;\r\n               }\r\n            }\r\n            while (cdigits+czero-clead < (int)precision && fp > DBL_MIN);\r\n\r\n            /* The total output count (max) is now 4+precision */\r\n\r\n            /* Check for an exponent, if we don't need one we are\r\n             * done and just need to terminate the string.  At\r\n             * this point exp_b10==(-1) is effectively if flag - it got\r\n             * to '-1' because of the decrement after outputing\r\n             * the decimal point above (the exponent required is\r\n             * *not* -1!)\r\n             */\r\n            if (exp_b10 >= (-1) && exp_b10 <= 2)\r\n            {\r\n               /* The following only happens if we didn't output the\r\n                * leading zeros above for negative exponent, so this\r\n                * doest add to the digit requirement.  Note that the\r\n                * two zeros here can only be output if the two leading\r\n                * zeros were *not* output, so this doesn't increase\r\n                * the output count.\r\n                */\r\n               while (--exp_b10 >= 0) *ascii++ = 48;\r\n\r\n               *ascii = 0;\r\n\r\n               /* Total buffer requirement (including the '\\0') is\r\n                * 5+precision - see check at the start.\r\n                */\r\n               return;\r\n            }\r\n\r\n            /* Here if an exponent is required, adjust size for\r\n             * the digits we output but did not count.  The total\r\n             * digit output here so far is at most 1+precision - no\r\n             * decimal point and no leading or trailing zeros have\r\n             * been output.\r\n             */\r\n            size -= cdigits;\r\n\r\n            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision */\r\n\r\n            /* The following use of an unsigned temporary avoids ambiguities in\r\n             * the signed arithmetic on exp_b10 and permits GCC at least to do\r\n             * better optimization.\r\n             */\r\n            {\r\n               unsigned int uexp_b10;\r\n\r\n               if (exp_b10 < 0)\r\n               {\r\n                  *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */\r\n                  uexp_b10 = -exp_b10;\r\n               }\r\n\r\n               else\r\n                  uexp_b10 = exp_b10;\r\n\r\n               cdigits = 0;\r\n\r\n               while (uexp_b10 > 0)\r\n               {\r\n                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);\r\n                  uexp_b10 /= 10;\r\n               }\r\n            }\r\n\r\n            /* Need another size check here for the exponent digits, so\r\n             * this need not be considered above.\r\n             */\r\n            if ((int)size > cdigits)\r\n            {\r\n               while (cdigits > 0) *ascii++ = exponent[--cdigits];\r\n\r\n               *ascii = 0;\r\n\r\n               return;\r\n            }\r\n         }\r\n      }\r\n      else if (!(fp >= DBL_MIN))\r\n      {\r\n         *ascii++ = 48; /* '0' */\r\n         *ascii = 0;\r\n         return;\r\n      }\r\n      else\r\n      {\r\n         *ascii++ = 105; /* 'i' */\r\n         *ascii++ = 110; /* 'n' */\r\n         *ascii++ = 102; /* 'f' */\r\n         *ascii = 0;\r\n         return;\r\n      }\r\n   }\r\n\r\n   /* Here on buffer too small. */\r\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\r\n}\r\n\r\n#  endif /* FLOATING_POINT */\r\n\r\n#  ifdef PNG_FIXED_POINT_SUPPORTED\r\n/* Function to format a fixed point value in ASCII.\r\n */\r\nvoid /* PRIVATE */\r\npng_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii,\r\n    png_size_t size, png_fixed_point fp)\r\n{\r\n   /* Require space for 10 decimal digits, a decimal point, a minus sign and a\r\n    * trailing \\0, 13 characters:\r\n    */\r\n   if (size > 12)\r\n   {\r\n      png_uint_32 num;\r\n\r\n      /* Avoid overflow here on the minimum integer. */\r\n      if (fp < 0)\r\n         *ascii++ = 45, --size, num = -fp;\r\n      else\r\n         num = fp;\r\n\r\n      if (num <= 0x80000000) /* else overflowed */\r\n      {\r\n         unsigned int ndigits = 0, first = 16 /* flag value */;\r\n         char digits[10];\r\n\r\n         while (num)\r\n         {\r\n            /* Split the low digit off num: */\r\n            unsigned int tmp = num/10;\r\n            num -= tmp*10;\r\n            digits[ndigits++] = (char)(48 + num);\r\n            /* Record the first non-zero digit, note that this is a number\r\n             * starting at 1, it's not actually the array index.\r\n             */\r\n            if (first == 16 && num > 0)\r\n               first = ndigits;\r\n            num = tmp;\r\n         }\r\n\r\n         if (ndigits > 0)\r\n         {\r\n            while (ndigits > 5) *ascii++ = digits[--ndigits];\r\n            /* The remaining digits are fractional digits, ndigits is '5' or\r\n             * smaller at this point.  It is certainly not zero.  Check for a\r\n             * non-zero fractional digit:\r\n             */\r\n            if (first <= 5)\r\n            {\r\n               unsigned int i;\r\n               *ascii++ = 46; /* decimal point */\r\n               /* ndigits may be <5 for small numbers, output leading zeros\r\n                * then ndigits digits to first:\r\n                */\r\n               i = 5;\r\n               while (ndigits < i) *ascii++ = 48, --i;\r\n               while (ndigits >= first) *ascii++ = digits[--ndigits];\r\n               /* Don't output the trailing zeros! */\r\n            }\r\n         }\r\n         else\r\n            *ascii++ = 48;\r\n\r\n         /* And null terminate the string: */\r\n         *ascii = 0;\r\n         return;\r\n      }\r\n   }\r\n\r\n   /* Here on buffer too small. */\r\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\r\n}\r\n#   endif /* FIXED_POINT */\r\n#endif /* READ_SCAL */\r\n\r\n#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\r\n   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\r\n   (defined(PNG_gAMA_SUPPORTED) || defined(PNG_cHRM_SUPPORTED) || \\\r\n   defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\r\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)) || \\\r\n   (defined(PNG_sCAL_SUPPORTED) && \\\r\n   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED))\r\npng_fixed_point\r\npng_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)\r\n{\r\n   double r = floor(100000 * fp + .5);\r\n\r\n   if (r > 2147483647. || r < -2147483648.)\r\n      png_fixed_error(png_ptr, text);\r\n\r\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\r\n      PNG_UNUSED(text)\r\n#  endif\r\n\r\n   return (png_fixed_point)r;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\\\r\n    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)\r\n/* muldiv functions */\r\n/* This API takes signed arguments and rounds the result to the nearest\r\n * integer (or, for a fixed point number - the standard argument - to\r\n * the nearest .00001).  Overflow and divide by zero are signalled in\r\n * the result, a boolean - true on success, false on overflow.\r\n */\r\nint\r\npng_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,\r\n    png_int_32 divisor)\r\n{\r\n   /* Return a * times / divisor, rounded. */\r\n   if (divisor != 0)\r\n   {\r\n      if (a == 0 || times == 0)\r\n      {\r\n         *res = 0;\r\n         return 1;\r\n      }\r\n      else\r\n      {\r\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n         double r = a;\r\n         r *= times;\r\n         r /= divisor;\r\n         r = floor(r+.5);\r\n\r\n         /* A png_fixed_point is a 32-bit integer. */\r\n         if (r <= 2147483647. && r >= -2147483648.)\r\n         {\r\n            *res = (png_fixed_point)r;\r\n            return 1;\r\n         }\r\n#else\r\n         int negative = 0;\r\n         png_uint_32 A, T, D;\r\n         png_uint_32 s16, s32, s00;\r\n\r\n         if (a < 0)\r\n            negative = 1, A = -a;\r\n         else\r\n            A = a;\r\n\r\n         if (times < 0)\r\n            negative = !negative, T = -times;\r\n         else\r\n            T = times;\r\n\r\n         if (divisor < 0)\r\n            negative = !negative, D = -divisor;\r\n         else\r\n            D = divisor;\r\n\r\n         /* Following can't overflow because the arguments only\r\n          * have 31 bits each, however the result may be 32 bits.\r\n          */\r\n         s16 = (A >> 16) * (T & 0xffff) +\r\n                           (A & 0xffff) * (T >> 16);\r\n         /* Can't overflow because the a*times bit is only 30\r\n          * bits at most.\r\n          */\r\n         s32 = (A >> 16) * (T >> 16) + (s16 >> 16);\r\n         s00 = (A & 0xffff) * (T & 0xffff);\r\n\r\n         s16 = (s16 & 0xffff) << 16;\r\n         s00 += s16;\r\n\r\n         if (s00 < s16)\r\n            ++s32; /* carry */\r\n\r\n         if (s32 < D) /* else overflow */\r\n         {\r\n            /* s32.s00 is now the 64-bit product, do a standard\r\n             * division, we know that s32 < D, so the maximum\r\n             * required shift is 31.\r\n             */\r\n            int bitshift = 32;\r\n            png_fixed_point result = 0; /* NOTE: signed */\r\n\r\n            while (--bitshift >= 0)\r\n            {\r\n               png_uint_32 d32, d00;\r\n\r\n               if (bitshift > 0)\r\n                  d32 = D >> (32-bitshift), d00 = D << bitshift;\r\n\r\n               else\r\n                  d32 = 0, d00 = D;\r\n\r\n               if (s32 > d32)\r\n               {\r\n                  if (s00 < d00) --s32; /* carry */\r\n                  s32 -= d32, s00 -= d00, result += 1<<bitshift;\r\n               }\r\n\r\n               else\r\n                  if (s32 == d32 && s00 >= d00)\r\n                     s32 = 0, s00 -= d00, result += 1<<bitshift;\r\n            }\r\n\r\n            /* Handle the rounding. */\r\n            if (s00 >= (D >> 1))\r\n               ++result;\r\n\r\n            if (negative)\r\n               result = -result;\r\n\r\n            /* Check for overflow. */\r\n            if ((negative && result <= 0) || (!negative && result >= 0))\r\n            {\r\n               *res = result;\r\n               return 1;\r\n            }\r\n         }\r\n#endif\r\n      }\r\n   }\r\n\r\n   return 0;\r\n}\r\n#endif /* READ_GAMMA || INCH_CONVERSIONS */\r\n\r\n#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)\r\n/* The following is for when the caller doesn't much care about the\r\n * result.\r\n */\r\npng_fixed_point\r\npng_muldiv_warn(png_const_structrp png_ptr, png_fixed_point a, png_int_32 times,\r\n    png_int_32 divisor)\r\n{\r\n   png_fixed_point result;\r\n\r\n   if (png_muldiv(&result, a, times, divisor))\r\n      return result;\r\n\r\n   png_warning(png_ptr, \"fixed point overflow ignored\");\r\n   return 0;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_GAMMA_SUPPORTED /* more fixed point functions for gamma */\r\n/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */\r\npng_fixed_point\r\npng_reciprocal(png_fixed_point a)\r\n{\r\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n   double r = floor(1E10/a+.5);\r\n\r\n   if (r <= 2147483647. && r >= -2147483648.)\r\n      return (png_fixed_point)r;\r\n#else\r\n   png_fixed_point res;\r\n\r\n   if (png_muldiv(&res, 100000, 100000, a))\r\n      return res;\r\n#endif\r\n\r\n   return 0; /* error/overflow */\r\n}\r\n\r\n/* This is the shared test on whether a gamma value is 'significant' - whether\r\n * it is worth doing gamma correction.\r\n */\r\nint /* PRIVATE */\r\npng_gamma_significant(png_fixed_point gamma_val)\r\n{\r\n   return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||\r\n       gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n#  ifdef PNG_16BIT_SUPPORTED\r\n/* A local convenience routine. */\r\nstatic png_fixed_point\r\npng_product2(png_fixed_point a, png_fixed_point b)\r\n{\r\n   /* The required result is 1/a * 1/b; the following preserves accuracy. */\r\n#    ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n   double r = a * 1E-5;\r\n   r *= b;\r\n   r = floor(r+.5);\r\n\r\n   if (r <= 2147483647. && r >= -2147483648.)\r\n      return (png_fixed_point)r;\r\n#    else\r\n   png_fixed_point res;\r\n\r\n   if (png_muldiv(&res, a, b, 100000))\r\n      return res;\r\n#    endif\r\n\r\n   return 0; /* overflow */\r\n}\r\n#  endif /* 16BIT */\r\n\r\n/* The inverse of the above. */\r\npng_fixed_point\r\npng_reciprocal2(png_fixed_point a, png_fixed_point b)\r\n{\r\n   /* The required result is 1/a * 1/b; the following preserves accuracy. */\r\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n   double r = 1E15/a;\r\n   r /= b;\r\n   r = floor(r+.5);\r\n\r\n   if (r <= 2147483647. && r >= -2147483648.)\r\n      return (png_fixed_point)r;\r\n#else\r\n   /* This may overflow because the range of png_fixed_point isn't symmetric,\r\n    * but this API is only used for the product of file and screen gamma so it\r\n    * doesn't matter that the smallest number it can produce is 1/21474, not\r\n    * 1/100000\r\n    */\r\n   png_fixed_point res = png_product2(a, b);\r\n\r\n   if (res != 0)\r\n      return png_reciprocal(res);\r\n#endif\r\n\r\n   return 0; /* overflow */\r\n}\r\n#endif /* READ_GAMMA */\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED /* gamma table code */\r\n#ifndef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n/* Fixed point gamma.\r\n *\r\n * The code to calculate the tables used below can be found in the shell script\r\n * contrib/tools/intgamma.sh\r\n *\r\n * To calculate gamma this code implements fast log() and exp() calls using only\r\n * fixed point arithmetic.  This code has sufficient precision for either 8-bit\r\n * or 16-bit sample values.\r\n *\r\n * The tables used here were calculated using simple 'bc' programs, but C double\r\n * precision floating point arithmetic would work fine.\r\n *\r\n * 8-bit log table\r\n *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to\r\n *   255, so it's the base 2 logarithm of a normalized 8-bit floating point\r\n *   mantissa.  The numbers are 32-bit fractions.\r\n */\r\nstatic const png_uint_32\r\npng_8bit_l2[128] =\r\n{\r\n   4270715492U, 4222494797U, 4174646467U, 4127164793U, 4080044201U, 4033279239U,\r\n   3986864580U, 3940795015U, 3895065449U, 3849670902U, 3804606499U, 3759867474U,\r\n   3715449162U, 3671346997U, 3627556511U, 3584073329U, 3540893168U, 3498011834U,\r\n   3455425220U, 3413129301U, 3371120137U, 3329393864U, 3287946700U, 3246774933U,\r\n   3205874930U, 3165243125U, 3124876025U, 3084770202U, 3044922296U, 3005329011U,\r\n   2965987113U, 2926893432U, 2888044853U, 2849438323U, 2811070844U, 2772939474U,\r\n   2735041326U, 2697373562U, 2659933400U, 2622718104U, 2585724991U, 2548951424U,\r\n   2512394810U, 2476052606U, 2439922311U, 2404001468U, 2368287663U, 2332778523U,\r\n   2297471715U, 2262364947U, 2227455964U, 2192742551U, 2158222529U, 2123893754U,\r\n   2089754119U, 2055801552U, 2022034013U, 1988449497U, 1955046031U, 1921821672U,\r\n   1888774511U, 1855902668U, 1823204291U, 1790677560U, 1758320682U, 1726131893U,\r\n   1694109454U, 1662251657U, 1630556815U, 1599023271U, 1567649391U, 1536433567U,\r\n   1505374214U, 1474469770U, 1443718700U, 1413119487U, 1382670639U, 1352370686U,\r\n   1322218179U, 1292211689U, 1262349810U, 1232631153U, 1203054352U, 1173618059U,\r\n   1144320946U, 1115161701U, 1086139034U, 1057251672U, 1028498358U, 999877854U,\r\n   971388940U, 943030410U, 914801076U, 886699767U, 858725327U, 830876614U,\r\n   803152505U, 775551890U, 748073672U, 720716771U, 693480120U, 666362667U,\r\n   639363374U, 612481215U, 585715177U, 559064263U, 532527486U, 506103872U,\r\n   479792461U, 453592303U, 427502463U, 401522014U, 375650043U, 349885648U,\r\n   324227938U, 298676034U, 273229066U, 247886176U, 222646516U, 197509248U,\r\n   172473545U, 147538590U, 122703574U, 97967701U, 73330182U, 48790236U,\r\n   24347096U, 0U\r\n\r\n#if 0\r\n   /* The following are the values for 16-bit tables - these work fine for the\r\n    * 8-bit conversions but produce very slightly larger errors in the 16-bit\r\n    * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To\r\n    * use these all the shifts below must be adjusted appropriately.\r\n    */\r\n   65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,\r\n   57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,\r\n   50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,\r\n   43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,\r\n   37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,\r\n   31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,\r\n   25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,\r\n   20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,\r\n   15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,\r\n   10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,\r\n   6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,\r\n   1119, 744, 372\r\n#endif\r\n};\r\n\r\nstatic png_int_32\r\npng_log8bit(unsigned int x)\r\n{\r\n   unsigned int lg2 = 0;\r\n   /* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,\r\n    * because the log is actually negate that means adding 1.  The final\r\n    * returned value thus has the range 0 (for 255 input) to 7.994 (for 1\r\n    * input), return -1 for the overflow (log 0) case, - so the result is\r\n    * always at most 19 bits.\r\n    */\r\n   if ((x &= 0xff) == 0)\r\n      return -1;\r\n\r\n   if ((x & 0xf0) == 0)\r\n      lg2  = 4, x <<= 4;\r\n\r\n   if ((x & 0xc0) == 0)\r\n      lg2 += 2, x <<= 2;\r\n\r\n   if ((x & 0x80) == 0)\r\n      lg2 += 1, x <<= 1;\r\n\r\n   /* result is at most 19 bits, so this cast is safe: */\r\n   return (png_int_32)((lg2 << 16) + ((png_8bit_l2[x-128]+32768)>>16));\r\n}\r\n\r\n/* The above gives exact (to 16 binary places) log2 values for 8-bit images,\r\n * for 16-bit images we use the most significant 8 bits of the 16-bit value to\r\n * get an approximation then multiply the approximation by a correction factor\r\n * determined by the remaining up to 8 bits.  This requires an additional step\r\n * in the 16-bit case.\r\n *\r\n * We want log2(value/65535), we have log2(v'/255), where:\r\n *\r\n *    value = v' * 256 + v''\r\n *          = v' * f\r\n *\r\n * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128\r\n * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less\r\n * than 258.  The final factor also needs to correct for the fact that our 8-bit\r\n * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.\r\n *\r\n * This gives a final formula using a calculated value 'x' which is value/v' and\r\n * scaling by 65536 to match the above table:\r\n *\r\n *   log2(x/257) * 65536\r\n *\r\n * Since these numbers are so close to '1' we can use simple linear\r\n * interpolation between the two end values 256/257 (result -368.61) and 258/257\r\n * (result 367.179).  The values used below are scaled by a further 64 to give\r\n * 16-bit precision in the interpolation:\r\n *\r\n * Start (256): -23591\r\n * Zero  (257):      0\r\n * End   (258):  23499\r\n */\r\nstatic png_int_32\r\npng_log16bit(png_uint_32 x)\r\n{\r\n   unsigned int lg2 = 0;\r\n\r\n   /* As above, but now the input has 16 bits. */\r\n   if ((x &= 0xffff) == 0)\r\n      return -1;\r\n\r\n   if ((x & 0xff00) == 0)\r\n      lg2  = 8, x <<= 8;\r\n\r\n   if ((x & 0xf000) == 0)\r\n      lg2 += 4, x <<= 4;\r\n\r\n   if ((x & 0xc000) == 0)\r\n      lg2 += 2, x <<= 2;\r\n\r\n   if ((x & 0x8000) == 0)\r\n      lg2 += 1, x <<= 1;\r\n\r\n   /* Calculate the base logarithm from the top 8 bits as a 28-bit fractional\r\n    * value.\r\n    */\r\n   lg2 <<= 28;\r\n   lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\r\n\r\n   /* Now we need to interpolate the factor, this requires a division by the top\r\n    * 8 bits.  Do this with maximum precision.\r\n    */\r\n   x = ((x << 16) + (x >> 9)) / (x >> 8);\r\n\r\n   /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\r\n    * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\r\n    * 16 bits to interpolate to get the low bits of the result.  Round the\r\n    * answer.  Note that the end point values are scaled by 64 to retain overall\r\n    * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\r\n    * the overall scaling by 6-12.  Round at every step.\r\n    */\r\n   x -= 1U << 24;\r\n\r\n   if (x <= 65536U) /* <= '257' */\r\n      lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);\r\n\r\n   else\r\n      lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);\r\n\r\n   /* Safe, because the result can't have more than 20 bits: */\r\n   return (png_int_32)((lg2 + 2048) >> 12);\r\n}\r\n\r\n/* The 'exp()' case must invert the above, taking a 20-bit fixed point\r\n * logarithmic value and returning a 16 or 8-bit number as appropriate.  In\r\n * each case only the low 16 bits are relevant - the fraction - since the\r\n * integer bits (the top 4) simply determine a shift.\r\n *\r\n * The worst case is the 16-bit distinction between 65535 and 65534, this\r\n * requires perhaps spurious accuracty in the decoding of the logarithm to\r\n * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance\r\n * of getting this accuracy in practice.\r\n *\r\n * To deal with this the following exp() function works out the exponent of the\r\n * frational part of the logarithm by using an accurate 32-bit value from the\r\n * top four fractional bits then multiplying in the remaining bits.\r\n */\r\nstatic const png_uint_32\r\npng_32bit_exp[16] =\r\n{\r\n   /* NOTE: the first entry is deliberately set to the maximum 32-bit value. */\r\n   4294967295U, 4112874773U, 3938502376U, 3771522796U, 3611622603U, 3458501653U,\r\n   3311872529U, 3171459999U, 3037000500U, 2908241642U, 2784941738U, 2666869345U,\r\n   2553802834U, 2445529972U, 2341847524U, 2242560872U\r\n};\r\n\r\n/* Adjustment table; provided to explain the numbers in the code below. */\r\n#if 0\r\nfor (i=11;i>=0;--i){ print i, \" \", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), \"\\n\"}\r\n   11 44937.64284865548751208448\r\n   10 45180.98734845585101160448\r\n    9 45303.31936980687359311872\r\n    8 45364.65110595323018870784\r\n    7 45395.35850361789624614912\r\n    6 45410.72259715102037508096\r\n    5 45418.40724413220722311168\r\n    4 45422.25021786898173001728\r\n    3 45424.17186732298419044352\r\n    2 45425.13273269940811464704\r\n    1 45425.61317555035558641664\r\n    0 45425.85339951654943850496\r\n#endif\r\n\r\nstatic png_uint_32\r\npng_exp(png_fixed_point x)\r\n{\r\n   if (x > 0 && x <= 0xfffff) /* Else overflow or zero (underflow) */\r\n   {\r\n      /* Obtain a 4-bit approximation */\r\n      png_uint_32 e = png_32bit_exp[(x >> 12) & 0xf];\r\n\r\n      /* Incorporate the low 12 bits - these decrease the returned value by\r\n       * multiplying by a number less than 1 if the bit is set.  The multiplier\r\n       * is determined by the above table and the shift. Notice that the values\r\n       * converge on 45426 and this is used to allow linear interpolation of the\r\n       * low bits.\r\n       */\r\n      if (x & 0x800)\r\n         e -= (((e >> 16) * 44938U) +  16U) >> 5;\r\n\r\n      if (x & 0x400)\r\n         e -= (((e >> 16) * 45181U) +  32U) >> 6;\r\n\r\n      if (x & 0x200)\r\n         e -= (((e >> 16) * 45303U) +  64U) >> 7;\r\n\r\n      if (x & 0x100)\r\n         e -= (((e >> 16) * 45365U) + 128U) >> 8;\r\n\r\n      if (x & 0x080)\r\n         e -= (((e >> 16) * 45395U) + 256U) >> 9;\r\n\r\n      if (x & 0x040)\r\n         e -= (((e >> 16) * 45410U) + 512U) >> 10;\r\n\r\n      /* And handle the low 6 bits in a single block. */\r\n      e -= (((e >> 16) * 355U * (x & 0x3fU)) + 256U) >> 9;\r\n\r\n      /* Handle the upper bits of x. */\r\n      e >>= x >> 16;\r\n      return e;\r\n   }\r\n\r\n   /* Check for overflow */\r\n   if (x <= 0)\r\n      return png_32bit_exp[0];\r\n\r\n   /* Else underflow */\r\n   return 0;\r\n}\r\n\r\nstatic png_byte\r\npng_exp8bit(png_fixed_point lg2)\r\n{\r\n   /* Get a 32-bit value: */\r\n   png_uint_32 x = png_exp(lg2);\r\n\r\n   /* Convert the 32-bit value to 0..255 by multiplying by 256-1, note that the\r\n    * second, rounding, step can't overflow because of the first, subtraction,\r\n    * step.\r\n    */\r\n   x -= x >> 8;\r\n   return (png_byte)((x + 0x7fffffU) >> 24);\r\n}\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\nstatic png_uint_16\r\npng_exp16bit(png_fixed_point lg2)\r\n{\r\n   /* Get a 32-bit value: */\r\n   png_uint_32 x = png_exp(lg2);\r\n\r\n   /* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */\r\n   x -= x >> 16;\r\n   return (png_uint_16)((x + 32767U) >> 16);\r\n}\r\n#endif /* 16BIT */\r\n#endif /* FLOATING_ARITHMETIC */\r\n\r\npng_byte\r\npng_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)\r\n{\r\n   if (value > 0 && value < 255)\r\n   {\r\n#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n         double r = floor(255*pow(value/255.,gamma_val*.00001)+.5);\r\n         return (png_byte)r;\r\n#     else\r\n         png_int_32 lg2 = png_log8bit(value);\r\n         png_fixed_point res;\r\n\r\n         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1))\r\n            return png_exp8bit(res);\r\n\r\n         /* Overflow. */\r\n         value = 0;\r\n#     endif\r\n   }\r\n\r\n   return (png_byte)value;\r\n}\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\npng_uint_16\r\npng_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)\r\n{\r\n   if (value > 0 && value < 65535)\r\n   {\r\n#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n         double r = floor(65535*pow(value/65535.,gamma_val*.00001)+.5);\r\n         return (png_uint_16)r;\r\n#     else\r\n         png_int_32 lg2 = png_log16bit(value);\r\n         png_fixed_point res;\r\n\r\n         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1))\r\n            return png_exp16bit(res);\r\n\r\n         /* Overflow. */\r\n         value = 0;\r\n#     endif\r\n   }\r\n\r\n   return (png_uint_16)value;\r\n}\r\n#endif /* 16BIT */\r\n\r\n/* This does the right thing based on the bit_depth field of the\r\n * png_struct, interpreting values as 8-bit or 16-bit.  While the result\r\n * is nominally a 16-bit value if bit depth is 8 then the result is\r\n * 8-bit (as are the arguments.)\r\n */\r\npng_uint_16 /* PRIVATE */\r\npng_gamma_correct(png_structrp png_ptr, unsigned int value,\r\n    png_fixed_point gamma_val)\r\n{\r\n   if (png_ptr->bit_depth == 8)\r\n      return png_gamma_8bit_correct(value, gamma_val);\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n   else\r\n      return png_gamma_16bit_correct(value, gamma_val);\r\n#else\r\n      /* should not reach this */\r\n      return 0;\r\n#endif /* 16BIT */\r\n}\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n/* Internal function to build a single 16-bit table - the table consists of\r\n * 'num' 256 entry subtables, where 'num' is determined by 'shift' - the amount\r\n * to shift the input values right (or 16-number_of_signifiant_bits).\r\n *\r\n * The caller is responsible for ensuring that the table gets cleaned up on\r\n * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument\r\n * should be somewhere that will be cleaned.\r\n */\r\nstatic void\r\npng_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,\r\n   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)\r\n{\r\n   /* Various values derived from 'shift': */\r\n   PNG_CONST unsigned int num = 1U << (8U - shift);\r\n   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;\r\n   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);\r\n   unsigned int i;\r\n\r\n   png_uint_16pp table = *ptable =\r\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\r\n\r\n   for (i = 0; i < num; i++)\r\n   {\r\n      png_uint_16p sub_table = table[i] =\r\n          (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));\r\n\r\n      /* The 'threshold' test is repeated here because it can arise for one of\r\n       * the 16-bit tables even if the others don't hit it.\r\n       */\r\n      if (png_gamma_significant(gamma_val))\r\n      {\r\n         /* The old code would overflow at the end and this would cause the\r\n          * 'pow' function to return a result >1, resulting in an\r\n          * arithmetic error.  This code follows the spec exactly; ig is\r\n          * the recovered input sample, it always has 8-16 bits.\r\n          *\r\n          * We want input * 65535/max, rounded, the arithmetic fits in 32\r\n          * bits (unsigned) so long as max <= 32767.\r\n          */\r\n         unsigned int j;\r\n         for (j = 0; j < 256; j++)\r\n         {\r\n            png_uint_32 ig = (j << (8-shift)) + i;\r\n#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\r\n               /* Inline the 'max' scaling operation: */\r\n               double d = floor(65535*pow(ig/(double)max, gamma_val*.00001)+.5);\r\n               sub_table[j] = (png_uint_16)d;\r\n#           else\r\n               if (shift)\r\n                  ig = (ig * 65535U + max_by_2)/max;\r\n\r\n               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);\r\n#           endif\r\n         }\r\n      }\r\n      else\r\n      {\r\n         /* We must still build a table, but do it the fast way. */\r\n         unsigned int j;\r\n\r\n         for (j = 0; j < 256; j++)\r\n         {\r\n            png_uint_32 ig = (j << (8-shift)) + i;\r\n\r\n            if (shift)\r\n               ig = (ig * 65535U + max_by_2)/max;\r\n\r\n            sub_table[j] = (png_uint_16)ig;\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\n/* NOTE: this function expects the *inverse* of the overall gamma transformation\r\n * required.\r\n */\r\nstatic void\r\npng_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,\r\n   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)\r\n{\r\n   PNG_CONST unsigned int num = 1U << (8U - shift);\r\n   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;\r\n   unsigned int i;\r\n   png_uint_32 last;\r\n\r\n   png_uint_16pp table = *ptable =\r\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\r\n\r\n   /* 'num' is the number of tables and also the number of low bits of low\r\n    * bits of the input 16-bit value used to select a table.  Each table is\r\n    * itself index by the high 8 bits of the value.\r\n    */\r\n   for (i = 0; i < num; i++)\r\n      table[i] = (png_uint_16p)png_malloc(png_ptr,\r\n          256 * (sizeof (png_uint_16)));\r\n\r\n   /* 'gamma_val' is set to the reciprocal of the value calculated above, so\r\n    * pow(out,g) is an *input* value.  'last' is the last input value set.\r\n    *\r\n    * In the loop 'i' is used to find output values.  Since the output is\r\n    * 8-bit there are only 256 possible values.  The tables are set up to\r\n    * select the closest possible output value for each input by finding\r\n    * the input value at the boundary between each pair of output values\r\n    * and filling the table up to that boundary with the lower output\r\n    * value.\r\n    *\r\n    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit\r\n    * values the code below uses a 16-bit value in i; the values start at\r\n    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last\r\n    * entries are filled with 255).  Start i at 128 and fill all 'last'\r\n    * table entries <= 'max'\r\n    */\r\n   last = 0;\r\n   for (i = 0; i < 255; ++i) /* 8-bit output value */\r\n   {\r\n      /* Find the corresponding maximum input value */\r\n      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */\r\n\r\n      /* Find the boundary value in 16 bits: */\r\n      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);\r\n\r\n      /* Adjust (round) to (16-shift) bits: */\r\n      bound = (bound * max + 32768U)/65535U + 1U;\r\n\r\n      while (last < bound)\r\n      {\r\n         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;\r\n         last++;\r\n      }\r\n   }\r\n\r\n   /* And fill in the final entries. */\r\n   while (last < (num << 8))\r\n   {\r\n      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;\r\n      last++;\r\n   }\r\n}\r\n#endif /* 16BIT */\r\n\r\n/* Build a single 8-bit table: same as the 16-bit case but much simpler (and\r\n * typically much faster).  Note that libpng currently does no sBIT processing\r\n * (apparently contrary to the spec) so a 256 entry table is always generated.\r\n */\r\nstatic void\r\npng_build_8bit_table(png_structrp png_ptr, png_bytepp ptable,\r\n   PNG_CONST png_fixed_point gamma_val)\r\n{\r\n   unsigned int i;\r\n   png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);\r\n\r\n   if (png_gamma_significant(gamma_val)) for (i=0; i<256; i++)\r\n      table[i] = png_gamma_8bit_correct(i, gamma_val);\r\n\r\n   else for (i=0; i<256; ++i)\r\n      table[i] = (png_byte)i;\r\n}\r\n\r\n/* Used from png_read_destroy and below to release the memory used by the gamma\r\n * tables.\r\n */\r\nvoid /* PRIVATE */\r\npng_destroy_gamma_table(png_structrp png_ptr)\r\n{\r\n   png_free(png_ptr, png_ptr->gamma_table);\r\n   png_ptr->gamma_table = NULL;\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n   if (png_ptr->gamma_16_table != NULL)\r\n   {\r\n      int i;\r\n      int istop = (1 << (8 - png_ptr->gamma_shift));\r\n      for (i = 0; i < istop; i++)\r\n      {\r\n         png_free(png_ptr, png_ptr->gamma_16_table[i]);\r\n      }\r\n   png_free(png_ptr, png_ptr->gamma_16_table);\r\n   png_ptr->gamma_16_table = NULL;\r\n   }\r\n#endif /* 16BIT */\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\r\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\r\n   png_free(png_ptr, png_ptr->gamma_from_1);\r\n   png_ptr->gamma_from_1 = NULL;\r\n   png_free(png_ptr, png_ptr->gamma_to_1);\r\n   png_ptr->gamma_to_1 = NULL;\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n   if (png_ptr->gamma_16_from_1 != NULL)\r\n   {\r\n      int i;\r\n      int istop = (1 << (8 - png_ptr->gamma_shift));\r\n      for (i = 0; i < istop; i++)\r\n      {\r\n         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);\r\n      }\r\n   png_free(png_ptr, png_ptr->gamma_16_from_1);\r\n   png_ptr->gamma_16_from_1 = NULL;\r\n   }\r\n   if (png_ptr->gamma_16_to_1 != NULL)\r\n   {\r\n      int i;\r\n      int istop = (1 << (8 - png_ptr->gamma_shift));\r\n      for (i = 0; i < istop; i++)\r\n      {\r\n         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);\r\n      }\r\n   png_free(png_ptr, png_ptr->gamma_16_to_1);\r\n   png_ptr->gamma_16_to_1 = NULL;\r\n   }\r\n#endif /* 16BIT */\r\n#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */\r\n}\r\n\r\n/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit\r\n * tables, we don't make a full table if we are reducing to 8-bit in\r\n * the future.  Note also how the gamma_16 tables are segmented so that\r\n * we don't need to allocate > 64K chunks for a full 16-bit table.\r\n */\r\nvoid /* PRIVATE */\r\npng_build_gamma_table(png_structrp png_ptr, int bit_depth)\r\n{\r\n  png_debug(1, \"in png_build_gamma_table\");\r\n\r\n  /* Remove any existing table; this copes with multiple calls to\r\n   * png_read_update_info.  The warning is because building the gamma tables\r\n   * multiple times is a performance hit - it's harmless but the ability to call\r\n   * png_read_update_info() multiple times is new in 1.5.6 so it seems sensible\r\n   * to warn if the app introduces such a hit.\r\n   */\r\n  if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)\r\n  {\r\n    png_warning(png_ptr, \"gamma table being rebuilt\");\r\n    png_destroy_gamma_table(png_ptr);\r\n  }\r\n\r\n  if (bit_depth <= 8)\r\n  {\r\n     png_build_8bit_table(png_ptr, &png_ptr->gamma_table,\r\n         png_ptr->screen_gamma > 0 ?  png_reciprocal2(png_ptr->colorspace.gamma,\r\n         png_ptr->screen_gamma) : PNG_FP_1);\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\r\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\r\n     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))\r\n     {\r\n        png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,\r\n            png_reciprocal(png_ptr->colorspace.gamma));\r\n\r\n        png_build_8bit_table(png_ptr, &png_ptr->gamma_from_1,\r\n            png_ptr->screen_gamma > 0 ?  png_reciprocal(png_ptr->screen_gamma) :\r\n            png_ptr->colorspace.gamma/* Probably doing rgb_to_gray */);\r\n     }\r\n#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */\r\n  }\r\n#ifdef PNG_16BIT_SUPPORTED\r\n  else\r\n  {\r\n     png_byte shift, sig_bit;\r\n\r\n     if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n     {\r\n        sig_bit = png_ptr->sig_bit.red;\r\n\r\n        if (png_ptr->sig_bit.green > sig_bit)\r\n           sig_bit = png_ptr->sig_bit.green;\r\n\r\n        if (png_ptr->sig_bit.blue > sig_bit)\r\n           sig_bit = png_ptr->sig_bit.blue;\r\n     }\r\n     else\r\n        sig_bit = png_ptr->sig_bit.gray;\r\n\r\n     /* 16-bit gamma code uses this equation:\r\n      *\r\n      *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]\r\n      *\r\n      * Where 'iv' is the input color value and 'ov' is the output value -\r\n      * pow(iv, gamma).\r\n      *\r\n      * Thus the gamma table consists of up to 256 256 entry tables.  The table\r\n      * is selected by the (8-gamma_shift) most significant of the low 8 bits of\r\n      * the color value then indexed by the upper 8 bits:\r\n      *\r\n      *   table[low bits][high 8 bits]\r\n      *\r\n      * So the table 'n' corresponds to all those 'iv' of:\r\n      *\r\n      *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>\r\n      *\r\n      */\r\n     if (sig_bit > 0 && sig_bit < 16U)\r\n        shift = (png_byte)(16U - sig_bit); /* shift == insignificant bits */\r\n\r\n     else\r\n        shift = 0; /* keep all 16 bits */\r\n\r\n     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))\r\n     {\r\n        /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively\r\n         * the significant bits in the *input* when the output will\r\n         * eventually be 8 bits.  By default it is 11.\r\n         */\r\n        if (shift < (16U - PNG_MAX_GAMMA_8))\r\n           shift = (16U - PNG_MAX_GAMMA_8);\r\n     }\r\n\r\n     if (shift > 8U)\r\n        shift = 8U; /* Guarantees at least one table! */\r\n\r\n     png_ptr->gamma_shift = shift;\r\n\r\n     /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now\r\n      * PNG_COMPOSE).  This effectively smashed the background calculation for\r\n      * 16-bit output because the 8-bit table assumes the result will be reduced\r\n      * to 8 bits.\r\n      */\r\n     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))\r\n         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,\r\n         png_ptr->screen_gamma > 0 ? png_product2(png_ptr->colorspace.gamma,\r\n         png_ptr->screen_gamma) : PNG_FP_1);\r\n\r\n     else\r\n         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,\r\n         png_ptr->screen_gamma > 0 ? png_reciprocal2(png_ptr->colorspace.gamma,\r\n         png_ptr->screen_gamma) : PNG_FP_1);\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\r\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\r\n     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))\r\n     {\r\n        png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,\r\n            png_reciprocal(png_ptr->colorspace.gamma));\r\n\r\n        /* Notice that the '16 from 1' table should be full precision, however\r\n         * the lookup on this table still uses gamma_shift, so it can't be.\r\n         * TODO: fix this.\r\n         */\r\n        png_build_16bit_table(png_ptr, &png_ptr->gamma_16_from_1, shift,\r\n            png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :\r\n            png_ptr->colorspace.gamma/* Probably doing rgb_to_gray */);\r\n     }\r\n#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */\r\n  }\r\n#endif /* 16BIT */\r\n}\r\n#endif /* READ_GAMMA */\r\n\r\n/* HARDWARE OPTION SUPPORT */\r\n#ifdef PNG_SET_OPTION_SUPPORTED\r\nint PNGAPI\r\npng_set_option(png_structrp png_ptr, int option, int onoff)\r\n{\r\n   if (png_ptr != NULL && option >= 0 && option < PNG_OPTION_NEXT &&\r\n      (option & 1) == 0)\r\n   {\r\n      int mask = 3 << option;\r\n      int setting = (2 + (onoff != 0)) << option;\r\n      int current = png_ptr->options;\r\n\r\n      png_ptr->options = (png_byte)((current & ~mask) | setting);\r\n\r\n      return (current & mask) >> option;\r\n   }\r\n\r\n   return PNG_OPTION_INVALID;\r\n}\r\n#endif\r\n\r\n/* sRGB support */\r\n#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\\\r\n   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)\r\n/* sRGB conversion tables; these are machine generated with the code in\r\n * contrib/tools/makesRGB.c.  The actual sRGB transfer curve defined in the\r\n * specification (see the article at http://en.wikipedia.org/wiki/SRGB)\r\n * is used, not the gamma=1/2.2 approximation use elsewhere in libpng.\r\n * The sRGB to linear table is exact (to the nearest 16 bit linear fraction).\r\n * The inverse (linear to sRGB) table has accuracies as follows:\r\n *\r\n * For all possible (255*65535+1) input values:\r\n *\r\n *    error: -0.515566 - 0.625971, 79441 (0.475369%) of readings inexact\r\n *\r\n * For the input values corresponding to the 65536 16-bit values:\r\n *\r\n *    error: -0.513727 - 0.607759, 308 (0.469978%) of readings inexact\r\n *\r\n * In all cases the inexact readings are off by one.\r\n */\r\n\r\n#ifdef PNG_SIMPLIFIED_READ_SUPPORTED\r\n/* The convert-to-sRGB table is only currently required for read. */\r\nconst png_uint_16 png_sRGB_table[256] =\r\n{\r\n   0,20,40,60,80,99,119,139,\r\n   159,179,199,219,241,264,288,313,\r\n   340,367,396,427,458,491,526,562,\r\n   599,637,677,718,761,805,851,898,\r\n   947,997,1048,1101,1156,1212,1270,1330,\r\n   1391,1453,1517,1583,1651,1720,1790,1863,\r\n   1937,2013,2090,2170,2250,2333,2418,2504,\r\n   2592,2681,2773,2866,2961,3058,3157,3258,\r\n   3360,3464,3570,3678,3788,3900,4014,4129,\r\n   4247,4366,4488,4611,4736,4864,4993,5124,\r\n   5257,5392,5530,5669,5810,5953,6099,6246,\r\n   6395,6547,6700,6856,7014,7174,7335,7500,\r\n   7666,7834,8004,8177,8352,8528,8708,8889,\r\n   9072,9258,9445,9635,9828,10022,10219,10417,\r\n   10619,10822,11028,11235,11446,11658,11873,12090,\r\n   12309,12530,12754,12980,13209,13440,13673,13909,\r\n   14146,14387,14629,14874,15122,15371,15623,15878,\r\n   16135,16394,16656,16920,17187,17456,17727,18001,\r\n   18277,18556,18837,19121,19407,19696,19987,20281,\r\n   20577,20876,21177,21481,21787,22096,22407,22721,\r\n   23038,23357,23678,24002,24329,24658,24990,25325,\r\n   25662,26001,26344,26688,27036,27386,27739,28094,\r\n   28452,28813,29176,29542,29911,30282,30656,31033,\r\n   31412,31794,32179,32567,32957,33350,33745,34143,\r\n   34544,34948,35355,35764,36176,36591,37008,37429,\r\n   37852,38278,38706,39138,39572,40009,40449,40891,\r\n   41337,41785,42236,42690,43147,43606,44069,44534,\r\n   45002,45473,45947,46423,46903,47385,47871,48359,\r\n   48850,49344,49841,50341,50844,51349,51858,52369,\r\n   52884,53401,53921,54445,54971,55500,56032,56567,\r\n   57105,57646,58190,58737,59287,59840,60396,60955,\r\n   61517,62082,62650,63221,63795,64372,64952,65535\r\n};\r\n\r\n#endif /* simplified read only */\r\n\r\n/* The base/delta tables are required for both read and write (but currently\r\n * only the simplified versions.)\r\n */\r\nconst png_uint_16 png_sRGB_base[512] =\r\n{\r\n   128,1782,3383,4644,5675,6564,7357,8074,\r\n   8732,9346,9921,10463,10977,11466,11935,12384,\r\n   12816,13233,13634,14024,14402,14769,15125,15473,\r\n   15812,16142,16466,16781,17090,17393,17690,17981,\r\n   18266,18546,18822,19093,19359,19621,19879,20133,\r\n   20383,20630,20873,21113,21349,21583,21813,22041,\r\n   22265,22487,22707,22923,23138,23350,23559,23767,\r\n   23972,24175,24376,24575,24772,24967,25160,25352,\r\n   25542,25730,25916,26101,26284,26465,26645,26823,\r\n   27000,27176,27350,27523,27695,27865,28034,28201,\r\n   28368,28533,28697,28860,29021,29182,29341,29500,\r\n   29657,29813,29969,30123,30276,30429,30580,30730,\r\n   30880,31028,31176,31323,31469,31614,31758,31902,\r\n   32045,32186,32327,32468,32607,32746,32884,33021,\r\n   33158,33294,33429,33564,33697,33831,33963,34095,\r\n   34226,34357,34486,34616,34744,34873,35000,35127,\r\n   35253,35379,35504,35629,35753,35876,35999,36122,\r\n   36244,36365,36486,36606,36726,36845,36964,37083,\r\n   37201,37318,37435,37551,37668,37783,37898,38013,\r\n   38127,38241,38354,38467,38580,38692,38803,38915,\r\n   39026,39136,39246,39356,39465,39574,39682,39790,\r\n   39898,40005,40112,40219,40325,40431,40537,40642,\r\n   40747,40851,40955,41059,41163,41266,41369,41471,\r\n   41573,41675,41777,41878,41979,42079,42179,42279,\r\n   42379,42478,42577,42676,42775,42873,42971,43068,\r\n   43165,43262,43359,43456,43552,43648,43743,43839,\r\n   43934,44028,44123,44217,44311,44405,44499,44592,\r\n   44685,44778,44870,44962,45054,45146,45238,45329,\r\n   45420,45511,45601,45692,45782,45872,45961,46051,\r\n   46140,46229,46318,46406,46494,46583,46670,46758,\r\n   46846,46933,47020,47107,47193,47280,47366,47452,\r\n   47538,47623,47709,47794,47879,47964,48048,48133,\r\n   48217,48301,48385,48468,48552,48635,48718,48801,\r\n   48884,48966,49048,49131,49213,49294,49376,49458,\r\n   49539,49620,49701,49782,49862,49943,50023,50103,\r\n   50183,50263,50342,50422,50501,50580,50659,50738,\r\n   50816,50895,50973,51051,51129,51207,51285,51362,\r\n   51439,51517,51594,51671,51747,51824,51900,51977,\r\n   52053,52129,52205,52280,52356,52432,52507,52582,\r\n   52657,52732,52807,52881,52956,53030,53104,53178,\r\n   53252,53326,53400,53473,53546,53620,53693,53766,\r\n   53839,53911,53984,54056,54129,54201,54273,54345,\r\n   54417,54489,54560,54632,54703,54774,54845,54916,\r\n   54987,55058,55129,55199,55269,55340,55410,55480,\r\n   55550,55620,55689,55759,55828,55898,55967,56036,\r\n   56105,56174,56243,56311,56380,56448,56517,56585,\r\n   56653,56721,56789,56857,56924,56992,57059,57127,\r\n   57194,57261,57328,57395,57462,57529,57595,57662,\r\n   57728,57795,57861,57927,57993,58059,58125,58191,\r\n   58256,58322,58387,58453,58518,58583,58648,58713,\r\n   58778,58843,58908,58972,59037,59101,59165,59230,\r\n   59294,59358,59422,59486,59549,59613,59677,59740,\r\n   59804,59867,59930,59993,60056,60119,60182,60245,\r\n   60308,60370,60433,60495,60558,60620,60682,60744,\r\n   60806,60868,60930,60992,61054,61115,61177,61238,\r\n   61300,61361,61422,61483,61544,61605,61666,61727,\r\n   61788,61848,61909,61969,62030,62090,62150,62211,\r\n   62271,62331,62391,62450,62510,62570,62630,62689,\r\n   62749,62808,62867,62927,62986,63045,63104,63163,\r\n   63222,63281,63340,63398,63457,63515,63574,63632,\r\n   63691,63749,63807,63865,63923,63981,64039,64097,\r\n   64155,64212,64270,64328,64385,64443,64500,64557,\r\n   64614,64672,64729,64786,64843,64900,64956,65013,\r\n   65070,65126,65183,65239,65296,65352,65409,65465\r\n};\r\n\r\nconst png_byte png_sRGB_delta[512] =\r\n{\r\n   207,201,158,129,113,100,90,82,77,72,68,64,61,59,56,54,\r\n   52,50,49,47,46,45,43,42,41,40,39,39,38,37,36,36,\r\n   35,34,34,33,33,32,32,31,31,30,30,30,29,29,28,28,\r\n   28,27,27,27,27,26,26,26,25,25,25,25,24,24,24,24,\r\n   23,23,23,23,23,22,22,22,22,22,22,21,21,21,21,21,\r\n   21,20,20,20,20,20,20,20,20,19,19,19,19,19,19,19,\r\n   19,18,18,18,18,18,18,18,18,18,18,17,17,17,17,17,\r\n   17,17,17,17,17,17,16,16,16,16,16,16,16,16,16,16,\r\n   16,16,16,16,15,15,15,15,15,15,15,15,15,15,15,15,\r\n   15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,\r\n   14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,\r\n   13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,\r\n   12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,\r\n   12,12,12,12,12,12,12,12,12,12,12,12,11,11,11,11,\r\n   11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,\r\n   11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,\r\n   11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,\r\n   10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,\r\n   10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,\r\n   10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,\r\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\r\n};\r\n#endif /* SIMPLIFIED READ/WRITE sRGB support */\r\n\r\n/* SIMPLIFIED READ/WRITE SUPPORT */\r\n#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\\\r\n   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)\r\nstatic int\r\npng_image_free_function(png_voidp argument)\r\n{\r\n   png_imagep image = png_voidcast(png_imagep, argument);\r\n   png_controlp cp = image->opaque;\r\n   png_control c;\r\n\r\n   /* Double check that we have a png_ptr - it should be impossible to get here\r\n    * without one.\r\n    */\r\n   if (cp->png_ptr == NULL)\r\n      return 0;\r\n\r\n   /* First free any data held in the control structure. */\r\n#  ifdef PNG_STDIO_SUPPORTED\r\n      if (cp->owned_file)\r\n      {\r\n         FILE *fp = png_voidcast(FILE*, cp->png_ptr->io_ptr);\r\n         cp->owned_file = 0;\r\n\r\n         /* Ignore errors here. */\r\n         if (fp != NULL)\r\n         {\r\n            cp->png_ptr->io_ptr = NULL;\r\n            (void)fclose(fp);\r\n         }\r\n      }\r\n#  endif\r\n\r\n   /* Copy the control structure so that the original, allocated, version can be\r\n    * safely freed.  Notice that a png_error here stops the remainder of the\r\n    * cleanup, but this is probably fine because that would indicate bad memory\r\n    * problems anyway.\r\n    */\r\n   c = *cp;\r\n   image->opaque = &c;\r\n   png_free(c.png_ptr, cp);\r\n\r\n   /* Then the structures, calling the correct API. */\r\n   if (c.for_write)\r\n   {\r\n#     ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED\r\n         png_destroy_write_struct(&c.png_ptr, &c.info_ptr);\r\n#     else\r\n         png_error(c.png_ptr, \"simplified write not supported\");\r\n#     endif\r\n   }\r\n   else\r\n   {\r\n#     ifdef PNG_SIMPLIFIED_READ_SUPPORTED\r\n         png_destroy_read_struct(&c.png_ptr, &c.info_ptr, NULL);\r\n#     else\r\n         png_error(c.png_ptr, \"simplified read not supported\");\r\n#     endif\r\n   }\r\n\r\n   /* Success. */\r\n   return 1;\r\n}\r\n\r\nvoid PNGAPI\r\npng_image_free(png_imagep image)\r\n{\r\n   /* Safely call the real function, but only if doing so is safe at this point\r\n    * (if not inside an error handling context).  Otherwise assume\r\n    * png_safe_execute will call this API after the return.\r\n    */\r\n   if (image != NULL && image->opaque != NULL &&\r\n      image->opaque->error_buf == NULL)\r\n   {\r\n      /* Ignore errors here: */\r\n      (void)png_safe_execute(image, png_image_free_function, image);\r\n      image->opaque = NULL;\r\n   }\r\n}\r\n\r\nint /* PRIVATE */\r\npng_image_error(png_imagep image, png_const_charp error_message)\r\n{\r\n   /* Utility to log an error. */\r\n   png_safecat(image->message, (sizeof image->message), 0, error_message);\r\n   image->warning_or_error |= PNG_IMAGE_ERROR;\r\n   png_image_free(image);\r\n   return 0;\r\n}\r\n\r\n#endif /* SIMPLIFIED READ/WRITE */\r\n#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */\r\n","\r\n/* pngerror.c - stub functions for i/o and memory allocation\r\n *\r\n * Last changed in libpng 1.6.10 [March 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * This file provides a location for all error handling.  Users who\r\n * need special error handling are expected to write replacement functions\r\n * and use png_set_error_fn() to use those functions.  See the instructions\r\n * at each function.\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n\r\nstatic PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,\r\n    png_const_charp error_message)),PNG_NORETURN);\r\n\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\nstatic void /* PRIVATE */\r\npng_default_warning PNGARG((png_const_structrp png_ptr,\r\n   png_const_charp warning_message));\r\n#endif /* PNG_WARNINGS_SUPPORTED */\r\n\r\n/* This function is called whenever there is a fatal error.  This function\r\n * should not be changed.  If there is a need to handle errors differently,\r\n * you should supply a replacement error function and use png_set_error_fn()\r\n * to replace the error function at run-time.\r\n */\r\n#ifdef PNG_ERROR_TEXT_SUPPORTED\r\nPNG_FUNCTION(void,PNGAPI\r\npng_error,(png_const_structrp png_ptr, png_const_charp error_message),\r\n   PNG_NORETURN)\r\n{\r\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\r\n   char msg[16];\r\n   if (png_ptr != NULL)\r\n   {\r\n      if (png_ptr->flags&\r\n         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))\r\n      {\r\n         if (*error_message == PNG_LITERAL_SHARP)\r\n         {\r\n            /* Strip \"#nnnn \" from beginning of error message. */\r\n            int offset;\r\n            for (offset = 1; offset<15; offset++)\r\n               if (error_message[offset] == ' ')\r\n                  break;\r\n\r\n            if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)\r\n            {\r\n               int i;\r\n               for (i = 0; i < offset - 1; i++)\r\n                  msg[i] = error_message[i + 1];\r\n               msg[i - 1] = '\\0';\r\n               error_message = msg;\r\n            }\r\n\r\n            else\r\n               error_message += offset;\r\n      }\r\n\r\n      else\r\n      {\r\n         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)\r\n         {\r\n            msg[0] = '0';\r\n            msg[1] = '\\0';\r\n            error_message = msg;\r\n         }\r\n       }\r\n     }\r\n   }\r\n#endif\r\n   if (png_ptr != NULL && png_ptr->error_fn != NULL)\r\n      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),\r\n          error_message);\r\n\r\n   /* If the custom handler doesn't exist, or if it returns,\r\n      use the default handler, which will not return. */\r\n   png_default_error(png_ptr, error_message);\r\n}\r\n#else\r\nPNG_FUNCTION(void,PNGAPI\r\npng_err,(png_const_structrp png_ptr),PNG_NORETURN)\r\n{\r\n   /* Prior to 1.5.2 the error_fn received a NULL pointer, expressed\r\n    * erroneously as '\\0', instead of the empty string \"\".  This was\r\n    * apparently an error, introduced in libpng-1.2.20, and png_default_error\r\n    * will crash in this case.\r\n    */\r\n   if (png_ptr != NULL && png_ptr->error_fn != NULL)\r\n      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr), \"\");\r\n\r\n   /* If the custom handler doesn't exist, or if it returns,\r\n      use the default handler, which will not return. */\r\n   png_default_error(png_ptr, \"\");\r\n}\r\n#endif /* PNG_ERROR_TEXT_SUPPORTED */\r\n\r\n/* Utility to safely appends strings to a buffer.  This never errors out so\r\n * error checking is not required in the caller.\r\n */\r\nsize_t\r\npng_safecat(png_charp buffer, size_t bufsize, size_t pos,\r\n   png_const_charp string)\r\n{\r\n   if (buffer != NULL && pos < bufsize)\r\n   {\r\n      if (string != NULL)\r\n         while (*string != '\\0' && pos < bufsize-1)\r\n           buffer[pos++] = *string++;\r\n\r\n      buffer[pos] = '\\0';\r\n   }\r\n\r\n   return pos;\r\n}\r\n\r\n#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)\r\n/* Utility to dump an unsigned value into a buffer, given a start pointer and\r\n * and end pointer (which should point just *beyond* the end of the buffer!)\r\n * Returns the pointer to the start of the formatted string.\r\n */\r\npng_charp\r\npng_format_number(png_const_charp start, png_charp end, int format,\r\n   png_alloc_size_t number)\r\n{\r\n   int count = 0;    /* number of digits output */\r\n   int mincount = 1; /* minimum number required */\r\n   int output = 0;   /* digit output (for the fixed point format) */\r\n\r\n   *--end = '\\0';\r\n\r\n   /* This is written so that the loop always runs at least once, even with\r\n    * number zero.\r\n    */\r\n   while (end > start && (number != 0 || count < mincount))\r\n   {\r\n\r\n      static const char digits[] = \"0123456789ABCDEF\";\r\n\r\n      switch (format)\r\n      {\r\n         case PNG_NUMBER_FORMAT_fixed:\r\n            /* Needs five digits (the fraction) */\r\n            mincount = 5;\r\n            if (output || number % 10 != 0)\r\n            {\r\n               *--end = digits[number % 10];\r\n               output = 1;\r\n            }\r\n            number /= 10;\r\n            break;\r\n\r\n         case PNG_NUMBER_FORMAT_02u:\r\n            /* Expects at least 2 digits. */\r\n            mincount = 2;\r\n            /* FALL THROUGH */\r\n\r\n         case PNG_NUMBER_FORMAT_u:\r\n            *--end = digits[number % 10];\r\n            number /= 10;\r\n            break;\r\n\r\n         case PNG_NUMBER_FORMAT_02x:\r\n            /* This format expects at least two digits */\r\n            mincount = 2;\r\n            /* FALL THROUGH */\r\n\r\n         case PNG_NUMBER_FORMAT_x:\r\n            *--end = digits[number & 0xf];\r\n            number >>= 4;\r\n            break;\r\n\r\n         default: /* an error */\r\n            number = 0;\r\n            break;\r\n      }\r\n\r\n      /* Keep track of the number of digits added */\r\n      ++count;\r\n\r\n      /* Float a fixed number here: */\r\n      if (format == PNG_NUMBER_FORMAT_fixed) if (count == 5) if (end > start)\r\n      {\r\n         /* End of the fraction, but maybe nothing was output?  In that case\r\n          * drop the decimal point.  If the number is a true zero handle that\r\n          * here.\r\n          */\r\n         if (output)\r\n            *--end = '.';\r\n         else if (number == 0) /* and !output */\r\n            *--end = '0';\r\n      }\r\n   }\r\n\r\n   return end;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\n/* This function is called whenever there is a non-fatal error.  This function\r\n * should not be changed.  If there is a need to handle warnings differently,\r\n * you should supply a replacement warning function and use\r\n * png_set_error_fn() to replace the warning function at run-time.\r\n */\r\nvoid PNGAPI\r\npng_warning(png_const_structrp png_ptr, png_const_charp warning_message)\r\n{\r\n   int offset = 0;\r\n   if (png_ptr != NULL)\r\n   {\r\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\r\n   if (png_ptr->flags&\r\n       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))\r\n#endif\r\n      {\r\n         if (*warning_message == PNG_LITERAL_SHARP)\r\n         {\r\n            for (offset = 1; offset < 15; offset++)\r\n               if (warning_message[offset] == ' ')\r\n                  break;\r\n         }\r\n      }\r\n   }\r\n   if (png_ptr != NULL && png_ptr->warning_fn != NULL)\r\n      (*(png_ptr->warning_fn))(png_constcast(png_structrp,png_ptr),\r\n         warning_message + offset);\r\n   else\r\n      png_default_warning(png_ptr, warning_message + offset);\r\n}\r\n\r\n/* These functions support 'formatted' warning messages with up to\r\n * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter\r\n * is introduced by @<number>, where 'number' starts at 1.  This follows the\r\n * standard established by X/Open for internationalizable error messages.\r\n */\r\nvoid\r\npng_warning_parameter(png_warning_parameters p, int number,\r\n   png_const_charp string)\r\n{\r\n   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)\r\n      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);\r\n}\r\n\r\nvoid\r\npng_warning_parameter_unsigned(png_warning_parameters p, int number, int format,\r\n   png_alloc_size_t value)\r\n{\r\n   char buffer[PNG_NUMBER_BUFFER_SIZE];\r\n   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));\r\n}\r\n\r\nvoid\r\npng_warning_parameter_signed(png_warning_parameters p, int number, int format,\r\n   png_int_32 value)\r\n{\r\n   png_alloc_size_t u;\r\n   png_charp str;\r\n   char buffer[PNG_NUMBER_BUFFER_SIZE];\r\n\r\n   /* Avoid overflow by doing the negate in a png_alloc_size_t: */\r\n   u = (png_alloc_size_t)value;\r\n   if (value < 0)\r\n      u = ~u + 1;\r\n\r\n   str = PNG_FORMAT_NUMBER(buffer, format, u);\r\n\r\n   if (value < 0 && str > buffer)\r\n      *--str = '-';\r\n\r\n   png_warning_parameter(p, number, str);\r\n}\r\n\r\nvoid\r\npng_formatted_warning(png_const_structrp png_ptr, png_warning_parameters p,\r\n   png_const_charp message)\r\n{\r\n   /* The internal buffer is just 192 bytes - enough for all our messages,\r\n    * overflow doesn't happen because this code checks!  If someone figures\r\n    * out how to send us a message longer than 192 bytes, all that will\r\n    * happen is that the message will be truncated appropriately.\r\n    */\r\n   size_t i = 0; /* Index in the msg[] buffer: */\r\n   char msg[192];\r\n\r\n   /* Each iteration through the following loop writes at most one character\r\n    * to msg[i++] then returns here to validate that there is still space for\r\n    * the trailing '\\0'.  It may (in the case of a parameter) read more than\r\n    * one character from message[]; it must check for '\\0' and continue to the\r\n    * test if it finds the end of string.\r\n    */\r\n   while (i<(sizeof msg)-1 && *message != '\\0')\r\n   {\r\n      /* '@' at end of string is now just printed (previously it was skipped);\r\n       * it is an error in the calling code to terminate the string with @.\r\n       */\r\n      if (p != NULL && *message == '@' && message[1] != '\\0')\r\n      {\r\n         int parameter_char = *++message; /* Consume the '@' */\r\n         static const char valid_parameters[] = \"123456789\";\r\n         int parameter = 0;\r\n\r\n         /* Search for the parameter digit, the index in the string is the\r\n          * parameter to use.\r\n          */\r\n         while (valid_parameters[parameter] != parameter_char &&\r\n            valid_parameters[parameter] != '\\0')\r\n            ++parameter;\r\n\r\n         /* If the parameter digit is out of range it will just get printed. */\r\n         if (parameter < PNG_WARNING_PARAMETER_COUNT)\r\n         {\r\n            /* Append this parameter */\r\n            png_const_charp parm = p[parameter];\r\n            png_const_charp pend = p[parameter] + (sizeof p[parameter]);\r\n\r\n            /* No need to copy the trailing '\\0' here, but there is no guarantee\r\n             * that parm[] has been initialized, so there is no guarantee of a\r\n             * trailing '\\0':\r\n             */\r\n            while (i<(sizeof msg)-1 && *parm != '\\0' && parm < pend)\r\n               msg[i++] = *parm++;\r\n\r\n            /* Consume the parameter digit too: */\r\n            ++message;\r\n            continue;\r\n         }\r\n\r\n         /* else not a parameter and there is a character after the @ sign; just\r\n          * copy that.  This is known not to be '\\0' because of the test above.\r\n          */\r\n      }\r\n\r\n      /* At this point *message can't be '\\0', even in the bad parameter case\r\n       * above where there is a lone '@' at the end of the message string.\r\n       */\r\n      msg[i++] = *message++;\r\n   }\r\n\r\n   /* i is always less than (sizeof msg), so: */\r\n   msg[i] = '\\0';\r\n\r\n   /* And this is the formatted message. It may be larger than\r\n    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these\r\n    * are not (currently) formatted.\r\n    */\r\n   png_warning(png_ptr, msg);\r\n}\r\n#endif /* PNG_WARNINGS_SUPPORTED */\r\n\r\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\r\nvoid PNGAPI\r\npng_benign_error(png_const_structrp png_ptr, png_const_charp error_message)\r\n{\r\n   if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)\r\n   {\r\n#     ifdef PNG_READ_SUPPORTED\r\n         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\r\n            png_ptr->chunk_name != 0)\r\n            png_chunk_warning(png_ptr, error_message);\r\n         else\r\n#     endif\r\n      png_warning(png_ptr, error_message);\r\n   }\r\n\r\n   else\r\n   {\r\n#     ifdef PNG_READ_SUPPORTED\r\n         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\r\n            png_ptr->chunk_name != 0)\r\n            png_chunk_error(png_ptr, error_message);\r\n         else\r\n#     endif\r\n      png_error(png_ptr, error_message);\r\n   }\r\n\r\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\r\n      PNG_UNUSED(error_message)\r\n#  endif\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_app_warning(png_const_structrp png_ptr, png_const_charp error_message)\r\n{\r\n  if (png_ptr->flags & PNG_FLAG_APP_WARNINGS_WARN)\r\n     png_warning(png_ptr, error_message);\r\n  else\r\n     png_error(png_ptr, error_message);\r\n\r\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\r\n      PNG_UNUSED(error_message)\r\n#  endif\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_app_error(png_const_structrp png_ptr, png_const_charp error_message)\r\n{\r\n  if (png_ptr->flags & PNG_FLAG_APP_ERRORS_WARN)\r\n     png_warning(png_ptr, error_message);\r\n  else\r\n     png_error(png_ptr, error_message);\r\n\r\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\r\n      PNG_UNUSED(error_message)\r\n#  endif\r\n}\r\n#endif /* BENIGN_ERRORS */\r\n\r\n/* These utilities are used internally to build an error message that relates\r\n * to the current chunk.  The chunk name comes from png_ptr->chunk_name,\r\n * this is used to prefix the message.  The message is limited in length\r\n * to 63 bytes, the name characters are output as hex digits wrapped in []\r\n * if the character is invalid.\r\n */\r\n#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\r\nstatic PNG_CONST char png_digit[16] = {\r\n   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n   'A', 'B', 'C', 'D', 'E', 'F'\r\n};\r\n\r\n#define PNG_MAX_ERROR_TEXT 196 /* Currently limited be profile_error in png.c */\r\n#if defined(PNG_WARNINGS_SUPPORTED) || \\\r\n   (defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED))\r\nstatic void /* PRIVATE */\r\npng_format_buffer(png_const_structrp png_ptr, png_charp buffer, png_const_charp\r\n    error_message)\r\n{\r\n   png_uint_32 chunk_name = png_ptr->chunk_name;\r\n   int iout = 0, ishift = 24;\r\n\r\n   while (ishift >= 0)\r\n   {\r\n      int c = (int)(chunk_name >> ishift) & 0xff;\r\n\r\n      ishift -= 8;\r\n      if (isnonalpha(c))\r\n      {\r\n         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;\r\n         buffer[iout++] = png_digit[(c & 0xf0) >> 4];\r\n         buffer[iout++] = png_digit[c & 0x0f];\r\n         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;\r\n      }\r\n\r\n      else\r\n      {\r\n         buffer[iout++] = (char)c;\r\n      }\r\n   }\r\n\r\n   if (error_message == NULL)\r\n      buffer[iout] = '\\0';\r\n\r\n   else\r\n   {\r\n      int iin = 0;\r\n\r\n      buffer[iout++] = ':';\r\n      buffer[iout++] = ' ';\r\n\r\n      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\\0')\r\n         buffer[iout++] = error_message[iin++];\r\n\r\n      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */\r\n      buffer[iout] = '\\0';\r\n   }\r\n}\r\n#endif /* PNG_WARNINGS_SUPPORTED || PNG_ERROR_TEXT_SUPPORTED */\r\n\r\n#if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)\r\nPNG_FUNCTION(void,PNGAPI\r\npng_chunk_error,(png_const_structrp png_ptr, png_const_charp error_message),\r\n   PNG_NORETURN)\r\n{\r\n   char msg[18+PNG_MAX_ERROR_TEXT];\r\n   if (png_ptr == NULL)\r\n      png_error(png_ptr, error_message);\r\n\r\n   else\r\n   {\r\n      png_format_buffer(png_ptr, msg, error_message);\r\n      png_error(png_ptr, msg);\r\n   }\r\n}\r\n#endif /* PNG_READ_SUPPORTED && PNG_ERROR_TEXT_SUPPORTED */\r\n\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\nvoid PNGAPI\r\npng_chunk_warning(png_const_structrp png_ptr, png_const_charp warning_message)\r\n{\r\n   char msg[18+PNG_MAX_ERROR_TEXT];\r\n   if (png_ptr == NULL)\r\n      png_warning(png_ptr, warning_message);\r\n\r\n   else\r\n   {\r\n      png_format_buffer(png_ptr, msg, warning_message);\r\n      png_warning(png_ptr, msg);\r\n   }\r\n}\r\n#endif /* PNG_WARNINGS_SUPPORTED */\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\r\nvoid PNGAPI\r\npng_chunk_benign_error(png_const_structrp png_ptr, png_const_charp\r\n    error_message)\r\n{\r\n   if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)\r\n      png_chunk_warning(png_ptr, error_message);\r\n\r\n   else\r\n      png_chunk_error(png_ptr, error_message);\r\n\r\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\r\n      PNG_UNUSED(error_message)\r\n#  endif\r\n}\r\n#endif\r\n#endif /* PNG_READ_SUPPORTED */\r\n\r\nvoid /* PRIVATE */\r\npng_chunk_report(png_const_structrp png_ptr, png_const_charp message, int error)\r\n{\r\n#  ifndef PNG_WARNINGS_SUPPORTED\r\n      PNG_UNUSED(message)\r\n#  endif\r\n\r\n   /* This is always supported, but for just read or just write it\r\n    * unconditionally does the right thing.\r\n    */\r\n#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)\r\n      if (png_ptr->mode & PNG_IS_READ_STRUCT)\r\n#  endif\r\n\r\n#  ifdef PNG_READ_SUPPORTED\r\n      {\r\n         if (error < PNG_CHUNK_ERROR)\r\n            png_chunk_warning(png_ptr, message);\r\n\r\n         else\r\n            png_chunk_benign_error(png_ptr, message);\r\n      }\r\n#  endif\r\n\r\n#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)\r\n      else if (!(png_ptr->mode & PNG_IS_READ_STRUCT))\r\n#  endif\r\n\r\n#  ifdef PNG_WRITE_SUPPORTED\r\n      {\r\n         if (error < PNG_CHUNK_WRITE_ERROR)\r\n            png_app_warning(png_ptr, message);\r\n\r\n         else\r\n            png_app_error(png_ptr, message);\r\n      }\r\n#  endif\r\n}\r\n\r\n#ifdef PNG_ERROR_TEXT_SUPPORTED\r\n#ifdef PNG_FLOATING_POINT_SUPPORTED\r\nPNG_FUNCTION(void,\r\npng_fixed_error,(png_const_structrp png_ptr, png_const_charp name),PNG_NORETURN)\r\n{\r\n#  define fixed_message \"fixed point overflow in \"\r\n#  define fixed_message_ln ((sizeof fixed_message)-1)\r\n   int  iin;\r\n   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];\r\n   memcpy(msg, fixed_message, fixed_message_ln);\r\n   iin = 0;\r\n   if (name != NULL) while (iin < (PNG_MAX_ERROR_TEXT-1) && name[iin] != 0)\r\n   {\r\n      msg[fixed_message_ln + iin] = name[iin];\r\n      ++iin;\r\n   }\r\n   msg[fixed_message_ln + iin] = 0;\r\n   png_error(png_ptr, msg);\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifdef PNG_SETJMP_SUPPORTED\r\n/* This API only exists if ANSI-C style error handling is used,\r\n * otherwise it is necessary for png_default_error to be overridden.\r\n */\r\njmp_buf* PNGAPI\r\npng_set_longjmp_fn(png_structrp png_ptr, png_longjmp_ptr longjmp_fn,\r\n    size_t jmp_buf_size)\r\n{\r\n   /* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value\r\n    * and it must not change after that.  Libpng doesn't care how big the\r\n    * buffer is, just that it doesn't change.\r\n    *\r\n    * If the buffer size is no *larger* than the size of jmp_buf when libpng is\r\n    * compiled a built in jmp_buf is returned; this preserves the pre-1.6.0\r\n    * semantics that this call will not fail.  If the size is larger, however,\r\n    * the buffer is allocated and this may fail, causing the function to return\r\n    * NULL.\r\n    */\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   if (png_ptr->jmp_buf_ptr == NULL)\r\n   {\r\n      png_ptr->jmp_buf_size = 0; /* not allocated */\r\n\r\n      if (jmp_buf_size <= (sizeof png_ptr->jmp_buf_local))\r\n         png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;\r\n\r\n      else\r\n      {\r\n         png_ptr->jmp_buf_ptr = png_voidcast(jmp_buf *,\r\n            png_malloc_warn(png_ptr, jmp_buf_size));\r\n\r\n         if (png_ptr->jmp_buf_ptr == NULL)\r\n            return NULL; /* new NULL return on OOM */\r\n\r\n         png_ptr->jmp_buf_size = jmp_buf_size;\r\n      }\r\n   }\r\n\r\n   else /* Already allocated: check the size */\r\n   {\r\n      size_t size = png_ptr->jmp_buf_size;\r\n\r\n      if (size == 0)\r\n      {\r\n         size = (sizeof png_ptr->jmp_buf_local);\r\n         if (png_ptr->jmp_buf_ptr != &png_ptr->jmp_buf_local)\r\n         {\r\n            /* This is an internal error in libpng: somehow we have been left\r\n             * with a stack allocated jmp_buf when the application regained\r\n             * control.  It's always possible to fix this up, but for the moment\r\n             * this is a png_error because that makes it easy to detect.\r\n             */\r\n            png_error(png_ptr, \"Libpng jmp_buf still allocated\");\r\n            /* png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local; */\r\n         }\r\n      }\r\n\r\n      if (size != jmp_buf_size)\r\n      {\r\n         png_warning(png_ptr, \"Application jmp_buf size changed\");\r\n         return NULL; /* caller will probably crash: no choice here */\r\n      }\r\n   }\r\n\r\n   /* Finally fill in the function, now we have a satisfactory buffer. It is\r\n    * valid to change the function on every call.\r\n    */\r\n   png_ptr->longjmp_fn = longjmp_fn;\r\n   return png_ptr->jmp_buf_ptr;\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_free_jmpbuf(png_structrp png_ptr)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      jmp_buf *jb = png_ptr->jmp_buf_ptr;\r\n\r\n      /* A size of 0 is used to indicate a local, stack, allocation of the\r\n       * pointer; used here and in png.c\r\n       */\r\n      if (jb != NULL && png_ptr->jmp_buf_size > 0)\r\n      {\r\n\r\n         /* This stuff is so that a failure to free the error control structure\r\n          * does not leave libpng in a state with no valid error handling: the\r\n          * free always succeeds, if there is an error it gets ignored.\r\n          */\r\n         if (jb != &png_ptr->jmp_buf_local)\r\n         {\r\n            /* Make an internal, libpng, jmp_buf to return here */\r\n            jmp_buf free_jmp_buf;\r\n\r\n            if (!setjmp(free_jmp_buf))\r\n            {\r\n               png_ptr->jmp_buf_ptr = &free_jmp_buf; /* come back here */\r\n               png_ptr->jmp_buf_size = 0; /* stack allocation */\r\n               png_ptr->longjmp_fn = longjmp;\r\n               png_free(png_ptr, jb); /* Return to setjmp on error */\r\n            }\r\n         }\r\n      }\r\n\r\n      /* *Always* cancel everything out: */\r\n      png_ptr->jmp_buf_size = 0;\r\n      png_ptr->jmp_buf_ptr = NULL;\r\n      png_ptr->longjmp_fn = 0;\r\n   }\r\n}\r\n#endif\r\n\r\n/* This is the default error handling function.  Note that replacements for\r\n * this function MUST NOT RETURN, or the program will likely crash.  This\r\n * function is used by default, or if the program supplies NULL for the\r\n * error function pointer in png_set_error_fn().\r\n */\r\nstatic PNG_FUNCTION(void /* PRIVATE */,\r\npng_default_error,(png_const_structrp png_ptr, png_const_charp error_message),\r\n   PNG_NORETURN)\r\n{\r\n#ifdef PNG_CONSOLE_IO_SUPPORTED\r\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\r\n   /* Check on NULL only added in 1.5.4 */\r\n   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)\r\n   {\r\n      /* Strip \"#nnnn \" from beginning of error message. */\r\n      int offset;\r\n      char error_number[16];\r\n      for (offset = 0; offset<15; offset++)\r\n      {\r\n         error_number[offset] = error_message[offset + 1];\r\n         if (error_message[offset] == ' ')\r\n            break;\r\n      }\r\n\r\n      if ((offset > 1) && (offset < 15))\r\n      {\r\n         error_number[offset - 1] = '\\0';\r\n         fprintf(stderr, \"libpng error no. %s: %s\",\r\n             error_number, error_message + offset + 1);\r\n         fprintf(stderr, PNG_STRING_NEWLINE);\r\n      }\r\n\r\n      else\r\n      {\r\n         fprintf(stderr, \"libpng error: %s, offset=%d\",\r\n             error_message, offset);\r\n         fprintf(stderr, PNG_STRING_NEWLINE);\r\n      }\r\n   }\r\n   else\r\n#endif\r\n   {\r\n      fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\r\n         \"undefined\");\r\n      fprintf(stderr, PNG_STRING_NEWLINE);\r\n   }\r\n#else\r\n   PNG_UNUSED(error_message) /* Make compiler happy */\r\n#endif\r\n   png_longjmp(png_ptr, 1);\r\n}\r\n\r\nPNG_FUNCTION(void,PNGAPI\r\npng_longjmp,(png_const_structrp png_ptr, int val),PNG_NORETURN)\r\n{\r\n#ifdef PNG_SETJMP_SUPPORTED\r\n   if (png_ptr && png_ptr->longjmp_fn && png_ptr->jmp_buf_ptr)\r\n      png_ptr->longjmp_fn(*png_ptr->jmp_buf_ptr, val);\r\n#endif\r\n\r\n   /* If control reaches this point, png_longjmp() must not return. The only\r\n    * choice is to terminate the whole process (or maybe the thread); to do\r\n    * this the ANSI-C abort() function is used unless a different method is \r\n    * implemented by overriding the default configuration setting for\r\n    * PNG_ABORT().\r\n    */\r\n   PNG_ABORT();\r\n}\r\n\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\n/* This function is called when there is a warning, but the library thinks\r\n * it can continue anyway.  Replacement functions don't have to do anything\r\n * here if you don't want them to.  In the default configuration, png_ptr is\r\n * not used, but it is passed in case it may be useful.\r\n */\r\nstatic void /* PRIVATE */\r\npng_default_warning(png_const_structrp png_ptr, png_const_charp warning_message)\r\n{\r\n#ifdef PNG_CONSOLE_IO_SUPPORTED\r\n#  ifdef PNG_ERROR_NUMBERS_SUPPORTED\r\n   if (*warning_message == PNG_LITERAL_SHARP)\r\n   {\r\n      int offset;\r\n      char warning_number[16];\r\n      for (offset = 0; offset < 15; offset++)\r\n      {\r\n         warning_number[offset] = warning_message[offset + 1];\r\n         if (warning_message[offset] == ' ')\r\n            break;\r\n      }\r\n\r\n      if ((offset > 1) && (offset < 15))\r\n      {\r\n         warning_number[offset + 1] = '\\0';\r\n         fprintf(stderr, \"libpng warning no. %s: %s\",\r\n             warning_number, warning_message + offset);\r\n         fprintf(stderr, PNG_STRING_NEWLINE);\r\n      }\r\n\r\n      else\r\n      {\r\n         fprintf(stderr, \"libpng warning: %s\",\r\n             warning_message);\r\n         fprintf(stderr, PNG_STRING_NEWLINE);\r\n      }\r\n   }\r\n   else\r\n#  endif\r\n\r\n   {\r\n      fprintf(stderr, \"libpng warning: %s\", warning_message);\r\n      fprintf(stderr, PNG_STRING_NEWLINE);\r\n   }\r\n#else\r\n   PNG_UNUSED(warning_message) /* Make compiler happy */\r\n#endif\r\n   PNG_UNUSED(png_ptr) /* Make compiler happy */\r\n}\r\n#endif /* PNG_WARNINGS_SUPPORTED */\r\n\r\n/* This function is called when the application wants to use another method\r\n * of handling errors and warnings.  Note that the error function MUST NOT\r\n * return to the calling routine or serious problems will occur.  The return\r\n * method used in the default routine calls longjmp(png_ptr->jmp_buf_ptr, 1)\r\n */\r\nvoid PNGAPI\r\npng_set_error_fn(png_structrp png_ptr, png_voidp error_ptr,\r\n    png_error_ptr error_fn, png_error_ptr warning_fn)\r\n{\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->error_ptr = error_ptr;\r\n   png_ptr->error_fn = error_fn;\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\n   png_ptr->warning_fn = warning_fn;\r\n#else\r\n   PNG_UNUSED(warning_fn)\r\n#endif\r\n}\r\n\r\n\r\n/* This function returns a pointer to the error_ptr associated with the user\r\n * functions.  The application should free any memory associated with this\r\n * pointer before png_write_destroy and png_read_destroy are called.\r\n */\r\npng_voidp PNGAPI\r\npng_get_error_ptr(png_const_structrp png_ptr)\r\n{\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   return ((png_voidp)png_ptr->error_ptr);\r\n}\r\n\r\n\r\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\r\nvoid PNGAPI\r\npng_set_strip_error_numbers(png_structrp png_ptr, png_uint_32 strip_mode)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      png_ptr->flags &=\r\n         ((~(PNG_FLAG_STRIP_ERROR_NUMBERS |\r\n         PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);\r\n   }\r\n}\r\n#endif\r\n\r\n#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\\\r\n   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)\r\n   /* Currently the above both depend on SETJMP_SUPPORTED, however it would be\r\n    * possible to implement without setjmp support just so long as there is some\r\n    * way to handle the error return here:\r\n    */\r\nPNG_FUNCTION(void /* PRIVATE */, (PNGCBAPI\r\npng_safe_error),(png_structp png_nonconst_ptr, png_const_charp error_message),\r\n   PNG_NORETURN)\r\n{\r\n   const png_const_structrp png_ptr = png_nonconst_ptr;\r\n   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);\r\n\r\n   /* An error is always logged here, overwriting anything (typically a warning)\r\n    * that is already there:\r\n    */\r\n   if (image != NULL)\r\n   {\r\n      png_safecat(image->message, (sizeof image->message), 0, error_message);\r\n      image->warning_or_error |= PNG_IMAGE_ERROR;\r\n\r\n      /* Retrieve the jmp_buf from within the png_control, making this work for\r\n       * C++ compilation too is pretty tricky: C++ wants a pointer to the first\r\n       * element of a jmp_buf, but C doesn't tell us the type of that.\r\n       */\r\n      if (image->opaque != NULL && image->opaque->error_buf != NULL)\r\n         longjmp(png_control_jmp_buf(image->opaque), 1);\r\n\r\n      /* Missing longjmp buffer, the following is to help debugging: */\r\n      {\r\n         size_t pos = png_safecat(image->message, (sizeof image->message), 0,\r\n            \"bad longjmp: \");\r\n         png_safecat(image->message, (sizeof image->message), pos,\r\n             error_message);\r\n      }\r\n   }\r\n\r\n   /* Here on an internal programming error. */\r\n   abort();\r\n}\r\n\r\n#ifdef PNG_WARNINGS_SUPPORTED\r\nvoid /* PRIVATE */ PNGCBAPI\r\npng_safe_warning(png_structp png_nonconst_ptr, png_const_charp warning_message)\r\n{\r\n   const png_const_structrp png_ptr = png_nonconst_ptr;\r\n   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);\r\n\r\n   /* A warning is only logged if there is no prior warning or error. */\r\n   if (image->warning_or_error == 0)\r\n   {\r\n      png_safecat(image->message, (sizeof image->message), 0, warning_message);\r\n      image->warning_or_error |= PNG_IMAGE_WARNING;\r\n   }\r\n}\r\n#endif\r\n\r\nint /* PRIVATE */\r\npng_safe_execute(png_imagep image_in, int (*function)(png_voidp), png_voidp arg)\r\n{\r\n   volatile png_imagep image = image_in;\r\n   volatile int result;\r\n   volatile png_voidp saved_error_buf;\r\n   jmp_buf safe_jmpbuf;\r\n\r\n   /* Safely execute function(arg) with png_error returning to this function. */\r\n   saved_error_buf = image->opaque->error_buf;\r\n   result = setjmp(safe_jmpbuf) == 0;\r\n\r\n   if (result)\r\n   {\r\n\r\n      image->opaque->error_buf = safe_jmpbuf;\r\n      result = function(arg);\r\n   }\r\n\r\n   image->opaque->error_buf = saved_error_buf;\r\n\r\n   /* And do the cleanup prior to any failure return. */\r\n   if (!result)\r\n      png_image_free(image);\r\n\r\n   return result;\r\n}\r\n#endif /* SIMPLIFIED READ/WRITE */\r\n#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */\r\n","\r\n/* pngget.c - retrieval of values from info struct\r\n *\r\n * Last changed in libpng 1.6.1 [March 28, 2013]\r\n * Copyright (c) 1998-2013 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n\r\npng_uint_32 PNGAPI\r\npng_get_valid(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_uint_32 flag)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return(info_ptr->valid & flag);\r\n\r\n   return(0);\r\n}\r\n\r\npng_size_t PNGAPI\r\npng_get_rowbytes(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return(info_ptr->rowbytes);\r\n\r\n   return(0);\r\n}\r\n\r\n#ifdef PNG_INFO_IMAGE_SUPPORTED\r\npng_bytepp PNGAPI\r\npng_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return(info_ptr->row_pointers);\r\n\r\n   return(0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_EASY_ACCESS_SUPPORTED\r\n/* Easy access to info, added in libpng-0.99 */\r\npng_uint_32 PNGAPI\r\npng_get_image_width(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->width;\r\n\r\n   return (0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_image_height(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->height;\r\n\r\n   return (0);\r\n}\r\n\r\npng_byte PNGAPI\r\npng_get_bit_depth(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->bit_depth;\r\n\r\n   return (0);\r\n}\r\n\r\npng_byte PNGAPI\r\npng_get_color_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->color_type;\r\n\r\n   return (0);\r\n}\r\n\r\npng_byte PNGAPI\r\npng_get_filter_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->filter_type;\r\n\r\n   return (0);\r\n}\r\n\r\npng_byte PNGAPI\r\npng_get_interlace_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->interlace_type;\r\n\r\n   return (0);\r\n}\r\n\r\npng_byte PNGAPI\r\npng_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return info_ptr->compression_type;\r\n\r\n   return (0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp\r\n   info_ptr)\r\n{\r\n#ifdef PNG_pHYs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\r\n      {\r\n         png_debug1(1, \"in %s retrieval function\",\r\n             \"png_get_x_pixels_per_meter\");\r\n\r\n         if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\r\n            return (info_ptr->x_pixels_per_unit);\r\n      }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_y_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp\r\n    info_ptr)\r\n{\r\n#ifdef PNG_pHYs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\",\r\n          \"png_get_y_pixels_per_meter\");\r\n\r\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\r\n         return (info_ptr->y_pixels_per_unit);\r\n   }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n#ifdef PNG_pHYs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_pixels_per_meter\");\r\n\r\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER &&\r\n          info_ptr->x_pixels_per_unit == info_ptr->y_pixels_per_unit)\r\n         return (info_ptr->x_pixels_per_unit);\r\n   }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\n#ifdef PNG_FLOATING_POINT_SUPPORTED\r\nfloat PNGAPI\r\npng_get_pixel_aspect_ratio(png_const_structrp png_ptr, png_const_inforp\r\n   info_ptr)\r\n{\r\n#ifdef PNG_READ_pHYs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_aspect_ratio\");\r\n\r\n      if (info_ptr->x_pixels_per_unit != 0)\r\n         return ((float)((float)info_ptr->y_pixels_per_unit\r\n             /(float)info_ptr->x_pixels_per_unit));\r\n   }\r\n#else\r\n   PNG_UNUSED(png_ptr)\r\n   PNG_UNUSED(info_ptr)\r\n#endif\r\n\r\n   return ((float)0.0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_FIXED_POINT_SUPPORTED\r\npng_fixed_point PNGAPI\r\npng_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr,\r\n    png_const_inforp info_ptr)\r\n{\r\n#ifdef PNG_READ_pHYs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs)\r\n       && info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0\r\n       && info_ptr->x_pixels_per_unit <= PNG_UINT_31_MAX\r\n       && info_ptr->y_pixels_per_unit <= PNG_UINT_31_MAX)\r\n   {\r\n      png_fixed_point res;\r\n\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_aspect_ratio_fixed\");\r\n\r\n      /* The following casts work because a PNG 4 byte integer only has a valid\r\n       * range of 0..2^31-1; otherwise the cast might overflow.\r\n       */\r\n      if (png_muldiv(&res, (png_int_32)info_ptr->y_pixels_per_unit, PNG_FP_1,\r\n          (png_int_32)info_ptr->x_pixels_per_unit))\r\n         return res;\r\n   }\r\n#else\r\n   PNG_UNUSED(png_ptr)\r\n   PNG_UNUSED(info_ptr)\r\n#endif\r\n\r\n   return 0;\r\n}\r\n#endif\r\n\r\npng_int_32 PNGAPI\r\npng_get_x_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n#ifdef PNG_oFFs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_x_offset_microns\");\r\n\r\n      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)\r\n         return (info_ptr->x_offset);\r\n   }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\npng_int_32 PNGAPI\r\npng_get_y_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n#ifdef PNG_oFFs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_y_offset_microns\");\r\n\r\n      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)\r\n         return (info_ptr->y_offset);\r\n   }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\npng_int_32 PNGAPI\r\npng_get_x_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n#ifdef PNG_oFFs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_x_offset_pixels\");\r\n\r\n      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)\r\n         return (info_ptr->x_offset);\r\n   }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\npng_int_32 PNGAPI\r\npng_get_y_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n#ifdef PNG_oFFs_SUPPORTED\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"png_get_y_offset_pixels\");\r\n\r\n      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)\r\n         return (info_ptr->y_offset);\r\n   }\r\n#endif\r\n\r\n   return (0);\r\n}\r\n\r\n#ifdef PNG_INCH_CONVERSIONS_SUPPORTED\r\nstatic png_uint_32\r\nppi_from_ppm(png_uint_32 ppm)\r\n{\r\n#if 0\r\n   /* The conversion is *(2.54/100), in binary (32 digits):\r\n    * .00000110100000001001110101001001\r\n    */\r\n   png_uint_32 t1001, t1101;\r\n   ppm >>= 1;                  /* .1 */\r\n   t1001 = ppm + (ppm >> 3);   /* .1001 */\r\n   t1101 = t1001 + (ppm >> 1); /* .1101 */\r\n   ppm >>= 20;                 /* .000000000000000000001 */\r\n   t1101 += t1101 >> 15;       /* .1101000000000001101 */\r\n   t1001 >>= 11;               /* .000000000001001 */\r\n   t1001 += t1001 >> 12;       /* .000000000001001000000001001 */\r\n   ppm += t1001;               /* .000000000001001000001001001 */\r\n   ppm += t1101;               /* .110100000001001110101001001 */\r\n   return (ppm + 16) >> 5;/* .00000110100000001001110101001001 */\r\n#else\r\n   /* The argument is a PNG unsigned integer, so it is not permitted\r\n    * to be bigger than 2^31.\r\n    */\r\n   png_fixed_point result;\r\n   if (ppm <= PNG_UINT_31_MAX && png_muldiv(&result, (png_int_32)ppm, 127,\r\n       5000))\r\n      return result;\r\n\r\n   /* Overflow. */\r\n   return 0;\r\n#endif\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_x_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_y_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));\r\n}\r\n\r\n#ifdef PNG_FIXED_POINT_SUPPORTED\r\nstatic png_fixed_point\r\npng_fixed_inches_from_microns(png_const_structrp png_ptr, png_int_32 microns)\r\n{\r\n   /* Convert from metres * 1,000,000 to inches * 100,000, meters to\r\n    * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.\r\n    * Notice that this can overflow - a warning is output and 0 is\r\n    * returned.\r\n    */\r\n   return png_muldiv_warn(png_ptr, microns, 500, 127);\r\n}\r\n\r\npng_fixed_point PNGAPI\r\npng_get_x_offset_inches_fixed(png_const_structrp png_ptr,\r\n    png_const_inforp info_ptr)\r\n{\r\n   return png_fixed_inches_from_microns(png_ptr,\r\n       png_get_x_offset_microns(png_ptr, info_ptr));\r\n}\r\n#endif\r\n\r\n#ifdef PNG_FIXED_POINT_SUPPORTED\r\npng_fixed_point PNGAPI\r\npng_get_y_offset_inches_fixed(png_const_structrp png_ptr,\r\n    png_const_inforp info_ptr)\r\n{\r\n   return png_fixed_inches_from_microns(png_ptr,\r\n       png_get_y_offset_microns(png_ptr, info_ptr));\r\n}\r\n#endif\r\n\r\n#ifdef PNG_FLOATING_POINT_SUPPORTED\r\nfloat PNGAPI\r\npng_get_x_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   /* To avoid the overflow do the conversion directly in floating\r\n    * point.\r\n    */\r\n   return (float)(png_get_x_offset_microns(png_ptr, info_ptr) * .00003937);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_FLOATING_POINT_SUPPORTED\r\nfloat PNGAPI\r\npng_get_y_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   /* To avoid the overflow do the conversion directly in floating\r\n    * point.\r\n    */\r\n   return (float)(png_get_y_offset_microns(png_ptr, info_ptr) * .00003937);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_pHYs_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_pHYs_dpi(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\r\n{\r\n   png_uint_32 retval = 0;\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"pHYs\");\r\n\r\n      if (res_x != NULL)\r\n      {\r\n         *res_x = info_ptr->x_pixels_per_unit;\r\n         retval |= PNG_INFO_pHYs;\r\n      }\r\n\r\n      if (res_y != NULL)\r\n      {\r\n         *res_y = info_ptr->y_pixels_per_unit;\r\n         retval |= PNG_INFO_pHYs;\r\n      }\r\n\r\n      if (unit_type != NULL)\r\n      {\r\n         *unit_type = (int)info_ptr->phys_unit_type;\r\n         retval |= PNG_INFO_pHYs;\r\n\r\n         if (*unit_type == 1)\r\n         {\r\n            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);\r\n            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);\r\n         }\r\n      }\r\n   }\r\n\r\n   return (retval);\r\n}\r\n#endif /* PNG_pHYs_SUPPORTED */\r\n#endif  /* PNG_INCH_CONVERSIONS_SUPPORTED */\r\n\r\n/* png_get_channels really belongs in here, too, but it's been around longer */\r\n\r\n#endif  /* PNG_EASY_ACCESS_SUPPORTED */\r\n\r\n\r\npng_byte PNGAPI\r\npng_get_channels(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return(info_ptr->channels);\r\n\r\n   return (0);\r\n}\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\npng_const_bytep PNGAPI\r\npng_get_signature(png_const_structrp png_ptr, png_const_inforp info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return(info_ptr->signature);\r\n\r\n   return (NULL);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_bKGD_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,\r\n   png_color_16p *background)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)\r\n       && background != NULL)\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"bKGD\");\r\n\r\n      *background = &(info_ptr->background);\r\n      return (PNG_INFO_bKGD);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_cHRM_SUPPORTED\r\n/* The XYZ APIs were added in 1.5.5 to take advantage of the code added at the\r\n * same time to correct the rgb grayscale coefficient defaults obtained from the\r\n * cHRM chunk in 1.5.4\r\n */\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_cHRM(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    double *white_x, double *white_y, double *red_x, double *red_y,\r\n    double *green_x, double *green_y, double *blue_x, double *blue_y)\r\n{\r\n   /* Quiet API change: this code used to only return the end points if a cHRM\r\n    * chunk was present, but the end points can also come from iCCP or sRGB\r\n    * chunks, so in 1.6.0 the png_get_ APIs return the end points regardless and\r\n    * the png_set_ APIs merely check that set end points are mutually\r\n    * consistent.\r\n    */\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"cHRM\");\r\n\r\n      if (white_x != NULL)\r\n         *white_x = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_xy.whitex, \"cHRM white X\");\r\n      if (white_y != NULL)\r\n         *white_y = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_xy.whitey, \"cHRM white Y\");\r\n      if (red_x != NULL)\r\n         *red_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redx,\r\n            \"cHRM red X\");\r\n      if (red_y != NULL)\r\n         *red_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redy,\r\n            \"cHRM red Y\");\r\n      if (green_x != NULL)\r\n         *green_x = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_xy.greenx, \"cHRM green X\");\r\n      if (green_y != NULL)\r\n         *green_y = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_xy.greeny, \"cHRM green Y\");\r\n      if (blue_x != NULL)\r\n         *blue_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluex,\r\n            \"cHRM blue X\");\r\n      if (blue_y != NULL)\r\n         *blue_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluey,\r\n            \"cHRM blue Y\");\r\n      return (PNG_INFO_cHRM);\r\n   }\r\n\r\n   return (0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_cHRM_XYZ(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n   double *red_X, double *red_Y, double *red_Z, double *green_X,\r\n   double *green_Y, double *green_Z, double *blue_X, double *blue_Y,\r\n   double *blue_Z)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ(float)\");\r\n\r\n      if (red_X != NULL)\r\n         *red_X = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_X,\r\n            \"cHRM red X\");\r\n      if (red_Y != NULL)\r\n         *red_Y = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Y,\r\n            \"cHRM red Y\");\r\n      if (red_Z != NULL)\r\n         *red_Z = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Z,\r\n            \"cHRM red Z\");\r\n      if (green_X != NULL)\r\n         *green_X = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_XYZ.green_X, \"cHRM green X\");\r\n      if (green_Y != NULL)\r\n         *green_Y = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_XYZ.green_Y, \"cHRM green Y\");\r\n      if (green_Z != NULL)\r\n         *green_Z = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_XYZ.green_Z, \"cHRM green Z\");\r\n      if (blue_X != NULL)\r\n         *blue_X = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_XYZ.blue_X, \"cHRM blue X\");\r\n      if (blue_Y != NULL)\r\n         *blue_Y = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_XYZ.blue_Y, \"cHRM blue Y\");\r\n      if (blue_Z != NULL)\r\n         *blue_Z = png_float(png_ptr,\r\n            info_ptr->colorspace.end_points_XYZ.blue_Z, \"cHRM blue Z\");\r\n      return (PNG_INFO_cHRM);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#  endif\r\n\r\n#  ifdef PNG_FIXED_POINT_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,\r\n    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,\r\n    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,\r\n    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,\r\n    png_fixed_point *int_blue_Z)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ\");\r\n\r\n      if (int_red_X != NULL)\r\n         *int_red_X = info_ptr->colorspace.end_points_XYZ.red_X;\r\n      if (int_red_Y != NULL)\r\n         *int_red_Y = info_ptr->colorspace.end_points_XYZ.red_Y;\r\n      if (int_red_Z != NULL)\r\n         *int_red_Z = info_ptr->colorspace.end_points_XYZ.red_Z;\r\n      if (int_green_X != NULL)\r\n         *int_green_X = info_ptr->colorspace.end_points_XYZ.green_X;\r\n      if (int_green_Y != NULL)\r\n         *int_green_Y = info_ptr->colorspace.end_points_XYZ.green_Y;\r\n      if (int_green_Z != NULL)\r\n         *int_green_Z = info_ptr->colorspace.end_points_XYZ.green_Z;\r\n      if (int_blue_X != NULL)\r\n         *int_blue_X = info_ptr->colorspace.end_points_XYZ.blue_X;\r\n      if (int_blue_Y != NULL)\r\n         *int_blue_Y = info_ptr->colorspace.end_points_XYZ.blue_Y;\r\n      if (int_blue_Z != NULL)\r\n         *int_blue_Z = info_ptr->colorspace.end_points_XYZ.blue_Z;\r\n      return (PNG_INFO_cHRM);\r\n   }\r\n\r\n   return (0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_cHRM_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,\r\n    png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,\r\n    png_fixed_point *blue_x, png_fixed_point *blue_y)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"cHRM\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS))\r\n   {\r\n      if (white_x != NULL)\r\n         *white_x = info_ptr->colorspace.end_points_xy.whitex;\r\n      if (white_y != NULL)\r\n         *white_y = info_ptr->colorspace.end_points_xy.whitey;\r\n      if (red_x != NULL)\r\n         *red_x = info_ptr->colorspace.end_points_xy.redx;\r\n      if (red_y != NULL)\r\n         *red_y = info_ptr->colorspace.end_points_xy.redy;\r\n      if (green_x != NULL)\r\n         *green_x = info_ptr->colorspace.end_points_xy.greenx;\r\n      if (green_y != NULL)\r\n         *green_y = info_ptr->colorspace.end_points_xy.greeny;\r\n      if (blue_x != NULL)\r\n         *blue_x = info_ptr->colorspace.end_points_xy.bluex;\r\n      if (blue_y != NULL)\r\n         *blue_y = info_ptr->colorspace.end_points_xy.bluey;\r\n      return (PNG_INFO_cHRM);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#  endif\r\n#endif\r\n\r\n#ifdef PNG_gAMA_SUPPORTED\r\n#  ifdef PNG_FIXED_POINT_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_gAMA_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_fixed_point *file_gamma)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"gAMA\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) &&\r\n      file_gamma != NULL)\r\n   {\r\n      *file_gamma = info_ptr->colorspace.gamma;\r\n      return (PNG_INFO_gAMA);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#  endif\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_gAMA(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    double *file_gamma)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"gAMA(float)\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) &&\r\n      file_gamma != NULL)\r\n   {\r\n      *file_gamma = png_float(png_ptr, info_ptr->colorspace.gamma,\r\n         \"png_get_gAMA\");\r\n      return (PNG_INFO_gAMA);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#  endif\r\n#endif\r\n\r\n#ifdef PNG_sRGB_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_sRGB(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    int *file_srgb_intent)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"sRGB\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)\r\n       && file_srgb_intent != NULL)\r\n   {\r\n      *file_srgb_intent = info_ptr->colorspace.rendering_intent;\r\n      return (PNG_INFO_sRGB);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_iCCP_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_charpp name, int *compression_type,\r\n    png_bytepp profile, png_uint_32 *proflen)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"iCCP\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)\r\n       && name != NULL && compression_type != NULL && profile != NULL &&\r\n\t\t proflen != NULL)\r\n   {\r\n      *name = info_ptr->iccp_name;\r\n      *profile = info_ptr->iccp_profile;\r\n      *proflen = png_get_uint_32(info_ptr->iccp_profile);\r\n      /* This is somewhat irrelevant since the profile data returned has\r\n       * actually been uncompressed.\r\n       */\r\n      *compression_type = PNG_COMPRESSION_TYPE_BASE;\r\n      return (PNG_INFO_iCCP);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_sPLT_SUPPORTED\r\nint PNGAPI\r\npng_get_sPLT(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_sPLT_tpp spalettes)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)\r\n   {\r\n      *spalettes = info_ptr->splt_palettes;\r\n      return info_ptr->splt_palettes_num;\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_hIST_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_hIST(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_uint_16p *hist)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"hIST\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)\r\n       && hist != NULL)\r\n   {\r\n      *hist = info_ptr->hist;\r\n      return (PNG_INFO_hIST);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\npng_uint_32 PNGAPI\r\npng_get_IHDR(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_uint_32 *width, png_uint_32 *height, int *bit_depth,\r\n    int *color_type, int *interlace_type, int *compression_type,\r\n    int *filter_type)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"IHDR\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || width == NULL ||\r\n       height == NULL || bit_depth == NULL || color_type == NULL)\r\n      return (0);\r\n\r\n   *width = info_ptr->width;\r\n   *height = info_ptr->height;\r\n   *bit_depth = info_ptr->bit_depth;\r\n   *color_type = info_ptr->color_type;\r\n\r\n   if (compression_type != NULL)\r\n      *compression_type = info_ptr->compression_type;\r\n\r\n   if (filter_type != NULL)\r\n      *filter_type = info_ptr->filter_type;\r\n\r\n   if (interlace_type != NULL)\r\n      *interlace_type = info_ptr->interlace_type;\r\n\r\n   /* This is redundant if we can be sure that the info_ptr values were all\r\n    * assigned in png_set_IHDR().  We do the check anyhow in case an\r\n    * application has ignored our advice not to mess with the members\r\n    * of info_ptr directly.\r\n    */\r\n   png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height,\r\n       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,\r\n       info_ptr->compression_type, info_ptr->filter_type);\r\n\r\n   return (1);\r\n}\r\n\r\n#ifdef PNG_oFFs_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_oFFs(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"oFFs\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)\r\n       && offset_x != NULL && offset_y != NULL && unit_type != NULL)\r\n   {\r\n      *offset_x = info_ptr->x_offset;\r\n      *offset_y = info_ptr->y_offset;\r\n      *unit_type = (int)info_ptr->offset_unit_type;\r\n      return (PNG_INFO_oFFs);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_pCAL_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,\r\n    png_charp *units, png_charpp *params)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"pCAL\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)\r\n       && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&\r\n       nparams != NULL && units != NULL && params != NULL)\r\n   {\r\n      *purpose = info_ptr->pcal_purpose;\r\n      *X0 = info_ptr->pcal_X0;\r\n      *X1 = info_ptr->pcal_X1;\r\n      *type = (int)info_ptr->pcal_type;\r\n      *nparams = (int)info_ptr->pcal_nparams;\r\n      *units = info_ptr->pcal_units;\r\n      *params = info_ptr->pcal_params;\r\n      return (PNG_INFO_pCAL);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_sCAL_SUPPORTED\r\n#  ifdef PNG_FIXED_POINT_SUPPORTED\r\n#    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \\\r\n         defined(PNG_FLOATING_POINT_SUPPORTED)\r\npng_uint_32 PNGAPI\r\npng_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    int *unit, png_fixed_point *width, png_fixed_point *height)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n       (info_ptr->valid & PNG_INFO_sCAL))\r\n   {\r\n      *unit = info_ptr->scal_unit;\r\n      /*TODO: make this work without FP support; the API is currently eliminated\r\n       * if neither floating point APIs nor internal floating point arithmetic\r\n       * are enabled.\r\n       */\r\n      *width = png_fixed(png_ptr, atof(info_ptr->scal_s_width), \"sCAL width\");\r\n      *height = png_fixed(png_ptr, atof(info_ptr->scal_s_height),\r\n         \"sCAL height\");\r\n      return (PNG_INFO_sCAL);\r\n   }\r\n\r\n   return(0);\r\n}\r\n#    endif /* FLOATING_ARITHMETIC */\r\n#  endif /* FIXED_POINT */\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_sCAL(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    int *unit, double *width, double *height)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n       (info_ptr->valid & PNG_INFO_sCAL))\r\n   {\r\n      *unit = info_ptr->scal_unit;\r\n      *width = atof(info_ptr->scal_s_width);\r\n      *height = atof(info_ptr->scal_s_height);\r\n      return (PNG_INFO_sCAL);\r\n   }\r\n\r\n   return(0);\r\n}\r\n#  endif /* FLOATING POINT */\r\npng_uint_32 PNGAPI\r\npng_get_sCAL_s(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    int *unit, png_charpp width, png_charpp height)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n       (info_ptr->valid & PNG_INFO_sCAL))\r\n   {\r\n      *unit = info_ptr->scal_unit;\r\n      *width = info_ptr->scal_s_width;\r\n      *height = info_ptr->scal_s_height;\r\n      return (PNG_INFO_sCAL);\r\n   }\r\n\r\n   return(0);\r\n}\r\n#endif /* sCAL */\r\n\r\n#ifdef PNG_pHYs_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_pHYs(png_const_structrp png_ptr, png_const_inforp info_ptr,\r\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\r\n{\r\n   png_uint_32 retval = 0;\r\n\r\n   png_debug1(1, \"in %s retrieval function\", \"pHYs\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL &&\r\n       (info_ptr->valid & PNG_INFO_pHYs))\r\n   {\r\n      if (res_x != NULL)\r\n      {\r\n         *res_x = info_ptr->x_pixels_per_unit;\r\n         retval |= PNG_INFO_pHYs;\r\n      }\r\n\r\n      if (res_y != NULL)\r\n      {\r\n         *res_y = info_ptr->y_pixels_per_unit;\r\n         retval |= PNG_INFO_pHYs;\r\n      }\r\n\r\n      if (unit_type != NULL)\r\n      {\r\n         *unit_type = (int)info_ptr->phys_unit_type;\r\n         retval |= PNG_INFO_pHYs;\r\n      }\r\n   }\r\n\r\n   return (retval);\r\n}\r\n#endif /* pHYs */\r\n\r\npng_uint_32 PNGAPI\r\npng_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_colorp *palette, int *num_palette)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"PLTE\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)\r\n       && palette != NULL)\r\n   {\r\n      *palette = info_ptr->palette;\r\n      *num_palette = info_ptr->num_palette;\r\n      png_debug1(3, \"num_palette = %d\", *num_palette);\r\n      return (PNG_INFO_PLTE);\r\n   }\r\n\r\n   return (0);\r\n}\r\n\r\n#ifdef PNG_sBIT_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_color_8p *sig_bit)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"sBIT\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)\r\n       && sig_bit != NULL)\r\n   {\r\n      *sig_bit = &(info_ptr->sig_bit);\r\n      return (PNG_INFO_sBIT);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_TEXT_SUPPORTED\r\nint PNGAPI\r\npng_get_text(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_textp *text_ptr, int *num_text)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)\r\n   {\r\n      png_debug1(1, \"in 0x%lx retrieval function\",\r\n         (unsigned long)png_ptr->chunk_name);\r\n\r\n      if (text_ptr != NULL)\r\n         *text_ptr = info_ptr->text;\r\n\r\n      if (num_text != NULL)\r\n         *num_text = info_ptr->num_text;\r\n\r\n      return info_ptr->num_text;\r\n   }\r\n\r\n   if (num_text != NULL)\r\n      *num_text = 0;\r\n\r\n   return(0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_tIME_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_tIME(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_timep *mod_time)\r\n{\r\n   png_debug1(1, \"in %s retrieval function\", \"tIME\");\r\n\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)\r\n       && mod_time != NULL)\r\n   {\r\n      *mod_time = &(info_ptr->mod_time);\r\n      return (PNG_INFO_tIME);\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_tRNS_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_tRNS(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)\r\n{\r\n   png_uint_32 retval = 0;\r\n   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))\r\n   {\r\n      png_debug1(1, \"in %s retrieval function\", \"tRNS\");\r\n\r\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      {\r\n         if (trans_alpha != NULL)\r\n         {\r\n            *trans_alpha = info_ptr->trans_alpha;\r\n            retval |= PNG_INFO_tRNS;\r\n         }\r\n\r\n         if (trans_color != NULL)\r\n            *trans_color = &(info_ptr->trans_color);\r\n      }\r\n\r\n      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */\r\n      {\r\n         if (trans_color != NULL)\r\n         {\r\n            *trans_color = &(info_ptr->trans_color);\r\n            retval |= PNG_INFO_tRNS;\r\n         }\r\n\r\n         if (trans_alpha != NULL)\r\n            *trans_alpha = NULL;\r\n      }\r\n\r\n      if (num_trans != NULL)\r\n      {\r\n         *num_trans = info_ptr->num_trans;\r\n         retval |= PNG_INFO_tRNS;\r\n      }\r\n   }\r\n\r\n   return (retval);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\r\nint PNGAPI\r\npng_get_unknown_chunks(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_unknown_chunkpp unknowns)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)\r\n   {\r\n      *unknowns = info_ptr->unknown_chunks;\r\n      return info_ptr->unknown_chunks_num;\r\n   }\r\n\r\n   return (0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\npng_byte PNGAPI\r\npng_get_rgb_to_gray_status (png_const_structrp png_ptr)\r\n{\r\n   return (png_byte)(png_ptr ? png_ptr->rgb_to_gray_status : 0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_USER_CHUNKS_SUPPORTED\r\npng_voidp PNGAPI\r\npng_get_user_chunk_ptr(png_const_structrp png_ptr)\r\n{\r\n   return (png_ptr ? png_ptr->user_chunk_ptr : NULL);\r\n}\r\n#endif\r\n\r\npng_size_t PNGAPI\r\npng_get_compression_buffer_size(png_const_structrp png_ptr)\r\n{\r\n   if (png_ptr == NULL)\r\n      return 0;\r\n\r\n#  ifdef PNG_WRITE_SUPPORTED\r\n      if (png_ptr->mode & PNG_IS_READ_STRUCT)\r\n#  endif\r\n   {\r\n#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n         return png_ptr->IDAT_read_size;\r\n#     else\r\n         return PNG_IDAT_READ_SIZE;\r\n#     endif\r\n   }\r\n\r\n#  ifdef PNG_WRITE_SUPPORTED\r\n      else\r\n         return png_ptr->zbuffer_size;\r\n#  endif\r\n}\r\n\r\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\r\n/* These functions were added to libpng 1.2.6 and were enabled\r\n * by default in libpng-1.4.0 */\r\npng_uint_32 PNGAPI\r\npng_get_user_width_max (png_const_structrp png_ptr)\r\n{\r\n   return (png_ptr ? png_ptr->user_width_max : 0);\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_user_height_max (png_const_structrp png_ptr)\r\n{\r\n   return (png_ptr ? png_ptr->user_height_max : 0);\r\n}\r\n\r\n/* This function was added to libpng 1.4.0 */\r\npng_uint_32 PNGAPI\r\npng_get_chunk_cache_max (png_const_structrp png_ptr)\r\n{\r\n   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);\r\n}\r\n\r\n/* This function was added to libpng 1.4.1 */\r\npng_alloc_size_t PNGAPI\r\npng_get_chunk_malloc_max (png_const_structrp png_ptr)\r\n{\r\n   return (png_ptr ? png_ptr->user_chunk_malloc_max : 0);\r\n}\r\n#endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */\r\n\r\n/* These functions were added to libpng 1.4.0 */\r\n#ifdef PNG_IO_STATE_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_io_state (png_const_structrp png_ptr)\r\n{\r\n   return png_ptr->io_state;\r\n}\r\n\r\npng_uint_32 PNGAPI\r\npng_get_io_chunk_type (png_const_structrp png_ptr)\r\n{\r\n   return png_ptr->chunk_name;\r\n}\r\n#endif /* ?PNG_IO_STATE_SUPPORTED */\r\n\r\n#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED\r\n#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED\r\nint PNGAPI\r\npng_get_palette_max(png_const_structp png_ptr, png_const_infop info_ptr)\r\n{\r\n   if (png_ptr != NULL && info_ptr != NULL)\r\n      return png_ptr->num_palette_max;\r\n\r\n   return (-1);\r\n}\r\n#  endif\r\n#endif\r\n\r\n#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */\r\n","\r\n/* pngmem.c - stub functions for memory allocation\r\n *\r\n * Last changed in libpng 1.6.8 [December 19, 2013]\r\n * Copyright (c) 1998-2013 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * This file provides a location for all memory allocation.  Users who\r\n * need special memory handling are expected to supply replacement\r\n * functions for png_malloc() and png_free(), and to use\r\n * png_create_read_struct_2() and png_create_write_struct_2() to\r\n * identify the replacement functions.\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n/* Free a png_struct */\r\nvoid /* PRIVATE */\r\npng_destroy_png_struct(png_structrp png_ptr)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      /* png_free might call png_error and may certainly call\r\n       * png_get_mem_ptr, so fake a temporary png_struct to support this.\r\n       */\r\n      png_struct dummy_struct = *png_ptr;\r\n      memset(png_ptr, 0, (sizeof *png_ptr));\r\n      png_free(&dummy_struct, png_ptr);\r\n\r\n#     ifdef PNG_SETJMP_SUPPORTED\r\n         /* We may have a jmp_buf left to deallocate. */\r\n         png_free_jmpbuf(&dummy_struct);\r\n#     endif\r\n   }\r\n}\r\n\r\n/* Allocate memory.  For reasonable files, size should never exceed\r\n * 64K.  However, zlib may allocate more then 64K if you don't tell\r\n * it not to.  See zconf.h and png.h for more information.  zlib does\r\n * need to allocate exactly 64K, so whatever you call here must\r\n * have the ability to do that.\r\n */\r\nPNG_FUNCTION(png_voidp,PNGAPI\r\npng_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)\r\n{\r\n   png_voidp ret;\r\n\r\n   ret = png_malloc(png_ptr, size);\r\n\r\n   if (ret != NULL)\r\n      memset(ret, 0, size);\r\n\r\n   return ret;\r\n}\r\n\r\n/* png_malloc_base, an internal function added at libpng 1.6.0, does the work of\r\n * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.\r\n * Checking and error handling must happen outside this routine; it returns NULL\r\n * if the allocation cannot be done (for any reason.)\r\n */\r\nPNG_FUNCTION(png_voidp /* PRIVATE */,\r\npng_malloc_base,(png_const_structrp png_ptr, png_alloc_size_t size),\r\n   PNG_ALLOCATED)\r\n{\r\n   /* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS\r\n    * allocators have also been removed in 1.6.0, so any 16-bit system now has\r\n    * to implement a user memory handler.  This checks to be sure it isn't\r\n    * called with big numbers.\r\n    */\r\n#ifndef PNG_USER_MEM_SUPPORTED\r\n   PNG_UNUSED(png_ptr)\r\n#endif\r\n\r\n   if (size > 0 && size <= PNG_SIZE_MAX\r\n#     ifdef PNG_MAX_MALLOC_64K\r\n         && size <= 65536U\r\n#     endif\r\n      )\r\n   {\r\n#ifdef PNG_USER_MEM_SUPPORTED\r\n      if (png_ptr != NULL && png_ptr->malloc_fn != NULL)\r\n         return png_ptr->malloc_fn(png_constcast(png_structrp,png_ptr), size);\r\n\r\n      else\r\n#endif\r\n         return malloc((size_t)size); /* checked for truncation above */\r\n   }\r\n\r\n   else\r\n      return NULL;\r\n}\r\n\r\n#if defined(PNG_TEXT_SUPPORTED) || defined(PNG_sPLT_SUPPORTED) ||\\\r\n   defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED)\r\n/* This is really here only to work round a spurious warning in GCC 4.6 and 4.7\r\n * that arises because of the checks in png_realloc_array that are repeated in\r\n * png_malloc_array.\r\n */\r\nstatic png_voidp\r\npng_malloc_array_checked(png_const_structrp png_ptr, int nelements,\r\n   size_t element_size)\r\n{\r\n   png_alloc_size_t req = nelements; /* known to be > 0 */\r\n\r\n   if (req <= PNG_SIZE_MAX/element_size)\r\n      return png_malloc_base(png_ptr, req * element_size);\r\n\r\n   /* The failure case when the request is too large */\r\n   return NULL;\r\n}\r\n\r\nPNG_FUNCTION(png_voidp /* PRIVATE */,\r\npng_malloc_array,(png_const_structrp png_ptr, int nelements,\r\n   size_t element_size),PNG_ALLOCATED)\r\n{\r\n   if (nelements <= 0 || element_size == 0)\r\n      png_error(png_ptr, \"internal error: array alloc\");\r\n\r\n   return png_malloc_array_checked(png_ptr, nelements, element_size);\r\n}\r\n\r\nPNG_FUNCTION(png_voidp /* PRIVATE */,\r\npng_realloc_array,(png_const_structrp png_ptr, png_const_voidp old_array,\r\n   int old_elements, int add_elements, size_t element_size),PNG_ALLOCATED)\r\n{\r\n   /* These are internal errors: */\r\n   if (add_elements <= 0 || element_size == 0 || old_elements < 0 ||\r\n      (old_array == NULL && old_elements > 0))\r\n      png_error(png_ptr, \"internal error: array realloc\");\r\n\r\n   /* Check for overflow on the elements count (so the caller does not have to\r\n    * check.)\r\n    */\r\n   if (add_elements <= INT_MAX - old_elements)\r\n   {\r\n      png_voidp new_array = png_malloc_array_checked(png_ptr,\r\n         old_elements+add_elements, element_size);\r\n\r\n      if (new_array != NULL)\r\n      {\r\n         /* Because png_malloc_array worked the size calculations below cannot\r\n          * overflow.\r\n          */\r\n         if (old_elements > 0)\r\n            memcpy(new_array, old_array, element_size*(unsigned)old_elements);\r\n\r\n         memset((char*)new_array + element_size*(unsigned)old_elements, 0,\r\n            element_size*(unsigned)add_elements);\r\n\r\n         return new_array;\r\n      }\r\n   }\r\n\r\n   return NULL; /* error */\r\n}\r\n#endif /* TEXT || sPLT || STORE_UNKNOWN_CHUNKS */\r\n\r\n/* Various functions that have different error handling are derived from this.\r\n * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate\r\n * function png_malloc_default is also provided.\r\n */\r\nPNG_FUNCTION(png_voidp,PNGAPI\r\npng_malloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)\r\n{\r\n   png_voidp ret;\r\n\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   ret = png_malloc_base(png_ptr, size);\r\n\r\n   if (ret == NULL)\r\n       png_error(png_ptr, \"Out of memory\"); /* 'm' means png_malloc */\r\n\r\n   return ret;\r\n}\r\n\r\n#ifdef PNG_USER_MEM_SUPPORTED\r\nPNG_FUNCTION(png_voidp,PNGAPI\r\npng_malloc_default,(png_const_structrp png_ptr, png_alloc_size_t size),\r\n   PNG_ALLOCATED PNG_DEPRECATED)\r\n{\r\n   png_voidp ret;\r\n\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   /* Passing 'NULL' here bypasses the application provided memory handler. */\r\n   ret = png_malloc_base(NULL/*use malloc*/, size);\r\n\r\n   if (ret == NULL)\r\n      png_error(png_ptr, \"Out of Memory\"); /* 'M' means png_malloc_default */\r\n\r\n   return ret;\r\n}\r\n#endif /* PNG_USER_MEM_SUPPORTED */\r\n\r\n/* This function was added at libpng version 1.2.3.  The png_malloc_warn()\r\n * function will issue a png_warning and return NULL instead of issuing a\r\n * png_error, if it fails to allocate the requested memory.\r\n */\r\nPNG_FUNCTION(png_voidp,PNGAPI\r\npng_malloc_warn,(png_const_structrp png_ptr, png_alloc_size_t size),\r\n   PNG_ALLOCATED)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      png_voidp ret = png_malloc_base(png_ptr, size);\r\n\r\n      if (ret != NULL)\r\n         return ret;\r\n\r\n      png_warning(png_ptr, \"Out of memory\");\r\n   }\r\n\r\n   return NULL;\r\n}\r\n\r\n/* Free a pointer allocated by png_malloc().  If ptr is NULL, return\r\n * without taking any action.\r\n */\r\nvoid PNGAPI\r\npng_free(png_const_structrp png_ptr, png_voidp ptr)\r\n{\r\n   if (png_ptr == NULL || ptr == NULL)\r\n      return;\r\n\r\n#ifdef PNG_USER_MEM_SUPPORTED\r\n   if (png_ptr->free_fn != NULL)\r\n      png_ptr->free_fn(png_constcast(png_structrp,png_ptr), ptr);\r\n\r\n   else\r\n      png_free_default(png_ptr, ptr);\r\n}\r\n\r\nPNG_FUNCTION(void,PNGAPI\r\npng_free_default,(png_const_structrp png_ptr, png_voidp ptr),PNG_DEPRECATED)\r\n{\r\n   if (png_ptr == NULL || ptr == NULL)\r\n      return;\r\n#endif /* PNG_USER_MEM_SUPPORTED */\r\n\r\n   free(ptr);\r\n}\r\n\r\n#ifdef PNG_USER_MEM_SUPPORTED\r\n/* This function is called when the application wants to use another method\r\n * of allocating and freeing memory.\r\n */\r\nvoid PNGAPI\r\npng_set_mem_fn(png_structrp png_ptr, png_voidp mem_ptr, png_malloc_ptr\r\n  malloc_fn, png_free_ptr free_fn)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      png_ptr->mem_ptr = mem_ptr;\r\n      png_ptr->malloc_fn = malloc_fn;\r\n      png_ptr->free_fn = free_fn;\r\n   }\r\n}\r\n\r\n/* This function returns a pointer to the mem_ptr associated with the user\r\n * functions.  The application should free any memory associated with this\r\n * pointer before png_write_destroy and png_read_destroy are called.\r\n */\r\npng_voidp PNGAPI\r\npng_get_mem_ptr(png_const_structrp png_ptr)\r\n{\r\n   if (png_ptr == NULL)\r\n      return NULL;\r\n\r\n   return png_ptr->mem_ptr;\r\n}\r\n#endif /* PNG_USER_MEM_SUPPORTED */\r\n#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */\r\n","\r\n/* pngread.c - read a PNG file\r\n *\r\n * Last changed in libpng 1.6.10 [March 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * This file contains routines that an application calls directly to\r\n * read a PNG file or stream.\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)\r\n#  include <errno.h>\r\n#endif\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\n\r\n/* Create a PNG structure for reading, and allocate any memory needed. */\r\nPNG_FUNCTION(png_structp,PNGAPI\r\npng_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,\r\n    png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)\r\n{\r\n#ifndef PNG_USER_MEM_SUPPORTED\r\n   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,\r\n      error_fn, warn_fn, NULL, NULL, NULL);\r\n#else\r\n   return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,\r\n       warn_fn, NULL, NULL, NULL);\r\n}\r\n\r\n/* Alternate create PNG structure for reading, and allocate any memory\r\n * needed.\r\n */\r\nPNG_FUNCTION(png_structp,PNGAPI\r\npng_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,\r\n    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,\r\n    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)\r\n{\r\n   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,\r\n      error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);\r\n#endif /* PNG_USER_MEM_SUPPORTED */\r\n\r\n   if (png_ptr != NULL)\r\n   {\r\n      png_ptr->mode = PNG_IS_READ_STRUCT;\r\n\r\n      /* Added in libpng-1.6.0; this can be used to detect a read structure if\r\n       * required (it will be zero in a write structure.)\r\n       */\r\n#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n         png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;\r\n#     endif\r\n\r\n#     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED\r\n         png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;\r\n\r\n         /* In stable builds only warn if an application error can be completely\r\n          * handled.\r\n          */\r\n#        if PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC\r\n            png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;\r\n#        endif\r\n#     endif\r\n\r\n      /* TODO: delay this, it can be done in png_init_io (if the app doesn't\r\n       * do it itself) avoiding setting the default function if it is not\r\n       * required.\r\n       */\r\n      png_set_read_fn(png_ptr, NULL, NULL);\r\n   }\r\n\r\n   return png_ptr;\r\n}\r\n\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n/* Read the information before the actual image data.  This has been\r\n * changed in v0.90 to allow reading a file that already has the magic\r\n * bytes read from the stream.  You can tell libpng how many bytes have\r\n * been read from the beginning of the stream (up to the maximum of 8)\r\n * via png_set_sig_bytes(), and we will only check the remaining bytes\r\n * here.  The application can then have access to the signature bytes we\r\n * read if it is determined that this isn't a valid PNG file.\r\n */\r\nvoid PNGAPI\r\npng_read_info(png_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\n   int keep;\r\n#endif\r\n\r\n   png_debug(1, \"in png_read_info\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   /* Read and check the PNG file signature. */\r\n   png_read_sig(png_ptr, info_ptr);\r\n\r\n   for (;;)\r\n   {\r\n      png_uint_32 length = png_read_chunk_header(png_ptr);\r\n      png_uint_32 chunk_name = png_ptr->chunk_name;\r\n\r\n      /* IDAT logic needs to happen here to simplify getting the two flags\r\n       * right.\r\n       */\r\n      if (chunk_name == png_IDAT)\r\n      {\r\n         if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n            png_chunk_error(png_ptr, \"Missing IHDR before IDAT\");\r\n\r\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\r\n             !(png_ptr->mode & PNG_HAVE_PLTE))\r\n            png_chunk_error(png_ptr, \"Missing PLTE before IDAT\");\r\n\r\n         else if (png_ptr->mode & PNG_AFTER_IDAT)\r\n            png_chunk_benign_error(png_ptr, \"Too many IDATs found\");\r\n\r\n         png_ptr->mode |= PNG_HAVE_IDAT;\r\n      }\r\n\r\n      else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n         png_ptr->mode |= PNG_AFTER_IDAT;\r\n\r\n      /* This should be a binary subdivision search or a hash for\r\n       * matching the chunk name rather than a linear search.\r\n       */\r\n      if (chunk_name == png_IHDR)\r\n         png_handle_IHDR(png_ptr, info_ptr, length);\r\n\r\n      else if (chunk_name == png_IEND)\r\n         png_handle_IEND(png_ptr, info_ptr, length);\r\n\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\n      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)\r\n      {\r\n         png_handle_unknown(png_ptr, info_ptr, length, keep);\r\n\r\n         if (chunk_name == png_PLTE)\r\n            png_ptr->mode |= PNG_HAVE_PLTE;\r\n\r\n         else if (chunk_name == png_IDAT)\r\n         {\r\n            png_ptr->idat_size = 0; /* It has been consumed */\r\n            break;\r\n         }\r\n      }\r\n#endif\r\n      else if (chunk_name == png_PLTE)\r\n         png_handle_PLTE(png_ptr, info_ptr, length);\r\n\r\n      else if (chunk_name == png_IDAT)\r\n      {\r\n         png_ptr->idat_size = length;\r\n         break;\r\n      }\r\n\r\n#ifdef PNG_READ_bKGD_SUPPORTED\r\n      else if (chunk_name == png_bKGD)\r\n         png_handle_bKGD(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_cHRM_SUPPORTED\r\n      else if (chunk_name == png_cHRM)\r\n         png_handle_cHRM(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_gAMA_SUPPORTED\r\n      else if (chunk_name == png_gAMA)\r\n         png_handle_gAMA(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_hIST_SUPPORTED\r\n      else if (chunk_name == png_hIST)\r\n         png_handle_hIST(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_oFFs_SUPPORTED\r\n      else if (chunk_name == png_oFFs)\r\n         png_handle_oFFs(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_pCAL_SUPPORTED\r\n      else if (chunk_name == png_pCAL)\r\n         png_handle_pCAL(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sCAL_SUPPORTED\r\n      else if (chunk_name == png_sCAL)\r\n         png_handle_sCAL(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_pHYs_SUPPORTED\r\n      else if (chunk_name == png_pHYs)\r\n         png_handle_pHYs(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sBIT_SUPPORTED\r\n      else if (chunk_name == png_sBIT)\r\n         png_handle_sBIT(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sRGB_SUPPORTED\r\n      else if (chunk_name == png_sRGB)\r\n         png_handle_sRGB(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_iCCP_SUPPORTED\r\n      else if (chunk_name == png_iCCP)\r\n         png_handle_iCCP(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sPLT_SUPPORTED\r\n      else if (chunk_name == png_sPLT)\r\n         png_handle_sPLT(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_tEXt_SUPPORTED\r\n      else if (chunk_name == png_tEXt)\r\n         png_handle_tEXt(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_tIME_SUPPORTED\r\n      else if (chunk_name == png_tIME)\r\n         png_handle_tIME(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_tRNS_SUPPORTED\r\n      else if (chunk_name == png_tRNS)\r\n         png_handle_tRNS(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_zTXt_SUPPORTED\r\n      else if (chunk_name == png_zTXt)\r\n         png_handle_zTXt(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_iTXt_SUPPORTED\r\n      else if (chunk_name == png_iTXt)\r\n         png_handle_iTXt(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n      else\r\n         png_handle_unknown(png_ptr, info_ptr, length,\r\n            PNG_HANDLE_CHUNK_AS_DEFAULT);\r\n   }\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n/* Optional call to update the users info_ptr structure */\r\nvoid PNGAPI\r\npng_read_update_info(png_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n   png_debug(1, \"in png_read_update_info\");\r\n\r\n   if (png_ptr != NULL)\r\n   {\r\n      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\r\n      {\r\n         png_read_start_row(png_ptr);\r\n\r\n#        ifdef PNG_READ_TRANSFORMS_SUPPORTED\r\n            png_read_transform_info(png_ptr, info_ptr);\r\n#        else\r\n            PNG_UNUSED(info_ptr)\r\n#        endif\r\n      }\r\n\r\n      /* New in 1.6.0 this avoids the bug of doing the initializations twice */\r\n      else\r\n         png_app_error(png_ptr,\r\n            \"png_read_update_info/png_start_read_image: duplicate call\");\r\n   }\r\n}\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n/* Initialize palette, background, etc, after transformations\r\n * are set, but before any reading takes place.  This allows\r\n * the user to obtain a gamma-corrected palette, for example.\r\n * If the user doesn't call this, we will do it ourselves.\r\n */\r\nvoid PNGAPI\r\npng_start_read_image(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_start_read_image\");\r\n\r\n   if (png_ptr != NULL)\r\n   {\r\n      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\r\n         png_read_start_row(png_ptr);\r\n\r\n      /* New in 1.6.0 this avoids the bug of doing the initializations twice */\r\n      else\r\n         png_app_error(png_ptr,\r\n            \"png_start_read_image/png_read_update_info: duplicate call\");\r\n   }\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n#ifdef PNG_MNG_FEATURES_SUPPORTED\r\n/* Undoes intrapixel differencing,\r\n * NOTE: this is apparently only supported in the 'sequential' reader.\r\n */\r\nstatic void\r\npng_do_read_intrapixel(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_read_intrapixel\");\r\n\r\n   if (\r\n       (row_info->color_type & PNG_COLOR_MASK_COLOR))\r\n   {\r\n      int bytes_per_pixel;\r\n      png_uint_32 row_width = row_info->width;\r\n\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         png_bytep rp;\r\n         png_uint_32 i;\r\n\r\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\r\n            bytes_per_pixel = 3;\r\n\r\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n            bytes_per_pixel = 4;\r\n\r\n         else\r\n            return;\r\n\r\n         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)\r\n         {\r\n            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);\r\n            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);\r\n         }\r\n      }\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         png_bytep rp;\r\n         png_uint_32 i;\r\n\r\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\r\n            bytes_per_pixel = 6;\r\n\r\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n            bytes_per_pixel = 8;\r\n\r\n         else\r\n            return;\r\n\r\n         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)\r\n         {\r\n            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);\r\n            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);\r\n            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);\r\n            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;\r\n            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;\r\n            *(rp    ) = (png_byte)((red >> 8) & 0xff);\r\n            *(rp + 1) = (png_byte)(red & 0xff);\r\n            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);\r\n            *(rp + 5) = (png_byte)(blue & 0xff);\r\n         }\r\n      }\r\n   }\r\n}\r\n#endif /* PNG_MNG_FEATURES_SUPPORTED */\r\n\r\nvoid PNGAPI\r\npng_read_row(png_structrp png_ptr, png_bytep row, png_bytep dsp_row)\r\n{\r\n   png_row_info row_info;\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_debug2(1, \"in png_read_row (row %lu, pass %d)\",\r\n       (unsigned long)png_ptr->row_number, png_ptr->pass);\r\n\r\n   /* png_read_start_row sets the information (in particular iwidth) for this\r\n    * interlace pass.\r\n    */\r\n   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))\r\n      png_read_start_row(png_ptr);\r\n\r\n   /* 1.5.6: row_info moved out of png_struct to a local here. */\r\n   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */\r\n   row_info.color_type = png_ptr->color_type;\r\n   row_info.bit_depth = png_ptr->bit_depth;\r\n   row_info.channels = png_ptr->channels;\r\n   row_info.pixel_depth = png_ptr->pixel_depth;\r\n   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);\r\n\r\n   if (png_ptr->row_number == 0 && png_ptr->pass == 0)\r\n   {\r\n   /* Check for transforms that have been set but were defined out */\r\n#if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_INVERT_MONO)\r\n      png_warning(png_ptr, \"PNG_READ_INVERT_SUPPORTED is not defined\");\r\n#endif\r\n\r\n#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_FILLER)\r\n      png_warning(png_ptr, \"PNG_READ_FILLER_SUPPORTED is not defined\");\r\n#endif\r\n\r\n#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \\\r\n    !defined(PNG_READ_PACKSWAP_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_PACKSWAP)\r\n      png_warning(png_ptr, \"PNG_READ_PACKSWAP_SUPPORTED is not defined\");\r\n#endif\r\n\r\n#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_PACK)\r\n      png_warning(png_ptr, \"PNG_READ_PACK_SUPPORTED is not defined\");\r\n#endif\r\n\r\n#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_SHIFT)\r\n      png_warning(png_ptr, \"PNG_READ_SHIFT_SUPPORTED is not defined\");\r\n#endif\r\n\r\n#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_BGR)\r\n      png_warning(png_ptr, \"PNG_READ_BGR_SUPPORTED is not defined\");\r\n#endif\r\n\r\n#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_SWAP_BYTES)\r\n      png_warning(png_ptr, \"PNG_READ_SWAP_SUPPORTED is not defined\");\r\n#endif\r\n   }\r\n\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   /* If interlaced and we do not need a new row, combine row and return.\r\n    * Notice that the pixels we have from previous rows have been transformed\r\n    * already; we can only combine like with like (transformed or\r\n    * untransformed) and, because of the libpng API for interlaced images, this\r\n    * means we must transform before de-interlacing.\r\n    */\r\n   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))\r\n   {\r\n      switch (png_ptr->pass)\r\n      {\r\n         case 0:\r\n            if (png_ptr->row_number & 0x07)\r\n            {\r\n               if (dsp_row != NULL)\r\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n\r\n         case 1:\r\n            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)\r\n            {\r\n               if (dsp_row != NULL)\r\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n\r\n         case 2:\r\n            if ((png_ptr->row_number & 0x07) != 4)\r\n            {\r\n               if (dsp_row != NULL && (png_ptr->row_number & 4))\r\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n\r\n         case 3:\r\n            if ((png_ptr->row_number & 3) || png_ptr->width < 3)\r\n            {\r\n               if (dsp_row != NULL)\r\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n\r\n         case 4:\r\n            if ((png_ptr->row_number & 3) != 2)\r\n            {\r\n               if (dsp_row != NULL && (png_ptr->row_number & 2))\r\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n\r\n         case 5:\r\n            if ((png_ptr->row_number & 1) || png_ptr->width < 2)\r\n            {\r\n               if (dsp_row != NULL)\r\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n\r\n         default:\r\n         case 6:\r\n            if (!(png_ptr->row_number & 1))\r\n            {\r\n               png_read_finish_row(png_ptr);\r\n               return;\r\n            }\r\n            break;\r\n      }\r\n   }\r\n#endif\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IDAT))\r\n      png_error(png_ptr, \"Invalid attempt to read row data\");\r\n\r\n   /* Fill the row with IDAT data: */\r\n   png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);\r\n\r\n   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)\r\n   {\r\n      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)\r\n         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,\r\n            png_ptr->prev_row + 1, png_ptr->row_buf[0]);\r\n      else\r\n         png_error(png_ptr, \"bad adaptive filter value\");\r\n   }\r\n\r\n   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before\r\n    * 1.5.6, while the buffer really is this big in current versions of libpng\r\n    * it may not be in the future, so this was changed just to copy the\r\n    * interlaced count:\r\n    */\r\n   memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);\r\n\r\n#ifdef PNG_MNG_FEATURES_SUPPORTED\r\n   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&\r\n       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))\r\n   {\r\n      /* Intrapixel differencing */\r\n      png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\r\n   if (png_ptr->transformations)\r\n      png_do_read_transformations(png_ptr, &row_info);\r\n#endif\r\n\r\n   /* The transformed pixel depth should match the depth now in row_info. */\r\n   if (png_ptr->transformed_pixel_depth == 0)\r\n   {\r\n      png_ptr->transformed_pixel_depth = row_info.pixel_depth;\r\n      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)\r\n         png_error(png_ptr, \"sequential row overflow\");\r\n   }\r\n\r\n   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)\r\n      png_error(png_ptr, \"internal sequential row size calculation error\");\r\n\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   /* Blow up interlaced rows to full size */\r\n   if (png_ptr->interlaced &&\r\n      (png_ptr->transformations & PNG_INTERLACE))\r\n   {\r\n      if (png_ptr->pass < 6)\r\n         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,\r\n            png_ptr->transformations);\r\n\r\n      if (dsp_row != NULL)\r\n         png_combine_row(png_ptr, dsp_row, 1/*display*/);\r\n\r\n      if (row != NULL)\r\n         png_combine_row(png_ptr, row, 0/*row*/);\r\n   }\r\n\r\n   else\r\n#endif\r\n   {\r\n      if (row != NULL)\r\n         png_combine_row(png_ptr, row, -1/*ignored*/);\r\n\r\n      if (dsp_row != NULL)\r\n         png_combine_row(png_ptr, dsp_row, -1/*ignored*/);\r\n   }\r\n   png_read_finish_row(png_ptr);\r\n\r\n   if (png_ptr->read_row_fn != NULL)\r\n      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);\r\n\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n/* Read one or more rows of image data.  If the image is interlaced,\r\n * and png_set_interlace_handling() has been called, the rows need to\r\n * contain the contents of the rows from the previous pass.  If the\r\n * image has alpha or transparency, and png_handle_alpha()[*] has been\r\n * called, the rows contents must be initialized to the contents of the\r\n * screen.\r\n *\r\n * \"row\" holds the actual image, and pixels are placed in it\r\n * as they arrive.  If the image is displayed after each pass, it will\r\n * appear to \"sparkle\" in.  \"display_row\" can be used to display a\r\n * \"chunky\" progressive image, with finer detail added as it becomes\r\n * available.  If you do not want this \"chunky\" display, you may pass\r\n * NULL for display_row.  If you do not want the sparkle display, and\r\n * you have not called png_handle_alpha(), you may pass NULL for rows.\r\n * If you have called png_handle_alpha(), and the image has either an\r\n * alpha channel or a transparency chunk, you must provide a buffer for\r\n * rows.  In this case, you do not have to provide a display_row buffer\r\n * also, but you may.  If the image is not interlaced, or if you have\r\n * not called png_set_interlace_handling(), the display_row buffer will\r\n * be ignored, so pass NULL to it.\r\n *\r\n * [*] png_handle_alpha() does not exist yet, as of this version of libpng\r\n */\r\n\r\nvoid PNGAPI\r\npng_read_rows(png_structrp png_ptr, png_bytepp row,\r\n    png_bytepp display_row, png_uint_32 num_rows)\r\n{\r\n   png_uint_32 i;\r\n   png_bytepp rp;\r\n   png_bytepp dp;\r\n\r\n   png_debug(1, \"in png_read_rows\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   rp = row;\r\n   dp = display_row;\r\n   if (rp != NULL && dp != NULL)\r\n      for (i = 0; i < num_rows; i++)\r\n      {\r\n         png_bytep rptr = *rp++;\r\n         png_bytep dptr = *dp++;\r\n\r\n         png_read_row(png_ptr, rptr, dptr);\r\n      }\r\n\r\n   else if (rp != NULL)\r\n      for (i = 0; i < num_rows; i++)\r\n      {\r\n         png_bytep rptr = *rp;\r\n         png_read_row(png_ptr, rptr, NULL);\r\n         rp++;\r\n      }\r\n\r\n   else if (dp != NULL)\r\n      for (i = 0; i < num_rows; i++)\r\n      {\r\n         png_bytep dptr = *dp;\r\n         png_read_row(png_ptr, NULL, dptr);\r\n         dp++;\r\n      }\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n/* Read the entire image.  If the image has an alpha channel or a tRNS\r\n * chunk, and you have called png_handle_alpha()[*], you will need to\r\n * initialize the image to the current image that PNG will be overlaying.\r\n * We set the num_rows again here, in case it was incorrectly set in\r\n * png_read_start_row() by a call to png_read_update_info() or\r\n * png_start_read_image() if png_set_interlace_handling() wasn't called\r\n * prior to either of these functions like it should have been.  You can\r\n * only call this function once.  If you desire to have an image for\r\n * each pass of a interlaced image, use png_read_rows() instead.\r\n *\r\n * [*] png_handle_alpha() does not exist yet, as of this version of libpng\r\n */\r\nvoid PNGAPI\r\npng_read_image(png_structrp png_ptr, png_bytepp image)\r\n{\r\n   png_uint_32 i, image_height;\r\n   int pass, j;\r\n   png_bytepp rp;\r\n\r\n   png_debug(1, \"in png_read_image\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))\r\n   {\r\n      pass = png_set_interlace_handling(png_ptr);\r\n      /* And make sure transforms are initialized. */\r\n      png_start_read_image(png_ptr);\r\n   }\r\n   else\r\n   {\r\n      if (png_ptr->interlaced && !(png_ptr->transformations & PNG_INTERLACE))\r\n      {\r\n         /* Caller called png_start_read_image or png_read_update_info without\r\n          * first turning on the PNG_INTERLACE transform.  We can fix this here,\r\n          * but the caller should do it!\r\n          */\r\n         png_warning(png_ptr, \"Interlace handling should be turned on when \"\r\n            \"using png_read_image\");\r\n         /* Make sure this is set correctly */\r\n         png_ptr->num_rows = png_ptr->height;\r\n      }\r\n\r\n      /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in\r\n       * the above error case.\r\n       */\r\n      pass = png_set_interlace_handling(png_ptr);\r\n   }\r\n#else\r\n   if (png_ptr->interlaced)\r\n      png_error(png_ptr,\r\n          \"Cannot read interlaced image -- interlace handler disabled\");\r\n\r\n   pass = 1;\r\n#endif\r\n\r\n   image_height=png_ptr->height;\r\n\r\n   for (j = 0; j < pass; j++)\r\n   {\r\n      rp = image;\r\n      for (i = 0; i < image_height; i++)\r\n      {\r\n         png_read_row(png_ptr, *rp, NULL);\r\n         rp++;\r\n      }\r\n   }\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n/* Read the end of the PNG file.  Will not read past the end of the\r\n * file, will verify the end is accurate, and will read any comments\r\n * or time information at the end of the file, if info is not NULL.\r\n */\r\nvoid PNGAPI\r\npng_read_end(png_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\n   int keep;\r\n#endif\r\n\r\n   png_debug(1, \"in png_read_end\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   /* If png_read_end is called in the middle of reading the rows there may\r\n    * still be pending IDAT data and an owned zstream.  Deal with this here.\r\n    */\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\n   if (!png_chunk_unknown_handling(png_ptr, png_IDAT))\r\n#endif\r\n      png_read_finish_IDAT(png_ptr);\r\n\r\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\r\n   /* Report invalid palette index; added at libng-1.5.10 */\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\r\n      png_ptr->num_palette_max > png_ptr->num_palette)\r\n     png_benign_error(png_ptr, \"Read palette index exceeding num_palette\");\r\n#endif\r\n\r\n   do\r\n   {\r\n      png_uint_32 length = png_read_chunk_header(png_ptr);\r\n      png_uint_32 chunk_name = png_ptr->chunk_name;\r\n\r\n      if (chunk_name == png_IEND)\r\n         png_handle_IEND(png_ptr, info_ptr, length);\r\n\r\n      else if (chunk_name == png_IHDR)\r\n         png_handle_IHDR(png_ptr, info_ptr, length);\r\n\r\n      else if (info_ptr == NULL)\r\n         png_crc_finish(png_ptr, length);\r\n\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\n      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)\r\n      {\r\n         if (chunk_name == png_IDAT)\r\n         {\r\n            if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))\r\n               png_benign_error(png_ptr, \"Too many IDATs found\");\r\n         }\r\n         png_handle_unknown(png_ptr, info_ptr, length, keep);\r\n         if (chunk_name == png_PLTE)\r\n            png_ptr->mode |= PNG_HAVE_PLTE;\r\n      }\r\n#endif\r\n\r\n      else if (chunk_name == png_IDAT)\r\n      {\r\n         /* Zero length IDATs are legal after the last IDAT has been\r\n          * read, but not after other chunks have been read.\r\n          */\r\n         if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))\r\n            png_benign_error(png_ptr, \"Too many IDATs found\");\r\n\r\n         png_crc_finish(png_ptr, length);\r\n      }\r\n      else if (chunk_name == png_PLTE)\r\n         png_handle_PLTE(png_ptr, info_ptr, length);\r\n\r\n#ifdef PNG_READ_bKGD_SUPPORTED\r\n      else if (chunk_name == png_bKGD)\r\n         png_handle_bKGD(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_cHRM_SUPPORTED\r\n      else if (chunk_name == png_cHRM)\r\n         png_handle_cHRM(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_gAMA_SUPPORTED\r\n      else if (chunk_name == png_gAMA)\r\n         png_handle_gAMA(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_hIST_SUPPORTED\r\n      else if (chunk_name == png_hIST)\r\n         png_handle_hIST(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_oFFs_SUPPORTED\r\n      else if (chunk_name == png_oFFs)\r\n         png_handle_oFFs(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_pCAL_SUPPORTED\r\n      else if (chunk_name == png_pCAL)\r\n         png_handle_pCAL(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sCAL_SUPPORTED\r\n      else if (chunk_name == png_sCAL)\r\n         png_handle_sCAL(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_pHYs_SUPPORTED\r\n      else if (chunk_name == png_pHYs)\r\n         png_handle_pHYs(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sBIT_SUPPORTED\r\n      else if (chunk_name == png_sBIT)\r\n         png_handle_sBIT(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sRGB_SUPPORTED\r\n      else if (chunk_name == png_sRGB)\r\n         png_handle_sRGB(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_iCCP_SUPPORTED\r\n      else if (chunk_name == png_iCCP)\r\n         png_handle_iCCP(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_sPLT_SUPPORTED\r\n      else if (chunk_name == png_sPLT)\r\n         png_handle_sPLT(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_tEXt_SUPPORTED\r\n      else if (chunk_name == png_tEXt)\r\n         png_handle_tEXt(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_tIME_SUPPORTED\r\n      else if (chunk_name == png_tIME)\r\n         png_handle_tIME(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_tRNS_SUPPORTED\r\n      else if (chunk_name == png_tRNS)\r\n         png_handle_tRNS(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_zTXt_SUPPORTED\r\n      else if (chunk_name == png_zTXt)\r\n         png_handle_zTXt(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n#ifdef PNG_READ_iTXt_SUPPORTED\r\n      else if (chunk_name == png_iTXt)\r\n         png_handle_iTXt(png_ptr, info_ptr, length);\r\n#endif\r\n\r\n      else\r\n         png_handle_unknown(png_ptr, info_ptr, length,\r\n            PNG_HANDLE_CHUNK_AS_DEFAULT);\r\n   } while (!(png_ptr->mode & PNG_HAVE_IEND));\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n/* Free all memory used in the read struct */\r\nstatic void\r\npng_read_destroy(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_read_destroy\");\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n   png_destroy_gamma_table(png_ptr);\r\n#endif\r\n\r\n   png_free(png_ptr, png_ptr->big_row_buf);\r\n   png_free(png_ptr, png_ptr->big_prev_row);\r\n   png_free(png_ptr, png_ptr->read_buffer);\r\n\r\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\r\n   png_free(png_ptr, png_ptr->palette_lookup);\r\n   png_free(png_ptr, png_ptr->quantize_index);\r\n#endif\r\n\r\n   if (png_ptr->free_me & PNG_FREE_PLTE)\r\n      png_zfree(png_ptr, png_ptr->palette);\r\n   png_ptr->free_me &= ~PNG_FREE_PLTE;\r\n\r\n#if defined(PNG_tRNS_SUPPORTED) || \\\r\n    defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\r\n   if (png_ptr->free_me & PNG_FREE_TRNS)\r\n      png_free(png_ptr, png_ptr->trans_alpha);\r\n   png_ptr->free_me &= ~PNG_FREE_TRNS;\r\n#endif\r\n\r\n   inflateEnd(&png_ptr->zstream);\r\n\r\n#ifdef PNG_PROGRESSIVE_READ_SUPPORTED\r\n   png_free(png_ptr, png_ptr->save_buffer);\r\n#endif\r\n\r\n#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) &&\\\r\n   defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\r\n   png_free(png_ptr, png_ptr->unknown_chunk.data);\r\n#endif\r\n\r\n#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\r\n   png_free(png_ptr, png_ptr->chunk_list);\r\n#endif\r\n\r\n   /* NOTE: the 'setjmp' buffer may still be allocated and the memory and error\r\n    * callbacks are still set at this point.  They are required to complete the\r\n    * destruction of the png_struct itself.\r\n    */\r\n}\r\n\r\n/* Free all memory used by the read */\r\nvoid PNGAPI\r\npng_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,\r\n    png_infopp end_info_ptr_ptr)\r\n{\r\n   png_structrp png_ptr = NULL;\r\n\r\n   png_debug(1, \"in png_destroy_read_struct\");\r\n\r\n   if (png_ptr_ptr != NULL)\r\n      png_ptr = *png_ptr_ptr;\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   /* libpng 1.6.0: use the API to destroy info structs to ensure consistent\r\n    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.\r\n    * The extra was, apparently, unnecessary yet this hides memory leak bugs.\r\n    */\r\n   png_destroy_info_struct(png_ptr, end_info_ptr_ptr);\r\n   png_destroy_info_struct(png_ptr, info_ptr_ptr);\r\n\r\n   *png_ptr_ptr = NULL;\r\n   png_read_destroy(png_ptr);\r\n   png_destroy_png_struct(png_ptr);\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_read_status_fn(png_structrp png_ptr, png_read_status_ptr read_row_fn)\r\n{\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->read_row_fn = read_row_fn;\r\n}\r\n\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n#ifdef PNG_INFO_IMAGE_SUPPORTED\r\nvoid PNGAPI\r\npng_read_png(png_structrp png_ptr, png_inforp info_ptr,\r\n                           int transforms,\r\n                           voidp params)\r\n{\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   /* png_read_info() gives us all of the information from the\r\n    * PNG file before the first IDAT (image data chunk).\r\n    */\r\n   png_read_info(png_ptr, info_ptr);\r\n   if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))\r\n      png_error(png_ptr, \"Image is too high to process with png_read_png()\");\r\n\r\n   /* -------------- image transformations start here ------------------- */\r\n   /* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM\r\n    * is not implemented.  This will only happen in de-configured (non-default)\r\n    * libpng builds.  The results can be unexpected - png_read_png may return\r\n    * short or mal-formed rows because the transform is skipped.\r\n    */\r\n\r\n   /* Tell libpng to strip 16-bit/color files down to 8 bits per color.\r\n    */\r\n   if (transforms & PNG_TRANSFORM_SCALE_16)\r\n     /* Added at libpng-1.5.4. \"strip_16\" produces the same result that it\r\n      * did in earlier versions, while \"scale_16\" is now more accurate.\r\n      */\r\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\r\n      png_set_scale_16(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SCALE_16 not supported\");\r\n#endif\r\n\r\n   /* If both SCALE and STRIP are required pngrtran will effectively cancel the\r\n    * latter by doing SCALE first.  This is ok and allows apps not to check for\r\n    * which is supported to get the right answer.\r\n    */\r\n   if (transforms & PNG_TRANSFORM_STRIP_16)\r\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\r\n      png_set_strip_16(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_STRIP_16 not supported\");\r\n#endif\r\n\r\n   /* Strip alpha bytes from the input data without combining with\r\n    * the background (not recommended).\r\n    */\r\n   if (transforms & PNG_TRANSFORM_STRIP_ALPHA)\r\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\r\n      png_set_strip_alpha(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_STRIP_ALPHA not supported\");\r\n#endif\r\n\r\n   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single\r\n    * byte into separate bytes (useful for paletted and grayscale images).\r\n    */\r\n   if (transforms & PNG_TRANSFORM_PACKING)\r\n#ifdef PNG_READ_PACK_SUPPORTED\r\n      png_set_packing(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_PACKING not supported\");\r\n#endif\r\n\r\n   /* Change the order of packed pixels to least significant bit first\r\n    * (not useful if you are using png_set_packing).\r\n    */\r\n   if (transforms & PNG_TRANSFORM_PACKSWAP)\r\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n      png_set_packswap(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_PACKSWAP not supported\");\r\n#endif\r\n\r\n   /* Expand paletted colors into true RGB triplets\r\n    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel\r\n    * Expand paletted or RGB images with transparency to full alpha\r\n    * channels so the data will be available as RGBA quartets.\r\n    */\r\n   if (transforms & PNG_TRANSFORM_EXPAND)\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n      png_set_expand(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_EXPAND not supported\");\r\n#endif\r\n\r\n   /* We don't handle background color or gamma transformation or quantizing.\r\n    */\r\n\r\n   /* Invert monochrome files to have 0 as white and 1 as black\r\n    */\r\n   if (transforms & PNG_TRANSFORM_INVERT_MONO)\r\n#ifdef PNG_READ_INVERT_SUPPORTED\r\n      png_set_invert_mono(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_INVERT_MONO not supported\");\r\n#endif\r\n\r\n   /* If you want to shift the pixel values from the range [0,255] or\r\n    * [0,65535] to the original [0,7] or [0,31], or whatever range the\r\n    * colors were originally in:\r\n    */\r\n   if (transforms & PNG_TRANSFORM_SHIFT)\r\n#ifdef PNG_READ_SHIFT_SUPPORTED\r\n      if (info_ptr->valid & PNG_INFO_sBIT)\r\n         png_set_shift(png_ptr, &info_ptr->sig_bit);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SHIFT not supported\");\r\n#endif\r\n\r\n   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */\r\n   if (transforms & PNG_TRANSFORM_BGR)\r\n#ifdef PNG_READ_BGR_SUPPORTED\r\n      png_set_bgr(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_BGR not supported\");\r\n#endif\r\n\r\n   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */\r\n   if (transforms & PNG_TRANSFORM_SWAP_ALPHA)\r\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\r\n      png_set_swap_alpha(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SWAP_ALPHA not supported\");\r\n#endif\r\n\r\n   /* Swap bytes of 16-bit files to least significant byte first */\r\n   if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)\r\n#ifdef PNG_READ_SWAP_SUPPORTED\r\n      png_set_swap(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SWAP_ENDIAN not supported\");\r\n#endif\r\n\r\n/* Added at libpng-1.2.41 */\r\n   /* Invert the alpha channel from opacity to transparency */\r\n   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)\r\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\r\n      png_set_invert_alpha(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_INVERT_ALPHA not supported\");\r\n#endif\r\n\r\n/* Added at libpng-1.2.41 */\r\n   /* Expand grayscale image to RGB */\r\n   if (transforms & PNG_TRANSFORM_GRAY_TO_RGB)\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n      png_set_gray_to_rgb(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_GRAY_TO_RGB not supported\");\r\n#endif\r\n\r\n/* Added at libpng-1.5.4 */\r\n   if (transforms & PNG_TRANSFORM_EXPAND_16)\r\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\r\n      png_set_expand_16(png_ptr);\r\n#else\r\n      png_app_error(png_ptr, \"PNG_TRANSFORM_EXPAND_16 not supported\");\r\n#endif\r\n\r\n   /* We don't handle adding filler bytes */\r\n\r\n   /* We use png_read_image and rely on that for interlace handling, but we also\r\n    * call png_read_update_info therefore must turn on interlace handling now:\r\n    */\r\n   (void)png_set_interlace_handling(png_ptr);\r\n\r\n   /* Optional call to gamma correct and add the background to the palette\r\n    * and update info structure.  REQUIRED if you are expecting libpng to\r\n    * update the palette for you (i.e., you selected such a transform above).\r\n    */\r\n   png_read_update_info(png_ptr, info_ptr);\r\n\r\n   /* -------------- image transformations end here ------------------- */\r\n\r\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\r\n   if (info_ptr->row_pointers == NULL)\r\n   {\r\n      png_uint_32 iptr;\r\n\r\n      info_ptr->row_pointers = png_voidcast(png_bytepp, png_malloc(png_ptr,\r\n          info_ptr->height * (sizeof (png_bytep))));\r\n\r\n      for (iptr=0; iptr<info_ptr->height; iptr++)\r\n         info_ptr->row_pointers[iptr] = NULL;\r\n\r\n      info_ptr->free_me |= PNG_FREE_ROWS;\r\n\r\n      for (iptr = 0; iptr < info_ptr->height; iptr++)\r\n         info_ptr->row_pointers[iptr] = png_voidcast(png_bytep,\r\n            png_malloc(png_ptr, info_ptr->rowbytes));\r\n   }\r\n\r\n   png_read_image(png_ptr, info_ptr->row_pointers);\r\n   info_ptr->valid |= PNG_INFO_IDAT;\r\n\r\n   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */\r\n   png_read_end(png_ptr, info_ptr);\r\n\r\n   PNG_UNUSED(params)\r\n}\r\n#endif /* PNG_INFO_IMAGE_SUPPORTED */\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\n#ifdef PNG_SIMPLIFIED_READ_SUPPORTED\r\n/* SIMPLIFIED READ\r\n *\r\n * This code currently relies on the sequential reader, though it could easily\r\n * be made to work with the progressive one.\r\n */\r\n/* Arguments to png_image_finish_read: */\r\n\r\n/* Encoding of PNG data (used by the color-map code) */\r\n#  define P_NOTSET  0 /* File encoding not yet known */\r\n#  define P_sRGB    1 /* 8-bit encoded to sRGB gamma */\r\n#  define P_LINEAR  2 /* 16-bit linear: not encoded, NOT pre-multiplied! */\r\n#  define P_FILE    3 /* 8-bit encoded to file gamma, not sRGB or linear */\r\n#  define P_LINEAR8 4 /* 8-bit linear: only from a file value */\r\n\r\n/* Color-map processing: after libpng has run on the PNG image further\r\n * processing may be needed to conver the data to color-map indicies.\r\n */\r\n#define PNG_CMAP_NONE      0\r\n#define PNG_CMAP_GA        1 /* Process GA data to a color-map with alpha */\r\n#define PNG_CMAP_TRANS     2 /* Process GA data to a background index */\r\n#define PNG_CMAP_RGB       3 /* Process RGB data */\r\n#define PNG_CMAP_RGB_ALPHA 4 /* Process RGBA data */\r\n\r\n/* The following document where the background is for each processing case. */\r\n#define PNG_CMAP_NONE_BACKGROUND      256\r\n#define PNG_CMAP_GA_BACKGROUND        231\r\n#define PNG_CMAP_TRANS_BACKGROUND     254\r\n#define PNG_CMAP_RGB_BACKGROUND       256\r\n#define PNG_CMAP_RGB_ALPHA_BACKGROUND 216\r\n\r\ntypedef struct\r\n{\r\n   /* Arguments: */\r\n   png_imagep image;\r\n   png_voidp  buffer;\r\n   png_int_32 row_stride;\r\n   png_voidp  colormap;\r\n   png_const_colorp background;\r\n   /* Local variables: */\r\n   png_voidp       local_row;\r\n   png_voidp       first_row;\r\n   ptrdiff_t       row_bytes;           /* step between rows */\r\n   int             file_encoding;       /* E_ values above */\r\n   png_fixed_point gamma_to_linear;     /* For P_FILE, reciprocal of gamma */\r\n   int             colormap_processing; /* PNG_CMAP_ values above */\r\n} png_image_read_control;\r\n\r\n/* Do all the *safe* initialization - 'safe' means that png_error won't be\r\n * called, so setting up the jmp_buf is not required.  This means that anything\r\n * called from here must *not* call png_malloc - it has to call png_malloc_warn\r\n * instead so that control is returned safely back to this routine.\r\n */\r\nstatic int\r\npng_image_read_init(png_imagep image)\r\n{\r\n   if (image->opaque == NULL)\r\n   {\r\n      png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,\r\n          png_safe_error, png_safe_warning);\r\n\r\n      /* And set the rest of the structure to NULL to ensure that the various\r\n       * fields are consistent.\r\n       */\r\n      memset(image, 0, (sizeof *image));\r\n      image->version = PNG_IMAGE_VERSION;\r\n\r\n      if (png_ptr != NULL)\r\n      {\r\n         png_infop info_ptr = png_create_info_struct(png_ptr);\r\n\r\n         if (info_ptr != NULL)\r\n         {\r\n            png_controlp control = png_voidcast(png_controlp,\r\n               png_malloc_warn(png_ptr, (sizeof *control)));\r\n\r\n            if (control != NULL)\r\n            {\r\n               memset(control, 0, (sizeof *control));\r\n\r\n               control->png_ptr = png_ptr;\r\n               control->info_ptr = info_ptr;\r\n               control->for_write = 0;\r\n\r\n               image->opaque = control;\r\n               return 1;\r\n            }\r\n\r\n            /* Error clean up */\r\n            png_destroy_info_struct(png_ptr, &info_ptr);\r\n         }\r\n\r\n         png_destroy_read_struct(&png_ptr, NULL, NULL);\r\n      }\r\n\r\n      return png_image_error(image, \"png_image_read: out of memory\");\r\n   }\r\n\r\n   return png_image_error(image, \"png_image_read: opaque pointer not NULL\");\r\n}\r\n\r\n/* Utility to find the base format of a PNG file from a png_struct. */\r\nstatic png_uint_32\r\npng_image_format(png_structrp png_ptr)\r\n{\r\n   png_uint_32 format = 0;\r\n\r\n   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n      format |= PNG_FORMAT_FLAG_COLOR;\r\n\r\n   if (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)\r\n      format |= PNG_FORMAT_FLAG_ALPHA;\r\n\r\n   /* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS\r\n    * sets the png_struct fields; that's all we are interested in here.  The\r\n    * precise interaction with an app call to png_set_tRNS and PNG file reading\r\n    * is unclear.\r\n    */\r\n   else if (png_ptr->num_trans > 0)\r\n      format |= PNG_FORMAT_FLAG_ALPHA;\r\n\r\n   if (png_ptr->bit_depth == 16)\r\n      format |= PNG_FORMAT_FLAG_LINEAR;\r\n\r\n   if (png_ptr->color_type & PNG_COLOR_MASK_PALETTE)\r\n      format |= PNG_FORMAT_FLAG_COLORMAP;\r\n\r\n   return format;\r\n}\r\n\r\n/* Is the given gamma significantly different from sRGB?  The test is the same\r\n * one used in pngrtran.c when deciding whether to do gamma correction.  The\r\n * arithmetic optimizes the division by using the fact that the inverse of the\r\n * file sRGB gamma is 2.2\r\n */\r\nstatic int\r\npng_gamma_not_sRGB(png_fixed_point g)\r\n{\r\n   if (g < PNG_FP_1)\r\n   {\r\n      /* An uninitialized gamma is assumed to be sRGB for the simplified API. */\r\n      if (g == 0)\r\n         return 0;\r\n\r\n      return png_gamma_significant((g * 11 + 2)/5 /* i.e. *2.2, rounded */);\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n/* Do the main body of a 'png_image_begin_read' function; read the PNG file\r\n * header and fill in all the information.  This is executed in a safe context,\r\n * unlike the init routine above.\r\n */\r\nstatic int\r\npng_image_read_header(png_voidp argument)\r\n{\r\n   png_imagep image = png_voidcast(png_imagep, argument);\r\n   png_structrp png_ptr = image->opaque->png_ptr;\r\n   png_inforp info_ptr = image->opaque->info_ptr;\r\n\r\n   png_set_benign_errors(png_ptr, 1/*warn*/);\r\n   png_read_info(png_ptr, info_ptr);\r\n\r\n   /* Do this the fast way; just read directly out of png_struct. */\r\n   image->width = png_ptr->width;\r\n   image->height = png_ptr->height;\r\n\r\n   {\r\n      png_uint_32 format = png_image_format(png_ptr);\r\n\r\n      image->format = format;\r\n\r\n#ifdef PNG_COLORSPACE_SUPPORTED\r\n      /* Does the colorspace match sRGB?  If there is no color endpoint\r\n       * (colorant) information assume yes, otherwise require the\r\n       * 'ENDPOINTS_MATCHP_sRGB' colorspace flag to have been set.  If the\r\n       * colorspace has been determined to be invalid ignore it.\r\n       */\r\n      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 && ((png_ptr->colorspace.flags\r\n         & (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB|\r\n            PNG_COLORSPACE_INVALID)) == PNG_COLORSPACE_HAVE_ENDPOINTS))\r\n         image->flags |= PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB;\r\n#endif\r\n   }\r\n\r\n   /* We need the maximum number of entries regardless of the format the\r\n    * application sets here.\r\n    */\r\n   {\r\n      png_uint_32 cmap_entries;\r\n\r\n      switch (png_ptr->color_type)\r\n      {\r\n         case PNG_COLOR_TYPE_GRAY:\r\n            cmap_entries = 1U << png_ptr->bit_depth;\r\n            break;\r\n\r\n         case PNG_COLOR_TYPE_PALETTE:\r\n            cmap_entries = png_ptr->num_palette;\r\n            break;\r\n\r\n         default:\r\n            cmap_entries = 256;\r\n            break;\r\n      }\r\n\r\n      if (cmap_entries > 256)\r\n         cmap_entries = 256;\r\n\r\n      image->colormap_entries = cmap_entries;\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n#ifdef PNG_STDIO_SUPPORTED\r\nint PNGAPI\r\npng_image_begin_read_from_stdio(png_imagep image, FILE* file)\r\n{\r\n   if (image != NULL && image->version == PNG_IMAGE_VERSION)\r\n   {\r\n      if (file != NULL)\r\n      {\r\n         if (png_image_read_init(image))\r\n         {\r\n            /* This is slightly evil, but png_init_io doesn't do anything other\r\n             * than this and we haven't changed the standard IO functions so\r\n             * this saves a 'safe' function.\r\n             */\r\n            image->opaque->png_ptr->io_ptr = file;\r\n            return png_safe_execute(image, png_image_read_header, image);\r\n         }\r\n      }\r\n\r\n      else\r\n         return png_image_error(image,\r\n            \"png_image_begin_read_from_stdio: invalid argument\");\r\n   }\r\n\r\n   else if (image != NULL)\r\n      return png_image_error(image,\r\n         \"png_image_begin_read_from_stdio: incorrect PNG_IMAGE_VERSION\");\r\n\r\n   return 0;\r\n}\r\n\r\nint PNGAPI\r\npng_image_begin_read_from_file(png_imagep image, const char *file_name)\r\n{\r\n   if (image != NULL && image->version == PNG_IMAGE_VERSION)\r\n   {\r\n      if (file_name != NULL)\r\n      {\r\n         FILE *fp = fopen(file_name, \"rb\");\r\n\r\n         if (fp != NULL)\r\n         {\r\n            if (png_image_read_init(image))\r\n            {\r\n               image->opaque->png_ptr->io_ptr = fp;\r\n               image->opaque->owned_file = 1;\r\n               return png_safe_execute(image, png_image_read_header, image);\r\n            }\r\n\r\n            /* Clean up: just the opened file. */\r\n            (void)fclose(fp);\r\n         }\r\n\r\n         else\r\n            return png_image_error(image, strerror(errno));\r\n      }\r\n\r\n      else\r\n         return png_image_error(image,\r\n            \"png_image_begin_read_from_file: invalid argument\");\r\n   }\r\n\r\n   else if (image != NULL)\r\n      return png_image_error(image,\r\n         \"png_image_begin_read_from_file: incorrect PNG_IMAGE_VERSION\");\r\n\r\n   return 0;\r\n}\r\n#endif /* PNG_STDIO_SUPPORTED */\r\n\r\nstatic void PNGCBAPI\r\npng_image_memory_read(png_structp png_ptr, png_bytep out, png_size_t need)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      png_imagep image = png_voidcast(png_imagep, png_ptr->io_ptr);\r\n      if (image != NULL)\r\n      {\r\n         png_controlp cp = image->opaque;\r\n         if (cp != NULL)\r\n         {\r\n            png_const_bytep memory = cp->memory;\r\n            png_size_t size = cp->size;\r\n\r\n            if (memory != NULL && size >= need)\r\n            {\r\n               memcpy(out, memory, need);\r\n               cp->memory = memory + need;\r\n               cp->size = size - need;\r\n               return;\r\n            }\r\n\r\n            png_error(png_ptr, \"read beyond end of data\");\r\n         }\r\n      }\r\n\r\n      png_error(png_ptr, \"invalid memory read\");\r\n   }\r\n}\r\n\r\nint PNGAPI png_image_begin_read_from_memory(png_imagep image,\r\n   png_const_voidp memory, png_size_t size)\r\n{\r\n   if (image != NULL && image->version == PNG_IMAGE_VERSION)\r\n   {\r\n      if (memory != NULL && size > 0)\r\n      {\r\n         if (png_image_read_init(image))\r\n         {\r\n            /* Now set the IO functions to read from the memory buffer and\r\n             * store it into io_ptr.  Again do this in-place to avoid calling a\r\n             * libpng function that requires error handling.\r\n             */\r\n            image->opaque->memory = png_voidcast(png_const_bytep, memory);\r\n            image->opaque->size = size;\r\n            image->opaque->png_ptr->io_ptr = image;\r\n            image->opaque->png_ptr->read_data_fn = png_image_memory_read;\r\n\r\n            return png_safe_execute(image, png_image_read_header, image);\r\n         }\r\n      }\r\n\r\n      else\r\n         return png_image_error(image,\r\n            \"png_image_begin_read_from_memory: invalid argument\");\r\n   }\r\n\r\n   else if (image != NULL)\r\n      return png_image_error(image,\r\n         \"png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION\");\r\n\r\n   return 0;\r\n}\r\n\r\n/* Utility function to skip chunks that are not used by the simplified image\r\n * read functions and an appropriate macro to call it.\r\n */\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\nstatic void\r\npng_image_skip_unused_chunks(png_structrp png_ptr)\r\n{\r\n   /* Prepare the reader to ignore all recognized chunks whose data will not\r\n    * be used, i.e., all chunks recognized by libpng except for those\r\n    * involved in basic image reading:\r\n    *\r\n    *    IHDR, PLTE, IDAT, IEND\r\n    *\r\n    * Or image data handling:\r\n    *\r\n    *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.\r\n    *\r\n    * This provides a small performance improvement and eliminates any\r\n    * potential vulnerability to security problems in the unused chunks.\r\n    *\r\n    * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored\r\n    * too.  This allows the simplified API to be compiled without iCCP support,\r\n    * however if the support is there the chunk is still checked to detect\r\n    * errors (which are unfortunately quite common.)\r\n    */\r\n   {\r\n         static PNG_CONST png_byte chunks_to_process[] = {\r\n            98,  75,  71,  68, '\\0',  /* bKGD */\r\n            99,  72,  82,  77, '\\0',  /* cHRM */\r\n           103,  65,  77,  65, '\\0',  /* gAMA */\r\n#        ifdef PNG_READ_iCCP_SUPPORTED\r\n           105,  67,  67,  80, '\\0',  /* iCCP */\r\n#        endif\r\n           115,  66,  73,  84, '\\0',  /* sBIT */\r\n           115,  82,  71,  66, '\\0',  /* sRGB */\r\n           };\r\n\r\n       /* Ignore unknown chunks and all other chunks except for the\r\n        * IHDR, PLTE, tRNS, IDAT, and IEND chunks.\r\n        */\r\n       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,\r\n         NULL, -1);\r\n\r\n       /* But do not ignore image data handling chunks */\r\n       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,\r\n         chunks_to_process, (sizeof chunks_to_process)/5);\r\n    }\r\n}\r\n\r\n#  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)\r\n#else\r\n#  define PNG_SKIP_CHUNKS(p) ((void)0)\r\n#endif /* PNG_HANDLE_AS_UNKNOWN_SUPPORTED */\r\n\r\n/* The following macro gives the exact rounded answer for all values in the\r\n * range 0..255 (it actually divides by 51.2, but the rounding still generates\r\n * the correct numbers 0..5\r\n */\r\n#define PNG_DIV51(v8) (((v8) * 5 + 130) >> 8)\r\n\r\n/* Utility functions to make particular color-maps */\r\nstatic void\r\nset_file_encoding(png_image_read_control *display)\r\n{\r\n   png_fixed_point g = display->image->opaque->png_ptr->colorspace.gamma;\r\n   if (png_gamma_significant(g))\r\n   {\r\n      if (png_gamma_not_sRGB(g))\r\n      {\r\n         display->file_encoding = P_FILE;\r\n         display->gamma_to_linear = png_reciprocal(g);\r\n      }\r\n\r\n      else\r\n         display->file_encoding = P_sRGB;\r\n   }\r\n\r\n   else\r\n      display->file_encoding = P_LINEAR8;\r\n}\r\n\r\nstatic unsigned int\r\ndecode_gamma(png_image_read_control *display, png_uint_32 value, int encoding)\r\n{\r\n   if (encoding == P_FILE) /* double check */\r\n      encoding = display->file_encoding;\r\n\r\n   if (encoding == P_NOTSET) /* must be the file encoding */\r\n   {\r\n      set_file_encoding(display);\r\n      encoding = display->file_encoding;\r\n   }\r\n\r\n   switch (encoding)\r\n   {\r\n      case P_FILE:\r\n         value = png_gamma_16bit_correct(value*257, display->gamma_to_linear);\r\n         break;\r\n\r\n      case P_sRGB:\r\n         value = png_sRGB_table[value];\r\n         break;\r\n\r\n      case P_LINEAR:\r\n         break;\r\n\r\n      case P_LINEAR8:\r\n         value *= 257;\r\n         break;\r\n\r\n      default:\r\n         png_error(display->image->opaque->png_ptr,\r\n            \"unexpected encoding (internal error)\");\r\n         break;\r\n   }\r\n\r\n   return value;\r\n}\r\n\r\nstatic png_uint_32\r\npng_colormap_compose(png_image_read_control *display,\r\n   png_uint_32 foreground, int foreground_encoding, png_uint_32 alpha,\r\n   png_uint_32 background, int encoding)\r\n{\r\n   /* The file value is composed on the background, the background has the given\r\n    * encoding and so does the result, the file is encoded with P_FILE and the\r\n    * file and alpha are 8-bit values.  The (output) encoding will always be\r\n    * P_LINEAR or P_sRGB.\r\n    */\r\n   png_uint_32 f = decode_gamma(display, foreground, foreground_encoding);\r\n   png_uint_32 b = decode_gamma(display, background, encoding);\r\n\r\n   /* The alpha is always an 8-bit value (it comes from the palette), the value\r\n    * scaled by 255 is what PNG_sRGB_FROM_LINEAR requires.\r\n    */\r\n   f = f * alpha + b * (255-alpha);\r\n\r\n   if (encoding == P_LINEAR)\r\n   {\r\n      /* Scale to 65535; divide by 255, approximately (in fact this is extremely\r\n       * accurate, it divides by 255.00000005937181414556, with no overflow.)\r\n       */\r\n      f *= 257; /* Now scaled by 65535 */\r\n      f += f >> 16;\r\n      f = (f+32768) >> 16;\r\n   }\r\n\r\n   else /* P_sRGB */\r\n      f = PNG_sRGB_FROM_LINEAR(f);\r\n\r\n   return f;\r\n}\r\n\r\n/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must\r\n * be 8-bit.\r\n */\r\nstatic void\r\npng_create_colormap_entry(png_image_read_control *display,\r\n   png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,\r\n   png_uint_32 alpha, int encoding)\r\n{\r\n   png_imagep image = display->image;\r\n   const int output_encoding = (image->format & PNG_FORMAT_FLAG_LINEAR) ?\r\n      P_LINEAR : P_sRGB;\r\n   const int convert_to_Y = (image->format & PNG_FORMAT_FLAG_COLOR) == 0 &&\r\n      (red != green || green != blue);\r\n\r\n   if (ip > 255)\r\n      png_error(image->opaque->png_ptr, \"color-map index out of range\");\r\n\r\n   /* Update the cache with whether the file gamma is significantly different\r\n    * from sRGB.\r\n    */\r\n   if (encoding == P_FILE)\r\n   {\r\n      if (display->file_encoding == P_NOTSET)\r\n         set_file_encoding(display);\r\n\r\n      /* Note that the cached value may be P_FILE too, but if it is then the\r\n       * gamma_to_linear member has been set.\r\n       */\r\n      encoding = display->file_encoding;\r\n   }\r\n\r\n   if (encoding == P_FILE)\r\n   {\r\n      png_fixed_point g = display->gamma_to_linear;\r\n\r\n      red = png_gamma_16bit_correct(red*257, g);\r\n      green = png_gamma_16bit_correct(green*257, g);\r\n      blue = png_gamma_16bit_correct(blue*257, g);\r\n\r\n      if (convert_to_Y || output_encoding == P_LINEAR)\r\n      {\r\n         alpha *= 257;\r\n         encoding = P_LINEAR;\r\n      }\r\n\r\n      else\r\n      {\r\n         red = PNG_sRGB_FROM_LINEAR(red * 255);\r\n         green = PNG_sRGB_FROM_LINEAR(green * 255);\r\n         blue = PNG_sRGB_FROM_LINEAR(blue * 255);\r\n         encoding = P_sRGB;\r\n      }\r\n   }\r\n\r\n   else if (encoding == P_LINEAR8)\r\n   {\r\n      /* This encoding occurs quite frequently in test cases because PngSuite\r\n       * includes a gAMA 1.0 chunk with most images.\r\n       */\r\n      red *= 257;\r\n      green *= 257;\r\n      blue *= 257;\r\n      alpha *= 257;\r\n      encoding = P_LINEAR;\r\n   }\r\n\r\n   else if (encoding == P_sRGB && (convert_to_Y || output_encoding == P_LINEAR))\r\n   {\r\n      /* The values are 8-bit sRGB values, but must be converted to 16-bit\r\n       * linear.\r\n       */\r\n      red = png_sRGB_table[red];\r\n      green = png_sRGB_table[green];\r\n      blue = png_sRGB_table[blue];\r\n      alpha *= 257;\r\n      encoding = P_LINEAR;\r\n   }\r\n\r\n   /* This is set if the color isn't gray but the output is. */\r\n   if (encoding == P_LINEAR)\r\n   {\r\n      if (convert_to_Y)\r\n      {\r\n         /* NOTE: these values are copied from png_do_rgb_to_gray */\r\n         png_uint_32 y = (png_uint_32)6968 * red  + (png_uint_32)23434 * green +\r\n            (png_uint_32)2366 * blue;\r\n\r\n         if (output_encoding == P_LINEAR)\r\n            y = (y + 16384) >> 15;\r\n\r\n         else\r\n         {\r\n            /* y is scaled by 32768, we need it scaled by 255: */\r\n            y = (y + 128) >> 8;\r\n            y *= 255;\r\n            y = PNG_sRGB_FROM_LINEAR((y + 64) >> 7);\r\n            encoding = P_sRGB;\r\n         }\r\n\r\n         blue = red = green = y;\r\n      }\r\n\r\n      else if (output_encoding == P_sRGB)\r\n      {\r\n         red = PNG_sRGB_FROM_LINEAR(red * 255);\r\n         green = PNG_sRGB_FROM_LINEAR(green * 255);\r\n         blue = PNG_sRGB_FROM_LINEAR(blue * 255);\r\n         alpha = PNG_DIV257(alpha);\r\n         encoding = P_sRGB;\r\n      }\r\n   }\r\n\r\n   if (encoding != output_encoding)\r\n      png_error(image->opaque->png_ptr, \"bad encoding (internal error)\");\r\n\r\n   /* Store the value. */\r\n   {\r\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\r\n         const int afirst = (image->format & PNG_FORMAT_FLAG_AFIRST) != 0 &&\r\n            (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;\r\n#     else\r\n#        define afirst 0\r\n#     endif\r\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\r\n         const int bgr = (image->format & PNG_FORMAT_FLAG_BGR) ? 2 : 0;\r\n#     else\r\n#        define bgr 0\r\n#     endif\r\n\r\n      if (output_encoding == P_LINEAR)\r\n      {\r\n         png_uint_16p entry = png_voidcast(png_uint_16p, display->colormap);\r\n\r\n         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);\r\n\r\n         /* The linear 16-bit values must be pre-multiplied by the alpha channel\r\n          * value, if less than 65535 (this is, effectively, composite on black\r\n          * if the alpha channel is removed.)\r\n          */\r\n         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))\r\n         {\r\n            case 4:\r\n               entry[afirst ? 0 : 3] = (png_uint_16)alpha;\r\n               /* FALL THROUGH */\r\n\r\n            case 3:\r\n               if (alpha < 65535)\r\n               {\r\n                  if (alpha > 0)\r\n                  {\r\n                     blue = (blue * alpha + 32767U)/65535U;\r\n                     green = (green * alpha + 32767U)/65535U;\r\n                     red = (red * alpha + 32767U)/65535U;\r\n                  }\r\n\r\n                  else\r\n                     red = green = blue = 0;\r\n               }\r\n               entry[afirst + (2 ^ bgr)] = (png_uint_16)blue;\r\n               entry[afirst + 1] = (png_uint_16)green;\r\n               entry[afirst + bgr] = (png_uint_16)red;\r\n               break;\r\n\r\n            case 2:\r\n               entry[1 ^ afirst] = (png_uint_16)alpha;\r\n               /* FALL THROUGH */\r\n\r\n            case 1:\r\n               if (alpha < 65535)\r\n               {\r\n                  if (alpha > 0)\r\n                     green = (green * alpha + 32767U)/65535U;\r\n\r\n                  else\r\n                     green = 0;\r\n               }\r\n               entry[afirst] = (png_uint_16)green;\r\n               break;\r\n\r\n            default:\r\n               break;\r\n         }\r\n      }\r\n\r\n      else /* output encoding is P_sRGB */\r\n      {\r\n         png_bytep entry = png_voidcast(png_bytep, display->colormap);\r\n\r\n         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);\r\n\r\n         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))\r\n         {\r\n            case 4:\r\n               entry[afirst ? 0 : 3] = (png_byte)alpha;\r\n            case 3:\r\n               entry[afirst + (2 ^ bgr)] = (png_byte)blue;\r\n               entry[afirst + 1] = (png_byte)green;\r\n               entry[afirst + bgr] = (png_byte)red;\r\n               break;\r\n\r\n            case 2:\r\n               entry[1 ^ afirst] = (png_byte)alpha;\r\n            case 1:\r\n               entry[afirst] = (png_byte)green;\r\n               break;\r\n\r\n            default:\r\n               break;\r\n         }\r\n      }\r\n\r\n#     ifdef afirst\r\n#        undef afirst\r\n#     endif\r\n#     ifdef bgr\r\n#        undef bgr\r\n#     endif\r\n   }\r\n}\r\n\r\nstatic int\r\nmake_gray_file_colormap(png_image_read_control *display)\r\n{\r\n   unsigned int i;\r\n\r\n   for (i=0; i<256; ++i)\r\n      png_create_colormap_entry(display, i, i, i, i, 255, P_FILE);\r\n\r\n   return i;\r\n}\r\n\r\nstatic int\r\nmake_gray_colormap(png_image_read_control *display)\r\n{\r\n   unsigned int i;\r\n\r\n   for (i=0; i<256; ++i)\r\n      png_create_colormap_entry(display, i, i, i, i, 255, P_sRGB);\r\n\r\n   return i;\r\n}\r\n#define PNG_GRAY_COLORMAP_ENTRIES 256\r\n\r\nstatic int\r\nmake_ga_colormap(png_image_read_control *display)\r\n{\r\n   unsigned int i, a;\r\n\r\n   /* Alpha is retained, the output will be a color-map with entries\r\n    * selected by six levels of alpha.  One transparent entry, 6 gray\r\n    * levels for all the intermediate alpha values, leaving 230 entries\r\n    * for the opaque grays.  The color-map entries are the six values\r\n    * [0..5]*51, the GA processing uses PNG_DIV51(value) to find the\r\n    * relevant entry.\r\n    *\r\n    * if (alpha > 229) // opaque\r\n    * {\r\n    *    // The 231 entries are selected to make the math below work:\r\n    *    base = 0;\r\n    *    entry = (231 * gray + 128) >> 8;\r\n    * }\r\n    * else if (alpha < 26) // transparent\r\n    * {\r\n    *    base = 231;\r\n    *    entry = 0;\r\n    * }\r\n    * else // partially opaque\r\n    * {\r\n    *    base = 226 + 6 * PNG_DIV51(alpha);\r\n    *    entry = PNG_DIV51(gray);\r\n    * }\r\n    */\r\n   i = 0;\r\n   while (i < 231)\r\n   {\r\n      unsigned int gray = (i * 256 + 115) / 231;\r\n      png_create_colormap_entry(display, i++, gray, gray, gray, 255, P_sRGB);\r\n   }\r\n\r\n   /* 255 is used here for the component values for consistency with the code\r\n    * that undoes premultiplication in pngwrite.c.\r\n    */\r\n   png_create_colormap_entry(display, i++, 255, 255, 255, 0, P_sRGB);\r\n\r\n   for (a=1; a<5; ++a)\r\n   {\r\n      unsigned int g;\r\n\r\n      for (g=0; g<6; ++g)\r\n         png_create_colormap_entry(display, i++, g*51, g*51, g*51, a*51,\r\n            P_sRGB);\r\n   }\r\n\r\n   return i;\r\n}\r\n\r\n#define PNG_GA_COLORMAP_ENTRIES 256\r\n\r\nstatic int\r\nmake_rgb_colormap(png_image_read_control *display)\r\n{\r\n   unsigned int i, r;\r\n\r\n   /* Build a 6x6x6 opaque RGB cube */\r\n   for (i=r=0; r<6; ++r)\r\n   {\r\n      unsigned int g;\r\n\r\n      for (g=0; g<6; ++g)\r\n      {\r\n         unsigned int b;\r\n\r\n         for (b=0; b<6; ++b)\r\n            png_create_colormap_entry(display, i++, r*51, g*51, b*51, 255,\r\n               P_sRGB);\r\n      }\r\n   }\r\n\r\n   return i;\r\n}\r\n\r\n#define PNG_RGB_COLORMAP_ENTRIES 216\r\n\r\n/* Return a palette index to the above palette given three 8-bit sRGB values. */\r\n#define PNG_RGB_INDEX(r,g,b) \\\r\n   ((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))\r\n\r\nstatic int\r\npng_image_read_colormap(png_voidp argument)\r\n{\r\n   png_image_read_control *display =\r\n      png_voidcast(png_image_read_control*, argument);\r\n   const png_imagep image = display->image;\r\n\r\n   const png_structrp png_ptr = image->opaque->png_ptr;\r\n   const png_uint_32 output_format = image->format;\r\n   const int output_encoding = (output_format & PNG_FORMAT_FLAG_LINEAR) ?\r\n      P_LINEAR : P_sRGB;\r\n\r\n   unsigned int cmap_entries;\r\n   unsigned int output_processing;        /* Output processing option */\r\n   unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */\r\n\r\n   /* Background information; the background color and the index of this color\r\n    * in the color-map if it exists (else 256).\r\n    */\r\n   unsigned int background_index = 256;\r\n   png_uint_32 back_r, back_g, back_b;\r\n\r\n   /* Flags to accumulate things that need to be done to the input. */\r\n   int expand_tRNS = 0;\r\n\r\n   /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is\r\n    * very difficult to do, the results look awful, and it is difficult to see\r\n    * what possible use it is because the application can't control the\r\n    * color-map.\r\n    */\r\n   if (((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0 ||\r\n         png_ptr->num_trans > 0) /* alpha in input */ &&\r\n      ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0) /* no alpha in output */)\r\n   {\r\n      if (output_encoding == P_LINEAR) /* compose on black */\r\n         back_b = back_g = back_r = 0;\r\n\r\n      else if (display->background == NULL /* no way to remove it */)\r\n         png_error(png_ptr,\r\n            \"a background color must be supplied to remove alpha/transparency\");\r\n\r\n      /* Get a copy of the background color (this avoids repeating the checks\r\n       * below.)  The encoding is 8-bit sRGB or 16-bit linear, depending on the\r\n       * output format.\r\n       */\r\n      else\r\n      {\r\n         back_g = display->background->green;\r\n         if (output_format & PNG_FORMAT_FLAG_COLOR)\r\n         {\r\n            back_r = display->background->red;\r\n            back_b = display->background->blue;\r\n         }\r\n         else\r\n            back_b = back_r = back_g;\r\n      }\r\n   }\r\n\r\n   else if (output_encoding == P_LINEAR)\r\n      back_b = back_r = back_g = 65535;\r\n\r\n   else\r\n      back_b = back_r = back_g = 255;\r\n\r\n   /* Default the input file gamma if required - this is necessary because\r\n    * libpng assumes that if no gamma information is present the data is in the\r\n    * output format, but the simplified API deduces the gamma from the input\r\n    * format.\r\n    */\r\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) == 0)\r\n   {\r\n      /* Do this directly, not using the png_colorspace functions, to ensure\r\n       * that it happens even if the colorspace is invalid (though probably if\r\n       * it is the setting will be ignored)  Note that the same thing can be\r\n       * achieved at the application interface with png_set_gAMA.\r\n       */\r\n      if (png_ptr->bit_depth == 16 &&\r\n         (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\r\n         png_ptr->colorspace.gamma = PNG_GAMMA_LINEAR;\r\n\r\n      else\r\n         png_ptr->colorspace.gamma = PNG_GAMMA_sRGB_INVERSE;\r\n\r\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\r\n   }\r\n\r\n   /* Decide what to do based on the PNG color type of the input data.  The\r\n    * utility function png_create_colormap_entry deals with most aspects of the\r\n    * output transformations; this code works out how to produce bytes of\r\n    * color-map entries from the original format.\r\n    */\r\n   switch (png_ptr->color_type)\r\n   {\r\n      case PNG_COLOR_TYPE_GRAY:\r\n         if (png_ptr->bit_depth <= 8)\r\n         {\r\n            /* There at most 256 colors in the output, regardless of\r\n             * transparency.\r\n             */\r\n            unsigned int step, i, val, trans = 256/*ignore*/, back_alpha = 0;\r\n\r\n            cmap_entries = 1U << png_ptr->bit_depth;\r\n            if (cmap_entries > image->colormap_entries)\r\n               png_error(png_ptr, \"gray[8] color-map: too few entries\");\r\n\r\n            step = 255 / (cmap_entries - 1);\r\n            output_processing = PNG_CMAP_NONE;\r\n\r\n            /* If there is a tRNS chunk then this either selects a transparent\r\n             * value or, if the output has no alpha, the background color.\r\n             */\r\n            if (png_ptr->num_trans > 0)\r\n            {\r\n               trans = png_ptr->trans_color.gray;\r\n\r\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0)\r\n                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;\r\n            }\r\n\r\n            /* png_create_colormap_entry just takes an RGBA and writes the\r\n             * corresponding color-map entry using the format from 'image',\r\n             * including the required conversion to sRGB or linear as\r\n             * appropriate.  The input values are always either sRGB (if the\r\n             * gamma correction flag is 0) or 0..255 scaled file encoded values\r\n             * (if the function must gamma correct them).\r\n             */\r\n            for (i=val=0; i<cmap_entries; ++i, val += step)\r\n            {\r\n               /* 'i' is a file value.  While this will result in duplicated\r\n                * entries for 8-bit non-sRGB encoded files it is necessary to\r\n                * have non-gamma corrected values to do tRNS handling.\r\n                */\r\n               if (i != trans)\r\n                  png_create_colormap_entry(display, i, val, val, val, 255,\r\n                     P_FILE/*8-bit with file gamma*/);\r\n\r\n               /* Else this entry is transparent.  The colors don't matter if\r\n                * there is an alpha channel (back_alpha == 0), but it does no\r\n                * harm to pass them in; the values are not set above so this\r\n                * passes in white.\r\n                *\r\n                * NOTE: this preserves the full precision of the application\r\n                * supplied background color when it is used.\r\n                */\r\n               else\r\n                  png_create_colormap_entry(display, i, back_r, back_g, back_b,\r\n                     back_alpha, output_encoding);\r\n            }\r\n\r\n            /* We need libpng to preserve the original encoding. */\r\n            data_encoding = P_FILE;\r\n\r\n            /* The rows from libpng, while technically gray values, are now also\r\n             * color-map indicies; however, they may need to be expanded to 1\r\n             * byte per pixel.  This is what png_set_packing does (i.e., it\r\n             * unpacks the bit values into bytes.)\r\n             */\r\n            if (png_ptr->bit_depth < 8)\r\n               png_set_packing(png_ptr);\r\n         }\r\n\r\n         else /* bit depth is 16 */\r\n         {\r\n            /* The 16-bit input values can be converted directly to 8-bit gamma\r\n             * encoded values; however, if a tRNS chunk is present 257 color-map\r\n             * entries are required.  This means that the extra entry requires\r\n             * special processing; add an alpha channel, sacrifice gray level\r\n             * 254 and convert transparent (alpha==0) entries to that.\r\n             *\r\n             * Use libpng to chop the data to 8 bits.  Convert it to sRGB at the\r\n             * same time to minimize quality loss.  If a tRNS chunk is present\r\n             * this means libpng must handle it too; otherwise it is impossible\r\n             * to do the exact match on the 16-bit value.\r\n             *\r\n             * If the output has no alpha channel *and* the background color is\r\n             * gray then it is possible to let libpng handle the substitution by\r\n             * ensuring that the corresponding gray level matches the background\r\n             * color exactly.\r\n             */\r\n            data_encoding = P_sRGB;\r\n\r\n            if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\r\n               png_error(png_ptr, \"gray[16] color-map: too few entries\");\r\n\r\n            cmap_entries = make_gray_colormap(display);\r\n\r\n            if (png_ptr->num_trans > 0)\r\n            {\r\n               unsigned int back_alpha;\r\n\r\n               if (output_format & PNG_FORMAT_FLAG_ALPHA)\r\n                  back_alpha = 0;\r\n\r\n               else\r\n               {\r\n                  if (back_r == back_g && back_g == back_b)\r\n                  {\r\n                     /* Background is gray; no special processing will be\r\n                      * required.\r\n                      */\r\n                     png_color_16 c;\r\n                     png_uint_32 gray = back_g;\r\n\r\n                     if (output_encoding == P_LINEAR)\r\n                     {\r\n                        gray = PNG_sRGB_FROM_LINEAR(gray * 255);\r\n\r\n                        /* And make sure the corresponding palette entry\r\n                         * matches.\r\n                         */\r\n                        png_create_colormap_entry(display, gray, back_g, back_g,\r\n                           back_g, 65535, P_LINEAR);\r\n                     }\r\n\r\n                     /* The background passed to libpng, however, must be the\r\n                      * sRGB value.\r\n                      */\r\n                     c.index = 0; /*unused*/\r\n                     c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\r\n\r\n                     /* NOTE: does this work without expanding tRNS to alpha?\r\n                      * It should be the color->gray case below apparently\r\n                      * doesn't.\r\n                      */\r\n                     png_set_background_fixed(png_ptr, &c,\r\n                        PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\r\n                        0/*gamma: not used*/);\r\n\r\n                     output_processing = PNG_CMAP_NONE;\r\n                     break;\r\n                  }\r\n\r\n                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;\r\n               }\r\n\r\n               /* output_processing means that the libpng-processed row will be\r\n                * 8-bit GA and it has to be processing to single byte color-map\r\n                * values.  Entry 254 is replaced by either a completely\r\n                * transparent entry or by the background color at full\r\n                * precision (and the background color is not a simple gray leve\r\n                * in this case.)\r\n                */\r\n               expand_tRNS = 1;\r\n               output_processing = PNG_CMAP_TRANS;\r\n               background_index = 254;\r\n\r\n               /* And set (overwrite) color-map entry 254 to the actual\r\n                * background color at full precision.\r\n                */\r\n               png_create_colormap_entry(display, 254, back_r, back_g, back_b,\r\n                  back_alpha, output_encoding);\r\n            }\r\n\r\n            else\r\n               output_processing = PNG_CMAP_NONE;\r\n         }\r\n         break;\r\n\r\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\r\n         /* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum\r\n          * of 65536 combinations.  If, however, the alpha channel is to be\r\n          * removed there are only 256 possibilities if the background is gray.\r\n          * (Otherwise there is a subset of the 65536 possibilities defined by\r\n          * the triangle between black, white and the background color.)\r\n          *\r\n          * Reduce 16-bit files to 8-bit and sRGB encode the result.  No need to\r\n          * worry about tRNS matching - tRNS is ignored if there is an alpha\r\n          * channel.\r\n          */\r\n         data_encoding = P_sRGB;\r\n\r\n         if (output_format & PNG_FORMAT_FLAG_ALPHA)\r\n         {\r\n            if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\r\n               png_error(png_ptr, \"gray+alpha color-map: too few entries\");\r\n\r\n            cmap_entries = make_ga_colormap(display);\r\n\r\n            background_index = PNG_CMAP_GA_BACKGROUND;\r\n            output_processing = PNG_CMAP_GA;\r\n         }\r\n\r\n         else /* alpha is removed */\r\n         {\r\n            /* Alpha must be removed as the PNG data is processed when the\r\n             * background is a color because the G and A channels are\r\n             * independent and the vector addition (non-parallel vectors) is a\r\n             * 2-D problem.\r\n             *\r\n             * This can be reduced to the same algorithm as above by making a\r\n             * colormap containing gray levels (for the opaque grays), a\r\n             * background entry (for a transparent pixel) and a set of four six\r\n             * level color values, one set for each intermediate alpha value.\r\n             * See the comments in make_ga_colormap for how this works in the\r\n             * per-pixel processing.\r\n             *\r\n             * If the background is gray, however, we only need a 256 entry gray\r\n             * level color map.  It is sufficient to make the entry generated\r\n             * for the background color be exactly the color specified.\r\n             */\r\n            if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0 ||\r\n               (back_r == back_g && back_g == back_b))\r\n            {\r\n               /* Background is gray; no special processing will be required. */\r\n               png_color_16 c;\r\n               png_uint_32 gray = back_g;\r\n\r\n               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\r\n                  png_error(png_ptr, \"gray-alpha color-map: too few entries\");\r\n\r\n               cmap_entries = make_gray_colormap(display);\r\n\r\n               if (output_encoding == P_LINEAR)\r\n               {\r\n                  gray = PNG_sRGB_FROM_LINEAR(gray * 255);\r\n\r\n                  /* And make sure the corresponding palette entry matches. */\r\n                  png_create_colormap_entry(display, gray, back_g, back_g,\r\n                     back_g, 65535, P_LINEAR);\r\n               }\r\n\r\n               /* The background passed to libpng, however, must be the sRGB\r\n                * value.\r\n                */\r\n               c.index = 0; /*unused*/\r\n               c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\r\n\r\n               png_set_background_fixed(png_ptr, &c,\r\n                  PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\r\n                  0/*gamma: not used*/);\r\n\r\n               output_processing = PNG_CMAP_NONE;\r\n            }\r\n\r\n            else\r\n            {\r\n               png_uint_32 i, a;\r\n\r\n               /* This is the same as png_make_ga_colormap, above, except that\r\n                * the entries are all opaque.\r\n                */\r\n               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\r\n                  png_error(png_ptr, \"ga-alpha color-map: too few entries\");\r\n\r\n               i = 0;\r\n               while (i < 231)\r\n               {\r\n                  png_uint_32 gray = (i * 256 + 115) / 231;\r\n                  png_create_colormap_entry(display, i++, gray, gray, gray,\r\n                     255, P_sRGB);\r\n               }\r\n\r\n               /* NOTE: this preserves the full precision of the application\r\n                * background color.\r\n                */\r\n               background_index = i;\r\n               png_create_colormap_entry(display, i++, back_r, back_g, back_b,\r\n                  output_encoding == P_LINEAR ? 65535U : 255U, output_encoding);\r\n\r\n               /* For non-opaque input composite on the sRGB background - this\r\n                * requires inverting the encoding for each component.  The input\r\n                * is still converted to the sRGB encoding because this is a\r\n                * reasonable approximate to the logarithmic curve of human\r\n                * visual sensitivity, at least over the narrow range which PNG\r\n                * represents.  Consequently 'G' is always sRGB encoded, while\r\n                * 'A' is linear.  We need the linear background colors.\r\n                */\r\n               if (output_encoding == P_sRGB) /* else already linear */\r\n               {\r\n                  /* This may produce a value not exactly matching the\r\n                   * background, but that's ok because these numbers are only\r\n                   * used when alpha != 0\r\n                   */\r\n                  back_r = png_sRGB_table[back_r];\r\n                  back_g = png_sRGB_table[back_g];\r\n                  back_b = png_sRGB_table[back_b];\r\n               }\r\n\r\n               for (a=1; a<5; ++a)\r\n               {\r\n                  unsigned int g;\r\n\r\n                  /* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled\r\n                   * by an 8-bit alpha value (0..255).\r\n                   */\r\n                  png_uint_32 alpha = 51 * a;\r\n                  png_uint_32 back_rx = (255-alpha) * back_r;\r\n                  png_uint_32 back_gx = (255-alpha) * back_g;\r\n                  png_uint_32 back_bx = (255-alpha) * back_b;\r\n\r\n                  for (g=0; g<6; ++g)\r\n                  {\r\n                     png_uint_32 gray = png_sRGB_table[g*51] * alpha;\r\n\r\n                     png_create_colormap_entry(display, i++,\r\n                        PNG_sRGB_FROM_LINEAR(gray + back_rx),\r\n                        PNG_sRGB_FROM_LINEAR(gray + back_gx),\r\n                        PNG_sRGB_FROM_LINEAR(gray + back_bx), 255, P_sRGB);\r\n                  }\r\n               }\r\n\r\n               cmap_entries = i;\r\n               output_processing = PNG_CMAP_GA;\r\n            }\r\n         }\r\n         break;\r\n\r\n      case PNG_COLOR_TYPE_RGB:\r\n      case PNG_COLOR_TYPE_RGB_ALPHA:\r\n         /* Exclude the case where the output is gray; we can always handle this\r\n          * with the cases above.\r\n          */\r\n         if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0)\r\n         {\r\n            /* The color-map will be grayscale, so we may as well convert the\r\n             * input RGB values to a simple grayscale and use the grayscale\r\n             * code above.\r\n             *\r\n             * NOTE: calling this apparently damages the recognition of the\r\n             * transparent color in background color handling; call\r\n             * png_set_tRNS_to_alpha before png_set_background_fixed.\r\n             */\r\n            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE, -1,\r\n               -1);\r\n            data_encoding = P_sRGB;\r\n\r\n            /* The output will now be one or two 8-bit gray or gray+alpha\r\n             * channels.  The more complex case arises when the input has alpha.\r\n             */\r\n            if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\r\n               png_ptr->num_trans > 0) &&\r\n               (output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\r\n            {\r\n               /* Both input and output have an alpha channel, so no background\r\n                * processing is required; just map the GA bytes to the right\r\n                * color-map entry.\r\n                */\r\n               expand_tRNS = 1;\r\n\r\n               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\r\n                  png_error(png_ptr, \"rgb[ga] color-map: too few entries\");\r\n\r\n               cmap_entries = make_ga_colormap(display);\r\n               background_index = PNG_CMAP_GA_BACKGROUND;\r\n               output_processing = PNG_CMAP_GA;\r\n            }\r\n\r\n            else\r\n            {\r\n               /* Either the input or the output has no alpha channel, so there\r\n                * will be no non-opaque pixels in the color-map; it will just be\r\n                * grayscale.\r\n                */\r\n               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\r\n                  png_error(png_ptr, \"rgb[gray] color-map: too few entries\");\r\n\r\n               /* Ideally this code would use libpng to do the gamma correction,\r\n                * but if an input alpha channel is to be removed we will hit the\r\n                * libpng bug in gamma+compose+rgb-to-gray (the double gamma\r\n                * correction bug).  Fix this by dropping the gamma correction in\r\n                * this case and doing it in the palette; this will result in\r\n                * duplicate palette entries, but that's better than the\r\n                * alternative of double gamma correction.\r\n                */\r\n               if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\r\n                  png_ptr->num_trans > 0) &&\r\n                  png_gamma_not_sRGB(png_ptr->colorspace.gamma))\r\n               {\r\n                  cmap_entries = make_gray_file_colormap(display);\r\n                  data_encoding = P_FILE;\r\n               }\r\n\r\n               else\r\n                  cmap_entries = make_gray_colormap(display);\r\n\r\n               /* But if the input has alpha or transparency it must be removed\r\n                */\r\n               if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\r\n                  png_ptr->num_trans > 0)\r\n               {\r\n                  png_color_16 c;\r\n                  png_uint_32 gray = back_g;\r\n\r\n                  /* We need to ensure that the application background exists in\r\n                   * the colormap and that completely transparent pixels map to\r\n                   * it.  Achieve this simply by ensuring that the entry\r\n                   * selected for the background really is the background color.\r\n                   */\r\n                  if (data_encoding == P_FILE) /* from the fixup above */\r\n                  {\r\n                     /* The app supplied a gray which is in output_encoding, we\r\n                      * need to convert it to a value of the input (P_FILE)\r\n                      * encoding then set this palette entry to the required\r\n                      * output encoding.\r\n                      */\r\n                     if (output_encoding == P_sRGB)\r\n                        gray = png_sRGB_table[gray]; /* now P_LINEAR */\r\n\r\n                     gray = PNG_DIV257(png_gamma_16bit_correct(gray,\r\n                        png_ptr->colorspace.gamma)); /* now P_FILE */\r\n\r\n                     /* And make sure the corresponding palette entry contains\r\n                      * exactly the required sRGB value.\r\n                      */\r\n                     png_create_colormap_entry(display, gray, back_g, back_g,\r\n                        back_g, 0/*unused*/, output_encoding);\r\n                  }\r\n\r\n                  else if (output_encoding == P_LINEAR)\r\n                  {\r\n                     gray = PNG_sRGB_FROM_LINEAR(gray * 255);\r\n\r\n                     /* And make sure the corresponding palette entry matches.\r\n                      */\r\n                     png_create_colormap_entry(display, gray, back_g, back_g,\r\n                        back_g, 0/*unused*/, P_LINEAR);\r\n                  }\r\n\r\n                  /* The background passed to libpng, however, must be the\r\n                   * output (normally sRGB) value.\r\n                   */\r\n                  c.index = 0; /*unused*/\r\n                  c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\r\n\r\n                  /* NOTE: the following is apparently a bug in libpng. Without\r\n                   * it the transparent color recognition in\r\n                   * png_set_background_fixed seems to go wrong.\r\n                   */\r\n                  expand_tRNS = 1;\r\n                  png_set_background_fixed(png_ptr, &c,\r\n                     PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\r\n                     0/*gamma: not used*/);\r\n               }\r\n\r\n               output_processing = PNG_CMAP_NONE;\r\n            }\r\n         }\r\n\r\n         else /* output is color */\r\n         {\r\n            /* We could use png_quantize here so long as there is no transparent\r\n             * color or alpha; png_quantize ignores alpha.  Easier overall just\r\n             * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.\r\n             * Consequently we always want libpng to produce sRGB data.\r\n             */\r\n            data_encoding = P_sRGB;\r\n\r\n            /* Is there any transparency or alpha? */\r\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\r\n               png_ptr->num_trans > 0)\r\n            {\r\n               /* Is there alpha in the output too?  If so all four channels are\r\n                * processed into a special RGB cube with alpha support.\r\n                */\r\n               if (output_format & PNG_FORMAT_FLAG_ALPHA)\r\n               {\r\n                  png_uint_32 r;\r\n\r\n                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)\r\n                     png_error(png_ptr, \"rgb+alpha color-map: too few entries\");\r\n\r\n                  cmap_entries = make_rgb_colormap(display);\r\n\r\n                  /* Add a transparent entry. */\r\n                  png_create_colormap_entry(display, cmap_entries, 255, 255,\r\n                     255, 0, P_sRGB);\r\n\r\n                  /* This is stored as the background index for the processing\r\n                   * algorithm.\r\n                   */\r\n                  background_index = cmap_entries++;\r\n\r\n                  /* Add 27 r,g,b entries each with alpha 0.5. */\r\n                  for (r=0; r<256; r = (r << 1) | 0x7f)\r\n                  {\r\n                     png_uint_32 g;\r\n\r\n                     for (g=0; g<256; g = (g << 1) | 0x7f)\r\n                     {\r\n                        png_uint_32 b;\r\n\r\n                        /* This generates components with the values 0, 127 and\r\n                         * 255\r\n                         */\r\n                        for (b=0; b<256; b = (b << 1) | 0x7f)\r\n                           png_create_colormap_entry(display, cmap_entries++,\r\n                              r, g, b, 128, P_sRGB);\r\n                     }\r\n                  }\r\n\r\n                  expand_tRNS = 1;\r\n                  output_processing = PNG_CMAP_RGB_ALPHA;\r\n               }\r\n\r\n               else\r\n               {\r\n                  /* Alpha/transparency must be removed.  The background must\r\n                   * exist in the color map (achieved by setting adding it after\r\n                   * the 666 color-map).  If the standard processing code will\r\n                   * pick up this entry automatically that's all that is\r\n                   * required; libpng can be called to do the background\r\n                   * processing.\r\n                   */\r\n                  unsigned int sample_size =\r\n                     PNG_IMAGE_SAMPLE_SIZE(output_format);\r\n                  png_uint_32 r, g, b; /* sRGB background */\r\n\r\n                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)\r\n                     png_error(png_ptr, \"rgb-alpha color-map: too few entries\");\r\n\r\n                  cmap_entries = make_rgb_colormap(display);\r\n\r\n                  png_create_colormap_entry(display, cmap_entries, back_r,\r\n                        back_g, back_b, 0/*unused*/, output_encoding);\r\n\r\n                  if (output_encoding == P_LINEAR)\r\n                  {\r\n                     r = PNG_sRGB_FROM_LINEAR(back_r * 255);\r\n                     g = PNG_sRGB_FROM_LINEAR(back_g * 255);\r\n                     b = PNG_sRGB_FROM_LINEAR(back_b * 255);\r\n                  }\r\n\r\n                  else\r\n                  {\r\n                     r = back_r;\r\n                     g = back_g;\r\n                     b = back_g;\r\n                  }\r\n\r\n                  /* Compare the newly-created color-map entry with the one the\r\n                   * PNG_CMAP_RGB algorithm will use.  If the two entries don't\r\n                   * match, add the new one and set this as the background\r\n                   * index.\r\n                   */\r\n                  if (memcmp((png_const_bytep)display->colormap +\r\n                        sample_size * cmap_entries,\r\n                     (png_const_bytep)display->colormap +\r\n                        sample_size * PNG_RGB_INDEX(r,g,b),\r\n                     sample_size) != 0)\r\n                  {\r\n                     /* The background color must be added. */\r\n                     background_index = cmap_entries++;\r\n\r\n                     /* Add 27 r,g,b entries each with created by composing with\r\n                      * the background at alpha 0.5.\r\n                      */\r\n                     for (r=0; r<256; r = (r << 1) | 0x7f)\r\n                     {\r\n                        for (g=0; g<256; g = (g << 1) | 0x7f)\r\n                        {\r\n                           /* This generates components with the values 0, 127\r\n                            * and 255\r\n                            */\r\n                           for (b=0; b<256; b = (b << 1) | 0x7f)\r\n                              png_create_colormap_entry(display, cmap_entries++,\r\n                                 png_colormap_compose(display, r, P_sRGB, 128,\r\n                                    back_r, output_encoding),\r\n                                 png_colormap_compose(display, g, P_sRGB, 128,\r\n                                    back_g, output_encoding),\r\n                                 png_colormap_compose(display, b, P_sRGB, 128,\r\n                                    back_b, output_encoding),\r\n                                 0/*unused*/, output_encoding);\r\n                        }\r\n                     }\r\n\r\n                     expand_tRNS = 1;\r\n                     output_processing = PNG_CMAP_RGB_ALPHA;\r\n                  }\r\n\r\n                  else /* background color is in the standard color-map */\r\n                  {\r\n                     png_color_16 c;\r\n\r\n                     c.index = 0; /*unused*/\r\n                     c.red = (png_uint_16)back_r;\r\n                     c.gray = c.green = (png_uint_16)back_g;\r\n                     c.blue = (png_uint_16)back_b;\r\n\r\n                     png_set_background_fixed(png_ptr, &c,\r\n                        PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\r\n                        0/*gamma: not used*/);\r\n\r\n                     output_processing = PNG_CMAP_RGB;\r\n                  }\r\n               }\r\n            }\r\n\r\n            else /* no alpha or transparency in the input */\r\n            {\r\n               /* Alpha in the output is irrelevant, simply map the opaque input\r\n                * pixels to the 6x6x6 color-map.\r\n                */\r\n               if (PNG_RGB_COLORMAP_ENTRIES > image->colormap_entries)\r\n                  png_error(png_ptr, \"rgb color-map: too few entries\");\r\n\r\n               cmap_entries = make_rgb_colormap(display);\r\n               output_processing = PNG_CMAP_RGB;\r\n            }\r\n         }\r\n         break;\r\n\r\n      case PNG_COLOR_TYPE_PALETTE:\r\n         /* It's already got a color-map.  It may be necessary to eliminate the\r\n          * tRNS entries though.\r\n          */\r\n         {\r\n            unsigned int num_trans = png_ptr->num_trans;\r\n            png_const_bytep trans = num_trans > 0 ? png_ptr->trans_alpha : NULL;\r\n            png_const_colorp colormap = png_ptr->palette;\r\n            const int do_background = trans != NULL &&\r\n               (output_format & PNG_FORMAT_FLAG_ALPHA) == 0;\r\n            unsigned int i;\r\n\r\n            /* Just in case: */\r\n            if (trans == NULL)\r\n               num_trans = 0;\r\n\r\n            output_processing = PNG_CMAP_NONE;\r\n            data_encoding = P_FILE; /* Don't change from color-map indicies */\r\n            cmap_entries = png_ptr->num_palette;\r\n            if (cmap_entries > 256)\r\n               cmap_entries = 256;\r\n\r\n            if (cmap_entries > image->colormap_entries)\r\n               png_error(png_ptr, \"palette color-map: too few entries\");\r\n\r\n            for (i=0; i < cmap_entries; ++i)\r\n            {\r\n               if (do_background && i < num_trans && trans[i] < 255)\r\n               {\r\n                  if (trans[i] == 0)\r\n                     png_create_colormap_entry(display, i, back_r, back_g,\r\n                        back_b, 0, output_encoding);\r\n\r\n                  else\r\n                  {\r\n                     /* Must compose the PNG file color in the color-map entry\r\n                      * on the sRGB color in 'back'.\r\n                      */\r\n                     png_create_colormap_entry(display, i,\r\n                        png_colormap_compose(display, colormap[i].red, P_FILE,\r\n                           trans[i], back_r, output_encoding),\r\n                        png_colormap_compose(display, colormap[i].green, P_FILE,\r\n                           trans[i], back_g, output_encoding),\r\n                        png_colormap_compose(display, colormap[i].blue, P_FILE,\r\n                           trans[i], back_b, output_encoding),\r\n                        output_encoding == P_LINEAR ? trans[i] * 257U :\r\n                           trans[i],\r\n                        output_encoding);\r\n                  }\r\n               }\r\n\r\n               else\r\n                  png_create_colormap_entry(display, i, colormap[i].red,\r\n                     colormap[i].green, colormap[i].blue,\r\n                     i < num_trans ? trans[i] : 255U, P_FILE/*8-bit*/);\r\n            }\r\n\r\n            /* The PNG data may have indicies packed in fewer than 8 bits, it\r\n             * must be expanded if so.\r\n             */\r\n            if (png_ptr->bit_depth < 8)\r\n               png_set_packing(png_ptr);\r\n         }\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"invalid PNG color type\");\r\n         /*NOT REACHED*/\r\n         break;\r\n   }\r\n\r\n   /* Now deal with the output processing */\r\n   if (expand_tRNS && png_ptr->num_trans > 0 &&\r\n      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) == 0)\r\n      png_set_tRNS_to_alpha(png_ptr);\r\n\r\n   switch (data_encoding)\r\n   {\r\n      default:\r\n         png_error(png_ptr, \"bad data option (internal error)\");\r\n         break;\r\n\r\n      case P_sRGB:\r\n         /* Change to 8-bit sRGB */\r\n         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, PNG_GAMMA_sRGB);\r\n         /* FALL THROUGH */\r\n\r\n      case P_FILE:\r\n         if (png_ptr->bit_depth > 8)\r\n            png_set_scale_16(png_ptr);\r\n         break;\r\n   }\r\n\r\n   if (cmap_entries > 256 || cmap_entries > image->colormap_entries)\r\n      png_error(png_ptr, \"color map overflow (BAD internal error)\");\r\n\r\n   image->colormap_entries = cmap_entries;\r\n\r\n   /* Double check using the recorded background index */\r\n   switch (output_processing)\r\n   {\r\n      case PNG_CMAP_NONE:\r\n         if (background_index != PNG_CMAP_NONE_BACKGROUND)\r\n            goto bad_background;\r\n         break;\r\n\r\n      case PNG_CMAP_GA:\r\n         if (background_index != PNG_CMAP_GA_BACKGROUND)\r\n            goto bad_background;\r\n         break;\r\n\r\n      case PNG_CMAP_TRANS:\r\n         if (background_index >= cmap_entries ||\r\n            background_index != PNG_CMAP_TRANS_BACKGROUND)\r\n            goto bad_background;\r\n         break;\r\n\r\n      case PNG_CMAP_RGB:\r\n         if (background_index != PNG_CMAP_RGB_BACKGROUND)\r\n            goto bad_background;\r\n         break;\r\n\r\n      case PNG_CMAP_RGB_ALPHA:\r\n         if (background_index != PNG_CMAP_RGB_ALPHA_BACKGROUND)\r\n            goto bad_background;\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"bad processing option (internal error)\");\r\n\r\n      bad_background:\r\n         png_error(png_ptr, \"bad background index (internal error)\");\r\n   }\r\n\r\n   display->colormap_processing = output_processing;\r\n\r\n   return 1/*ok*/;\r\n}\r\n\r\n/* The final part of the color-map read called from png_image_finish_read. */\r\nstatic int\r\npng_image_read_and_map(png_voidp argument)\r\n{\r\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\r\n      argument);\r\n   png_imagep image = display->image;\r\n   png_structrp png_ptr = image->opaque->png_ptr;\r\n   int passes;\r\n\r\n   /* Called when the libpng data must be transformed into the color-mapped\r\n    * form.  There is a local row buffer in display->local and this routine must\r\n    * do the interlace handling.\r\n    */\r\n   switch (png_ptr->interlaced)\r\n   {\r\n      case PNG_INTERLACE_NONE:\r\n         passes = 1;\r\n         break;\r\n\r\n      case PNG_INTERLACE_ADAM7:\r\n         passes = PNG_INTERLACE_ADAM7_PASSES;\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"unknown interlace type\");\r\n   }\r\n\r\n   {\r\n      png_uint_32  height = image->height;\r\n      png_uint_32  width = image->width;\r\n      int          proc = display->colormap_processing;\r\n      png_bytep    first_row = png_voidcast(png_bytep, display->first_row);\r\n      ptrdiff_t    step_row = display->row_bytes;\r\n      int pass;\r\n\r\n      for (pass = 0; pass < passes; ++pass)\r\n      {\r\n         unsigned int     startx, stepx, stepy;\r\n         png_uint_32      y;\r\n\r\n         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\r\n         {\r\n            /* The row may be empty for a short image: */\r\n            if (PNG_PASS_COLS(width, pass) == 0)\r\n               continue;\r\n\r\n            startx = PNG_PASS_START_COL(pass);\r\n            stepx = PNG_PASS_COL_OFFSET(pass);\r\n            y = PNG_PASS_START_ROW(pass);\r\n            stepy = PNG_PASS_ROW_OFFSET(pass);\r\n         }\r\n\r\n         else\r\n         {\r\n            y = 0;\r\n            startx = 0;\r\n            stepx = stepy = 1;\r\n         }\r\n\r\n         for (; y<height; y += stepy)\r\n         {\r\n            png_bytep inrow = png_voidcast(png_bytep, display->local_row);\r\n            png_bytep outrow = first_row + y * step_row;\r\n            png_const_bytep end_row = outrow + width;\r\n\r\n            /* Read read the libpng data into the temporary buffer. */\r\n            png_read_row(png_ptr, inrow, NULL);\r\n\r\n            /* Now process the row according to the processing option, note\r\n             * that the caller verifies that the format of the libpng output\r\n             * data is as required.\r\n             */\r\n            outrow += startx;\r\n            switch (proc)\r\n            {\r\n               case PNG_CMAP_GA:\r\n                  for (; outrow < end_row; outrow += stepx)\r\n                  {\r\n                     /* The data is always in the PNG order */\r\n                     unsigned int gray = *inrow++;\r\n                     unsigned int alpha = *inrow++;\r\n                     unsigned int entry;\r\n\r\n                     /* NOTE: this code is copied as a comment in\r\n                      * make_ga_colormap above.  Please update the\r\n                      * comment if you change this code!\r\n                      */\r\n                     if (alpha > 229) /* opaque */\r\n                     {\r\n                        entry = (231 * gray + 128) >> 8;\r\n                     }\r\n                     else if (alpha < 26) /* transparent */\r\n                     {\r\n                        entry = 231;\r\n                     }\r\n                     else /* partially opaque */\r\n                     {\r\n                        entry = 226 + 6 * PNG_DIV51(alpha) + PNG_DIV51(gray);\r\n                     }\r\n\r\n                     *outrow = (png_byte)entry;\r\n                  }\r\n                  break;\r\n\r\n               case PNG_CMAP_TRANS:\r\n                  for (; outrow < end_row; outrow += stepx)\r\n                  {\r\n                     png_byte gray = *inrow++;\r\n                     png_byte alpha = *inrow++;\r\n\r\n                     if (alpha == 0)\r\n                        *outrow = PNG_CMAP_TRANS_BACKGROUND;\r\n\r\n                     else if (gray != PNG_CMAP_TRANS_BACKGROUND)\r\n                        *outrow = gray;\r\n\r\n                     else\r\n                        *outrow = (png_byte)(PNG_CMAP_TRANS_BACKGROUND+1);\r\n                  }\r\n                  break;\r\n\r\n               case PNG_CMAP_RGB:\r\n                  for (; outrow < end_row; outrow += stepx)\r\n                  {\r\n                     *outrow = PNG_RGB_INDEX(inrow[0], inrow[1], inrow[2]);\r\n                     inrow += 3;\r\n                  }\r\n                  break;\r\n\r\n               case PNG_CMAP_RGB_ALPHA:\r\n                  for (; outrow < end_row; outrow += stepx)\r\n                  {\r\n                     unsigned int alpha = inrow[3];\r\n\r\n                     /* Because the alpha entries only hold alpha==0.5 values\r\n                      * split the processing at alpha==0.25 (64) and 0.75\r\n                      * (196).\r\n                      */\r\n\r\n                     if (alpha >= 196)\r\n                        *outrow = PNG_RGB_INDEX(inrow[0], inrow[1],\r\n                           inrow[2]);\r\n\r\n                     else if (alpha < 64)\r\n                        *outrow = PNG_CMAP_RGB_ALPHA_BACKGROUND;\r\n\r\n                     else\r\n                     {\r\n                        /* Likewise there are three entries for each of r, g\r\n                         * and b.  We could select the entry by popcount on\r\n                         * the top two bits on those architectures that\r\n                         * support it, this is what the code below does,\r\n                         * crudely.\r\n                         */\r\n                        unsigned int back_i = PNG_CMAP_RGB_ALPHA_BACKGROUND+1;\r\n\r\n                        /* Here are how the values map:\r\n                         *\r\n                         * 0x00 .. 0x3f -> 0\r\n                         * 0x40 .. 0xbf -> 1\r\n                         * 0xc0 .. 0xff -> 2\r\n                         *\r\n                         * So, as above with the explicit alpha checks, the\r\n                         * breakpoints are at 64 and 196.\r\n                         */\r\n                        if (inrow[0] & 0x80) back_i += 9; /* red */\r\n                        if (inrow[0] & 0x40) back_i += 9;\r\n                        if (inrow[0] & 0x80) back_i += 3; /* green */\r\n                        if (inrow[0] & 0x40) back_i += 3;\r\n                        if (inrow[0] & 0x80) back_i += 1; /* blue */\r\n                        if (inrow[0] & 0x40) back_i += 1;\r\n\r\n                        *outrow = (png_byte)back_i;\r\n                     }\r\n\r\n                     inrow += 4;\r\n                  }\r\n                  break;\r\n\r\n               default:\r\n                  break;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int\r\npng_image_read_colormapped(png_voidp argument)\r\n{\r\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\r\n      argument);\r\n   png_imagep image = display->image;\r\n   png_controlp control = image->opaque;\r\n   png_structrp png_ptr = control->png_ptr;\r\n   png_inforp info_ptr = control->info_ptr;\r\n\r\n   int passes = 0; /* As a flag */\r\n\r\n   PNG_SKIP_CHUNKS(png_ptr);\r\n\r\n   /* Update the 'info' structure and make sure the result is as required; first\r\n    * make sure to turn on the interlace handling if it will be required\r\n    * (because it can't be turned on *after* the call to png_read_update_info!)\r\n    */\r\n   if (display->colormap_processing == PNG_CMAP_NONE)\r\n      passes = png_set_interlace_handling(png_ptr);\r\n\r\n   png_read_update_info(png_ptr, info_ptr);\r\n\r\n   /* The expected output can be deduced from the colormap_processing option. */\r\n   switch (display->colormap_processing)\r\n   {\r\n      case PNG_CMAP_NONE:\r\n         /* Output must be one channel and one byte per pixel, the output\r\n          * encoding can be anything.\r\n          */\r\n         if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||\r\n            info_ptr->color_type == PNG_COLOR_TYPE_GRAY) &&\r\n            info_ptr->bit_depth == 8)\r\n            break;\r\n\r\n         goto bad_output;\r\n\r\n      case PNG_CMAP_TRANS:\r\n      case PNG_CMAP_GA:\r\n         /* Output must be two channels and the 'G' one must be sRGB, the latter\r\n          * can be checked with an exact number because it should have been set\r\n          * to this number above!\r\n          */\r\n         if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\r\n            info_ptr->bit_depth == 8 &&\r\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\r\n            image->colormap_entries == 256)\r\n            break;\r\n\r\n         goto bad_output;\r\n\r\n      case PNG_CMAP_RGB:\r\n         /* Output must be 8-bit sRGB encoded RGB */\r\n         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&\r\n            info_ptr->bit_depth == 8 &&\r\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\r\n            image->colormap_entries == 216)\r\n            break;\r\n\r\n         goto bad_output;\r\n\r\n      case PNG_CMAP_RGB_ALPHA:\r\n         /* Output must be 8-bit sRGB encoded RGBA */\r\n         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\r\n            info_ptr->bit_depth == 8 &&\r\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\r\n            image->colormap_entries == 244 /* 216 + 1 + 27 */)\r\n            break;\r\n\r\n         /* goto bad_output; */\r\n         /* FALL THROUGH */\r\n\r\n      default:\r\n      bad_output:\r\n         png_error(png_ptr, \"bad color-map processing (internal error)\");\r\n   }\r\n\r\n   /* Now read the rows.  Do this here if it is possible to read directly into\r\n    * the output buffer, otherwise allocate a local row buffer of the maximum\r\n    * size libpng requires and call the relevant processing routine safely.\r\n    */\r\n   {\r\n      png_voidp first_row = display->buffer;\r\n      ptrdiff_t row_bytes = display->row_stride;\r\n\r\n      /* The following expression is designed to work correctly whether it gives\r\n       * a signed or an unsigned result.\r\n       */\r\n      if (row_bytes < 0)\r\n      {\r\n         char *ptr = png_voidcast(char*, first_row);\r\n         ptr += (image->height-1) * (-row_bytes);\r\n         first_row = png_voidcast(png_voidp, ptr);\r\n      }\r\n\r\n      display->first_row = first_row;\r\n      display->row_bytes = row_bytes;\r\n   }\r\n\r\n   if (passes == 0)\r\n   {\r\n      int result;\r\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\r\n\r\n      display->local_row = row;\r\n      result = png_safe_execute(image, png_image_read_and_map, display);\r\n      display->local_row = NULL;\r\n      png_free(png_ptr, row);\r\n\r\n      return result;\r\n   }\r\n\r\n   else\r\n   {\r\n      png_alloc_size_t row_bytes = display->row_bytes;\r\n\r\n      while (--passes >= 0)\r\n      {\r\n         png_uint_32      y = image->height;\r\n         png_bytep        row = png_voidcast(png_bytep, display->first_row);\r\n\r\n         while (y-- > 0)\r\n         {\r\n            png_read_row(png_ptr, row, NULL);\r\n            row += row_bytes;\r\n         }\r\n      }\r\n\r\n      return 1;\r\n   }\r\n}\r\n\r\n/* Just the row reading part of png_image_read. */\r\nstatic int\r\npng_image_read_composite(png_voidp argument)\r\n{\r\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\r\n      argument);\r\n   png_imagep image = display->image;\r\n   png_structrp png_ptr = image->opaque->png_ptr;\r\n   int passes;\r\n\r\n   switch (png_ptr->interlaced)\r\n   {\r\n      case PNG_INTERLACE_NONE:\r\n         passes = 1;\r\n         break;\r\n\r\n      case PNG_INTERLACE_ADAM7:\r\n         passes = PNG_INTERLACE_ADAM7_PASSES;\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"unknown interlace type\");\r\n   }\r\n\r\n   {\r\n      png_uint_32  height = image->height;\r\n      png_uint_32  width = image->width;\r\n      ptrdiff_t    step_row = display->row_bytes;\r\n      unsigned int channels = (image->format & PNG_FORMAT_FLAG_COLOR) ? 3 : 1;\r\n      int pass;\r\n\r\n      for (pass = 0; pass < passes; ++pass)\r\n      {\r\n         unsigned int     startx, stepx, stepy;\r\n         png_uint_32      y;\r\n\r\n         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\r\n         {\r\n            /* The row may be empty for a short image: */\r\n            if (PNG_PASS_COLS(width, pass) == 0)\r\n               continue;\r\n\r\n            startx = PNG_PASS_START_COL(pass) * channels;\r\n            stepx = PNG_PASS_COL_OFFSET(pass) * channels;\r\n            y = PNG_PASS_START_ROW(pass);\r\n            stepy = PNG_PASS_ROW_OFFSET(pass);\r\n         }\r\n\r\n         else\r\n         {\r\n            y = 0;\r\n            startx = 0;\r\n            stepx = channels;\r\n            stepy = 1;\r\n         }\r\n\r\n         for (; y<height; y += stepy)\r\n         {\r\n            png_bytep inrow = png_voidcast(png_bytep, display->local_row);\r\n            png_bytep outrow;\r\n            png_const_bytep end_row;\r\n\r\n            /* Read the row, which is packed: */\r\n            png_read_row(png_ptr, inrow, NULL);\r\n\r\n            outrow = png_voidcast(png_bytep, display->first_row);\r\n            outrow += y * step_row;\r\n            end_row = outrow + width * channels;\r\n\r\n            /* Now do the composition on each pixel in this row. */\r\n            outrow += startx;\r\n            for (; outrow < end_row; outrow += stepx)\r\n            {\r\n               png_byte alpha = inrow[channels];\r\n\r\n               if (alpha > 0) /* else no change to the output */\r\n               {\r\n                  unsigned int c;\r\n\r\n                  for (c=0; c<channels; ++c)\r\n                  {\r\n                     png_uint_32 component = inrow[c];\r\n\r\n                     if (alpha < 255) /* else just use component */\r\n                     {\r\n                        /* This is PNG_OPTIMIZED_ALPHA, the component value\r\n                         * is a linear 8-bit value.  Combine this with the\r\n                         * current outrow[c] value which is sRGB encoded.\r\n                         * Arithmetic here is 16-bits to preserve the output\r\n                         * values correctly.\r\n                         */\r\n                        component *= 257*255; /* =65535 */\r\n                        component += (255-alpha)*png_sRGB_table[outrow[c]];\r\n\r\n                        /* So 'component' is scaled by 255*65535 and is\r\n                         * therefore appropriate for the sRGB to linear\r\n                         * conversion table.\r\n                         */\r\n                        component = PNG_sRGB_FROM_LINEAR(component);\r\n                     }\r\n\r\n                     outrow[c] = (png_byte)component;\r\n                  }\r\n               }\r\n\r\n               inrow += channels+1; /* components and alpha channel */\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n/* The do_local_background case; called when all the following transforms are to\r\n * be done:\r\n *\r\n * PNG_RGB_TO_GRAY\r\n * PNG_COMPOSITE\r\n * PNG_GAMMA\r\n *\r\n * This is a work-round for the fact that both the PNG_RGB_TO_GRAY and\r\n * PNG_COMPOSITE code performs gamma correction, so we get double gamma\r\n * correction.  The fix-up is to prevent the PNG_COMPOSITE operation happening\r\n * inside libpng, so this routine sees an 8 or 16-bit gray+alpha row and handles\r\n * the removal or pre-multiplication of the alpha channel.\r\n */\r\nstatic int\r\npng_image_read_background(png_voidp argument)\r\n{\r\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\r\n      argument);\r\n   png_imagep image = display->image;\r\n   png_structrp png_ptr = image->opaque->png_ptr;\r\n   png_inforp info_ptr = image->opaque->info_ptr;\r\n   png_uint_32 height = image->height;\r\n   png_uint_32 width = image->width;\r\n   int pass, passes;\r\n\r\n   /* Double check the convoluted logic below.  We expect to get here with\r\n    * libpng doing rgb to gray and gamma correction but background processing\r\n    * left to the png_image_read_background function.  The rows libpng produce\r\n    * might be 8 or 16-bit but should always have two channels; gray plus alpha.\r\n    */\r\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\r\n      png_error(png_ptr, \"lost rgb to gray\");\r\n\r\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0)\r\n      png_error(png_ptr, \"unexpected compose\");\r\n\r\n   if (png_get_channels(png_ptr, info_ptr) != 2)\r\n      png_error(png_ptr, \"lost/gained channels\");\r\n\r\n   /* Expect the 8-bit case to always remove the alpha channel */\r\n   if ((image->format & PNG_FORMAT_FLAG_LINEAR) == 0 &&\r\n      (image->format & PNG_FORMAT_FLAG_ALPHA) != 0)\r\n      png_error(png_ptr, \"unexpected 8-bit transformation\");\r\n\r\n   switch (png_ptr->interlaced)\r\n   {\r\n      case PNG_INTERLACE_NONE:\r\n         passes = 1;\r\n         break;\r\n\r\n      case PNG_INTERLACE_ADAM7:\r\n         passes = PNG_INTERLACE_ADAM7_PASSES;\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"unknown interlace type\");\r\n   }\r\n\r\n   /* Use direct access to info_ptr here because otherwise the simplified API\r\n    * would require PNG_EASY_ACCESS_SUPPORTED (just for this.)  Note this is\r\n    * checking the value after libpng expansions, not the original value in the\r\n    * PNG.\r\n    */\r\n   switch (info_ptr->bit_depth)\r\n   {\r\n      default:\r\n         png_error(png_ptr, \"unexpected bit depth\");\r\n         break;\r\n\r\n      case 8:\r\n         /* 8-bit sRGB gray values with an alpha channel; the alpha channel is\r\n          * to be removed by composing on a background: either the row if\r\n          * display->background is NULL or display->background->green if not.\r\n          * Unlike the code above ALPHA_OPTIMIZED has *not* been done.\r\n          */\r\n         {\r\n            png_bytep first_row = png_voidcast(png_bytep, display->first_row);\r\n            ptrdiff_t step_row = display->row_bytes;\r\n\r\n            for (pass = 0; pass < passes; ++pass)\r\n            {\r\n               png_bytep        row = png_voidcast(png_bytep,\r\n                                                   display->first_row);\r\n               unsigned int     startx, stepx, stepy;\r\n               png_uint_32      y;\r\n\r\n               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\r\n               {\r\n                  /* The row may be empty for a short image: */\r\n                  if (PNG_PASS_COLS(width, pass) == 0)\r\n                     continue;\r\n\r\n                  startx = PNG_PASS_START_COL(pass);\r\n                  stepx = PNG_PASS_COL_OFFSET(pass);\r\n                  y = PNG_PASS_START_ROW(pass);\r\n                  stepy = PNG_PASS_ROW_OFFSET(pass);\r\n               }\r\n\r\n               else\r\n               {\r\n                  y = 0;\r\n                  startx = 0;\r\n                  stepx = stepy = 1;\r\n               }\r\n\r\n               if (display->background == NULL)\r\n               {\r\n                  for (; y<height; y += stepy)\r\n                  {\r\n                     png_bytep inrow = png_voidcast(png_bytep,\r\n                        display->local_row);\r\n                     png_bytep outrow = first_row + y * step_row;\r\n                     png_const_bytep end_row = outrow + width;\r\n\r\n                     /* Read the row, which is packed: */\r\n                     png_read_row(png_ptr, inrow, NULL);\r\n\r\n                     /* Now do the composition on each pixel in this row. */\r\n                     outrow += startx;\r\n                     for (; outrow < end_row; outrow += stepx)\r\n                     {\r\n                        png_byte alpha = inrow[1];\r\n\r\n                        if (alpha > 0) /* else no change to the output */\r\n                        {\r\n                           png_uint_32 component = inrow[0];\r\n\r\n                           if (alpha < 255) /* else just use component */\r\n                           {\r\n                              /* Since PNG_OPTIMIZED_ALPHA was not set it is\r\n                               * necessary to invert the sRGB transfer\r\n                               * function and multiply the alpha out.\r\n                               */\r\n                              component = png_sRGB_table[component] * alpha;\r\n                              component += png_sRGB_table[outrow[0]] *\r\n                                 (255-alpha);\r\n                              component = PNG_sRGB_FROM_LINEAR(component);\r\n                           }\r\n\r\n                           outrow[0] = (png_byte)component;\r\n                        }\r\n\r\n                        inrow += 2; /* gray and alpha channel */\r\n                     }\r\n                  }\r\n               }\r\n\r\n               else /* constant background value */\r\n               {\r\n                  png_byte background8 = display->background->green;\r\n                  png_uint_16 background = png_sRGB_table[background8];\r\n\r\n                  for (; y<height; y += stepy)\r\n                  {\r\n                     png_bytep inrow = png_voidcast(png_bytep,\r\n                        display->local_row);\r\n                     png_bytep outrow = first_row + y * step_row;\r\n                     png_const_bytep end_row = outrow + width;\r\n\r\n                     /* Read the row, which is packed: */\r\n                     png_read_row(png_ptr, inrow, NULL);\r\n\r\n                     /* Now do the composition on each pixel in this row. */\r\n                     outrow += startx;\r\n                     for (; outrow < end_row; outrow += stepx)\r\n                     {\r\n                        png_byte alpha = inrow[1];\r\n\r\n                        if (alpha > 0) /* else use background */\r\n                        {\r\n                           png_uint_32 component = inrow[0];\r\n\r\n                           if (alpha < 255) /* else just use component */\r\n                           {\r\n                              component = png_sRGB_table[component] * alpha;\r\n                              component += background * (255-alpha);\r\n                              component = PNG_sRGB_FROM_LINEAR(component);\r\n                           }\r\n\r\n                           outrow[0] = (png_byte)component;\r\n                        }\r\n\r\n                        else\r\n                           outrow[0] = background8;\r\n\r\n                        inrow += 2; /* gray and alpha channel */\r\n                     }\r\n\r\n                     row += display->row_bytes;\r\n                  }\r\n               }\r\n            }\r\n         }\r\n         break;\r\n\r\n      case 16:\r\n         /* 16-bit linear with pre-multiplied alpha; the pre-multiplication must\r\n          * still be done and, maybe, the alpha channel removed.  This code also\r\n          * handles the alpha-first option.\r\n          */\r\n         {\r\n            png_uint_16p first_row = png_voidcast(png_uint_16p,\r\n               display->first_row);\r\n            /* The division by two is safe because the caller passed in a\r\n             * stride which was multiplied by 2 (below) to get row_bytes.\r\n             */\r\n            ptrdiff_t    step_row = display->row_bytes / 2;\r\n            int preserve_alpha = (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;\r\n            unsigned int outchannels = 1+preserve_alpha;\r\n            int swap_alpha = 0;\r\n\r\n#           ifdef PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED\r\n               if (preserve_alpha && (image->format & PNG_FORMAT_FLAG_AFIRST))\r\n                  swap_alpha = 1;\r\n#           endif\r\n\r\n            for (pass = 0; pass < passes; ++pass)\r\n            {\r\n               unsigned int     startx, stepx, stepy;\r\n               png_uint_32      y;\r\n\r\n               /* The 'x' start and step are adjusted to output components here.\r\n                */\r\n               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\r\n               {\r\n                  /* The row may be empty for a short image: */\r\n                  if (PNG_PASS_COLS(width, pass) == 0)\r\n                     continue;\r\n\r\n                  startx = PNG_PASS_START_COL(pass) * outchannels;\r\n                  stepx = PNG_PASS_COL_OFFSET(pass) * outchannels;\r\n                  y = PNG_PASS_START_ROW(pass);\r\n                  stepy = PNG_PASS_ROW_OFFSET(pass);\r\n               }\r\n\r\n               else\r\n               {\r\n                  y = 0;\r\n                  startx = 0;\r\n                  stepx = outchannels;\r\n                  stepy = 1;\r\n               }\r\n\r\n               for (; y<height; y += stepy)\r\n               {\r\n                  png_const_uint_16p inrow;\r\n                  png_uint_16p outrow = first_row + y*step_row;\r\n                  png_uint_16p end_row = outrow + width * outchannels;\r\n\r\n                  /* Read the row, which is packed: */\r\n                  png_read_row(png_ptr, png_voidcast(png_bytep,\r\n                     display->local_row), NULL);\r\n                  inrow = png_voidcast(png_const_uint_16p, display->local_row);\r\n\r\n                  /* Now do the pre-multiplication on each pixel in this row.\r\n                   */\r\n                  outrow += startx;\r\n                  for (; outrow < end_row; outrow += stepx)\r\n                  {\r\n                     png_uint_32 component = inrow[0];\r\n                     png_uint_16 alpha = inrow[1];\r\n\r\n                     if (alpha > 0) /* else 0 */\r\n                     {\r\n                        if (alpha < 65535) /* else just use component */\r\n                        {\r\n                           component *= alpha;\r\n                           component += 32767;\r\n                           component /= 65535;\r\n                        }\r\n                     }\r\n\r\n                     else\r\n                        component = 0;\r\n\r\n                     outrow[swap_alpha] = (png_uint_16)component;\r\n                     if (preserve_alpha)\r\n                        outrow[1 ^ swap_alpha] = alpha;\r\n\r\n                     inrow += 2; /* components and alpha channel */\r\n                  }\r\n               }\r\n            }\r\n         }\r\n         break;\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n/* The guts of png_image_finish_read as a png_safe_execute callback. */\r\nstatic int\r\npng_image_read_direct(png_voidp argument)\r\n{\r\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\r\n      argument);\r\n   png_imagep image = display->image;\r\n   png_structrp png_ptr = image->opaque->png_ptr;\r\n   png_inforp info_ptr = image->opaque->info_ptr;\r\n\r\n   png_uint_32 format = image->format;\r\n   int linear = (format & PNG_FORMAT_FLAG_LINEAR) != 0;\r\n   int do_local_compose = 0;\r\n   int do_local_background = 0; /* to avoid double gamma correction bug */\r\n   int passes = 0;\r\n\r\n   /* Add transforms to ensure the correct output format is produced then check\r\n    * that the required implementation support is there.  Always expand; always\r\n    * need 8 bits minimum, no palette and expanded tRNS.\r\n    */\r\n   png_set_expand(png_ptr);\r\n\r\n   /* Now check the format to see if it was modified. */\r\n   {\r\n      png_uint_32 base_format = png_image_format(png_ptr) &\r\n         ~PNG_FORMAT_FLAG_COLORMAP /* removed by png_set_expand */;\r\n      png_uint_32 change = format ^ base_format;\r\n      png_fixed_point output_gamma;\r\n      int mode; /* alpha mode */\r\n\r\n      /* Do this first so that we have a record if rgb to gray is happening. */\r\n      if (change & PNG_FORMAT_FLAG_COLOR)\r\n      {\r\n         /* gray<->color transformation required. */\r\n         if (format & PNG_FORMAT_FLAG_COLOR)\r\n            png_set_gray_to_rgb(png_ptr);\r\n\r\n         else\r\n         {\r\n            /* libpng can't do both rgb to gray and\r\n             * background/pre-multiplication if there is also significant gamma\r\n             * correction, because both operations require linear colors and\r\n             * the code only supports one transform doing the gamma correction.\r\n             * Handle this by doing the pre-multiplication or background\r\n             * operation in this code, if necessary.\r\n             *\r\n             * TODO: fix this by rewriting pngrtran.c (!)\r\n             *\r\n             * For the moment (given that fixing this in pngrtran.c is an\r\n             * enormous change) 'do_local_background' is used to indicate that\r\n             * the problem exists.\r\n             */\r\n            if (base_format & PNG_FORMAT_FLAG_ALPHA)\r\n               do_local_background = 1/*maybe*/;\r\n\r\n            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE,\r\n               PNG_RGB_TO_GRAY_DEFAULT, PNG_RGB_TO_GRAY_DEFAULT);\r\n         }\r\n\r\n         change &= ~PNG_FORMAT_FLAG_COLOR;\r\n      }\r\n\r\n      /* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.\r\n       */\r\n      {\r\n         png_fixed_point input_gamma_default;\r\n\r\n         if ((base_format & PNG_FORMAT_FLAG_LINEAR) &&\r\n            (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\r\n            input_gamma_default = PNG_GAMMA_LINEAR;\r\n         else\r\n            input_gamma_default = PNG_DEFAULT_sRGB;\r\n\r\n         /* Call png_set_alpha_mode to set the default for the input gamma; the\r\n          * output gamma is set by a second call below.\r\n          */\r\n         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, input_gamma_default);\r\n      }\r\n\r\n      if (linear)\r\n      {\r\n         /* If there *is* an alpha channel in the input it must be multiplied\r\n          * out; use PNG_ALPHA_STANDARD, otherwise just use PNG_ALPHA_PNG.\r\n          */\r\n         if (base_format & PNG_FORMAT_FLAG_ALPHA)\r\n            mode = PNG_ALPHA_STANDARD; /* associated alpha */\r\n\r\n         else\r\n            mode = PNG_ALPHA_PNG;\r\n\r\n         output_gamma = PNG_GAMMA_LINEAR;\r\n      }\r\n\r\n      else\r\n      {\r\n         mode = PNG_ALPHA_PNG;\r\n         output_gamma = PNG_DEFAULT_sRGB;\r\n      }\r\n\r\n      /* If 'do_local_background' is set check for the presence of gamma\r\n       * correction; this is part of the work-round for the libpng bug\r\n       * described above.\r\n       *\r\n       * TODO: fix libpng and remove this.\r\n       */\r\n      if (do_local_background)\r\n      {\r\n         png_fixed_point gtest;\r\n\r\n         /* This is 'png_gamma_threshold' from pngrtran.c; the test used for\r\n          * gamma correction, the screen gamma hasn't been set on png_struct\r\n          * yet; it's set below.  png_struct::gamma, however, is set to the\r\n          * final value.\r\n          */\r\n         if (png_muldiv(&gtest, output_gamma, png_ptr->colorspace.gamma,\r\n               PNG_FP_1) && !png_gamma_significant(gtest))\r\n            do_local_background = 0;\r\n\r\n         else if (mode == PNG_ALPHA_STANDARD)\r\n         {\r\n            do_local_background = 2/*required*/;\r\n            mode = PNG_ALPHA_PNG; /* prevent libpng doing it */\r\n         }\r\n\r\n         /* else leave as 1 for the checks below */\r\n      }\r\n\r\n      /* If the bit-depth changes then handle that here. */\r\n      if (change & PNG_FORMAT_FLAG_LINEAR)\r\n      {\r\n         if (linear /*16-bit output*/)\r\n            png_set_expand_16(png_ptr);\r\n\r\n         else /* 8-bit output */\r\n            png_set_scale_16(png_ptr);\r\n\r\n         change &= ~PNG_FORMAT_FLAG_LINEAR;\r\n      }\r\n\r\n      /* Now the background/alpha channel changes. */\r\n      if (change & PNG_FORMAT_FLAG_ALPHA)\r\n      {\r\n         /* Removing an alpha channel requires composition for the 8-bit\r\n          * formats; for the 16-bit it is already done, above, by the\r\n          * pre-multiplication and the channel just needs to be stripped.\r\n          */\r\n         if (base_format & PNG_FORMAT_FLAG_ALPHA)\r\n         {\r\n            /* If RGB->gray is happening the alpha channel must be left and the\r\n             * operation completed locally.\r\n             *\r\n             * TODO: fix libpng and remove this.\r\n             */\r\n            if (do_local_background)\r\n               do_local_background = 2/*required*/;\r\n\r\n            /* 16-bit output: just remove the channel */\r\n            else if (linear) /* compose on black (well, pre-multiply) */\r\n               png_set_strip_alpha(png_ptr);\r\n\r\n            /* 8-bit output: do an appropriate compose */\r\n            else if (display->background != NULL)\r\n            {\r\n               png_color_16 c;\r\n\r\n               c.index = 0; /*unused*/\r\n               c.red = display->background->red;\r\n               c.green = display->background->green;\r\n               c.blue = display->background->blue;\r\n               c.gray = display->background->green;\r\n\r\n               /* This is always an 8-bit sRGB value, using the 'green' channel\r\n                * for gray is much better than calculating the luminance here;\r\n                * we can get off-by-one errors in that calculation relative to\r\n                * the app expectations and that will show up in transparent\r\n                * pixels.\r\n                */\r\n               png_set_background_fixed(png_ptr, &c,\r\n                  PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\r\n                  0/*gamma: not used*/);\r\n            }\r\n\r\n            else /* compose on row: implemented below. */\r\n            {\r\n               do_local_compose = 1;\r\n               /* This leaves the alpha channel in the output, so it has to be\r\n                * removed by the code below.  Set the encoding to the 'OPTIMIZE'\r\n                * one so the code only has to hack on the pixels that require\r\n                * composition.\r\n                */\r\n               mode = PNG_ALPHA_OPTIMIZED;\r\n            }\r\n         }\r\n\r\n         else /* output needs an alpha channel */\r\n         {\r\n            /* This is tricky because it happens before the swap operation has\r\n             * been accomplished; however, the swap does *not* swap the added\r\n             * alpha channel (weird API), so it must be added in the correct\r\n             * place.\r\n             */\r\n            png_uint_32 filler; /* opaque filler */\r\n            int where;\r\n\r\n            if (linear)\r\n               filler = 65535;\r\n\r\n            else\r\n               filler = 255;\r\n\r\n#           ifdef PNG_FORMAT_AFIRST_SUPPORTED\r\n               if (format & PNG_FORMAT_FLAG_AFIRST)\r\n               {\r\n                  where = PNG_FILLER_BEFORE;\r\n                  change &= ~PNG_FORMAT_FLAG_AFIRST;\r\n               }\r\n\r\n               else\r\n#           endif\r\n               where = PNG_FILLER_AFTER;\r\n\r\n            png_set_add_alpha(png_ptr, filler, where);\r\n         }\r\n\r\n         /* This stops the (irrelevant) call to swap_alpha below. */\r\n         change &= ~PNG_FORMAT_FLAG_ALPHA;\r\n      }\r\n\r\n      /* Now set the alpha mode correctly; this is always done, even if there is\r\n       * no alpha channel in either the input or the output because it correctly\r\n       * sets the output gamma.\r\n       */\r\n      png_set_alpha_mode_fixed(png_ptr, mode, output_gamma);\r\n\r\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\r\n         if (change & PNG_FORMAT_FLAG_BGR)\r\n         {\r\n            /* Check only the output format; PNG is never BGR; don't do this if\r\n             * the output is gray, but fix up the 'format' value in that case.\r\n             */\r\n            if (format & PNG_FORMAT_FLAG_COLOR)\r\n               png_set_bgr(png_ptr);\r\n\r\n            else\r\n               format &= ~PNG_FORMAT_FLAG_BGR;\r\n\r\n            change &= ~PNG_FORMAT_FLAG_BGR;\r\n         }\r\n#     endif\r\n\r\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\r\n         if (change & PNG_FORMAT_FLAG_AFIRST)\r\n         {\r\n            /* Only relevant if there is an alpha channel - it's particularly\r\n             * important to handle this correctly because do_local_compose may\r\n             * be set above and then libpng will keep the alpha channel for this\r\n             * code to remove.\r\n             */\r\n            if (format & PNG_FORMAT_FLAG_ALPHA)\r\n            {\r\n               /* Disable this if doing a local background,\r\n                * TODO: remove this when local background is no longer required.\r\n                */\r\n               if (do_local_background != 2)\r\n                  png_set_swap_alpha(png_ptr);\r\n            }\r\n\r\n            else\r\n               format &= ~PNG_FORMAT_FLAG_AFIRST;\r\n\r\n            change &= ~PNG_FORMAT_FLAG_AFIRST;\r\n         }\r\n#     endif\r\n\r\n      /* If the *output* is 16-bit then we need to check for a byte-swap on this\r\n       * architecture.\r\n       */\r\n      if (linear)\r\n      {\r\n         PNG_CONST png_uint_16 le = 0x0001;\r\n\r\n         if (*(png_const_bytep)&le)\r\n            png_set_swap(png_ptr);\r\n      }\r\n\r\n      /* If change is not now 0 some transformation is missing - error out. */\r\n      if (change)\r\n         png_error(png_ptr, \"png_read_image: unsupported transformation\");\r\n   }\r\n\r\n   PNG_SKIP_CHUNKS(png_ptr);\r\n\r\n   /* Update the 'info' structure and make sure the result is as required; first\r\n    * make sure to turn on the interlace handling if it will be required\r\n    * (because it can't be turned on *after* the call to png_read_update_info!)\r\n    *\r\n    * TODO: remove the do_local_background fixup below.\r\n    */\r\n   if (!do_local_compose && do_local_background != 2)\r\n      passes = png_set_interlace_handling(png_ptr);\r\n\r\n   png_read_update_info(png_ptr, info_ptr);\r\n\r\n   {\r\n      png_uint_32 info_format = 0;\r\n\r\n      if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n         info_format |= PNG_FORMAT_FLAG_COLOR;\r\n\r\n      if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)\r\n      {\r\n         /* do_local_compose removes this channel below. */\r\n         if (!do_local_compose)\r\n         {\r\n            /* do_local_background does the same if required. */\r\n            if (do_local_background != 2 ||\r\n               (format & PNG_FORMAT_FLAG_ALPHA) != 0)\r\n               info_format |= PNG_FORMAT_FLAG_ALPHA;\r\n         }\r\n      }\r\n\r\n      else if (do_local_compose) /* internal error */\r\n         png_error(png_ptr, \"png_image_read: alpha channel lost\");\r\n\r\n      if (info_ptr->bit_depth == 16)\r\n         info_format |= PNG_FORMAT_FLAG_LINEAR;\r\n\r\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\r\n         if (png_ptr->transformations & PNG_BGR)\r\n            info_format |= PNG_FORMAT_FLAG_BGR;\r\n#     endif\r\n\r\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\r\n         if (do_local_background == 2)\r\n         {\r\n            if (format & PNG_FORMAT_FLAG_AFIRST)\r\n               info_format |= PNG_FORMAT_FLAG_AFIRST;\r\n         }\r\n\r\n         if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0 ||\r\n            ((png_ptr->transformations & PNG_ADD_ALPHA) != 0 &&\r\n            (png_ptr->flags & PNG_FLAG_FILLER_AFTER) == 0))\r\n         {\r\n            if (do_local_background == 2)\r\n               png_error(png_ptr, \"unexpected alpha swap transformation\");\r\n\r\n            info_format |= PNG_FORMAT_FLAG_AFIRST;\r\n         }\r\n#     endif\r\n\r\n      /* This is actually an internal error. */\r\n      if (info_format != format)\r\n         png_error(png_ptr, \"png_read_image: invalid transformations\");\r\n   }\r\n\r\n   /* Now read the rows.  If do_local_compose is set then it is necessary to use\r\n    * a local row buffer.  The output will be GA, RGBA or BGRA and must be\r\n    * converted to G, RGB or BGR as appropriate.  The 'local_row' member of the\r\n    * display acts as a flag.\r\n    */\r\n   {\r\n      png_voidp first_row = display->buffer;\r\n      ptrdiff_t row_bytes = display->row_stride;\r\n\r\n      if (linear)\r\n         row_bytes *= 2;\r\n\r\n      /* The following expression is designed to work correctly whether it gives\r\n       * a signed or an unsigned result.\r\n       */\r\n      if (row_bytes < 0)\r\n      {\r\n         char *ptr = png_voidcast(char*, first_row);\r\n         ptr += (image->height-1) * (-row_bytes);\r\n         first_row = png_voidcast(png_voidp, ptr);\r\n      }\r\n\r\n      display->first_row = first_row;\r\n      display->row_bytes = row_bytes;\r\n   }\r\n\r\n   if (do_local_compose)\r\n   {\r\n      int result;\r\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\r\n\r\n      display->local_row = row;\r\n      result = png_safe_execute(image, png_image_read_composite, display);\r\n      display->local_row = NULL;\r\n      png_free(png_ptr, row);\r\n\r\n      return result;\r\n   }\r\n\r\n   else if (do_local_background == 2)\r\n   {\r\n      int result;\r\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\r\n\r\n      display->local_row = row;\r\n      result = png_safe_execute(image, png_image_read_background, display);\r\n      display->local_row = NULL;\r\n      png_free(png_ptr, row);\r\n\r\n      return result;\r\n   }\r\n\r\n   else\r\n   {\r\n      png_alloc_size_t row_bytes = display->row_bytes;\r\n\r\n      while (--passes >= 0)\r\n      {\r\n         png_uint_32      y = image->height;\r\n         png_bytep        row = png_voidcast(png_bytep, display->first_row);\r\n\r\n         while (y-- > 0)\r\n         {\r\n            png_read_row(png_ptr, row, NULL);\r\n            row += row_bytes;\r\n         }\r\n      }\r\n\r\n      return 1;\r\n   }\r\n}\r\n\r\nint PNGAPI\r\npng_image_finish_read(png_imagep image, png_const_colorp background,\r\n   void *buffer, png_int_32 row_stride, void *colormap)\r\n{\r\n   if (image != NULL && image->version == PNG_IMAGE_VERSION)\r\n   {\r\n      png_uint_32 check;\r\n\r\n      if (row_stride == 0)\r\n         row_stride = PNG_IMAGE_ROW_STRIDE(*image);\r\n\r\n      if (row_stride < 0)\r\n         check = -row_stride;\r\n\r\n      else\r\n         check = row_stride;\r\n\r\n      if (image->opaque != NULL && buffer != NULL &&\r\n         check >= PNG_IMAGE_ROW_STRIDE(*image))\r\n      {\r\n         if ((image->format & PNG_FORMAT_FLAG_COLORMAP) == 0 ||\r\n            (image->colormap_entries > 0 && colormap != NULL))\r\n         {\r\n            int result;\r\n            png_image_read_control display;\r\n\r\n            memset(&display, 0, (sizeof display));\r\n            display.image = image;\r\n            display.buffer = buffer;\r\n            display.row_stride = row_stride;\r\n            display.colormap = colormap;\r\n            display.background = background;\r\n            display.local_row = NULL;\r\n\r\n            /* Choose the correct 'end' routine; for the color-map case all the\r\n             * setup has already been done.\r\n             */\r\n            if (image->format & PNG_FORMAT_FLAG_COLORMAP)\r\n               result =\r\n                  png_safe_execute(image, png_image_read_colormap, &display) &&\r\n                  png_safe_execute(image, png_image_read_colormapped, &display);\r\n\r\n            else\r\n               result =\r\n                  png_safe_execute(image, png_image_read_direct, &display);\r\n\r\n            png_image_free(image);\r\n            return result;\r\n         }\r\n\r\n         else\r\n            return png_image_error(image,\r\n               \"png_image_finish_read[color-map]: no color-map\");\r\n      }\r\n\r\n      else\r\n         return png_image_error(image,\r\n            \"png_image_finish_read: invalid argument\");\r\n   }\r\n\r\n   else if (image != NULL)\r\n      return png_image_error(image,\r\n         \"png_image_finish_read: damaged PNG_IMAGE_VERSION\");\r\n\r\n   return 0;\r\n}\r\n\r\n#endif /* PNG_SIMPLIFIED_READ_SUPPORTED */\r\n#endif /* PNG_READ_SUPPORTED */\r\n","\r\n/* pngrio.c - functions for data input\r\n *\r\n * Last changed in libpng 1.6.9 [February 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * This file provides a location for all input.  Users who need\r\n * special handling are expected to write a function that has the same\r\n * arguments as this and performs a similar function, but that possibly\r\n * has a different input method.  Note that you shouldn't change this\r\n * function, but rather write a replacement function and then make\r\n * libpng use it at run time with png_set_read_fn(...).\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\n\r\n/* Read the data from whatever input you are using.  The default routine\r\n * reads from a file pointer.  Note that this routine sometimes gets called\r\n * with very small lengths, so you should implement some kind of simple\r\n * buffering if you are using unbuffered reads.  This should never be asked\r\n * to read more then 64K on a 16 bit machine.\r\n */\r\nvoid /* PRIVATE */\r\npng_read_data(png_structrp png_ptr, png_bytep data, png_size_t length)\r\n{\r\n   png_debug1(4, \"reading %d bytes\", (int)length);\r\n\r\n   if (png_ptr->read_data_fn != NULL)\r\n      (*(png_ptr->read_data_fn))(png_ptr, data, length);\r\n\r\n   else\r\n      png_error(png_ptr, \"Call to NULL read function\");\r\n}\r\n\r\n#ifdef PNG_STDIO_SUPPORTED\r\n/* This is the function that does the actual reading of data.  If you are\r\n * not reading from a standard C stream, you should create a replacement\r\n * read_data function and use it at run time with png_set_read_fn(), rather\r\n * than changing the library.\r\n */\r\nvoid PNGCBAPI\r\npng_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)\r\n{\r\n   png_size_t check;\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   /* fread() returns 0 on error, so it is OK to store this in a png_size_t\r\n    * instead of an int, which is what fread() actually returns.\r\n    */\r\n   check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));\r\n\r\n   if (check != length)\r\n      png_error(png_ptr, \"Read Error\");\r\n}\r\n#endif\r\n\r\n/* This function allows the application to supply a new input function\r\n * for libpng if standard C streams aren't being used.\r\n *\r\n * This function takes as its arguments:\r\n *\r\n * png_ptr      - pointer to a png input data structure\r\n *\r\n * io_ptr       - pointer to user supplied structure containing info about\r\n *                the input functions.  May be NULL.\r\n *\r\n * read_data_fn - pointer to a new input function that takes as its\r\n *                arguments a pointer to a png_struct, a pointer to\r\n *                a location where input data can be stored, and a 32-bit\r\n *                unsigned int that is the number of bytes to be read.\r\n *                To exit and output any fatal error messages the new write\r\n *                function should call png_error(png_ptr, \"Error msg\").\r\n *                May be NULL, in which case libpng's default function will\r\n *                be used.\r\n */\r\nvoid PNGAPI\r\npng_set_read_fn(png_structrp png_ptr, png_voidp io_ptr,\r\n   png_rw_ptr read_data_fn)\r\n{\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->io_ptr = io_ptr;\r\n\r\n#ifdef PNG_STDIO_SUPPORTED\r\n   if (read_data_fn != NULL)\r\n      png_ptr->read_data_fn = read_data_fn;\r\n\r\n   else\r\n      png_ptr->read_data_fn = png_default_read_data;\r\n#else\r\n   png_ptr->read_data_fn = read_data_fn;\r\n#endif\r\n\r\n#ifdef PNG_WRITE_SUPPORTED\r\n   /* It is an error to write to a read device */\r\n   if (png_ptr->write_data_fn != NULL)\r\n   {\r\n      png_ptr->write_data_fn = NULL;\r\n      png_warning(png_ptr,\r\n          \"Can't set both read_data_fn and write_data_fn in the\"\r\n          \" same structure\");\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_WRITE_FLUSH_SUPPORTED\r\n   png_ptr->output_flush_fn = NULL;\r\n#endif\r\n}\r\n#endif /* PNG_READ_SUPPORTED */\r\n","\r\n/* pngrtran.c - transforms the data in a row for PNG readers\r\n *\r\n * Last changed in libpng 1.6.10 [March 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * This file contains functions optionally called by an application\r\n * in order to tell libpng how to handle data when reading a PNG.\r\n * Transformations that are used in both reading and writing are\r\n * in pngtrans.c.\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\n\r\n/* Set the action on getting a CRC error for an ancillary or critical chunk. */\r\nvoid PNGAPI\r\npng_set_crc_action(png_structrp png_ptr, int crit_action, int ancil_action)\r\n{\r\n   png_debug(1, \"in png_set_crc_action\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   /* Tell libpng how we react to CRC errors in critical chunks */\r\n   switch (crit_action)\r\n   {\r\n      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */\r\n         break;\r\n\r\n      case PNG_CRC_WARN_USE:                               /* Warn/use data */\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\r\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;\r\n         break;\r\n\r\n      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\r\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |\r\n                           PNG_FLAG_CRC_CRITICAL_IGNORE;\r\n         break;\r\n\r\n      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */\r\n         png_warning(png_ptr,\r\n            \"Can't discard critical data on CRC error\");\r\n      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */\r\n\r\n      case PNG_CRC_DEFAULT:\r\n      default:\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\r\n         break;\r\n   }\r\n\r\n   /* Tell libpng how we react to CRC errors in ancillary chunks */\r\n   switch (ancil_action)\r\n   {\r\n      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */\r\n         break;\r\n\r\n      case PNG_CRC_WARN_USE:                              /* Warn/use data */\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\r\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;\r\n         break;\r\n\r\n      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\r\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |\r\n                           PNG_FLAG_CRC_ANCILLARY_NOWARN;\r\n         break;\r\n\r\n      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\r\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;\r\n         break;\r\n\r\n      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */\r\n\r\n      case PNG_CRC_DEFAULT:\r\n      default:\r\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\r\n         break;\r\n   }\r\n}\r\n\r\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\r\n/* Is it OK to set a transformation now?  Only if png_start_read_image or\r\n * png_read_update_info have not been called.  It is not necessary for the IHDR\r\n * to have been read in all cases, the parameter allows for this check too.\r\n */\r\nstatic int\r\npng_rtran_ok(png_structrp png_ptr, int need_IHDR)\r\n{\r\n   if (png_ptr != NULL)\r\n   {\r\n      if (png_ptr->flags & PNG_FLAG_ROW_INIT)\r\n         png_app_error(png_ptr,\r\n            \"invalid after png_start_read_image or png_read_update_info\");\r\n\r\n      else if (need_IHDR && (png_ptr->mode & PNG_HAVE_IHDR) == 0)\r\n         png_app_error(png_ptr, \"invalid before the PNG header has been read\");\r\n\r\n      else\r\n      {\r\n         /* Turn on failure to initialize correctly for all transforms. */\r\n         png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;\r\n\r\n         return 1; /* Ok */\r\n      }\r\n   }\r\n\r\n   return 0; /* no png_error possible! */\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\r\n/* Handle alpha and tRNS via a background color */\r\nvoid PNGFAPI\r\npng_set_background_fixed(png_structrp png_ptr,\r\n    png_const_color_16p background_color, int background_gamma_code,\r\n    int need_expand, png_fixed_point background_gamma)\r\n{\r\n   png_debug(1, \"in png_set_background_fixed\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0) || background_color == NULL)\r\n      return;\r\n\r\n   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)\r\n   {\r\n      png_warning(png_ptr, \"Application must supply a known background gamma\");\r\n      return;\r\n   }\r\n\r\n   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;\r\n   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n\r\n   png_ptr->background = *background_color;\r\n   png_ptr->background_gamma = background_gamma;\r\n   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);\r\n   if (need_expand)\r\n      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;\r\n   else\r\n      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_background(png_structrp png_ptr,\r\n    png_const_color_16p background_color, int background_gamma_code,\r\n    int need_expand, double background_gamma)\r\n{\r\n   png_set_background_fixed(png_ptr, background_color, background_gamma_code,\r\n      need_expand, png_fixed(png_ptr, background_gamma, \"png_set_background\"));\r\n}\r\n#  endif  /* FLOATING_POINT */\r\n#endif /* READ_BACKGROUND */\r\n\r\n/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the\r\n * one that pngrtran does first (scale) happens.  This is necessary to allow the\r\n * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.\r\n */\r\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\r\nvoid PNGAPI\r\npng_set_scale_16(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_scale_16\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_SCALE_16_TO_8;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\r\n/* Chop 16-bit depth files to 8-bit depth */\r\nvoid PNGAPI\r\npng_set_strip_16(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_strip_16\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_16_TO_8;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\r\nvoid PNGAPI\r\npng_set_strip_alpha(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_strip_alpha\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_STRIP_ALPHA;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_ALPHA_MODE_SUPPORTED) || defined(PNG_READ_GAMMA_SUPPORTED)\r\nstatic png_fixed_point\r\ntranslate_gamma_flags(png_structrp png_ptr, png_fixed_point output_gamma,\r\n   int is_screen)\r\n{\r\n   /* Check for flag values.  The main reason for having the old Mac value as a\r\n    * flag is that it is pretty near impossible to work out what the correct\r\n    * value is from Apple documentation - a working Mac system is needed to\r\n    * discover the value!\r\n    */\r\n   if (output_gamma == PNG_DEFAULT_sRGB ||\r\n      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)\r\n   {\r\n      /* If there is no sRGB support this just sets the gamma to the standard\r\n       * sRGB value.  (This is a side effect of using this function!)\r\n       */\r\n#     ifdef PNG_READ_sRGB_SUPPORTED\r\n         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;\r\n#     else\r\n         PNG_UNUSED(png_ptr)\r\n#     endif\r\n      if (is_screen)\r\n         output_gamma = PNG_GAMMA_sRGB;\r\n      else\r\n         output_gamma = PNG_GAMMA_sRGB_INVERSE;\r\n   }\r\n\r\n   else if (output_gamma == PNG_GAMMA_MAC_18 ||\r\n      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)\r\n   {\r\n      if (is_screen)\r\n         output_gamma = PNG_GAMMA_MAC_OLD;\r\n      else\r\n         output_gamma = PNG_GAMMA_MAC_INVERSE;\r\n   }\r\n\r\n   return output_gamma;\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nstatic png_fixed_point\r\nconvert_gamma_value(png_structrp png_ptr, double output_gamma)\r\n{\r\n   /* The following silently ignores cases where fixed point (times 100,000)\r\n    * gamma values are passed to the floating point API.  This is safe and it\r\n    * means the fixed point constants work just fine with the floating point\r\n    * API.  The alternative would just lead to undetected errors and spurious\r\n    * bug reports.  Negative values fail inside the _fixed API unless they\r\n    * correspond to the flag values.\r\n    */\r\n   if (output_gamma > 0 && output_gamma < 128)\r\n      output_gamma *= PNG_FP_1;\r\n\r\n   /* This preserves -1 and -2 exactly: */\r\n   output_gamma = floor(output_gamma + .5);\r\n\r\n   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)\r\n      png_fixed_error(png_ptr, \"gamma value\");\r\n\r\n   return (png_fixed_point)output_gamma;\r\n}\r\n#  endif\r\n#endif /* READ_ALPHA_MODE || READ_GAMMA */\r\n\r\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\r\nvoid PNGFAPI\r\npng_set_alpha_mode_fixed(png_structrp png_ptr, int mode,\r\n   png_fixed_point output_gamma)\r\n{\r\n   int compose = 0;\r\n   png_fixed_point file_gamma;\r\n\r\n   png_debug(1, \"in png_set_alpha_mode\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1/*screen*/);\r\n\r\n   /* Validate the value to ensure it is in a reasonable range. The value\r\n    * is expected to be 1 or greater, but this range test allows for some\r\n    * viewing correction values.  The intent is to weed out users of this API\r\n    * who use the inverse of the gamma value accidentally!  Since some of these\r\n    * values are reasonable this may have to be changed.\r\n    */\r\n   if (output_gamma < 70000 || output_gamma > 300000)\r\n      png_error(png_ptr, \"output gamma out of expected range\");\r\n\r\n   /* The default file gamma is the inverse of the output gamma; the output\r\n    * gamma may be changed below so get the file value first:\r\n    */\r\n   file_gamma = png_reciprocal(output_gamma);\r\n\r\n   /* There are really 8 possibilities here, composed of any combination\r\n    * of:\r\n    *\r\n    *    premultiply the color channels\r\n    *    do not encode non-opaque pixels\r\n    *    encode the alpha as well as the color channels\r\n    *\r\n    * The differences disappear if the input/output ('screen') gamma is 1.0,\r\n    * because then the encoding is a no-op and there is only the choice of\r\n    * premultiplying the color channels or not.\r\n    *\r\n    * png_set_alpha_mode and png_set_background interact because both use\r\n    * png_compose to do the work.  Calling both is only useful when\r\n    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along\r\n    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.\r\n    */\r\n   switch (mode)\r\n   {\r\n      case PNG_ALPHA_PNG:        /* default: png standard */\r\n         /* No compose, but it may be set by png_set_background! */\r\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n         break;\r\n\r\n      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */\r\n         compose = 1;\r\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n         /* The output is linear: */\r\n         output_gamma = PNG_FP_1;\r\n         break;\r\n\r\n      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */\r\n         compose = 1;\r\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;\r\n         /* output_gamma records the encoding of opaque pixels! */\r\n         break;\r\n\r\n      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */\r\n         compose = 1;\r\n         png_ptr->transformations |= PNG_ENCODE_ALPHA;\r\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"invalid alpha mode\");\r\n   }\r\n\r\n   /* Only set the default gamma if the file gamma has not been set (this has\r\n    * the side effect that the gamma in a second call to png_set_alpha_mode will\r\n    * be ignored.)\r\n    */\r\n   if (png_ptr->colorspace.gamma == 0)\r\n   {\r\n      png_ptr->colorspace.gamma = file_gamma;\r\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\r\n   }\r\n\r\n   /* But always set the output gamma: */\r\n   png_ptr->screen_gamma = output_gamma;\r\n\r\n   /* Finally, if pre-multiplying, set the background fields to achieve the\r\n    * desired result.\r\n    */\r\n   if (compose)\r\n   {\r\n      /* And obtain alpha pre-multiplication by composing on black: */\r\n      memset(&png_ptr->background, 0, (sizeof png_ptr->background));\r\n      png_ptr->background_gamma = png_ptr->colorspace.gamma; /* just in case */\r\n      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;\r\n      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\r\n\r\n      if (png_ptr->transformations & PNG_COMPOSE)\r\n         png_error(png_ptr,\r\n            \"conflicting calls to set alpha mode and background\");\r\n\r\n      png_ptr->transformations |= PNG_COMPOSE;\r\n   }\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)\r\n{\r\n   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,\r\n      output_gamma));\r\n}\r\n#  endif\r\n#endif\r\n\r\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\r\n/* Dither file to 8-bit.  Supply a palette, the current number\r\n * of elements in the palette, the maximum number of elements\r\n * allowed, and a histogram if possible.  If the current number\r\n * of colors is greater then the maximum number, the palette will be\r\n * modified to fit in the maximum number.  \"full_quantize\" indicates\r\n * whether we need a quantizing cube set up for RGB images, or if we\r\n * simply are reducing the number of colors in a paletted image.\r\n */\r\n\r\ntypedef struct png_dsort_struct\r\n{\r\n   struct png_dsort_struct * next;\r\n   png_byte left;\r\n   png_byte right;\r\n} png_dsort;\r\ntypedef png_dsort *   png_dsortp;\r\ntypedef png_dsort * * png_dsortpp;\r\n\r\nvoid PNGAPI\r\npng_set_quantize(png_structrp png_ptr, png_colorp palette,\r\n    int num_palette, int maximum_colors, png_const_uint_16p histogram,\r\n    int full_quantize)\r\n{\r\n   png_debug(1, \"in png_set_quantize\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_QUANTIZE;\r\n\r\n   if (!full_quantize)\r\n   {\r\n      int i;\r\n\r\n      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,\r\n          (png_uint_32)(num_palette * (sizeof (png_byte))));\r\n      for (i = 0; i < num_palette; i++)\r\n         png_ptr->quantize_index[i] = (png_byte)i;\r\n   }\r\n\r\n   if (num_palette > maximum_colors)\r\n   {\r\n      if (histogram != NULL)\r\n      {\r\n         /* This is easy enough, just throw out the least used colors.\r\n          * Perhaps not the best solution, but good enough.\r\n          */\r\n\r\n         int i;\r\n\r\n         /* Initialize an array to sort colors */\r\n         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,\r\n             (png_uint_32)(num_palette * (sizeof (png_byte))));\r\n\r\n         /* Initialize the quantize_sort array */\r\n         for (i = 0; i < num_palette; i++)\r\n            png_ptr->quantize_sort[i] = (png_byte)i;\r\n\r\n         /* Find the least used palette entries by starting a\r\n          * bubble sort, and running it until we have sorted\r\n          * out enough colors.  Note that we don't care about\r\n          * sorting all the colors, just finding which are\r\n          * least used.\r\n          */\r\n\r\n         for (i = num_palette - 1; i >= maximum_colors; i--)\r\n         {\r\n            int done; /* To stop early if the list is pre-sorted */\r\n            int j;\r\n\r\n            done = 1;\r\n            for (j = 0; j < i; j++)\r\n            {\r\n               if (histogram[png_ptr->quantize_sort[j]]\r\n                   < histogram[png_ptr->quantize_sort[j + 1]])\r\n               {\r\n                  png_byte t;\r\n\r\n                  t = png_ptr->quantize_sort[j];\r\n                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];\r\n                  png_ptr->quantize_sort[j + 1] = t;\r\n                  done = 0;\r\n               }\r\n            }\r\n\r\n            if (done)\r\n               break;\r\n         }\r\n\r\n         /* Swap the palette around, and set up a table, if necessary */\r\n         if (full_quantize)\r\n         {\r\n            int j = num_palette;\r\n\r\n            /* Put all the useful colors within the max, but don't\r\n             * move the others.\r\n             */\r\n            for (i = 0; i < maximum_colors; i++)\r\n            {\r\n               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)\r\n               {\r\n                  do\r\n                     j--;\r\n                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);\r\n\r\n                  palette[i] = palette[j];\r\n               }\r\n            }\r\n         }\r\n         else\r\n         {\r\n            int j = num_palette;\r\n\r\n            /* Move all the used colors inside the max limit, and\r\n             * develop a translation table.\r\n             */\r\n            for (i = 0; i < maximum_colors; i++)\r\n            {\r\n               /* Only move the colors we need to */\r\n               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)\r\n               {\r\n                  png_color tmp_color;\r\n\r\n                  do\r\n                     j--;\r\n                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);\r\n\r\n                  tmp_color = palette[j];\r\n                  palette[j] = palette[i];\r\n                  palette[i] = tmp_color;\r\n                  /* Indicate where the color went */\r\n                  png_ptr->quantize_index[j] = (png_byte)i;\r\n                  png_ptr->quantize_index[i] = (png_byte)j;\r\n               }\r\n            }\r\n\r\n            /* Find closest color for those colors we are not using */\r\n            for (i = 0; i < num_palette; i++)\r\n            {\r\n               if ((int)png_ptr->quantize_index[i] >= maximum_colors)\r\n               {\r\n                  int min_d, k, min_k, d_index;\r\n\r\n                  /* Find the closest color to one we threw out */\r\n                  d_index = png_ptr->quantize_index[i];\r\n                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);\r\n                  for (k = 1, min_k = 0; k < maximum_colors; k++)\r\n                  {\r\n                     int d;\r\n\r\n                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);\r\n\r\n                     if (d < min_d)\r\n                     {\r\n                        min_d = d;\r\n                        min_k = k;\r\n                     }\r\n                  }\r\n                  /* Point to closest color */\r\n                  png_ptr->quantize_index[i] = (png_byte)min_k;\r\n               }\r\n            }\r\n         }\r\n         png_free(png_ptr, png_ptr->quantize_sort);\r\n         png_ptr->quantize_sort = NULL;\r\n      }\r\n      else\r\n      {\r\n         /* This is much harder to do simply (and quickly).  Perhaps\r\n          * we need to go through a median cut routine, but those\r\n          * don't always behave themselves with only a few colors\r\n          * as input.  So we will just find the closest two colors,\r\n          * and throw out one of them (chosen somewhat randomly).\r\n          * [We don't understand this at all, so if someone wants to\r\n          *  work on improving it, be our guest - AED, GRP]\r\n          */\r\n         int i;\r\n         int max_d;\r\n         int num_new_palette;\r\n         png_dsortp t;\r\n         png_dsortpp hash;\r\n\r\n         t = NULL;\r\n\r\n         /* Initialize palette index arrays */\r\n         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,\r\n             (png_uint_32)(num_palette * (sizeof (png_byte))));\r\n         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,\r\n             (png_uint_32)(num_palette * (sizeof (png_byte))));\r\n\r\n         /* Initialize the sort array */\r\n         for (i = 0; i < num_palette; i++)\r\n         {\r\n            png_ptr->index_to_palette[i] = (png_byte)i;\r\n            png_ptr->palette_to_index[i] = (png_byte)i;\r\n         }\r\n\r\n         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *\r\n             (sizeof (png_dsortp))));\r\n\r\n         num_new_palette = num_palette;\r\n\r\n         /* Initial wild guess at how far apart the farthest pixel\r\n          * pair we will be eliminating will be.  Larger\r\n          * numbers mean more areas will be allocated, Smaller\r\n          * numbers run the risk of not saving enough data, and\r\n          * having to do this all over again.\r\n          *\r\n          * I have not done extensive checking on this number.\r\n          */\r\n         max_d = 96;\r\n\r\n         while (num_new_palette > maximum_colors)\r\n         {\r\n            for (i = 0; i < num_new_palette - 1; i++)\r\n            {\r\n               int j;\r\n\r\n               for (j = i + 1; j < num_new_palette; j++)\r\n               {\r\n                  int d;\r\n\r\n                  d = PNG_COLOR_DIST(palette[i], palette[j]);\r\n\r\n                  if (d <= max_d)\r\n                  {\r\n\r\n                     t = (png_dsortp)png_malloc_warn(png_ptr,\r\n                         (png_uint_32)(sizeof (png_dsort)));\r\n\r\n                     if (t == NULL)\r\n                         break;\r\n\r\n                     t->next = hash[d];\r\n                     t->left = (png_byte)i;\r\n                     t->right = (png_byte)j;\r\n                     hash[d] = t;\r\n                  }\r\n               }\r\n               if (t == NULL)\r\n                  break;\r\n            }\r\n\r\n            if (t != NULL)\r\n            for (i = 0; i <= max_d; i++)\r\n            {\r\n               if (hash[i] != NULL)\r\n               {\r\n                  png_dsortp p;\r\n\r\n                  for (p = hash[i]; p; p = p->next)\r\n                  {\r\n                     if ((int)png_ptr->index_to_palette[p->left]\r\n                         < num_new_palette &&\r\n                         (int)png_ptr->index_to_palette[p->right]\r\n                         < num_new_palette)\r\n                     {\r\n                        int j, next_j;\r\n\r\n                        if (num_new_palette & 0x01)\r\n                        {\r\n                           j = p->left;\r\n                           next_j = p->right;\r\n                        }\r\n                        else\r\n                        {\r\n                           j = p->right;\r\n                           next_j = p->left;\r\n                        }\r\n\r\n                        num_new_palette--;\r\n                        palette[png_ptr->index_to_palette[j]]\r\n                            = palette[num_new_palette];\r\n                        if (!full_quantize)\r\n                        {\r\n                           int k;\r\n\r\n                           for (k = 0; k < num_palette; k++)\r\n                           {\r\n                              if (png_ptr->quantize_index[k] ==\r\n                                  png_ptr->index_to_palette[j])\r\n                                 png_ptr->quantize_index[k] =\r\n                                     png_ptr->index_to_palette[next_j];\r\n\r\n                              if ((int)png_ptr->quantize_index[k] ==\r\n                                  num_new_palette)\r\n                                 png_ptr->quantize_index[k] =\r\n                                     png_ptr->index_to_palette[j];\r\n                           }\r\n                        }\r\n\r\n                        png_ptr->index_to_palette[png_ptr->palette_to_index\r\n                            [num_new_palette]] = png_ptr->index_to_palette[j];\r\n\r\n                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]\r\n                            = png_ptr->palette_to_index[num_new_palette];\r\n\r\n                        png_ptr->index_to_palette[j] =\r\n                            (png_byte)num_new_palette;\r\n\r\n                        png_ptr->palette_to_index[num_new_palette] =\r\n                            (png_byte)j;\r\n                     }\r\n                     if (num_new_palette <= maximum_colors)\r\n                        break;\r\n                  }\r\n                  if (num_new_palette <= maximum_colors)\r\n                     break;\r\n               }\r\n            }\r\n\r\n            for (i = 0; i < 769; i++)\r\n            {\r\n               if (hash[i] != NULL)\r\n               {\r\n                  png_dsortp p = hash[i];\r\n                  while (p)\r\n                  {\r\n                     t = p->next;\r\n                     png_free(png_ptr, p);\r\n                     p = t;\r\n                  }\r\n               }\r\n               hash[i] = 0;\r\n            }\r\n            max_d += 96;\r\n         }\r\n         png_free(png_ptr, hash);\r\n         png_free(png_ptr, png_ptr->palette_to_index);\r\n         png_free(png_ptr, png_ptr->index_to_palette);\r\n         png_ptr->palette_to_index = NULL;\r\n         png_ptr->index_to_palette = NULL;\r\n      }\r\n      num_palette = maximum_colors;\r\n   }\r\n   if (png_ptr->palette == NULL)\r\n   {\r\n      png_ptr->palette = palette;\r\n   }\r\n   png_ptr->num_palette = (png_uint_16)num_palette;\r\n\r\n   if (full_quantize)\r\n   {\r\n      int i;\r\n      png_bytep distance;\r\n      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +\r\n          PNG_QUANTIZE_BLUE_BITS;\r\n      int num_red = (1 << PNG_QUANTIZE_RED_BITS);\r\n      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);\r\n      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);\r\n      png_size_t num_entries = ((png_size_t)1 << total_bits);\r\n\r\n      png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,\r\n          (png_uint_32)(num_entries * (sizeof (png_byte))));\r\n\r\n      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *\r\n          (sizeof (png_byte))));\r\n\r\n      memset(distance, 0xff, num_entries * (sizeof (png_byte)));\r\n\r\n      for (i = 0; i < num_palette; i++)\r\n      {\r\n         int ir, ig, ib;\r\n         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));\r\n         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));\r\n         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));\r\n\r\n         for (ir = 0; ir < num_red; ir++)\r\n         {\r\n            /* int dr = abs(ir - r); */\r\n            int dr = ((ir > r) ? ir - r : r - ir);\r\n            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +\r\n                PNG_QUANTIZE_GREEN_BITS));\r\n\r\n            for (ig = 0; ig < num_green; ig++)\r\n            {\r\n               /* int dg = abs(ig - g); */\r\n               int dg = ((ig > g) ? ig - g : g - ig);\r\n               int dt = dr + dg;\r\n               int dm = ((dr > dg) ? dr : dg);\r\n               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);\r\n\r\n               for (ib = 0; ib < num_blue; ib++)\r\n               {\r\n                  int d_index = index_g | ib;\r\n                  /* int db = abs(ib - b); */\r\n                  int db = ((ib > b) ? ib - b : b - ib);\r\n                  int dmax = ((dm > db) ? dm : db);\r\n                  int d = dmax + dt + db;\r\n\r\n                  if (d < (int)distance[d_index])\r\n                  {\r\n                     distance[d_index] = (png_byte)d;\r\n                     png_ptr->palette_lookup[d_index] = (png_byte)i;\r\n                  }\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      png_free(png_ptr, distance);\r\n   }\r\n}\r\n#endif /* PNG_READ_QUANTIZE_SUPPORTED */\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\nvoid PNGFAPI\r\npng_set_gamma_fixed(png_structrp png_ptr, png_fixed_point scrn_gamma,\r\n   png_fixed_point file_gamma)\r\n{\r\n   png_debug(1, \"in png_set_gamma_fixed\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   /* New in libpng-1.5.4 - reserve particular negative values as flags. */\r\n   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1/*screen*/);\r\n   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0/*file*/);\r\n\r\n   /* Checking the gamma values for being >0 was added in 1.5.4 along with the\r\n    * premultiplied alpha support; this actually hides an undocumented feature\r\n    * of the previous implementation which allowed gamma processing to be\r\n    * disabled in background handling.  There is no evidence (so far) that this\r\n    * was being used; however, png_set_background itself accepted and must still\r\n    * accept '0' for the gamma value it takes, because it isn't always used.\r\n    *\r\n    * Since this is an API change (albeit a very minor one that removes an\r\n    * undocumented API feature) the following checks were only enabled in\r\n    * libpng-1.6.0.\r\n    */\r\n   if (file_gamma <= 0)\r\n      png_error(png_ptr, \"invalid file gamma in png_set_gamma\");\r\n\r\n   if (scrn_gamma <= 0)\r\n      png_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\r\n\r\n   /* Set the gamma values unconditionally - this overrides the value in the PNG\r\n    * file if a gAMA chunk was present.  png_set_alpha_mode provides a\r\n    * different, easier, way to default the file gamma.\r\n    */\r\n   png_ptr->colorspace.gamma = file_gamma;\r\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\r\n   png_ptr->screen_gamma = scrn_gamma;\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_gamma(png_structrp png_ptr, double scrn_gamma, double file_gamma)\r\n{\r\n   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),\r\n      convert_gamma_value(png_ptr, file_gamma));\r\n}\r\n#  endif /* FLOATING_POINT_SUPPORTED */\r\n#endif /* READ_GAMMA */\r\n\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n/* Expand paletted images to RGB, expand grayscale images of\r\n * less than 8-bit depth to 8-bit depth, and expand tRNS chunks\r\n * to alpha channels.\r\n */\r\nvoid PNGAPI\r\npng_set_expand(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_expand\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\r\n}\r\n\r\n/* GRR 19990627:  the following three functions currently are identical\r\n *  to png_set_expand().  However, it is entirely reasonable that someone\r\n *  might wish to expand an indexed image to RGB but *not* expand a single,\r\n *  fully transparent palette entry to a full alpha channel--perhaps instead\r\n *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace\r\n *  the transparent color with a particular RGB value, or drop tRNS entirely.\r\n *  IOW, a future version of the library may make the transformations flag\r\n *  a bit more fine-grained, with separate bits for each of these three\r\n *  functions.\r\n *\r\n *  More to the point, these functions make it obvious what libpng will be\r\n *  doing, whereas \"expand\" can (and does) mean any number of things.\r\n *\r\n *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified\r\n *  to expand only the sample depth but not to expand the tRNS to alpha\r\n *  and its name was changed to png_set_expand_gray_1_2_4_to_8().\r\n */\r\n\r\n/* Expand paletted images to RGB. */\r\nvoid PNGAPI\r\npng_set_palette_to_rgb(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_palette_to_rgb\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\r\n}\r\n\r\n/* Expand grayscale images of less than 8-bit depth to 8 bits. */\r\nvoid PNGAPI\r\npng_set_expand_gray_1_2_4_to_8(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_expand_gray_1_2_4_to_8\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_EXPAND;\r\n}\r\n\r\n/* Expand tRNS chunks to alpha channels. */\r\nvoid PNGAPI\r\npng_set_tRNS_to_alpha(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_tRNS_to_alpha\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\r\n}\r\n#endif /* defined(PNG_READ_EXPAND_SUPPORTED) */\r\n\r\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\r\n/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise\r\n * it may not work correctly.)\r\n */\r\nvoid PNGAPI\r\npng_set_expand_16(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_expand_16\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\nvoid PNGAPI\r\npng_set_gray_to_rgb(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_gray_to_rgb\");\r\n\r\n   if (!png_rtran_ok(png_ptr, 0))\r\n      return;\r\n\r\n   /* Because rgb must be 8 bits or more: */\r\n   png_set_expand_gray_1_2_4_to_8(png_ptr);\r\n   png_ptr->transformations |= PNG_GRAY_TO_RGB;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\nvoid PNGFAPI\r\npng_set_rgb_to_gray_fixed(png_structrp png_ptr, int error_action,\r\n    png_fixed_point red, png_fixed_point green)\r\n{\r\n   png_debug(1, \"in png_set_rgb_to_gray\");\r\n\r\n   /* Need the IHDR here because of the check on color_type below. */\r\n   /* TODO: fix this */\r\n   if (!png_rtran_ok(png_ptr, 1))\r\n      return;\r\n\r\n   switch(error_action)\r\n   {\r\n      case PNG_ERROR_ACTION_NONE:\r\n         png_ptr->transformations |= PNG_RGB_TO_GRAY;\r\n         break;\r\n\r\n      case PNG_ERROR_ACTION_WARN:\r\n         png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;\r\n         break;\r\n\r\n      case PNG_ERROR_ACTION_ERROR:\r\n         png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;\r\n         break;\r\n\r\n      default:\r\n         png_error(png_ptr, \"invalid error action to rgb_to_gray\");\r\n         break;\r\n   }\r\n\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n      png_ptr->transformations |= PNG_EXPAND;\r\n#else\r\n   {\r\n      /* Make this an error in 1.6 because otherwise the application may assume\r\n       * that it just worked and get a memory overwrite.\r\n       */\r\n      png_error(png_ptr,\r\n        \"Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED\");\r\n\r\n      /* png_ptr->transformations &= ~PNG_RGB_TO_GRAY; */\r\n   }\r\n#endif\r\n   {\r\n      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)\r\n      {\r\n         png_uint_16 red_int, green_int;\r\n\r\n         /* NOTE: this calculation does not round, but this behavior is retained\r\n          * for consistency, the inaccuracy is very small.  The code here always\r\n          * overwrites the coefficients, regardless of whether they have been\r\n          * defaulted or set already.\r\n          */\r\n         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);\r\n         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);\r\n\r\n         png_ptr->rgb_to_gray_red_coeff   = red_int;\r\n         png_ptr->rgb_to_gray_green_coeff = green_int;\r\n         png_ptr->rgb_to_gray_coefficients_set = 1;\r\n      }\r\n\r\n      else\r\n      {\r\n         if (red >= 0 && green >= 0)\r\n            png_app_warning(png_ptr,\r\n               \"ignoring out of range rgb_to_gray coefficients\");\r\n\r\n         /* Use the defaults, from the cHRM chunk if set, else the historical\r\n          * values which are close to the sRGB/HDTV/ITU-Rec 709 values.  See\r\n          * png_do_rgb_to_gray for more discussion of the values.  In this case\r\n          * the coefficients are not marked as 'set' and are not overwritten if\r\n          * something has already provided a default.\r\n          */\r\n         if (png_ptr->rgb_to_gray_red_coeff == 0 &&\r\n            png_ptr->rgb_to_gray_green_coeff == 0)\r\n         {\r\n            png_ptr->rgb_to_gray_red_coeff   = 6968;\r\n            png_ptr->rgb_to_gray_green_coeff = 23434;\r\n            /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\n#ifdef PNG_FLOATING_POINT_SUPPORTED\r\n/* Convert a RGB image to a grayscale of the same width.  This allows us,\r\n * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.\r\n */\r\n\r\nvoid PNGAPI\r\npng_set_rgb_to_gray(png_structrp png_ptr, int error_action, double red,\r\n   double green)\r\n{\r\n   png_set_rgb_to_gray_fixed(png_ptr, error_action,\r\n      png_fixed(png_ptr, red, \"rgb to gray red coefficient\"),\r\n      png_fixed(png_ptr, green, \"rgb to gray green coefficient\"));\r\n}\r\n#endif /* FLOATING POINT */\r\n\r\n#endif /* RGB_TO_GRAY */\r\n\r\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \\\r\n    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\r\nvoid PNGAPI\r\npng_set_read_user_transform_fn(png_structrp png_ptr, png_user_transform_ptr\r\n    read_user_transform_fn)\r\n{\r\n   png_debug(1, \"in png_set_read_user_transform_fn\");\r\n\r\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\r\n   png_ptr->transformations |= PNG_USER_TRANSFORM;\r\n   png_ptr->read_user_transform_fn = read_user_transform_fn;\r\n#endif\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n/* In the case of gamma transformations only do transformations on images where\r\n * the [file] gamma and screen_gamma are not close reciprocals, otherwise it\r\n * slows things down slightly, and also needlessly introduces small errors.\r\n */\r\nstatic int /* PRIVATE */\r\npng_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)\r\n{\r\n   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma\r\n    * correction as a difference of the overall transform from 1.0\r\n    *\r\n    * We want to compare the threshold with s*f - 1, if we get\r\n    * overflow here it is because of wacky gamma values so we\r\n    * turn on processing anyway.\r\n    */\r\n   png_fixed_point gtest;\r\n   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||\r\n       png_gamma_significant(gtest);\r\n}\r\n#endif\r\n\r\n/* Initialize everything needed for the read.  This includes modifying\r\n * the palette.\r\n */\r\n\r\n/*For the moment 'png_init_palette_transformations' and\r\n * 'png_init_rgb_transformations' only do some flag canceling optimizations.\r\n * The intent is that these two routines should have palette or rgb operations\r\n * extracted from 'png_init_read_transformations'.\r\n */\r\nstatic void /* PRIVATE */\r\npng_init_palette_transformations(png_structrp png_ptr)\r\n{\r\n   /* Called to handle the (input) palette case.  In png_do_read_transformations\r\n    * the first step is to expand the palette if requested, so this code must\r\n    * take care to only make changes that are invariant with respect to the\r\n    * palette expansion, or only do them if there is no expansion.\r\n    *\r\n    * STRIP_ALPHA has already been handled in the caller (by setting num_trans\r\n    * to 0.)\r\n    */\r\n   int input_has_alpha = 0;\r\n   int input_has_transparency = 0;\r\n\r\n   if (png_ptr->num_trans > 0)\r\n   {\r\n      int i;\r\n\r\n      /* Ignore if all the entries are opaque (unlikely!) */\r\n      for (i=0; i<png_ptr->num_trans; ++i)\r\n      {\r\n         if (png_ptr->trans_alpha[i] == 255)\r\n            continue;\r\n         else if (png_ptr->trans_alpha[i] == 0)\r\n            input_has_transparency = 1;\r\n         else\r\n         {\r\n            input_has_transparency = 1;\r\n            input_has_alpha = 1;\r\n            break;\r\n         }\r\n      }\r\n   }\r\n\r\n   /* If no alpha we can optimize. */\r\n   if (!input_has_alpha)\r\n   {\r\n      /* Any alpha means background and associative alpha processing is\r\n       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA\r\n       * and ENCODE_ALPHA are irrelevant.\r\n       */\r\n      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n\r\n      if (!input_has_transparency)\r\n         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);\r\n   }\r\n\r\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\r\n   /* png_set_background handling - deals with the complexity of whether the\r\n    * background color is in the file format or the screen format in the case\r\n    * where an 'expand' will happen.\r\n    */\r\n\r\n   /* The following code cannot be entered in the alpha pre-multiplication case\r\n    * because PNG_BACKGROUND_EXPAND is cancelled below.\r\n    */\r\n   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&\r\n       (png_ptr->transformations & PNG_EXPAND))\r\n   {\r\n      {\r\n         png_ptr->background.red   =\r\n             png_ptr->palette[png_ptr->background.index].red;\r\n         png_ptr->background.green =\r\n             png_ptr->palette[png_ptr->background.index].green;\r\n         png_ptr->background.blue  =\r\n             png_ptr->palette[png_ptr->background.index].blue;\r\n\r\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\r\n        if (png_ptr->transformations & PNG_INVERT_ALPHA)\r\n        {\r\n           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))\r\n           {\r\n              /* Invert the alpha channel (in tRNS) unless the pixels are\r\n               * going to be expanded, in which case leave it for later\r\n               */\r\n              int i, istop = png_ptr->num_trans;\r\n\r\n              for (i=0; i<istop; i++)\r\n                 png_ptr->trans_alpha[i] = (png_byte)(255 -\r\n                    png_ptr->trans_alpha[i]);\r\n           }\r\n        }\r\n#endif /* PNG_READ_INVERT_ALPHA_SUPPORTED */\r\n      }\r\n   } /* background expand and (therefore) no alpha association. */\r\n#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */\r\n}\r\n\r\nstatic void /* PRIVATE */\r\npng_init_rgb_transformations(png_structrp png_ptr)\r\n{\r\n   /* Added to libpng-1.5.4: check the color type to determine whether there\r\n    * is any alpha or transparency in the image and simply cancel the\r\n    * background and alpha mode stuff if there isn't.\r\n    */\r\n   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;\r\n   int input_has_transparency = png_ptr->num_trans > 0;\r\n\r\n   /* If no alpha we can optimize. */\r\n   if (!input_has_alpha)\r\n   {\r\n      /* Any alpha means background and associative alpha processing is\r\n       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA\r\n       * and ENCODE_ALPHA are irrelevant.\r\n       */\r\n#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED\r\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n#     endif\r\n\r\n      if (!input_has_transparency)\r\n         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);\r\n   }\r\n\r\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\r\n   /* png_set_background handling - deals with the complexity of whether the\r\n    * background color is in the file format or the screen format in the case\r\n    * where an 'expand' will happen.\r\n    */\r\n\r\n   /* The following code cannot be entered in the alpha pre-multiplication case\r\n    * because PNG_BACKGROUND_EXPAND is cancelled below.\r\n    */\r\n   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&\r\n       (png_ptr->transformations & PNG_EXPAND) &&\r\n       !(png_ptr->color_type & PNG_COLOR_MASK_COLOR))\r\n       /* i.e., GRAY or GRAY_ALPHA */\r\n   {\r\n      {\r\n         /* Expand background and tRNS chunks */\r\n         int gray = png_ptr->background.gray;\r\n         int trans_gray = png_ptr->trans_color.gray;\r\n\r\n         switch (png_ptr->bit_depth)\r\n         {\r\n            case 1:\r\n               gray *= 0xff;\r\n               trans_gray *= 0xff;\r\n               break;\r\n\r\n            case 2:\r\n               gray *= 0x55;\r\n               trans_gray *= 0x55;\r\n               break;\r\n\r\n            case 4:\r\n               gray *= 0x11;\r\n               trans_gray *= 0x11;\r\n               break;\r\n\r\n            default:\r\n\r\n            case 8:\r\n               /* FALL THROUGH (Already 8 bits) */\r\n\r\n            case 16:\r\n               /* Already a full 16 bits */\r\n               break;\r\n         }\r\n\r\n         png_ptr->background.red = png_ptr->background.green =\r\n            png_ptr->background.blue = (png_uint_16)gray;\r\n\r\n         if (!(png_ptr->transformations & PNG_EXPAND_tRNS))\r\n         {\r\n            png_ptr->trans_color.red = png_ptr->trans_color.green =\r\n               png_ptr->trans_color.blue = (png_uint_16)trans_gray;\r\n         }\r\n      }\r\n   } /* background expand and (therefore) no alpha association. */\r\n#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_init_read_transformations(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_init_read_transformations\");\r\n\r\n   /* This internal function is called from png_read_start_row in pngrutil.c\r\n    * and it is called before the 'rowbytes' calculation is done, so the code\r\n    * in here can change or update the transformations flags.\r\n    *\r\n    * First do updates that do not depend on the details of the PNG image data\r\n    * being processed.\r\n    */\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds\r\n    * png_set_alpha_mode and this is another source for a default file gamma so\r\n    * the test needs to be performed later - here.  In addition prior to 1.5.4\r\n    * the tests were repeated for the PALETTE color type here - this is no\r\n    * longer necessary (and doesn't seem to have been necessary before.)\r\n    */\r\n   {\r\n      /* The following temporary indicates if overall gamma correction is\r\n       * required.\r\n       */\r\n      int gamma_correction = 0;\r\n\r\n      if (png_ptr->colorspace.gamma != 0) /* has been set */\r\n      {\r\n         if (png_ptr->screen_gamma != 0) /* screen set too */\r\n            gamma_correction = png_gamma_threshold(png_ptr->colorspace.gamma,\r\n               png_ptr->screen_gamma);\r\n\r\n         else\r\n            /* Assume the output matches the input; a long time default behavior\r\n             * of libpng, although the standard has nothing to say about this.\r\n             */\r\n            png_ptr->screen_gamma = png_reciprocal(png_ptr->colorspace.gamma);\r\n      }\r\n\r\n      else if (png_ptr->screen_gamma != 0)\r\n         /* The converse - assume the file matches the screen, note that this\r\n          * perhaps undesireable default can (from 1.5.4) be changed by calling\r\n          * png_set_alpha_mode (even if the alpha handling mode isn't required\r\n          * or isn't changed from the default.)\r\n          */\r\n         png_ptr->colorspace.gamma = png_reciprocal(png_ptr->screen_gamma);\r\n\r\n      else /* neither are set */\r\n         /* Just in case the following prevents any processing - file and screen\r\n          * are both assumed to be linear and there is no way to introduce a\r\n          * third gamma value other than png_set_background with 'UNIQUE', and,\r\n          * prior to 1.5.4\r\n          */\r\n         png_ptr->screen_gamma = png_ptr->colorspace.gamma = PNG_FP_1;\r\n\r\n      /* We have a gamma value now. */\r\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\r\n\r\n      /* Now turn the gamma transformation on or off as appropriate.  Notice\r\n       * that PNG_GAMMA just refers to the file->screen correction.  Alpha\r\n       * composition may independently cause gamma correction because it needs\r\n       * linear data (e.g. if the file has a gAMA chunk but the screen gamma\r\n       * hasn't been specified.)  In any case this flag may get turned off in\r\n       * the code immediately below if the transform can be handled outside the\r\n       * row loop.\r\n       */\r\n      if (gamma_correction)\r\n         png_ptr->transformations |= PNG_GAMMA;\r\n\r\n      else\r\n         png_ptr->transformations &= ~PNG_GAMMA;\r\n   }\r\n#endif\r\n\r\n   /* Certain transformations have the effect of preventing other\r\n    * transformations that happen afterward in png_do_read_transformations,\r\n    * resolve the interdependencies here.  From the code of\r\n    * png_do_read_transformations the order is:\r\n    *\r\n    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)\r\n    *  2) PNG_STRIP_ALPHA (if no compose)\r\n    *  3) PNG_RGB_TO_GRAY\r\n    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY\r\n    *  5) PNG_COMPOSE\r\n    *  6) PNG_GAMMA\r\n    *  7) PNG_STRIP_ALPHA (if compose)\r\n    *  8) PNG_ENCODE_ALPHA\r\n    *  9) PNG_SCALE_16_TO_8\r\n    * 10) PNG_16_TO_8\r\n    * 11) PNG_QUANTIZE (converts to palette)\r\n    * 12) PNG_EXPAND_16\r\n    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY\r\n    * 14) PNG_INVERT_MONO\r\n    * 15) PNG_INVERT_ALPHA\r\n    * 16) PNG_SHIFT\r\n    * 17) PNG_PACK\r\n    * 18) PNG_BGR\r\n    * 19) PNG_PACKSWAP\r\n    * 20) PNG_FILLER (includes PNG_ADD_ALPHA)\r\n    * 21) PNG_SWAP_ALPHA\r\n    * 22) PNG_SWAP_BYTES\r\n    * 23) PNG_USER_TRANSFORM [must be last]\r\n    */\r\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&\r\n      !(png_ptr->transformations & PNG_COMPOSE))\r\n   {\r\n      /* Stripping the alpha channel happens immediately after the 'expand'\r\n       * transformations, before all other transformation, so it cancels out\r\n       * the alpha handling.  It has the side effect negating the effect of\r\n       * PNG_EXPAND_tRNS too:\r\n       */\r\n      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |\r\n         PNG_EXPAND_tRNS);\r\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n\r\n      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen\r\n       * so transparency information would remain just so long as it wasn't\r\n       * expanded.  This produces unexpected API changes if the set of things\r\n       * that do PNG_EXPAND_tRNS changes (perfectly possible given the\r\n       * documentation - which says ask for what you want, accept what you\r\n       * get.)  This makes the behavior consistent from 1.5.4:\r\n       */\r\n      png_ptr->num_trans = 0;\r\n   }\r\n#endif /* STRIP_ALPHA supported, no COMPOSE */\r\n\r\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\r\n   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA\r\n    * settings will have no effect.\r\n    */\r\n   if (!png_gamma_significant(png_ptr->screen_gamma))\r\n   {\r\n      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\r\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\n   /* Make sure the coefficients for the rgb to gray conversion are set\r\n    * appropriately.\r\n    */\r\n   if (png_ptr->transformations & PNG_RGB_TO_GRAY)\r\n      png_colorspace_set_rgb_coefficients(png_ptr);\r\n#endif\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\r\n   /* Detect gray background and attempt to enable optimization for\r\n    * gray --> RGB case.\r\n    *\r\n    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or\r\n    * RGB_ALPHA (in which case need_expand is superfluous anyway), the\r\n    * background color might actually be gray yet not be flagged as such.\r\n    * This is not a problem for the current code, which uses\r\n    * PNG_BACKGROUND_IS_GRAY only to decide when to do the\r\n    * png_do_gray_to_rgb() transformation.\r\n    *\r\n    * TODO: this code needs to be revised to avoid the complexity and\r\n    * interdependencies.  The color type of the background should be recorded in\r\n    * png_set_background, along with the bit depth, then the code has a record\r\n    * of exactly what color space the background is currently in.\r\n    */\r\n   if (png_ptr->transformations & PNG_BACKGROUND_EXPAND)\r\n   {\r\n      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if\r\n       * the file was grayscale the background value is gray.\r\n       */\r\n      if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR))\r\n         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;\r\n   }\r\n\r\n   else if (png_ptr->transformations & PNG_COMPOSE)\r\n   {\r\n      /* PNG_COMPOSE: png_set_background was called with need_expand false,\r\n       * so the color is in the color space of the output or png_set_alpha_mode\r\n       * was called and the color is black.  Ignore RGB_TO_GRAY because that\r\n       * happens before GRAY_TO_RGB.\r\n       */\r\n      if (png_ptr->transformations & PNG_GRAY_TO_RGB)\r\n      {\r\n         if (png_ptr->background.red == png_ptr->background.green &&\r\n             png_ptr->background.red == png_ptr->background.blue)\r\n         {\r\n            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;\r\n            png_ptr->background.gray = png_ptr->background.red;\r\n         }\r\n      }\r\n   }\r\n#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */\r\n#endif /* PNG_READ_GRAY_TO_RGB_SUPPORTED */\r\n\r\n   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations\r\n    * can be performed directly on the palette, and some (such as rgb to gray)\r\n    * can be optimized inside the palette.  This is particularly true of the\r\n    * composite (background and alpha) stuff, which can be pretty much all done\r\n    * in the palette even if the result is expanded to RGB or gray afterward.\r\n    *\r\n    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and\r\n    * earlier and the palette stuff is actually handled on the first row.  This\r\n    * leads to the reported bug that the palette returned by png_get_PLTE is not\r\n    * updated.\r\n    */\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      png_init_palette_transformations(png_ptr);\r\n\r\n   else\r\n      png_init_rgb_transformations(png_ptr);\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \\\r\n   defined(PNG_READ_EXPAND_16_SUPPORTED)\r\n   if ((png_ptr->transformations & PNG_EXPAND_16) &&\r\n      (png_ptr->transformations & PNG_COMPOSE) &&\r\n      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&\r\n      png_ptr->bit_depth != 16)\r\n   {\r\n      /* TODO: fix this.  Because the expand_16 operation is after the compose\r\n       * handling the background color must be 8, not 16, bits deep, but the\r\n       * application will supply a 16-bit value so reduce it here.\r\n       *\r\n       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at\r\n       * present, so that case is ok (until do_expand_16 is moved.)\r\n       *\r\n       * NOTE: this discards the low 16 bits of the user supplied background\r\n       * color, but until expand_16 works properly there is no choice!\r\n       */\r\n#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))\r\n      CHOP(png_ptr->background.red);\r\n      CHOP(png_ptr->background.green);\r\n      CHOP(png_ptr->background.blue);\r\n      CHOP(png_ptr->background.gray);\r\n#     undef CHOP\r\n   }\r\n#endif /* PNG_READ_BACKGROUND_SUPPORTED && PNG_READ_EXPAND_16_SUPPORTED */\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \\\r\n   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \\\r\n   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))\r\n   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) &&\r\n      (png_ptr->transformations & PNG_COMPOSE) &&\r\n      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&\r\n      png_ptr->bit_depth == 16)\r\n   {\r\n      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per\r\n       * component this will also happen after PNG_COMPOSE and so the background\r\n       * color must be pre-expanded here.\r\n       *\r\n       * TODO: fix this too.\r\n       */\r\n      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);\r\n      png_ptr->background.green =\r\n         (png_uint_16)(png_ptr->background.green * 257);\r\n      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);\r\n      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);\r\n   }\r\n#endif\r\n\r\n   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the\r\n    * background support (see the comments in scripts/pnglibconf.dfa), this\r\n    * allows pre-multiplication of the alpha channel to be implemented as\r\n    * compositing on black.  This is probably sub-optimal and has been done in\r\n    * 1.5.4 betas simply to enable external critique and testing (i.e. to\r\n    * implement the new API quickly, without lots of internal changes.)\r\n    */\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\r\n      /* Includes ALPHA_MODE */\r\n      png_ptr->background_1 = png_ptr->background;\r\n#  endif\r\n\r\n   /* This needs to change - in the palette image case a whole set of tables are\r\n    * built when it would be quicker to just calculate the correct value for\r\n    * each palette entry directly.  Also, the test is too tricky - why check\r\n    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that\r\n    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the\r\n    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction\r\n    * the gamma tables will not be built even if composition is required on a\r\n    * gamma encoded value.\r\n    *\r\n    * In 1.5.4 this is addressed below by an additional check on the individual\r\n    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the\r\n    * tables.\r\n    */\r\n   if ((png_ptr->transformations & PNG_GAMMA)\r\n      || ((png_ptr->transformations & PNG_RGB_TO_GRAY)\r\n         && (png_gamma_significant(png_ptr->colorspace.gamma) ||\r\n            png_gamma_significant(png_ptr->screen_gamma)))\r\n      || ((png_ptr->transformations & PNG_COMPOSE)\r\n         && (png_gamma_significant(png_ptr->colorspace.gamma)\r\n            || png_gamma_significant(png_ptr->screen_gamma)\r\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\r\n            || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE\r\n               && png_gamma_significant(png_ptr->background_gamma))\r\n#  endif\r\n      )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA)\r\n         && png_gamma_significant(png_ptr->screen_gamma))\r\n      )\r\n   {\r\n      png_build_gamma_table(png_ptr, png_ptr->bit_depth);\r\n\r\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\r\n      if (png_ptr->transformations & PNG_COMPOSE)\r\n      {\r\n         /* Issue a warning about this combination: because RGB_TO_GRAY is\r\n          * optimized to do the gamma transform if present yet do_background has\r\n          * to do the same thing if both options are set a\r\n          * double-gamma-correction happens.  This is true in all versions of\r\n          * libpng to date.\r\n          */\r\n         if (png_ptr->transformations & PNG_RGB_TO_GRAY)\r\n            png_warning(png_ptr,\r\n               \"libpng does not support gamma+background+rgb_to_gray\");\r\n\r\n         if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n         {\r\n            /* We don't get to here unless there is a tRNS chunk with non-opaque\r\n             * entries - see the checking code at the start of this function.\r\n             */\r\n            png_color back, back_1;\r\n            png_colorp palette = png_ptr->palette;\r\n            int num_palette = png_ptr->num_palette;\r\n            int i;\r\n            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)\r\n            {\r\n\r\n               back.red = png_ptr->gamma_table[png_ptr->background.red];\r\n               back.green = png_ptr->gamma_table[png_ptr->background.green];\r\n               back.blue = png_ptr->gamma_table[png_ptr->background.blue];\r\n\r\n               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];\r\n               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];\r\n               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];\r\n            }\r\n            else\r\n            {\r\n               png_fixed_point g, gs;\r\n\r\n               switch (png_ptr->background_gamma_type)\r\n               {\r\n                  case PNG_BACKGROUND_GAMMA_SCREEN:\r\n                     g = (png_ptr->screen_gamma);\r\n                     gs = PNG_FP_1;\r\n                     break;\r\n\r\n                  case PNG_BACKGROUND_GAMMA_FILE:\r\n                     g = png_reciprocal(png_ptr->colorspace.gamma);\r\n                     gs = png_reciprocal2(png_ptr->colorspace.gamma,\r\n                        png_ptr->screen_gamma);\r\n                     break;\r\n\r\n                  case PNG_BACKGROUND_GAMMA_UNIQUE:\r\n                     g = png_reciprocal(png_ptr->background_gamma);\r\n                     gs = png_reciprocal2(png_ptr->background_gamma,\r\n                        png_ptr->screen_gamma);\r\n                     break;\r\n                  default:\r\n                     g = PNG_FP_1;    /* back_1 */\r\n                     gs = PNG_FP_1;   /* back */\r\n                     break;\r\n               }\r\n\r\n               if (png_gamma_significant(gs))\r\n               {\r\n                  back.red = png_gamma_8bit_correct(png_ptr->background.red,\r\n                      gs);\r\n                  back.green = png_gamma_8bit_correct(png_ptr->background.green,\r\n                      gs);\r\n                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,\r\n                      gs);\r\n               }\r\n\r\n               else\r\n               {\r\n                  back.red   = (png_byte)png_ptr->background.red;\r\n                  back.green = (png_byte)png_ptr->background.green;\r\n                  back.blue  = (png_byte)png_ptr->background.blue;\r\n               }\r\n\r\n               if (png_gamma_significant(g))\r\n               {\r\n                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,\r\n                     g);\r\n                  back_1.green = png_gamma_8bit_correct(\r\n                     png_ptr->background.green, g);\r\n                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,\r\n                     g);\r\n               }\r\n\r\n               else\r\n               {\r\n                  back_1.red   = (png_byte)png_ptr->background.red;\r\n                  back_1.green = (png_byte)png_ptr->background.green;\r\n                  back_1.blue  = (png_byte)png_ptr->background.blue;\r\n               }\r\n            }\r\n\r\n            for (i = 0; i < num_palette; i++)\r\n            {\r\n               if (i < (int)png_ptr->num_trans &&\r\n                   png_ptr->trans_alpha[i] != 0xff)\r\n               {\r\n                  if (png_ptr->trans_alpha[i] == 0)\r\n                  {\r\n                     palette[i] = back;\r\n                  }\r\n                  else /* if (png_ptr->trans_alpha[i] != 0xff) */\r\n                  {\r\n                     png_byte v, w;\r\n\r\n                     v = png_ptr->gamma_to_1[palette[i].red];\r\n                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);\r\n                     palette[i].red = png_ptr->gamma_from_1[w];\r\n\r\n                     v = png_ptr->gamma_to_1[palette[i].green];\r\n                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);\r\n                     palette[i].green = png_ptr->gamma_from_1[w];\r\n\r\n                     v = png_ptr->gamma_to_1[palette[i].blue];\r\n                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);\r\n                     palette[i].blue = png_ptr->gamma_from_1[w];\r\n                  }\r\n               }\r\n               else\r\n               {\r\n                  palette[i].red = png_ptr->gamma_table[palette[i].red];\r\n                  palette[i].green = png_ptr->gamma_table[palette[i].green];\r\n                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];\r\n               }\r\n            }\r\n\r\n            /* Prevent the transformations being done again.\r\n             *\r\n             * NOTE: this is highly dubious; it removes the transformations in\r\n             * place.  This seems inconsistent with the general treatment of the\r\n             * transformations elsewhere.\r\n             */\r\n            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);\r\n         } /* color_type == PNG_COLOR_TYPE_PALETTE */\r\n\r\n         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */\r\n         else /* color_type != PNG_COLOR_TYPE_PALETTE */\r\n         {\r\n            int gs_sig, g_sig;\r\n            png_fixed_point g = PNG_FP_1;  /* Correction to linear */\r\n            png_fixed_point gs = PNG_FP_1; /* Correction to screen */\r\n\r\n            switch (png_ptr->background_gamma_type)\r\n            {\r\n               case PNG_BACKGROUND_GAMMA_SCREEN:\r\n                  g = png_ptr->screen_gamma;\r\n                  /* gs = PNG_FP_1; */\r\n                  break;\r\n\r\n               case PNG_BACKGROUND_GAMMA_FILE:\r\n                  g = png_reciprocal(png_ptr->colorspace.gamma);\r\n                  gs = png_reciprocal2(png_ptr->colorspace.gamma,\r\n                     png_ptr->screen_gamma);\r\n                  break;\r\n\r\n               case PNG_BACKGROUND_GAMMA_UNIQUE:\r\n                  g = png_reciprocal(png_ptr->background_gamma);\r\n                  gs = png_reciprocal2(png_ptr->background_gamma,\r\n                      png_ptr->screen_gamma);\r\n                  break;\r\n\r\n               default:\r\n                  png_error(png_ptr, \"invalid background gamma type\");\r\n            }\r\n\r\n            g_sig = png_gamma_significant(g);\r\n            gs_sig = png_gamma_significant(gs);\r\n\r\n            if (g_sig)\r\n               png_ptr->background_1.gray = png_gamma_correct(png_ptr,\r\n                   png_ptr->background.gray, g);\r\n\r\n            if (gs_sig)\r\n               png_ptr->background.gray = png_gamma_correct(png_ptr,\r\n                   png_ptr->background.gray, gs);\r\n\r\n            if ((png_ptr->background.red != png_ptr->background.green) ||\r\n                (png_ptr->background.red != png_ptr->background.blue) ||\r\n                (png_ptr->background.red != png_ptr->background.gray))\r\n            {\r\n               /* RGB or RGBA with color background */\r\n               if (g_sig)\r\n               {\r\n                  png_ptr->background_1.red = png_gamma_correct(png_ptr,\r\n                      png_ptr->background.red, g);\r\n\r\n                  png_ptr->background_1.green = png_gamma_correct(png_ptr,\r\n                      png_ptr->background.green, g);\r\n\r\n                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,\r\n                      png_ptr->background.blue, g);\r\n               }\r\n\r\n               if (gs_sig)\r\n               {\r\n                  png_ptr->background.red = png_gamma_correct(png_ptr,\r\n                      png_ptr->background.red, gs);\r\n\r\n                  png_ptr->background.green = png_gamma_correct(png_ptr,\r\n                      png_ptr->background.green, gs);\r\n\r\n                  png_ptr->background.blue = png_gamma_correct(png_ptr,\r\n                      png_ptr->background.blue, gs);\r\n               }\r\n            }\r\n\r\n            else\r\n            {\r\n               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */\r\n               png_ptr->background_1.red = png_ptr->background_1.green\r\n                   = png_ptr->background_1.blue = png_ptr->background_1.gray;\r\n\r\n               png_ptr->background.red = png_ptr->background.green\r\n                   = png_ptr->background.blue = png_ptr->background.gray;\r\n            }\r\n\r\n            /* The background is now in screen gamma: */\r\n            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;\r\n         } /* color_type != PNG_COLOR_TYPE_PALETTE */\r\n      }/* png_ptr->transformations & PNG_BACKGROUND */\r\n\r\n      else\r\n      /* Transformation does not include PNG_BACKGROUND */\r\n#endif /* PNG_READ_BACKGROUND_SUPPORTED */\r\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\n         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */\r\n         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||\r\n         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\r\n#endif\r\n         )\r\n      {\r\n         png_colorp palette = png_ptr->palette;\r\n         int num_palette = png_ptr->num_palette;\r\n         int i;\r\n\r\n         /* NOTE: there are other transformations that should probably be in\r\n          * here too.\r\n          */\r\n         for (i = 0; i < num_palette; i++)\r\n         {\r\n            palette[i].red = png_ptr->gamma_table[palette[i].red];\r\n            palette[i].green = png_ptr->gamma_table[palette[i].green];\r\n            palette[i].blue = png_ptr->gamma_table[palette[i].blue];\r\n         }\r\n\r\n         /* Done the gamma correction. */\r\n         png_ptr->transformations &= ~PNG_GAMMA;\r\n      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */\r\n   }\r\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\r\n   else\r\n#endif\r\n#endif /* PNG_READ_GAMMA_SUPPORTED */\r\n\r\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\r\n   /* No GAMMA transformation (see the hanging else 4 lines above) */\r\n   if ((png_ptr->transformations & PNG_COMPOSE) &&\r\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\r\n   {\r\n      int i;\r\n      int istop = (int)png_ptr->num_trans;\r\n      png_color back;\r\n      png_colorp palette = png_ptr->palette;\r\n\r\n      back.red   = (png_byte)png_ptr->background.red;\r\n      back.green = (png_byte)png_ptr->background.green;\r\n      back.blue  = (png_byte)png_ptr->background.blue;\r\n\r\n      for (i = 0; i < istop; i++)\r\n      {\r\n         if (png_ptr->trans_alpha[i] == 0)\r\n         {\r\n            palette[i] = back;\r\n         }\r\n\r\n         else if (png_ptr->trans_alpha[i] != 0xff)\r\n         {\r\n            /* The png_composite() macro is defined in png.h */\r\n            png_composite(palette[i].red, palette[i].red,\r\n                png_ptr->trans_alpha[i], back.red);\r\n\r\n            png_composite(palette[i].green, palette[i].green,\r\n                png_ptr->trans_alpha[i], back.green);\r\n\r\n            png_composite(palette[i].blue, palette[i].blue,\r\n                png_ptr->trans_alpha[i], back.blue);\r\n         }\r\n      }\r\n\r\n      png_ptr->transformations &= ~PNG_COMPOSE;\r\n   }\r\n#endif /* PNG_READ_BACKGROUND_SUPPORTED */\r\n\r\n#ifdef PNG_READ_SHIFT_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_SHIFT) &&\r\n      !(png_ptr->transformations & PNG_EXPAND) &&\r\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\r\n   {\r\n      int i;\r\n      int istop = png_ptr->num_palette;\r\n      int shift = 8 - png_ptr->sig_bit.red;\r\n\r\n      png_ptr->transformations &= ~PNG_SHIFT;\r\n\r\n      /* significant bits can be in the range 1 to 7 for a meaninful result, if\r\n       * the number of significant bits is 0 then no shift is done (this is an\r\n       * error condition which is silently ignored.)\r\n       */\r\n      if (shift > 0 && shift < 8)\r\n         for (i=0; i<istop; ++i)\r\n         {\r\n            int component = png_ptr->palette[i].red;\r\n\r\n            component >>= shift;\r\n            png_ptr->palette[i].red = (png_byte)component;\r\n         }\r\n\r\n      shift = 8 - png_ptr->sig_bit.green;\r\n      if (shift > 0 && shift < 8)\r\n         for (i=0; i<istop; ++i)\r\n         {\r\n            int component = png_ptr->palette[i].green;\r\n\r\n            component >>= shift;\r\n            png_ptr->palette[i].green = (png_byte)component;\r\n         }\r\n\r\n      shift = 8 - png_ptr->sig_bit.blue;\r\n      if (shift > 0 && shift < 8)\r\n         for (i=0; i<istop; ++i)\r\n         {\r\n            int component = png_ptr->palette[i].blue;\r\n\r\n            component >>= shift;\r\n            png_ptr->palette[i].blue = (png_byte)component;\r\n         }\r\n   }\r\n#endif  /* PNG_READ_SHIFT_SUPPORTED */\r\n}\r\n\r\n/* Modify the info structure to reflect the transformations.  The\r\n * info should be updated so a PNG file could be written with it,\r\n * assuming the transformations result in valid PNG data.\r\n */\r\nvoid /* PRIVATE */\r\npng_read_transform_info(png_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n   png_debug(1, \"in png_read_transform_info\");\r\n\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n   if (png_ptr->transformations & PNG_EXPAND)\r\n   {\r\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      {\r\n         /* This check must match what actually happens in\r\n          * png_do_expand_palette; if it ever checks the tRNS chunk to see if\r\n          * it is all opaque we must do the same (at present it does not.)\r\n          */\r\n         if (png_ptr->num_trans > 0)\r\n            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;\r\n\r\n         else\r\n            info_ptr->color_type = PNG_COLOR_TYPE_RGB;\r\n\r\n         info_ptr->bit_depth = 8;\r\n         info_ptr->num_trans = 0;\r\n\r\n         if (png_ptr->palette == NULL)\r\n            png_error (png_ptr, \"Palette is NULL in indexed image\");\r\n      }\r\n      else\r\n      {\r\n         if (png_ptr->num_trans)\r\n         {\r\n            if (png_ptr->transformations & PNG_EXPAND_tRNS)\r\n               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;\r\n         }\r\n         if (info_ptr->bit_depth < 8)\r\n            info_ptr->bit_depth = 8;\r\n\r\n         info_ptr->num_trans = 0;\r\n      }\r\n   }\r\n#endif\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\r\n   /* The following is almost certainly wrong unless the background value is in\r\n    * the screen space!\r\n    */\r\n   if (png_ptr->transformations & PNG_COMPOSE)\r\n      info_ptr->background = png_ptr->background;\r\n#endif\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),\r\n    * however it seems that the code in png_init_read_transformations, which has\r\n    * been called before this from png_read_update_info->png_read_start_row\r\n    * sometimes does the gamma transform and cancels the flag.\r\n    *\r\n    * TODO: this looks wrong; the info_ptr should end up with a gamma equal to\r\n    * the screen_gamma value.  The following probably results in weirdness if\r\n    * the info_ptr is used by the app after the rows have been read.\r\n    */\r\n   info_ptr->colorspace.gamma = png_ptr->colorspace.gamma;\r\n#endif\r\n\r\n   if (info_ptr->bit_depth == 16)\r\n   {\r\n#  ifdef PNG_READ_16BIT_SUPPORTED\r\n#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\r\n         if (png_ptr->transformations & PNG_SCALE_16_TO_8)\r\n            info_ptr->bit_depth = 8;\r\n#     endif\r\n\r\n#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\r\n         if (png_ptr->transformations & PNG_16_TO_8)\r\n            info_ptr->bit_depth = 8;\r\n#     endif\r\n\r\n#  else\r\n      /* No 16 bit support: force chopping 16-bit input down to 8, in this case\r\n       * the app program can chose if both APIs are available by setting the\r\n       * correct scaling to use.\r\n       */\r\n#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\r\n         /* For compatibility with previous versions use the strip method by\r\n          * default.  This code works because if PNG_SCALE_16_TO_8 is already\r\n          * set the code below will do that in preference to the chop.\r\n          */\r\n         png_ptr->transformations |= PNG_16_TO_8;\r\n         info_ptr->bit_depth = 8;\r\n#     else\r\n\r\n#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\r\n            png_ptr->transformations |= PNG_SCALE_16_TO_8;\r\n            info_ptr->bit_depth = 8;\r\n#        else\r\n\r\n            CONFIGURATION ERROR: you must enable at least one 16 to 8 method\r\n#        endif\r\n#    endif\r\n#endif /* !READ_16BIT_SUPPORTED */\r\n   }\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n   if (png_ptr->transformations & PNG_GRAY_TO_RGB)\r\n      info_ptr->color_type = (png_byte)(info_ptr->color_type |\r\n         PNG_COLOR_MASK_COLOR);\r\n#endif\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\n   if (png_ptr->transformations & PNG_RGB_TO_GRAY)\r\n      info_ptr->color_type = (png_byte)(info_ptr->color_type &\r\n         ~PNG_COLOR_MASK_COLOR);\r\n#endif\r\n\r\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\r\n   if (png_ptr->transformations & PNG_QUANTIZE)\r\n   {\r\n      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||\r\n          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&\r\n          png_ptr->palette_lookup && info_ptr->bit_depth == 8)\r\n      {\r\n         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\r\n   if (png_ptr->transformations & PNG_EXPAND_16 && info_ptr->bit_depth == 8 &&\r\n      info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      info_ptr->bit_depth = 16;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_PACK_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))\r\n      info_ptr->bit_depth = 8;\r\n#endif\r\n\r\n   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      info_ptr->channels = 1;\r\n\r\n   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n      info_ptr->channels = 3;\r\n\r\n   else\r\n      info_ptr->channels = 1;\r\n\r\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\r\n   if (png_ptr->transformations & PNG_STRIP_ALPHA)\r\n   {\r\n      info_ptr->color_type = (png_byte)(info_ptr->color_type &\r\n         ~PNG_COLOR_MASK_ALPHA);\r\n      info_ptr->num_trans = 0;\r\n   }\r\n#endif\r\n\r\n   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)\r\n      info_ptr->channels++;\r\n\r\n#ifdef PNG_READ_FILLER_SUPPORTED\r\n   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */\r\n   if ((png_ptr->transformations & PNG_FILLER) &&\r\n       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||\r\n       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))\r\n   {\r\n      info_ptr->channels++;\r\n      /* If adding a true alpha channel not just filler */\r\n      if (png_ptr->transformations & PNG_ADD_ALPHA)\r\n         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;\r\n   }\r\n#endif\r\n\r\n#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \\\r\ndefined(PNG_READ_USER_TRANSFORM_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_USER_TRANSFORM)\r\n   {\r\n      if (info_ptr->bit_depth < png_ptr->user_transform_depth)\r\n         info_ptr->bit_depth = png_ptr->user_transform_depth;\r\n\r\n      if (info_ptr->channels < png_ptr->user_transform_channels)\r\n         info_ptr->channels = png_ptr->user_transform_channels;\r\n   }\r\n#endif\r\n\r\n   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *\r\n       info_ptr->bit_depth);\r\n\r\n   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);\r\n\r\n   /* Adding in 1.5.4: cache the above value in png_struct so that we can later\r\n    * check in png_rowbytes that the user buffer won't get overwritten.  Note\r\n    * that the field is not always set - if png_read_update_info isn't called\r\n    * the application has to either not do any transforms or get the calculation\r\n    * right itself.\r\n    */\r\n   png_ptr->info_rowbytes = info_ptr->rowbytes;\r\n\r\n#ifndef PNG_READ_EXPAND_SUPPORTED\r\n   if (png_ptr)\r\n      return;\r\n#endif\r\n}\r\n\r\n#ifdef PNG_READ_PACK_SUPPORTED\r\n/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,\r\n * without changing the actual values.  Thus, if you had a row with\r\n * a bit depth of 1, you would end up with bytes that only contained\r\n * the numbers 0 or 1.  If you would rather they contain 0 and 255, use\r\n * png_do_shift() after this.\r\n */\r\nstatic void\r\npng_do_unpack(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_unpack\");\r\n\r\n   if (row_info->bit_depth < 8)\r\n   {\r\n      png_uint_32 i;\r\n      png_uint_32 row_width=row_info->width;\r\n\r\n      switch (row_info->bit_depth)\r\n      {\r\n         case 1:\r\n         {\r\n            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);\r\n            png_bytep dp = row + (png_size_t)row_width - 1;\r\n            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *dp = (png_byte)((*sp >> shift) & 0x01);\r\n\r\n               if (shift == 7)\r\n               {\r\n                  shift = 0;\r\n                  sp--;\r\n               }\r\n\r\n               else\r\n                  shift++;\r\n\r\n               dp--;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case 2:\r\n         {\r\n\r\n            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);\r\n            png_bytep dp = row + (png_size_t)row_width - 1;\r\n            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *dp = (png_byte)((*sp >> shift) & 0x03);\r\n\r\n               if (shift == 6)\r\n               {\r\n                  shift = 0;\r\n                  sp--;\r\n               }\r\n\r\n               else\r\n                  shift += 2;\r\n\r\n               dp--;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case 4:\r\n         {\r\n            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);\r\n            png_bytep dp = row + (png_size_t)row_width - 1;\r\n            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *dp = (png_byte)((*sp >> shift) & 0x0f);\r\n\r\n               if (shift == 4)\r\n               {\r\n                  shift = 0;\r\n                  sp--;\r\n               }\r\n\r\n               else\r\n                  shift = 4;\r\n\r\n               dp--;\r\n            }\r\n            break;\r\n         }\r\n\r\n         default:\r\n            break;\r\n      }\r\n      row_info->bit_depth = 8;\r\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\r\n      row_info->rowbytes = row_width * row_info->channels;\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_SHIFT_SUPPORTED\r\n/* Reverse the effects of png_do_shift.  This routine merely shifts the\r\n * pixels back to their significant bits values.  Thus, if you have\r\n * a row of bit depth 8, but only 5 are significant, this will shift\r\n * the values back to 0 through 31.\r\n */\r\nstatic void\r\npng_do_unshift(png_row_infop row_info, png_bytep row,\r\n    png_const_color_8p sig_bits)\r\n{\r\n   int color_type;\r\n\r\n   png_debug(1, \"in png_do_unshift\");\r\n\r\n   /* The palette case has already been handled in the _init routine. */\r\n   color_type = row_info->color_type;\r\n\r\n   if (color_type != PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      int shift[4];\r\n      int channels = 0;\r\n      int bit_depth = row_info->bit_depth;\r\n\r\n      if (color_type & PNG_COLOR_MASK_COLOR)\r\n      {\r\n         shift[channels++] = bit_depth - sig_bits->red;\r\n         shift[channels++] = bit_depth - sig_bits->green;\r\n         shift[channels++] = bit_depth - sig_bits->blue;\r\n      }\r\n\r\n      else\r\n      {\r\n         shift[channels++] = bit_depth - sig_bits->gray;\r\n      }\r\n\r\n      if (color_type & PNG_COLOR_MASK_ALPHA)\r\n      {\r\n         shift[channels++] = bit_depth - sig_bits->alpha;\r\n      }\r\n\r\n      {\r\n         int c, have_shift;\r\n\r\n         for (c = have_shift = 0; c < channels; ++c)\r\n         {\r\n            /* A shift of more than the bit depth is an error condition but it\r\n             * gets ignored here.\r\n             */\r\n            if (shift[c] <= 0 || shift[c] >= bit_depth)\r\n               shift[c] = 0;\r\n\r\n            else\r\n               have_shift = 1;\r\n         }\r\n\r\n         if (!have_shift)\r\n            return;\r\n      }\r\n\r\n      switch (bit_depth)\r\n      {\r\n         default:\r\n         /* Must be 1bpp gray: should not be here! */\r\n            /* NOTREACHED */\r\n            break;\r\n\r\n         case 2:\r\n         /* Must be 2bpp gray */\r\n         /* assert(channels == 1 && shift[0] == 1) */\r\n         {\r\n            png_bytep bp = row;\r\n            png_bytep bp_end = bp + row_info->rowbytes;\r\n\r\n            while (bp < bp_end)\r\n            {\r\n               int b = (*bp >> 1) & 0x55;\r\n               *bp++ = (png_byte)b;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case 4:\r\n         /* Must be 4bpp gray */\r\n         /* assert(channels == 1) */\r\n         {\r\n            png_bytep bp = row;\r\n            png_bytep bp_end = bp + row_info->rowbytes;\r\n            int gray_shift = shift[0];\r\n            int mask =  0xf >> gray_shift;\r\n\r\n            mask |= mask << 4;\r\n\r\n            while (bp < bp_end)\r\n            {\r\n               int b = (*bp >> gray_shift) & mask;\r\n               *bp++ = (png_byte)b;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case 8:\r\n         /* Single byte components, G, GA, RGB, RGBA */\r\n         {\r\n            png_bytep bp = row;\r\n            png_bytep bp_end = bp + row_info->rowbytes;\r\n            int channel = 0;\r\n\r\n            while (bp < bp_end)\r\n            {\r\n               int b = *bp >> shift[channel];\r\n               if (++channel >= channels)\r\n                  channel = 0;\r\n               *bp++ = (png_byte)b;\r\n            }\r\n            break;\r\n         }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n         case 16:\r\n         /* Double byte components, G, GA, RGB, RGBA */\r\n         {\r\n            png_bytep bp = row;\r\n            png_bytep bp_end = bp + row_info->rowbytes;\r\n            int channel = 0;\r\n\r\n            while (bp < bp_end)\r\n            {\r\n               int value = (bp[0] << 8) + bp[1];\r\n\r\n               value >>= shift[channel];\r\n               if (++channel >= channels)\r\n                  channel = 0;\r\n               *bp++ = (png_byte)(value >> 8);\r\n               *bp++ = (png_byte)(value & 0xff);\r\n            }\r\n            break;\r\n         }\r\n#endif\r\n      }\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\r\n/* Scale rows of bit depth 16 down to 8 accurately */\r\nstatic void\r\npng_do_scale_16_to_8(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_scale_16_to_8\");\r\n\r\n   if (row_info->bit_depth == 16)\r\n   {\r\n      png_bytep sp = row; /* source */\r\n      png_bytep dp = row; /* destination */\r\n      png_bytep ep = sp + row_info->rowbytes; /* end+1 */\r\n\r\n      while (sp < ep)\r\n      {\r\n         /* The input is an array of 16 bit components, these must be scaled to\r\n          * 8 bits each.  For a 16 bit value V the required value (from the PNG\r\n          * specification) is:\r\n          *\r\n          *    (V * 255) / 65535\r\n          *\r\n          * This reduces to round(V / 257), or floor((V + 128.5)/257)\r\n          *\r\n          * Represent V as the two byte value vhi.vlo.  Make a guess that the\r\n          * result is the top byte of V, vhi, then the correction to this value\r\n          * is:\r\n          *\r\n          *    error = floor(((V-vhi.vhi) + 128.5) / 257)\r\n          *          = floor(((vlo-vhi) + 128.5) / 257)\r\n          *\r\n          * This can be approximated using integer arithmetic (and a signed\r\n          * shift):\r\n          *\r\n          *    error = (vlo-vhi+128) >> 8;\r\n          *\r\n          * The approximate differs from the exact answer only when (vlo-vhi) is\r\n          * 128; it then gives a correction of +1 when the exact correction is\r\n          * 0.  This gives 128 errors.  The exact answer (correct for all 16 bit\r\n          * input values) is:\r\n          *\r\n          *    error = (vlo-vhi+128)*65535 >> 24;\r\n          *\r\n          * An alternative arithmetic calculation which also gives no errors is:\r\n          *\r\n          *    (V * 255 + 32895) >> 16\r\n          */\r\n\r\n         png_int_32 tmp = *sp++; /* must be signed! */\r\n         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;\r\n         *dp++ = (png_byte)tmp;\r\n      }\r\n\r\n      row_info->bit_depth = 8;\r\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\r\n      row_info->rowbytes = row_info->width * row_info->channels;\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\r\nstatic void\r\n/* Simply discard the low byte.  This was the default behavior prior\r\n * to libpng-1.5.4.\r\n */\r\npng_do_chop(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_chop\");\r\n\r\n   if (row_info->bit_depth == 16)\r\n   {\r\n      png_bytep sp = row; /* source */\r\n      png_bytep dp = row; /* destination */\r\n      png_bytep ep = sp + row_info->rowbytes; /* end+1 */\r\n\r\n      while (sp < ep)\r\n      {\r\n         *dp++ = *sp;\r\n         sp += 2; /* skip low byte */\r\n      }\r\n\r\n      row_info->bit_depth = 8;\r\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\r\n      row_info->rowbytes = row_info->width * row_info->channels;\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\r\nstatic void\r\npng_do_read_swap_alpha(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_read_swap_alpha\");\r\n\r\n   {\r\n      png_uint_32 row_width = row_info->width;\r\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n      {\r\n         /* This converts from RGBA to ARGB */\r\n         if (row_info->bit_depth == 8)\r\n         {\r\n            png_bytep sp = row + row_info->rowbytes;\r\n            png_bytep dp = sp;\r\n            png_byte save;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               save = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = save;\r\n            }\r\n         }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n         /* This converts from RRGGBBAA to AARRGGBB */\r\n         else\r\n         {\r\n            png_bytep sp = row + row_info->rowbytes;\r\n            png_bytep dp = sp;\r\n            png_byte save[2];\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               save[0] = *(--sp);\r\n               save[1] = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = save[0];\r\n               *(--dp) = save[1];\r\n            }\r\n         }\r\n#endif\r\n      }\r\n\r\n      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\n      {\r\n         /* This converts from GA to AG */\r\n         if (row_info->bit_depth == 8)\r\n         {\r\n            png_bytep sp = row + row_info->rowbytes;\r\n            png_bytep dp = sp;\r\n            png_byte save;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               save = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = save;\r\n            }\r\n         }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n         /* This converts from GGAA to AAGG */\r\n         else\r\n         {\r\n            png_bytep sp = row + row_info->rowbytes;\r\n            png_bytep dp = sp;\r\n            png_byte save[2];\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               save[0] = *(--sp);\r\n               save[1] = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = save[0];\r\n               *(--dp) = save[1];\r\n            }\r\n         }\r\n#endif\r\n      }\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\r\nstatic void\r\npng_do_read_invert_alpha(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_uint_32 row_width;\r\n   png_debug(1, \"in png_do_read_invert_alpha\");\r\n\r\n   row_width = row_info->width;\r\n   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         /* This inverts the alpha channel in RGBA */\r\n         png_bytep sp = row + row_info->rowbytes;\r\n         png_bytep dp = sp;\r\n         png_uint_32 i;\r\n\r\n         for (i = 0; i < row_width; i++)\r\n         {\r\n            *(--dp) = (png_byte)(255 - *(--sp));\r\n\r\n/*          This does nothing:\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            We can replace it with:\r\n*/\r\n            sp-=3;\r\n            dp=sp;\r\n         }\r\n      }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n      /* This inverts the alpha channel in RRGGBBAA */\r\n      else\r\n      {\r\n         png_bytep sp = row + row_info->rowbytes;\r\n         png_bytep dp = sp;\r\n         png_uint_32 i;\r\n\r\n         for (i = 0; i < row_width; i++)\r\n         {\r\n            *(--dp) = (png_byte)(255 - *(--sp));\r\n            *(--dp) = (png_byte)(255 - *(--sp));\r\n\r\n/*          This does nothing:\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n            We can replace it with:\r\n*/\r\n            sp-=6;\r\n            dp=sp;\r\n         }\r\n      }\r\n#endif\r\n   }\r\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         /* This inverts the alpha channel in GA */\r\n         png_bytep sp = row + row_info->rowbytes;\r\n         png_bytep dp = sp;\r\n         png_uint_32 i;\r\n\r\n         for (i = 0; i < row_width; i++)\r\n         {\r\n            *(--dp) = (png_byte)(255 - *(--sp));\r\n            *(--dp) = *(--sp);\r\n         }\r\n      }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n      else\r\n      {\r\n         /* This inverts the alpha channel in GGAA */\r\n         png_bytep sp  = row + row_info->rowbytes;\r\n         png_bytep dp = sp;\r\n         png_uint_32 i;\r\n\r\n         for (i = 0; i < row_width; i++)\r\n         {\r\n            *(--dp) = (png_byte)(255 - *(--sp));\r\n            *(--dp) = (png_byte)(255 - *(--sp));\r\n/*\r\n            *(--dp) = *(--sp);\r\n            *(--dp) = *(--sp);\r\n*/\r\n            sp-=2;\r\n            dp=sp;\r\n         }\r\n      }\r\n#endif\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_FILLER_SUPPORTED\r\n/* Add filler channel if we have RGB color */\r\nstatic void\r\npng_do_read_filler(png_row_infop row_info, png_bytep row,\r\n    png_uint_32 filler, png_uint_32 flags)\r\n{\r\n   png_uint_32 i;\r\n   png_uint_32 row_width = row_info->width;\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);\r\n#endif\r\n   png_byte lo_filler = (png_byte)(filler & 0xff);\r\n\r\n   png_debug(1, \"in png_do_read_filler\");\r\n\r\n   if (\r\n       row_info->color_type == PNG_COLOR_TYPE_GRAY)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         if (flags & PNG_FLAG_FILLER_AFTER)\r\n         {\r\n            /* This changes the data from G to GX */\r\n            png_bytep sp = row + (png_size_t)row_width;\r\n            png_bytep dp =  sp + (png_size_t)row_width;\r\n            for (i = 1; i < row_width; i++)\r\n            {\r\n               *(--dp) = lo_filler;\r\n               *(--dp) = *(--sp);\r\n            }\r\n            *(--dp) = lo_filler;\r\n            row_info->channels = 2;\r\n            row_info->pixel_depth = 16;\r\n            row_info->rowbytes = row_width * 2;\r\n         }\r\n\r\n         else\r\n         {\r\n            /* This changes the data from G to XG */\r\n            png_bytep sp = row + (png_size_t)row_width;\r\n            png_bytep dp = sp  + (png_size_t)row_width;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = lo_filler;\r\n            }\r\n            row_info->channels = 2;\r\n            row_info->pixel_depth = 16;\r\n            row_info->rowbytes = row_width * 2;\r\n         }\r\n      }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         if (flags & PNG_FLAG_FILLER_AFTER)\r\n         {\r\n            /* This changes the data from GG to GGXX */\r\n            png_bytep sp = row + (png_size_t)row_width * 2;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\r\n            for (i = 1; i < row_width; i++)\r\n            {\r\n               *(--dp) = hi_filler;\r\n               *(--dp) = lo_filler;\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n            }\r\n            *(--dp) = hi_filler;\r\n            *(--dp) = lo_filler;\r\n            row_info->channels = 2;\r\n            row_info->pixel_depth = 32;\r\n            row_info->rowbytes = row_width * 4;\r\n         }\r\n\r\n         else\r\n         {\r\n            /* This changes the data from GG to XXGG */\r\n            png_bytep sp = row + (png_size_t)row_width * 2;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = hi_filler;\r\n               *(--dp) = lo_filler;\r\n            }\r\n            row_info->channels = 2;\r\n            row_info->pixel_depth = 32;\r\n            row_info->rowbytes = row_width * 4;\r\n         }\r\n      }\r\n#endif\r\n   } /* COLOR_TYPE == GRAY */\r\n   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         if (flags & PNG_FLAG_FILLER_AFTER)\r\n         {\r\n            /* This changes the data from RGB to RGBX */\r\n            png_bytep sp = row + (png_size_t)row_width * 3;\r\n            png_bytep dp = sp  + (png_size_t)row_width;\r\n            for (i = 1; i < row_width; i++)\r\n            {\r\n               *(--dp) = lo_filler;\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n            }\r\n            *(--dp) = lo_filler;\r\n            row_info->channels = 4;\r\n            row_info->pixel_depth = 32;\r\n            row_info->rowbytes = row_width * 4;\r\n         }\r\n\r\n         else\r\n         {\r\n            /* This changes the data from RGB to XRGB */\r\n            png_bytep sp = row + (png_size_t)row_width * 3;\r\n            png_bytep dp = sp + (png_size_t)row_width;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = lo_filler;\r\n            }\r\n            row_info->channels = 4;\r\n            row_info->pixel_depth = 32;\r\n            row_info->rowbytes = row_width * 4;\r\n         }\r\n      }\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         if (flags & PNG_FLAG_FILLER_AFTER)\r\n         {\r\n            /* This changes the data from RRGGBB to RRGGBBXX */\r\n            png_bytep sp = row + (png_size_t)row_width * 6;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\r\n            for (i = 1; i < row_width; i++)\r\n            {\r\n               *(--dp) = hi_filler;\r\n               *(--dp) = lo_filler;\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n            }\r\n            *(--dp) = hi_filler;\r\n            *(--dp) = lo_filler;\r\n            row_info->channels = 4;\r\n            row_info->pixel_depth = 64;\r\n            row_info->rowbytes = row_width * 8;\r\n         }\r\n\r\n         else\r\n         {\r\n            /* This changes the data from RRGGBB to XXRRGGBB */\r\n            png_bytep sp = row + (png_size_t)row_width * 6;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = *(--sp);\r\n               *(--dp) = hi_filler;\r\n               *(--dp) = lo_filler;\r\n            }\r\n\r\n            row_info->channels = 4;\r\n            row_info->pixel_depth = 64;\r\n            row_info->rowbytes = row_width * 8;\r\n         }\r\n      }\r\n#endif\r\n   } /* COLOR_TYPE == RGB */\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n/* Expand grayscale files to RGB, with or without alpha */\r\nstatic void\r\npng_do_gray_to_rgb(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_uint_32 i;\r\n   png_uint_32 row_width = row_info->width;\r\n\r\n   png_debug(1, \"in png_do_gray_to_rgb\");\r\n\r\n   if (row_info->bit_depth >= 8 &&\r\n       !(row_info->color_type & PNG_COLOR_MASK_COLOR))\r\n   {\r\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\r\n      {\r\n         if (row_info->bit_depth == 8)\r\n         {\r\n            /* This changes G to RGB */\r\n            png_bytep sp = row + (png_size_t)row_width - 1;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(dp--) = *sp;\r\n               *(dp--) = *sp;\r\n               *(dp--) = *(sp--);\r\n            }\r\n         }\r\n\r\n         else\r\n         {\r\n            /* This changes GG to RRGGBB */\r\n            png_bytep sp = row + (png_size_t)row_width * 2 - 1;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 4;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(dp--) = *sp;\r\n               *(dp--) = *(sp - 1);\r\n               *(dp--) = *sp;\r\n               *(dp--) = *(sp - 1);\r\n               *(dp--) = *(sp--);\r\n               *(dp--) = *(sp--);\r\n            }\r\n         }\r\n      }\r\n\r\n      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\n      {\r\n         if (row_info->bit_depth == 8)\r\n         {\r\n            /* This changes GA to RGBA */\r\n            png_bytep sp = row + (png_size_t)row_width * 2 - 1;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 2;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(dp--) = *(sp--);\r\n               *(dp--) = *sp;\r\n               *(dp--) = *sp;\r\n               *(dp--) = *(sp--);\r\n            }\r\n         }\r\n\r\n         else\r\n         {\r\n            /* This changes GGAA to RRGGBBAA */\r\n            png_bytep sp = row + (png_size_t)row_width * 4 - 1;\r\n            png_bytep dp = sp  + (png_size_t)row_width * 4;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               *(dp--) = *(sp--);\r\n               *(dp--) = *(sp--);\r\n               *(dp--) = *sp;\r\n               *(dp--) = *(sp - 1);\r\n               *(dp--) = *sp;\r\n               *(dp--) = *(sp - 1);\r\n               *(dp--) = *(sp--);\r\n               *(dp--) = *(sp--);\r\n            }\r\n         }\r\n      }\r\n      row_info->channels = (png_byte)(row_info->channels + 2);\r\n      row_info->color_type |= PNG_COLOR_MASK_COLOR;\r\n      row_info->pixel_depth = (png_byte)(row_info->channels *\r\n          row_info->bit_depth);\r\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\n/* Reduce RGB files to grayscale, with or without alpha\r\n * using the equation given in Poynton's ColorFAQ of 1998-01-04 at\r\n * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but\r\n * versions dated 1998 through November 2002 have been archived at\r\n * http://web.archive.org/web/20000816232553/http://www.inforamp.net/\r\n * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )\r\n * Charles Poynton poynton at poynton.com\r\n *\r\n *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B\r\n *\r\n *  which can be expressed with integers as\r\n *\r\n *     Y = (6969 * R + 23434 * G + 2365 * B)/32768\r\n *\r\n * Poynton's current link (as of January 2003 through July 2011):\r\n * <http://www.poynton.com/notes/colour_and_gamma/>\r\n * has changed the numbers slightly:\r\n *\r\n *     Y = 0.2126*R + 0.7152*G + 0.0722*B\r\n *\r\n *  which can be expressed with integers as\r\n *\r\n *     Y = (6966 * R + 23436 * G + 2366 * B)/32768\r\n *\r\n *  Historically, however, libpng uses numbers derived from the ITU-R Rec 709\r\n *  end point chromaticities and the D65 white point.  Depending on the\r\n *  precision used for the D65 white point this produces a variety of different\r\n *  numbers, however if the four decimal place value used in ITU-R Rec 709 is\r\n *  used (0.3127,0.3290) the Y calculation would be:\r\n *\r\n *     Y = (6968 * R + 23435 * G + 2366 * B)/32768\r\n *\r\n *  While this is correct the rounding results in an overflow for white, because\r\n *  the sum of the rounded coefficients is 32769, not 32768.  Consequently\r\n *  libpng uses, instead, the closest non-overflowing approximation:\r\n *\r\n *     Y = (6968 * R + 23434 * G + 2366 * B)/32768\r\n *\r\n *  Starting with libpng-1.5.5, if the image being converted has a cHRM chunk\r\n *  (including an sRGB chunk) then the chromaticities are used to calculate the\r\n *  coefficients.  See the chunk handling in pngrutil.c for more information.\r\n *\r\n *  In all cases the calculation is to be done in a linear colorspace.  If no\r\n *  gamma information is available to correct the encoding of the original RGB\r\n *  values this results in an implicit assumption that the original PNG RGB\r\n *  values were linear.\r\n *\r\n *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because\r\n *  the API takes just red and green coefficients the blue coefficient is\r\n *  calculated to make the sum 32768.  This will result in different rounding\r\n *  to that used above.\r\n */\r\nstatic int\r\npng_do_rgb_to_gray(png_structrp png_ptr, png_row_infop row_info, png_bytep row)\r\n\r\n{\r\n   int rgb_error = 0;\r\n\r\n   png_debug(1, \"in png_do_rgb_to_gray\");\r\n\r\n   if (!(row_info->color_type & PNG_COLOR_MASK_PALETTE) &&\r\n       (row_info->color_type & PNG_COLOR_MASK_COLOR))\r\n   {\r\n      PNG_CONST png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;\r\n      PNG_CONST png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;\r\n      PNG_CONST png_uint_32 bc = 32768 - rc - gc;\r\n      PNG_CONST png_uint_32 row_width = row_info->width;\r\n      PNG_CONST int have_alpha =\r\n         (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;\r\n\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n         /* Notice that gamma to/from 1 are not necessarily inverses (if\r\n          * there is an overall gamma correction).  Prior to 1.5.5 this code\r\n          * checked the linearized values for equality; this doesn't match\r\n          * the documentation, the original values must be checked.\r\n          */\r\n         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\r\n         {\r\n            png_bytep sp = row;\r\n            png_bytep dp = row;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               png_byte red   = *(sp++);\r\n               png_byte green = *(sp++);\r\n               png_byte blue  = *(sp++);\r\n\r\n               if (red != green || red != blue)\r\n               {\r\n                  red = png_ptr->gamma_to_1[red];\r\n                  green = png_ptr->gamma_to_1[green];\r\n                  blue = png_ptr->gamma_to_1[blue];\r\n\r\n                  rgb_error |= 1;\r\n                  *(dp++) = png_ptr->gamma_from_1[\r\n                      (rc*red + gc*green + bc*blue + 16384)>>15];\r\n               }\r\n\r\n               else\r\n               {\r\n                  /* If there is no overall correction the table will not be\r\n                   * set.\r\n                   */\r\n                  if (png_ptr->gamma_table != NULL)\r\n                     red = png_ptr->gamma_table[red];\r\n\r\n                  *(dp++) = red;\r\n               }\r\n\r\n               if (have_alpha)\r\n                  *(dp++) = *(sp++);\r\n            }\r\n         }\r\n         else\r\n#endif\r\n         {\r\n            png_bytep sp = row;\r\n            png_bytep dp = row;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               png_byte red   = *(sp++);\r\n               png_byte green = *(sp++);\r\n               png_byte blue  = *(sp++);\r\n\r\n               if (red != green || red != blue)\r\n               {\r\n                  rgb_error |= 1;\r\n                  /* NOTE: this is the historical approach which simply\r\n                   * truncates the results.\r\n                   */\r\n                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);\r\n               }\r\n\r\n               else\r\n                  *(dp++) = red;\r\n\r\n               if (have_alpha)\r\n                  *(dp++) = *(sp++);\r\n            }\r\n         }\r\n      }\r\n\r\n      else /* RGB bit_depth == 16 */\r\n      {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)\r\n         {\r\n            png_bytep sp = row;\r\n            png_bytep dp = row;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               png_uint_16 red, green, blue, w;\r\n\r\n               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\r\n               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\r\n               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\r\n\r\n               if (red == green && red == blue)\r\n               {\r\n                  if (png_ptr->gamma_16_table != NULL)\r\n                     w = png_ptr->gamma_16_table[(red&0xff)\r\n                         >> png_ptr->gamma_shift][red>>8];\r\n\r\n                  else\r\n                     w = red;\r\n               }\r\n\r\n               else\r\n               {\r\n                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)\r\n                      >> png_ptr->gamma_shift][red>>8];\r\n                  png_uint_16 green_1 =\r\n                      png_ptr->gamma_16_to_1[(green&0xff) >>\r\n                      png_ptr->gamma_shift][green>>8];\r\n                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)\r\n                      >> png_ptr->gamma_shift][blue>>8];\r\n                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1\r\n                      + bc*blue_1 + 16384)>>15);\r\n                  w = png_ptr->gamma_16_from_1[(gray16&0xff) >>\r\n                      png_ptr->gamma_shift][gray16 >> 8];\r\n                  rgb_error |= 1;\r\n               }\r\n\r\n               *(dp++) = (png_byte)((w>>8) & 0xff);\r\n               *(dp++) = (png_byte)(w & 0xff);\r\n\r\n               if (have_alpha)\r\n               {\r\n                  *(dp++) = *(sp++);\r\n                  *(dp++) = *(sp++);\r\n               }\r\n            }\r\n         }\r\n         else\r\n#endif\r\n         {\r\n            png_bytep sp = row;\r\n            png_bytep dp = row;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               png_uint_16 red, green, blue, gray16;\r\n\r\n               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\r\n               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\r\n               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;\r\n\r\n               if (red != green || red != blue)\r\n                  rgb_error |= 1;\r\n\r\n               /* From 1.5.5 in the 16 bit case do the accurate conversion even\r\n                * in the 'fast' case - this is because this is where the code\r\n                * ends up when handling linear 16 bit data.\r\n                */\r\n               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>\r\n                  15);\r\n               *(dp++) = (png_byte)((gray16>>8) & 0xff);\r\n               *(dp++) = (png_byte)(gray16 & 0xff);\r\n\r\n               if (have_alpha)\r\n               {\r\n                  *(dp++) = *(sp++);\r\n                  *(dp++) = *(sp++);\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      row_info->channels = (png_byte)(row_info->channels - 2);\r\n      row_info->color_type = (png_byte)(row_info->color_type &\r\n          ~PNG_COLOR_MASK_COLOR);\r\n      row_info->pixel_depth = (png_byte)(row_info->channels *\r\n          row_info->bit_depth);\r\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\r\n   }\r\n   return rgb_error;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\r\n/* Replace any alpha or transparency with the supplied background color.\r\n * \"background\" is already in the screen gamma, while \"background_1\" is\r\n * at a gamma of 1.0.  Paletted files have already been taken care of.\r\n */\r\nstatic void\r\npng_do_compose(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\r\n{\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n   png_const_bytep gamma_table = png_ptr->gamma_table;\r\n   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;\r\n   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;\r\n   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;\r\n   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;\r\n   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;\r\n   int gamma_shift = png_ptr->gamma_shift;\r\n   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;\r\n#endif\r\n\r\n   png_bytep sp;\r\n   png_uint_32 i;\r\n   png_uint_32 row_width = row_info->width;\r\n   int shift;\r\n\r\n   png_debug(1, \"in png_do_compose\");\r\n\r\n   {\r\n      switch (row_info->color_type)\r\n      {\r\n         case PNG_COLOR_TYPE_GRAY:\r\n         {\r\n            switch (row_info->bit_depth)\r\n            {\r\n               case 1:\r\n               {\r\n                  sp = row;\r\n                  shift = 7;\r\n                  for (i = 0; i < row_width; i++)\r\n                  {\r\n                     if ((png_uint_16)((*sp >> shift) & 0x01)\r\n                        == png_ptr->trans_color.gray)\r\n                     {\r\n                        unsigned int tmp = *sp & (0x7f7f >> (7 - shift));\r\n                        tmp |= png_ptr->background.gray << shift;\r\n                        *sp = (png_byte)(tmp & 0xff);\r\n                     }\r\n\r\n                     if (!shift)\r\n                     {\r\n                        shift = 7;\r\n                        sp++;\r\n                     }\r\n\r\n                     else\r\n                        shift--;\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               case 2:\r\n               {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n                  if (gamma_table != NULL)\r\n                  {\r\n                     sp = row;\r\n                     shift = 6;\r\n                     for (i = 0; i < row_width; i++)\r\n                     {\r\n                        if ((png_uint_16)((*sp >> shift) & 0x03)\r\n                            == png_ptr->trans_color.gray)\r\n                        {\r\n                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\r\n                           tmp |= png_ptr->background.gray << shift;\r\n                           *sp = (png_byte)(tmp & 0xff);\r\n                        }\r\n\r\n                        else\r\n                        {\r\n                           unsigned int p = (*sp >> shift) & 0x03;\r\n                           unsigned int g = (gamma_table [p | (p << 2) |\r\n                               (p << 4) | (p << 6)] >> 6) & 0x03;\r\n                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\r\n                           tmp |= g << shift;\r\n                           *sp = (png_byte)(tmp & 0xff);\r\n                        }\r\n\r\n                        if (!shift)\r\n                        {\r\n                           shift = 6;\r\n                           sp++;\r\n                        }\r\n\r\n                        else\r\n                           shift -= 2;\r\n                     }\r\n                  }\r\n\r\n                  else\r\n#endif\r\n                  {\r\n                     sp = row;\r\n                     shift = 6;\r\n                     for (i = 0; i < row_width; i++)\r\n                     {\r\n                        if ((png_uint_16)((*sp >> shift) & 0x03)\r\n                            == png_ptr->trans_color.gray)\r\n                        {\r\n                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\r\n                           tmp |= png_ptr->background.gray << shift;\r\n                           *sp = (png_byte)(tmp & 0xff);\r\n                        }\r\n\r\n                        if (!shift)\r\n                        {\r\n                           shift = 6;\r\n                           sp++;\r\n                        }\r\n\r\n                        else\r\n                           shift -= 2;\r\n                     }\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               case 4:\r\n               {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n                  if (gamma_table != NULL)\r\n                  {\r\n                     sp = row;\r\n                     shift = 4;\r\n                     for (i = 0; i < row_width; i++)\r\n                     {\r\n                        if ((png_uint_16)((*sp >> shift) & 0x0f)\r\n                            == png_ptr->trans_color.gray)\r\n                        {\r\n                           unsigned int tmp = *sp & (0xf0f >> (4 - shift));\r\n                           tmp |= png_ptr->background.gray << shift;\r\n                           *sp = (png_byte)(tmp & 0xff);\r\n                        }\r\n\r\n                        else\r\n                        {\r\n                           unsigned int p = (*sp >> shift) & 0x0f;\r\n                           unsigned int g = (gamma_table[p | (p << 4)] >> 4) &\r\n                              0x0f;\r\n                           unsigned int tmp = *sp & (0xf0f >> (4 - shift));\r\n                           tmp |= g << shift;\r\n                           *sp = (png_byte)(tmp & 0xff);\r\n                        }\r\n\r\n                        if (!shift)\r\n                        {\r\n                           shift = 4;\r\n                           sp++;\r\n                        }\r\n\r\n                        else\r\n                           shift -= 4;\r\n                     }\r\n                  }\r\n\r\n                  else\r\n#endif\r\n                  {\r\n                     sp = row;\r\n                     shift = 4;\r\n                     for (i = 0; i < row_width; i++)\r\n                     {\r\n                        if ((png_uint_16)((*sp >> shift) & 0x0f)\r\n                            == png_ptr->trans_color.gray)\r\n                        {\r\n                           unsigned int tmp = *sp & (0xf0f >> (4 - shift));\r\n                           tmp |= png_ptr->background.gray << shift;\r\n                           *sp = (png_byte)(tmp & 0xff);\r\n                        }\r\n\r\n                        if (!shift)\r\n                        {\r\n                           shift = 4;\r\n                           sp++;\r\n                        }\r\n\r\n                        else\r\n                           shift -= 4;\r\n                     }\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               case 8:\r\n               {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n                  if (gamma_table != NULL)\r\n                  {\r\n                     sp = row;\r\n                     for (i = 0; i < row_width; i++, sp++)\r\n                     {\r\n                        if (*sp == png_ptr->trans_color.gray)\r\n                           *sp = (png_byte)png_ptr->background.gray;\r\n\r\n                        else\r\n                           *sp = gamma_table[*sp];\r\n                     }\r\n                  }\r\n                  else\r\n#endif\r\n                  {\r\n                     sp = row;\r\n                     for (i = 0; i < row_width; i++, sp++)\r\n                     {\r\n                        if (*sp == png_ptr->trans_color.gray)\r\n                           *sp = (png_byte)png_ptr->background.gray;\r\n                     }\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               case 16:\r\n               {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n                  if (gamma_16 != NULL)\r\n                  {\r\n                     sp = row;\r\n                     for (i = 0; i < row_width; i++, sp += 2)\r\n                     {\r\n                        png_uint_16 v;\r\n\r\n                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));\r\n\r\n                        if (v == png_ptr->trans_color.gray)\r\n                        {\r\n                           /* Background is already in screen gamma */\r\n                           *sp = (png_byte)((png_ptr->background.gray >> 8)\r\n                                & 0xff);\r\n                           *(sp + 1) = (png_byte)(png_ptr->background.gray\r\n                                & 0xff);\r\n                        }\r\n\r\n                        else\r\n                        {\r\n                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\r\n                           *sp = (png_byte)((v >> 8) & 0xff);\r\n                           *(sp + 1) = (png_byte)(v & 0xff);\r\n                        }\r\n                     }\r\n                  }\r\n                  else\r\n#endif\r\n                  {\r\n                     sp = row;\r\n                     for (i = 0; i < row_width; i++, sp += 2)\r\n                     {\r\n                        png_uint_16 v;\r\n\r\n                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));\r\n\r\n                        if (v == png_ptr->trans_color.gray)\r\n                        {\r\n                           *sp = (png_byte)((png_ptr->background.gray >> 8)\r\n                                & 0xff);\r\n                           *(sp + 1) = (png_byte)(png_ptr->background.gray\r\n                                & 0xff);\r\n                        }\r\n                     }\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               default:\r\n                  break;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case PNG_COLOR_TYPE_RGB:\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n               if (gamma_table != NULL)\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 3)\r\n                  {\r\n                     if (*sp == png_ptr->trans_color.red &&\r\n                         *(sp + 1) == png_ptr->trans_color.green &&\r\n                         *(sp + 2) == png_ptr->trans_color.blue)\r\n                     {\r\n                        *sp = (png_byte)png_ptr->background.red;\r\n                        *(sp + 1) = (png_byte)png_ptr->background.green;\r\n                        *(sp + 2) = (png_byte)png_ptr->background.blue;\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        *sp = gamma_table[*sp];\r\n                        *(sp + 1) = gamma_table[*(sp + 1)];\r\n                        *(sp + 2) = gamma_table[*(sp + 2)];\r\n                     }\r\n                  }\r\n               }\r\n               else\r\n#endif\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 3)\r\n                  {\r\n                     if (*sp == png_ptr->trans_color.red &&\r\n                         *(sp + 1) == png_ptr->trans_color.green &&\r\n                         *(sp + 2) == png_ptr->trans_color.blue)\r\n                     {\r\n                        *sp = (png_byte)png_ptr->background.red;\r\n                        *(sp + 1) = (png_byte)png_ptr->background.green;\r\n                        *(sp + 2) = (png_byte)png_ptr->background.blue;\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n            else /* if (row_info->bit_depth == 16) */\r\n            {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n               if (gamma_16 != NULL)\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 6)\r\n                  {\r\n                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\r\n\r\n                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\r\n                         + *(sp + 3));\r\n\r\n                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\r\n                         + *(sp + 5));\r\n\r\n                     if (r == png_ptr->trans_color.red &&\r\n                         g == png_ptr->trans_color.green &&\r\n                         b == png_ptr->trans_color.blue)\r\n                     {\r\n                        /* Background is already in screen gamma */\r\n                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\r\n                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\r\n                                & 0xff);\r\n                        *(sp + 3) = (png_byte)(png_ptr->background.green\r\n                                & 0xff);\r\n                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\r\n                                & 0xff);\r\n                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\r\n                        *sp = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(v & 0xff);\r\n\r\n                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];\r\n                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 3) = (png_byte)(v & 0xff);\r\n\r\n                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];\r\n                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 5) = (png_byte)(v & 0xff);\r\n                     }\r\n                  }\r\n               }\r\n\r\n               else\r\n#endif\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 6)\r\n                  {\r\n                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\r\n\r\n                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\r\n                         + *(sp + 3));\r\n\r\n                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\r\n                         + *(sp + 5));\r\n\r\n                     if (r == png_ptr->trans_color.red &&\r\n                         g == png_ptr->trans_color.green &&\r\n                         b == png_ptr->trans_color.blue)\r\n                     {\r\n                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\r\n                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\r\n                                & 0xff);\r\n                        *(sp + 3) = (png_byte)(png_ptr->background.green\r\n                                & 0xff);\r\n                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\r\n                                & 0xff);\r\n                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case PNG_COLOR_TYPE_GRAY_ALPHA:\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&\r\n                   gamma_table != NULL)\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 2)\r\n                  {\r\n                     png_uint_16 a = *(sp + 1);\r\n\r\n                     if (a == 0xff)\r\n                        *sp = gamma_table[*sp];\r\n\r\n                     else if (a == 0)\r\n                     {\r\n                        /* Background is already in screen gamma */\r\n                        *sp = (png_byte)png_ptr->background.gray;\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        png_byte v, w;\r\n\r\n                        v = gamma_to_1[*sp];\r\n                        png_composite(w, v, a, png_ptr->background_1.gray);\r\n                        if (!optimize)\r\n                           w = gamma_from_1[w];\r\n                        *sp = w;\r\n                     }\r\n                  }\r\n               }\r\n               else\r\n#endif\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 2)\r\n                  {\r\n                     png_byte a = *(sp + 1);\r\n\r\n                     if (a == 0)\r\n                        *sp = (png_byte)png_ptr->background.gray;\r\n\r\n                     else if (a < 0xff)\r\n                        png_composite(*sp, *sp, a, png_ptr->background.gray);\r\n                  }\r\n               }\r\n            }\r\n            else /* if (png_ptr->bit_depth == 16) */\r\n            {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&\r\n                   gamma_16_to_1 != NULL)\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 4)\r\n                  {\r\n                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)\r\n                         + *(sp + 3));\r\n\r\n                     if (a == (png_uint_16)0xffff)\r\n                     {\r\n                        png_uint_16 v;\r\n\r\n                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\r\n                        *sp = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(v & 0xff);\r\n                     }\r\n\r\n                     else if (a == 0)\r\n                     {\r\n                        /* Background is already in screen gamma */\r\n                        *sp = (png_byte)((png_ptr->background.gray >> 8)\r\n                                & 0xff);\r\n                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        png_uint_16 g, v, w;\r\n\r\n                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];\r\n                        png_composite_16(v, g, a, png_ptr->background_1.gray);\r\n                        if (optimize)\r\n                           w = v;\r\n                        else\r\n                           w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];\r\n                        *sp = (png_byte)((w >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(w & 0xff);\r\n                     }\r\n                  }\r\n               }\r\n               else\r\n#endif\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 4)\r\n                  {\r\n                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)\r\n                         + *(sp + 3));\r\n\r\n                     if (a == 0)\r\n                     {\r\n                        *sp = (png_byte)((png_ptr->background.gray >> 8)\r\n                                & 0xff);\r\n                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);\r\n                     }\r\n\r\n                     else if (a < 0xffff)\r\n                     {\r\n                        png_uint_16 g, v;\r\n\r\n                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));\r\n                        png_composite_16(v, g, a, png_ptr->background.gray);\r\n                        *sp = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(v & 0xff);\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case PNG_COLOR_TYPE_RGB_ALPHA:\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&\r\n                   gamma_table != NULL)\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 4)\r\n                  {\r\n                     png_byte a = *(sp + 3);\r\n\r\n                     if (a == 0xff)\r\n                     {\r\n                        *sp = gamma_table[*sp];\r\n                        *(sp + 1) = gamma_table[*(sp + 1)];\r\n                        *(sp + 2) = gamma_table[*(sp + 2)];\r\n                     }\r\n\r\n                     else if (a == 0)\r\n                     {\r\n                        /* Background is already in screen gamma */\r\n                        *sp = (png_byte)png_ptr->background.red;\r\n                        *(sp + 1) = (png_byte)png_ptr->background.green;\r\n                        *(sp + 2) = (png_byte)png_ptr->background.blue;\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        png_byte v, w;\r\n\r\n                        v = gamma_to_1[*sp];\r\n                        png_composite(w, v, a, png_ptr->background_1.red);\r\n                        if (!optimize) w = gamma_from_1[w];\r\n                        *sp = w;\r\n\r\n                        v = gamma_to_1[*(sp + 1)];\r\n                        png_composite(w, v, a, png_ptr->background_1.green);\r\n                        if (!optimize) w = gamma_from_1[w];\r\n                        *(sp + 1) = w;\r\n\r\n                        v = gamma_to_1[*(sp + 2)];\r\n                        png_composite(w, v, a, png_ptr->background_1.blue);\r\n                        if (!optimize) w = gamma_from_1[w];\r\n                        *(sp + 2) = w;\r\n                     }\r\n                  }\r\n               }\r\n               else\r\n#endif\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 4)\r\n                  {\r\n                     png_byte a = *(sp + 3);\r\n\r\n                     if (a == 0)\r\n                     {\r\n                        *sp = (png_byte)png_ptr->background.red;\r\n                        *(sp + 1) = (png_byte)png_ptr->background.green;\r\n                        *(sp + 2) = (png_byte)png_ptr->background.blue;\r\n                     }\r\n\r\n                     else if (a < 0xff)\r\n                     {\r\n                        png_composite(*sp, *sp, a, png_ptr->background.red);\r\n\r\n                        png_composite(*(sp + 1), *(sp + 1), a,\r\n                            png_ptr->background.green);\r\n\r\n                        png_composite(*(sp + 2), *(sp + 2), a,\r\n                            png_ptr->background.blue);\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n            else /* if (row_info->bit_depth == 16) */\r\n            {\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&\r\n                   gamma_16_to_1 != NULL)\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 8)\r\n                  {\r\n                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))\r\n                         << 8) + (png_uint_16)(*(sp + 7)));\r\n\r\n                     if (a == (png_uint_16)0xffff)\r\n                     {\r\n                        png_uint_16 v;\r\n\r\n                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\r\n                        *sp = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(v & 0xff);\r\n\r\n                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];\r\n                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 3) = (png_byte)(v & 0xff);\r\n\r\n                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];\r\n                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 5) = (png_byte)(v & 0xff);\r\n                     }\r\n\r\n                     else if (a == 0)\r\n                     {\r\n                        /* Background is already in screen gamma */\r\n                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\r\n                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\r\n                                & 0xff);\r\n                        *(sp + 3) = (png_byte)(png_ptr->background.green\r\n                                & 0xff);\r\n                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\r\n                                & 0xff);\r\n                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        png_uint_16 v, w;\r\n\r\n                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];\r\n                        png_composite_16(w, v, a, png_ptr->background_1.red);\r\n                        if (!optimize)\r\n                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >>\r\n                                8];\r\n                        *sp = (png_byte)((w >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(w & 0xff);\r\n\r\n                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];\r\n                        png_composite_16(w, v, a, png_ptr->background_1.green);\r\n                        if (!optimize)\r\n                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >>\r\n                                8];\r\n\r\n                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);\r\n                        *(sp + 3) = (png_byte)(w & 0xff);\r\n\r\n                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];\r\n                        png_composite_16(w, v, a, png_ptr->background_1.blue);\r\n                        if (!optimize)\r\n                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >>\r\n                                8];\r\n\r\n                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);\r\n                        *(sp + 5) = (png_byte)(w & 0xff);\r\n                     }\r\n                  }\r\n               }\r\n\r\n               else\r\n#endif\r\n               {\r\n                  sp = row;\r\n                  for (i = 0; i < row_width; i++, sp += 8)\r\n                  {\r\n                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))\r\n                         << 8) + (png_uint_16)(*(sp + 7)));\r\n\r\n                     if (a == 0)\r\n                     {\r\n                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\r\n                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\r\n                                & 0xff);\r\n                        *(sp + 3) = (png_byte)(png_ptr->background.green\r\n                                & 0xff);\r\n                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\r\n                                & 0xff);\r\n                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\r\n                     }\r\n\r\n                     else if (a < 0xffff)\r\n                     {\r\n                        png_uint_16 v;\r\n\r\n                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\r\n                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\r\n                            + *(sp + 3));\r\n                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\r\n                            + *(sp + 5));\r\n\r\n                        png_composite_16(v, r, a, png_ptr->background.red);\r\n                        *sp = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 1) = (png_byte)(v & 0xff);\r\n\r\n                        png_composite_16(v, g, a, png_ptr->background.green);\r\n                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 3) = (png_byte)(v & 0xff);\r\n\r\n                        png_composite_16(v, b, a, png_ptr->background.blue);\r\n                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);\r\n                        *(sp + 5) = (png_byte)(v & 0xff);\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         default:\r\n            break;\r\n      }\r\n   }\r\n}\r\n#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_READ_ALPHA_MODE_SUPPORTED */\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n/* Gamma correct the image, avoiding the alpha channel.  Make sure\r\n * you do this after you deal with the transparency issue on grayscale\r\n * or RGB images. If your bit depth is 8, use gamma_table, if it\r\n * is 16, use gamma_16_table and gamma_shift.  Build these with\r\n * build_gamma_table().\r\n */\r\nstatic void\r\npng_do_gamma(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\r\n{\r\n   png_const_bytep gamma_table = png_ptr->gamma_table;\r\n   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;\r\n   int gamma_shift = png_ptr->gamma_shift;\r\n\r\n   png_bytep sp;\r\n   png_uint_32 i;\r\n   png_uint_32 row_width=row_info->width;\r\n\r\n   png_debug(1, \"in png_do_gamma\");\r\n\r\n   if (((row_info->bit_depth <= 8 && gamma_table != NULL) ||\r\n       (row_info->bit_depth == 16 && gamma_16_table != NULL)))\r\n   {\r\n      switch (row_info->color_type)\r\n      {\r\n         case PNG_COLOR_TYPE_RGB:\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n               }\r\n            }\r\n\r\n            else /* if (row_info->bit_depth == 16) */\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  png_uint_16 v;\r\n\r\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 2;\r\n\r\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 2;\r\n\r\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 2;\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case PNG_COLOR_TYPE_RGB_ALPHA:\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n\r\n                  sp++;\r\n               }\r\n            }\r\n\r\n            else /* if (row_info->bit_depth == 16) */\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 2;\r\n\r\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 2;\r\n\r\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 4;\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case PNG_COLOR_TYPE_GRAY_ALPHA:\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  *sp = gamma_table[*sp];\r\n                  sp += 2;\r\n               }\r\n            }\r\n\r\n            else /* if (row_info->bit_depth == 16) */\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 4;\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case PNG_COLOR_TYPE_GRAY:\r\n         {\r\n            if (row_info->bit_depth == 2)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i += 4)\r\n               {\r\n                  int a = *sp & 0xc0;\r\n                  int b = *sp & 0x30;\r\n                  int c = *sp & 0x0c;\r\n                  int d = *sp & 0x03;\r\n\r\n                  *sp = (png_byte)(\r\n                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|\r\n                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|\r\n                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|\r\n                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));\r\n                  sp++;\r\n               }\r\n            }\r\n\r\n            if (row_info->bit_depth == 4)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i += 2)\r\n               {\r\n                  int msb = *sp & 0xf0;\r\n                  int lsb = *sp & 0x0f;\r\n\r\n                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)\r\n                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));\r\n                  sp++;\r\n               }\r\n            }\r\n\r\n            else if (row_info->bit_depth == 8)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  *sp = gamma_table[*sp];\r\n                  sp++;\r\n               }\r\n            }\r\n\r\n            else if (row_info->bit_depth == 16)\r\n            {\r\n               sp = row;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\r\n                  *sp = (png_byte)((v >> 8) & 0xff);\r\n                  *(sp + 1) = (png_byte)(v & 0xff);\r\n                  sp += 2;\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         default:\r\n            break;\r\n      }\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\r\n/* Encode the alpha channel to the output gamma (the input channel is always\r\n * linear.)  Called only with color types that have an alpha channel.  Needs the\r\n * from_1 tables.\r\n */\r\nstatic void\r\npng_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\r\n{\r\n   png_uint_32 row_width = row_info->width;\r\n\r\n   png_debug(1, \"in png_do_encode_alpha\");\r\n\r\n   if (row_info->color_type & PNG_COLOR_MASK_ALPHA)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         PNG_CONST png_bytep table = png_ptr->gamma_from_1;\r\n\r\n         if (table != NULL)\r\n         {\r\n            PNG_CONST int step =\r\n               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;\r\n\r\n            /* The alpha channel is the last component: */\r\n            row += step - 1;\r\n\r\n            for (; row_width > 0; --row_width, row += step)\r\n               *row = table[*row];\r\n\r\n            return;\r\n         }\r\n      }\r\n\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         PNG_CONST png_uint_16pp table = png_ptr->gamma_16_from_1;\r\n         PNG_CONST int gamma_shift = png_ptr->gamma_shift;\r\n\r\n         if (table != NULL)\r\n         {\r\n            PNG_CONST int step =\r\n               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;\r\n\r\n            /* The alpha channel is the last component: */\r\n            row += step - 2;\r\n\r\n            for (; row_width > 0; --row_width, row += step)\r\n            {\r\n               png_uint_16 v;\r\n\r\n               v = table[*(row + 1) >> gamma_shift][*row];\r\n               *row = (png_byte)((v >> 8) & 0xff);\r\n               *(row + 1) = (png_byte)(v & 0xff);\r\n            }\r\n\r\n            return;\r\n         }\r\n      }\r\n   }\r\n\r\n   /* Only get to here if called with a weird row_info; no harm has been done,\r\n    * so just issue a warning.\r\n    */\r\n   png_warning(png_ptr, \"png_do_encode_alpha: unexpected call\");\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n/* Expands a palette row to an RGB or RGBA row depending\r\n * upon whether you supply trans and num_trans.\r\n */\r\nstatic void\r\npng_do_expand_palette(png_row_infop row_info, png_bytep row,\r\n   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)\r\n{\r\n   int shift, value;\r\n   png_bytep sp, dp;\r\n   png_uint_32 i;\r\n   png_uint_32 row_width=row_info->width;\r\n\r\n   png_debug(1, \"in png_do_expand_palette\");\r\n\r\n   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      if (row_info->bit_depth < 8)\r\n      {\r\n         switch (row_info->bit_depth)\r\n         {\r\n            case 1:\r\n            {\r\n               sp = row + (png_size_t)((row_width - 1) >> 3);\r\n               dp = row + (png_size_t)row_width - 1;\r\n               shift = 7 - (int)((row_width + 7) & 0x07);\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  if ((*sp >> shift) & 0x01)\r\n                     *dp = 1;\r\n\r\n                  else\r\n                     *dp = 0;\r\n\r\n                  if (shift == 7)\r\n                  {\r\n                     shift = 0;\r\n                     sp--;\r\n                  }\r\n\r\n                  else\r\n                     shift++;\r\n\r\n                  dp--;\r\n               }\r\n               break;\r\n            }\r\n\r\n            case 2:\r\n            {\r\n               sp = row + (png_size_t)((row_width - 1) >> 2);\r\n               dp = row + (png_size_t)row_width - 1;\r\n               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  value = (*sp >> shift) & 0x03;\r\n                  *dp = (png_byte)value;\r\n                  if (shift == 6)\r\n                  {\r\n                     shift = 0;\r\n                     sp--;\r\n                  }\r\n\r\n                  else\r\n                     shift += 2;\r\n\r\n                  dp--;\r\n               }\r\n               break;\r\n            }\r\n\r\n            case 4:\r\n            {\r\n               sp = row + (png_size_t)((row_width - 1) >> 1);\r\n               dp = row + (png_size_t)row_width - 1;\r\n               shift = (int)((row_width & 0x01) << 2);\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  value = (*sp >> shift) & 0x0f;\r\n                  *dp = (png_byte)value;\r\n                  if (shift == 4)\r\n                  {\r\n                     shift = 0;\r\n                     sp--;\r\n                  }\r\n\r\n                  else\r\n                     shift += 4;\r\n\r\n                  dp--;\r\n               }\r\n               break;\r\n            }\r\n\r\n            default:\r\n               break;\r\n         }\r\n         row_info->bit_depth = 8;\r\n         row_info->pixel_depth = 8;\r\n         row_info->rowbytes = row_width;\r\n      }\r\n\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         {\r\n            if (num_trans > 0)\r\n            {\r\n               sp = row + (png_size_t)row_width - 1;\r\n               dp = row + (png_size_t)(row_width << 2) - 1;\r\n\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  if ((int)(*sp) >= num_trans)\r\n                     *dp-- = 0xff;\r\n\r\n                  else\r\n                     *dp-- = trans_alpha[*sp];\r\n\r\n                  *dp-- = palette[*sp].blue;\r\n                  *dp-- = palette[*sp].green;\r\n                  *dp-- = palette[*sp].red;\r\n                  sp--;\r\n               }\r\n               row_info->bit_depth = 8;\r\n               row_info->pixel_depth = 32;\r\n               row_info->rowbytes = row_width * 4;\r\n               row_info->color_type = 6;\r\n               row_info->channels = 4;\r\n            }\r\n\r\n            else\r\n            {\r\n               sp = row + (png_size_t)row_width - 1;\r\n               dp = row + (png_size_t)(row_width * 3) - 1;\r\n\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  *dp-- = palette[*sp].blue;\r\n                  *dp-- = palette[*sp].green;\r\n                  *dp-- = palette[*sp].red;\r\n                  sp--;\r\n               }\r\n\r\n               row_info->bit_depth = 8;\r\n               row_info->pixel_depth = 24;\r\n               row_info->rowbytes = row_width * 3;\r\n               row_info->color_type = 2;\r\n               row_info->channels = 3;\r\n            }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\n/* If the bit depth < 8, it is expanded to 8.  Also, if the already\r\n * expanded transparency value is supplied, an alpha channel is built.\r\n */\r\nstatic void\r\npng_do_expand(png_row_infop row_info, png_bytep row,\r\n    png_const_color_16p trans_color)\r\n{\r\n   int shift, value;\r\n   png_bytep sp, dp;\r\n   png_uint_32 i;\r\n   png_uint_32 row_width=row_info->width;\r\n\r\n   png_debug(1, \"in png_do_expand\");\r\n\r\n   {\r\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\r\n      {\r\n         unsigned int gray = trans_color ? trans_color->gray : 0;\r\n\r\n         if (row_info->bit_depth < 8)\r\n         {\r\n            switch (row_info->bit_depth)\r\n            {\r\n               case 1:\r\n               {\r\n                  gray = (gray & 0x01) * 0xff;\r\n                  sp = row + (png_size_t)((row_width - 1) >> 3);\r\n                  dp = row + (png_size_t)row_width - 1;\r\n                  shift = 7 - (int)((row_width + 7) & 0x07);\r\n                  for (i = 0; i < row_width; i++)\r\n                  {\r\n                     if ((*sp >> shift) & 0x01)\r\n                        *dp = 0xff;\r\n\r\n                     else\r\n                        *dp = 0;\r\n\r\n                     if (shift == 7)\r\n                     {\r\n                        shift = 0;\r\n                        sp--;\r\n                     }\r\n\r\n                     else\r\n                        shift++;\r\n\r\n                     dp--;\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               case 2:\r\n               {\r\n                  gray = (gray & 0x03) * 0x55;\r\n                  sp = row + (png_size_t)((row_width - 1) >> 2);\r\n                  dp = row + (png_size_t)row_width - 1;\r\n                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\r\n                  for (i = 0; i < row_width; i++)\r\n                  {\r\n                     value = (*sp >> shift) & 0x03;\r\n                     *dp = (png_byte)(value | (value << 2) | (value << 4) |\r\n                        (value << 6));\r\n                     if (shift == 6)\r\n                     {\r\n                        shift = 0;\r\n                        sp--;\r\n                     }\r\n\r\n                     else\r\n                        shift += 2;\r\n\r\n                     dp--;\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               case 4:\r\n               {\r\n                  gray = (gray & 0x0f) * 0x11;\r\n                  sp = row + (png_size_t)((row_width - 1) >> 1);\r\n                  dp = row + (png_size_t)row_width - 1;\r\n                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);\r\n                  for (i = 0; i < row_width; i++)\r\n                  {\r\n                     value = (*sp >> shift) & 0x0f;\r\n                     *dp = (png_byte)(value | (value << 4));\r\n                     if (shift == 4)\r\n                     {\r\n                        shift = 0;\r\n                        sp--;\r\n                     }\r\n\r\n                     else\r\n                        shift = 4;\r\n\r\n                     dp--;\r\n                  }\r\n                  break;\r\n               }\r\n\r\n               default:\r\n                  break;\r\n            }\r\n\r\n            row_info->bit_depth = 8;\r\n            row_info->pixel_depth = 8;\r\n            row_info->rowbytes = row_width;\r\n         }\r\n\r\n         if (trans_color != NULL)\r\n         {\r\n            if (row_info->bit_depth == 8)\r\n            {\r\n               gray = gray & 0xff;\r\n               sp = row + (png_size_t)row_width - 1;\r\n               dp = row + (png_size_t)(row_width << 1) - 1;\r\n\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  if (*sp == gray)\r\n                     *dp-- = 0;\r\n\r\n                  else\r\n                     *dp-- = 0xff;\r\n\r\n                  *dp-- = *sp--;\r\n               }\r\n            }\r\n\r\n            else if (row_info->bit_depth == 16)\r\n            {\r\n               unsigned int gray_high = (gray >> 8) & 0xff;\r\n               unsigned int gray_low = gray & 0xff;\r\n               sp = row + row_info->rowbytes - 1;\r\n               dp = row + (row_info->rowbytes << 1) - 1;\r\n               for (i = 0; i < row_width; i++)\r\n               {\r\n                  if (*(sp - 1) == gray_high && *(sp) == gray_low)\r\n                  {\r\n                     *dp-- = 0;\r\n                     *dp-- = 0;\r\n                  }\r\n\r\n                  else\r\n                  {\r\n                     *dp-- = 0xff;\r\n                     *dp-- = 0xff;\r\n                  }\r\n\r\n                  *dp-- = *sp--;\r\n                  *dp-- = *sp--;\r\n               }\r\n            }\r\n\r\n            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\r\n            row_info->channels = 2;\r\n            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);\r\n            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,\r\n               row_width);\r\n         }\r\n      }\r\n      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_color)\r\n      {\r\n         if (row_info->bit_depth == 8)\r\n         {\r\n            png_byte red = (png_byte)(trans_color->red & 0xff);\r\n            png_byte green = (png_byte)(trans_color->green & 0xff);\r\n            png_byte blue = (png_byte)(trans_color->blue & 0xff);\r\n            sp = row + (png_size_t)row_info->rowbytes - 1;\r\n            dp = row + (png_size_t)(row_width << 2) - 1;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)\r\n                  *dp-- = 0;\r\n\r\n               else\r\n                  *dp-- = 0xff;\r\n\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n            }\r\n         }\r\n         else if (row_info->bit_depth == 16)\r\n         {\r\n            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);\r\n            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);\r\n            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);\r\n            png_byte red_low = (png_byte)(trans_color->red & 0xff);\r\n            png_byte green_low = (png_byte)(trans_color->green & 0xff);\r\n            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);\r\n            sp = row + row_info->rowbytes - 1;\r\n            dp = row + (png_size_t)(row_width << 3) - 1;\r\n            for (i = 0; i < row_width; i++)\r\n            {\r\n               if (*(sp - 5) == red_high &&\r\n                   *(sp - 4) == red_low &&\r\n                   *(sp - 3) == green_high &&\r\n                   *(sp - 2) == green_low &&\r\n                   *(sp - 1) == blue_high &&\r\n                   *(sp    ) == blue_low)\r\n               {\r\n                  *dp-- = 0;\r\n                  *dp-- = 0;\r\n               }\r\n\r\n               else\r\n               {\r\n                  *dp-- = 0xff;\r\n                  *dp-- = 0xff;\r\n               }\r\n\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n               *dp-- = *sp--;\r\n            }\r\n         }\r\n         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;\r\n         row_info->channels = 4;\r\n         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);\r\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\r\n      }\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\r\n/* If the bit depth is 8 and the color type is not a palette type expand the\r\n * whole row to 16 bits.  Has no effect otherwise.\r\n */\r\nstatic void\r\npng_do_expand_16(png_row_infop row_info, png_bytep row)\r\n{\r\n   if (row_info->bit_depth == 8 &&\r\n      row_info->color_type != PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      /* The row have a sequence of bytes containing [0..255] and we need\r\n       * to turn it into another row containing [0..65535], to do this we\r\n       * calculate:\r\n       *\r\n       *  (input / 255) * 65535\r\n       *\r\n       *  Which happens to be exactly input * 257 and this can be achieved\r\n       *  simply by byte replication in place (copying backwards).\r\n       */\r\n      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */\r\n      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */\r\n      while (dp > sp)\r\n         dp[-2] = dp[-1] = *--sp, dp -= 2;\r\n\r\n      row_info->rowbytes *= 2;\r\n      row_info->bit_depth = 16;\r\n      row_info->pixel_depth = (png_byte)(row_info->channels * 16);\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\r\nstatic void\r\npng_do_quantize(png_row_infop row_info, png_bytep row,\r\n    png_const_bytep palette_lookup, png_const_bytep quantize_lookup)\r\n{\r\n   png_bytep sp, dp;\r\n   png_uint_32 i;\r\n   png_uint_32 row_width=row_info->width;\r\n\r\n   png_debug(1, \"in png_do_quantize\");\r\n\r\n   if (row_info->bit_depth == 8)\r\n   {\r\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB && palette_lookup)\r\n      {\r\n         int r, g, b, p;\r\n         sp = row;\r\n         dp = row;\r\n         for (i = 0; i < row_width; i++)\r\n         {\r\n            r = *sp++;\r\n            g = *sp++;\r\n            b = *sp++;\r\n\r\n            /* This looks real messy, but the compiler will reduce\r\n             * it down to a reasonable formula.  For example, with\r\n             * 5 bits per color, we get:\r\n             * p = (((r >> 3) & 0x1f) << 10) |\r\n             *    (((g >> 3) & 0x1f) << 5) |\r\n             *    ((b >> 3) & 0x1f);\r\n             */\r\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\r\n                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\r\n                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\r\n                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\r\n                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\r\n                (PNG_QUANTIZE_BLUE_BITS)) |\r\n                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\r\n                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\r\n\r\n            *dp++ = palette_lookup[p];\r\n         }\r\n\r\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\r\n         row_info->channels = 1;\r\n         row_info->pixel_depth = row_info->bit_depth;\r\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\r\n      }\r\n\r\n      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\r\n         palette_lookup != NULL)\r\n      {\r\n         int r, g, b, p;\r\n         sp = row;\r\n         dp = row;\r\n         for (i = 0; i < row_width; i++)\r\n         {\r\n            r = *sp++;\r\n            g = *sp++;\r\n            b = *sp++;\r\n            sp++;\r\n\r\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\r\n                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\r\n                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\r\n                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\r\n                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\r\n                (PNG_QUANTIZE_BLUE_BITS)) |\r\n                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\r\n                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\r\n\r\n            *dp++ = palette_lookup[p];\r\n         }\r\n\r\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\r\n         row_info->channels = 1;\r\n         row_info->pixel_depth = row_info->bit_depth;\r\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\r\n      }\r\n\r\n      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&\r\n         quantize_lookup)\r\n      {\r\n         sp = row;\r\n\r\n         for (i = 0; i < row_width; i++, sp++)\r\n         {\r\n            *sp = quantize_lookup[*sp];\r\n         }\r\n      }\r\n   }\r\n}\r\n#endif /* PNG_READ_QUANTIZE_SUPPORTED */\r\n\r\n/* Transform the row.  The order of transformations is significant,\r\n * and is very touchy.  If you add a transformation, take care to\r\n * decide how it fits in with the other transformations here.\r\n */\r\nvoid /* PRIVATE */\r\npng_do_read_transformations(png_structrp png_ptr, png_row_infop row_info)\r\n{\r\n   png_debug(1, \"in png_do_read_transformations\");\r\n\r\n   if (png_ptr->row_buf == NULL)\r\n   {\r\n      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this\r\n       * error is incredibly rare and incredibly easy to debug without this\r\n       * information.\r\n       */\r\n      png_error(png_ptr, \"NULL row buffer\");\r\n   }\r\n\r\n   /* The following is debugging; prior to 1.5.4 the code was never compiled in;\r\n    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro\r\n    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.6 the new flag is set only for\r\n    * all transformations, however in practice the ROW_INIT always gets done on\r\n    * demand, if necessary.\r\n    */\r\n   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&\r\n      !(png_ptr->flags & PNG_FLAG_ROW_INIT))\r\n   {\r\n      /* Application has failed to call either png_read_start_image() or\r\n       * png_read_update_info() after setting transforms that expand pixels.\r\n       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).\r\n       */\r\n      png_error(png_ptr, \"Uninitialized row\");\r\n   }\r\n\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n   if (png_ptr->transformations & PNG_EXPAND)\r\n   {\r\n      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      {\r\n         png_do_expand_palette(row_info, png_ptr->row_buf + 1,\r\n             png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);\r\n      }\r\n\r\n      else\r\n      {\r\n         if (png_ptr->num_trans &&\r\n             (png_ptr->transformations & PNG_EXPAND_tRNS))\r\n            png_do_expand(row_info, png_ptr->row_buf + 1,\r\n                &(png_ptr->trans_color));\r\n\r\n         else\r\n            png_do_expand(row_info, png_ptr->row_buf + 1,\r\n                NULL);\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&\r\n      !(png_ptr->transformations & PNG_COMPOSE) &&\r\n      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\r\n      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\r\n      png_do_strip_channel(row_info, png_ptr->row_buf + 1,\r\n         0 /* at_start == false, because SWAP_ALPHA happens later */);\r\n#endif\r\n\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\n   if (png_ptr->transformations & PNG_RGB_TO_GRAY)\r\n   {\r\n      int rgb_error =\r\n          png_do_rgb_to_gray(png_ptr, row_info,\r\n              png_ptr->row_buf + 1);\r\n\r\n      if (rgb_error)\r\n      {\r\n         png_ptr->rgb_to_gray_status=1;\r\n         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==\r\n             PNG_RGB_TO_GRAY_WARN)\r\n            png_warning(png_ptr, \"png_do_rgb_to_gray found nongray pixel\");\r\n\r\n         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==\r\n             PNG_RGB_TO_GRAY_ERR)\r\n            png_error(png_ptr, \"png_do_rgb_to_gray found nongray pixel\");\r\n      }\r\n   }\r\n#endif\r\n\r\n/* From Andreas Dilger e-mail to png-implement, 26 March 1998:\r\n *\r\n *   In most cases, the \"simple transparency\" should be done prior to doing\r\n *   gray-to-RGB, or you will have to test 3x as many bytes to check if a\r\n *   pixel is transparent.  You would also need to make sure that the\r\n *   transparency information is upgraded to RGB.\r\n *\r\n *   To summarize, the current flow is:\r\n *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite\r\n *                                   with background \"in place\" if transparent,\r\n *                                   convert to RGB if necessary\r\n *   - Gray + alpha -> composite with gray background and remove alpha bytes,\r\n *                                   convert to RGB if necessary\r\n *\r\n *   To support RGB backgrounds for gray images we need:\r\n *   - Gray + simple transparency -> convert to RGB + simple transparency,\r\n *                                   compare 3 or 6 bytes and composite with\r\n *                                   background \"in place\" if transparent\r\n *                                   (3x compare/pixel compared to doing\r\n *                                   composite with gray bkgrnd)\r\n *   - Gray + alpha -> convert to RGB + alpha, composite with background and\r\n *                                   remove alpha bytes (3x float\r\n *                                   operations/pixel compared with composite\r\n *                                   on gray background)\r\n *\r\n *  Greg's change will do this.  The reason it wasn't done before is for\r\n *  performance, as this increases the per-pixel operations.  If we would check\r\n *  in advance if the background was gray or RGB, and position the gray-to-RGB\r\n *  transform appropriately, then it would save a lot of work/time.\r\n */\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n   /* If gray -> RGB, do so now only if background is non-gray; else do later\r\n    * for performance reasons\r\n    */\r\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&\r\n       !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))\r\n      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_COMPOSE)\r\n      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);\r\n#endif\r\n\r\n#ifdef PNG_READ_GAMMA_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_GAMMA) &&\r\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\r\n      /* Because RGB_TO_GRAY does the gamma transform. */\r\n      !(png_ptr->transformations & PNG_RGB_TO_GRAY) &&\r\n#endif\r\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\r\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\r\n      /* Because PNG_COMPOSE does the gamma transform if there is something to\r\n       * do (if there is an alpha channel or transparency.)\r\n       */\r\n       !((png_ptr->transformations & PNG_COMPOSE) &&\r\n       ((png_ptr->num_trans != 0) ||\r\n       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&\r\n#endif\r\n      /* Because png_init_read_transformations transforms the palette, unless\r\n       * RGB_TO_GRAY will do the transform.\r\n       */\r\n       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))\r\n      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);\r\n#endif\r\n\r\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&\r\n      (png_ptr->transformations & PNG_COMPOSE) &&\r\n      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\r\n      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\r\n      png_do_strip_channel(row_info, png_ptr->row_buf + 1,\r\n         0 /* at_start == false, because SWAP_ALPHA happens later */);\r\n#endif\r\n\r\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) &&\r\n      (row_info->color_type & PNG_COLOR_MASK_ALPHA))\r\n      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);\r\n#endif\r\n\r\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\r\n   if (png_ptr->transformations & PNG_SCALE_16_TO_8)\r\n      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\r\n   /* There is no harm in doing both of these because only one has any effect,\r\n    * by putting the 'scale' option first if the app asks for scale (either by\r\n    * calling the API or in a TRANSFORM flag) this is what happens.\r\n    */\r\n   if (png_ptr->transformations & PNG_16_TO_8)\r\n      png_do_chop(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\r\n   if (png_ptr->transformations & PNG_QUANTIZE)\r\n   {\r\n      png_do_quantize(row_info, png_ptr->row_buf + 1,\r\n          png_ptr->palette_lookup, png_ptr->quantize_index);\r\n\r\n      if (row_info->rowbytes == 0)\r\n         png_error(png_ptr, \"png_do_quantize returned rowbytes=0\");\r\n   }\r\n#endif /* PNG_READ_QUANTIZE_SUPPORTED */\r\n\r\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\r\n   /* Do the expansion now, after all the arithmetic has been done.  Notice\r\n    * that previous transformations can handle the PNG_EXPAND_16 flag if this\r\n    * is efficient (particularly true in the case of gamma correction, where\r\n    * better accuracy results faster!)\r\n    */\r\n   if (png_ptr->transformations & PNG_EXPAND_16)\r\n      png_do_expand_16(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n   /* NOTE: moved here in 1.5.4 (from much later in this list.) */\r\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&\r\n       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))\r\n      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_INVERT_SUPPORTED\r\n   if (png_ptr->transformations & PNG_INVERT_MONO)\r\n      png_do_invert(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\r\n   if (png_ptr->transformations & PNG_INVERT_ALPHA)\r\n      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_SHIFT_SUPPORTED\r\n   if (png_ptr->transformations & PNG_SHIFT)\r\n      png_do_unshift(row_info, png_ptr->row_buf + 1,\r\n          &(png_ptr->shift));\r\n#endif\r\n\r\n#ifdef PNG_READ_PACK_SUPPORTED\r\n   if (png_ptr->transformations & PNG_PACK)\r\n      png_do_unpack(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\r\n   /* Added at libpng-1.5.10 */\r\n   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&\r\n       png_ptr->num_palette_max >= 0)\r\n      png_do_check_palette_indexes(png_ptr, row_info);\r\n#endif\r\n\r\n#ifdef PNG_READ_BGR_SUPPORTED\r\n   if (png_ptr->transformations & PNG_BGR)\r\n      png_do_bgr(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n   if (png_ptr->transformations & PNG_PACKSWAP)\r\n      png_do_packswap(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_FILLER_SUPPORTED\r\n   if (png_ptr->transformations & PNG_FILLER)\r\n      png_do_read_filler(row_info, png_ptr->row_buf + 1,\r\n          (png_uint_32)png_ptr->filler, png_ptr->flags);\r\n#endif\r\n\r\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\r\n   if (png_ptr->transformations & PNG_SWAP_ALPHA)\r\n      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n\r\n#ifdef PNG_READ_16BIT_SUPPORTED\r\n#ifdef PNG_READ_SWAP_SUPPORTED\r\n   if (png_ptr->transformations & PNG_SWAP_BYTES)\r\n      png_do_swap(row_info, png_ptr->row_buf + 1);\r\n#endif\r\n#endif\r\n\r\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\r\n   if (png_ptr->transformations & PNG_USER_TRANSFORM)\r\n    {\r\n      if (png_ptr->read_user_transform_fn != NULL)\r\n         (*(png_ptr->read_user_transform_fn)) /* User read transform function */\r\n             (png_ptr,     /* png_ptr */\r\n             row_info,     /* row_info: */\r\n                /*  png_uint_32 width;       width of row */\r\n                /*  png_size_t rowbytes;     number of bytes in row */\r\n                /*  png_byte color_type;     color type of pixels */\r\n                /*  png_byte bit_depth;      bit depth of samples */\r\n                /*  png_byte channels;       number of channels (1-4) */\r\n                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */\r\n             png_ptr->row_buf + 1);    /* start of pixel data for row */\r\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\r\n      if (png_ptr->user_transform_depth)\r\n         row_info->bit_depth = png_ptr->user_transform_depth;\r\n\r\n      if (png_ptr->user_transform_channels)\r\n         row_info->channels = png_ptr->user_transform_channels;\r\n#endif\r\n      row_info->pixel_depth = (png_byte)(row_info->bit_depth *\r\n          row_info->channels);\r\n\r\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);\r\n   }\r\n#endif\r\n}\r\n\r\n#endif /* PNG_READ_TRANSFORMS_SUPPORTED */\r\n#endif /* PNG_READ_SUPPORTED */\r\n","\r\n/* pngrutil.c - utilities to read a PNG file\r\n *\r\n * Last changed in libpng 1.6.10 [March 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * This file contains routines that are only called from within\r\n * libpng itself during the course of reading an image.\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#ifdef PNG_READ_SUPPORTED\r\n\r\npng_uint_32 PNGAPI\r\npng_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)\r\n{\r\n   png_uint_32 uval = png_get_uint_32(buf);\r\n\r\n   if (uval > PNG_UINT_31_MAX)\r\n      png_error(png_ptr, \"PNG unsigned integer out of range\");\r\n\r\n   return (uval);\r\n}\r\n\r\n#if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)\r\n/* The following is a variation on the above for use with the fixed\r\n * point values used for gAMA and cHRM.  Instead of png_error it\r\n * issues a warning and returns (-1) - an invalid value because both\r\n * gAMA and cHRM use *unsigned* integers for fixed point values.\r\n */\r\n#define PNG_FIXED_ERROR (-1)\r\n\r\nstatic png_fixed_point /* PRIVATE */\r\npng_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)\r\n{\r\n   png_uint_32 uval = png_get_uint_32(buf);\r\n\r\n   if (uval <= PNG_UINT_31_MAX)\r\n      return (png_fixed_point)uval; /* known to be in range */\r\n\r\n   /* The caller can turn off the warning by passing NULL. */\r\n   if (png_ptr != NULL)\r\n      png_warning(png_ptr, \"PNG fixed point integer out of range\");\r\n\r\n   return PNG_FIXED_ERROR;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED\r\n/* NOTE: the read macros will obscure these definitions, so that if\r\n * PNG_USE_READ_MACROS is set the library will not use them internally,\r\n * but the APIs will still be available externally.\r\n *\r\n * The parentheses around \"PNGAPI function_name\" in the following three\r\n * functions are necessary because they allow the macros to co-exist with\r\n * these (unused but exported) functions.\r\n */\r\n\r\n/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\r\npng_uint_32 (PNGAPI\r\npng_get_uint_32)(png_const_bytep buf)\r\n{\r\n   png_uint_32 uval =\r\n       ((png_uint_32)(*(buf    )) << 24) +\r\n       ((png_uint_32)(*(buf + 1)) << 16) +\r\n       ((png_uint_32)(*(buf + 2)) <<  8) +\r\n       ((png_uint_32)(*(buf + 3))      ) ;\r\n\r\n   return uval;\r\n}\r\n\r\n/* Grab a signed 32-bit integer from a buffer in big-endian format.  The\r\n * data is stored in the PNG file in two's complement format and there\r\n * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore\r\n * the following code does a two's complement to native conversion.\r\n */\r\npng_int_32 (PNGAPI\r\npng_get_int_32)(png_const_bytep buf)\r\n{\r\n   png_uint_32 uval = png_get_uint_32(buf);\r\n   if ((uval & 0x80000000) == 0) /* non-negative */\r\n      return uval;\r\n\r\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\r\n   return -(png_int_32)uval;\r\n}\r\n\r\n/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */\r\npng_uint_16 (PNGAPI\r\npng_get_uint_16)(png_const_bytep buf)\r\n{\r\n   /* ANSI-C requires an int value to accomodate at least 16 bits so this\r\n    * works and allows the compiler not to worry about possible narrowing\r\n    * on 32 bit systems.  (Pre-ANSI systems did not make integers smaller\r\n    * than 16 bits either.)\r\n    */\r\n   unsigned int val =\r\n       ((unsigned int)(*buf) << 8) +\r\n       ((unsigned int)(*(buf + 1)));\r\n\r\n   return (png_uint_16)val;\r\n}\r\n\r\n#endif /* PNG_READ_INT_FUNCTIONS_SUPPORTED */\r\n\r\n/* Read and check the PNG file signature */\r\nvoid /* PRIVATE */\r\npng_read_sig(png_structrp png_ptr, png_inforp info_ptr)\r\n{\r\n   png_size_t num_checked, num_to_check;\r\n\r\n   /* Exit if the user application does not expect a signature. */\r\n   if (png_ptr->sig_bytes >= 8)\r\n      return;\r\n\r\n   num_checked = png_ptr->sig_bytes;\r\n   num_to_check = 8 - num_checked;\r\n\r\n#ifdef PNG_IO_STATE_SUPPORTED\r\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;\r\n#endif\r\n\r\n   /* The signature must be serialized in a single I/O call. */\r\n   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);\r\n   png_ptr->sig_bytes = 8;\r\n\r\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))\r\n   {\r\n      if (num_checked < 4 &&\r\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\r\n         png_error(png_ptr, \"Not a PNG file\");\r\n      else\r\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\r\n   }\r\n   if (num_checked < 3)\r\n      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\r\n}\r\n\r\n/* Read the chunk header (length + type name).\r\n * Put the type name into png_ptr->chunk_name, and return the length.\r\n */\r\npng_uint_32 /* PRIVATE */\r\npng_read_chunk_header(png_structrp png_ptr)\r\n{\r\n   png_byte buf[8];\r\n   png_uint_32 length;\r\n\r\n#ifdef PNG_IO_STATE_SUPPORTED\r\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;\r\n#endif\r\n\r\n   /* Read the length and the chunk name.\r\n    * This must be performed in a single I/O call.\r\n    */\r\n   png_read_data(png_ptr, buf, 8);\r\n   length = png_get_uint_31(png_ptr, buf);\r\n\r\n   /* Put the chunk name into png_ptr->chunk_name. */\r\n   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\r\n\r\n   png_debug2(0, \"Reading %lx chunk, length = %lu\",\r\n       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\r\n\r\n   /* Reset the crc and run it over the chunk name. */\r\n   png_reset_crc(png_ptr);\r\n   png_calculate_crc(png_ptr, buf + 4, 4);\r\n\r\n   /* Check to see if chunk name is valid. */\r\n   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\r\n\r\n#ifdef PNG_IO_STATE_SUPPORTED\r\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;\r\n#endif\r\n\r\n   return length;\r\n}\r\n\r\n/* Read data, and (optionally) run it through the CRC. */\r\nvoid /* PRIVATE */\r\npng_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)\r\n{\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_read_data(png_ptr, buf, length);\r\n   png_calculate_crc(png_ptr, buf, length);\r\n}\r\n\r\n/* Optionally skip data and then check the CRC.  Depending on whether we\r\n * are reading an ancillary or critical chunk, and how the program has set\r\n * things up, we may calculate the CRC on the data and print a message.\r\n * Returns '1' if there was a CRC error, '0' otherwise.\r\n */\r\nint /* PRIVATE */\r\npng_crc_finish(png_structrp png_ptr, png_uint_32 skip)\r\n{\r\n   /* The size of the local buffer for inflate is a good guess as to a\r\n    * reasonable size to use for buffering reads from the application.\r\n    */\r\n   while (skip > 0)\r\n   {\r\n      png_uint_32 len;\r\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\r\n\r\n      len = (sizeof tmpbuf);\r\n      if (len > skip)\r\n         len = skip;\r\n      skip -= len;\r\n\r\n      png_crc_read(png_ptr, tmpbuf, len);\r\n   }\r\n\r\n   if (png_crc_error(png_ptr))\r\n   {\r\n      if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) ?\r\n          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) :\r\n          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE))\r\n      {\r\n         png_chunk_warning(png_ptr, \"CRC error\");\r\n      }\r\n\r\n      else\r\n         png_chunk_error(png_ptr, \"CRC error\");\r\n\r\n      return (1);\r\n   }\r\n\r\n   return (0);\r\n}\r\n\r\n/* Compare the CRC stored in the PNG file with that calculated by libpng from\r\n * the data it has read thus far.\r\n */\r\nint /* PRIVATE */\r\npng_crc_error(png_structrp png_ptr)\r\n{\r\n   png_byte crc_bytes[4];\r\n   png_uint_32 crc;\r\n   int need_crc = 1;\r\n\r\n   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name))\r\n   {\r\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\r\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\r\n         need_crc = 0;\r\n   }\r\n\r\n   else /* critical */\r\n   {\r\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\r\n         need_crc = 0;\r\n   }\r\n\r\n#ifdef PNG_IO_STATE_SUPPORTED\r\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\r\n#endif\r\n\r\n   /* The chunk CRC must be serialized in a single I/O call. */\r\n   png_read_data(png_ptr, crc_bytes, 4);\r\n\r\n   if (need_crc)\r\n   {\r\n      crc = png_get_uint_32(crc_bytes);\r\n      return ((int)(crc != png_ptr->crc));\r\n   }\r\n\r\n   else\r\n      return (0);\r\n}\r\n\r\n#if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\\\r\n    defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\\\r\n    defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\\\r\n    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)\r\n/* Manage the read buffer; this simply reallocates the buffer if it is not small\r\n * enough (or if it is not allocated).  The routine returns a pointer to the\r\n * buffer; if an error occurs and 'warn' is set the routine returns NULL, else\r\n * it will call png_error (via png_malloc) on failure.  (warn == 2 means\r\n * 'silent').\r\n */\r\nstatic png_bytep\r\npng_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)\r\n{\r\n   png_bytep buffer = png_ptr->read_buffer;\r\n\r\n   if (buffer != NULL && new_size > png_ptr->read_buffer_size)\r\n   {\r\n      png_ptr->read_buffer = NULL;\r\n      png_ptr->read_buffer = NULL;\r\n      png_ptr->read_buffer_size = 0;\r\n      png_free(png_ptr, buffer);\r\n      buffer = NULL;\r\n   }\r\n\r\n   if (buffer == NULL)\r\n   {\r\n      buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));\r\n\r\n      if (buffer != NULL)\r\n      {\r\n         png_ptr->read_buffer = buffer;\r\n         png_ptr->read_buffer_size = new_size;\r\n      }\r\n\r\n      else if (warn < 2) /* else silent */\r\n      {\r\n         if (warn)\r\n             png_chunk_warning(png_ptr, \"insufficient memory to read chunk\");\r\n\r\n         else\r\n             png_chunk_error(png_ptr, \"insufficient memory to read chunk\");\r\n      }\r\n   }\r\n\r\n   return buffer;\r\n}\r\n#endif /* PNG_READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */\r\n\r\n/* png_inflate_claim: claim the zstream for some nefarious purpose that involves\r\n * decompression.  Returns Z_OK on success, else a zlib error code.  It checks\r\n * the owner but, in final release builds, just issues a warning if some other\r\n * chunk apparently owns the stream.  Prior to release it does a png_error.\r\n */\r\nstatic int\r\npng_inflate_claim(png_structrp png_ptr, png_uint_32 owner)\r\n{\r\n   if (png_ptr->zowner != 0)\r\n   {\r\n      char msg[64];\r\n\r\n      PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);\r\n      /* So the message that results is \"<chunk> using zstream\"; this is an\r\n       * internal error, but is very useful for debugging.  i18n requirements\r\n       * are minimal.\r\n       */\r\n      (void)png_safecat(msg, (sizeof msg), 4, \" using zstream\");\r\n#     if PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC\r\n         png_chunk_warning(png_ptr, msg);\r\n         png_ptr->zowner = 0;\r\n#     else\r\n         png_chunk_error(png_ptr, msg);\r\n#     endif\r\n   }\r\n\r\n   /* Implementation note: unlike 'png_deflate_claim' this internal function\r\n    * does not take the size of the data as an argument.  Some efficiency could\r\n    * be gained by using this when it is known *if* the zlib stream itself does\r\n    * not record the number; however, this is an illusion: the original writer\r\n    * of the PNG may have selected a lower window size, and we really must\r\n    * follow that because, for systems with with limited capabilities, we\r\n    * would otherwise reject the application's attempts to use a smaller window\r\n    * size (zlib doesn't have an interface to say \"this or lower\"!).\r\n    *\r\n    * inflateReset2 was added to zlib 1.2.4; before this the window could not be\r\n    * reset, therefore it is necessary to always allocate the maximum window\r\n    * size with earlier zlibs just in case later compressed chunks need it.\r\n    */\r\n   {\r\n      int ret; /* zlib return code */\r\n#     if PNG_ZLIB_VERNUM >= 0x1240\r\n\r\n#        if defined(PNG_SET_OPTION_SUPPORTED) && \\\r\n            defined(PNG_MAXIMUM_INFLATE_WINDOW)\r\n            int window_bits;\r\n\r\n            if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==\r\n               PNG_OPTION_ON)\r\n               window_bits = 15;\r\n\r\n            else\r\n               window_bits = 0;\r\n#        else\r\n#           define window_bits 0\r\n#        endif\r\n#     endif\r\n\r\n      /* Set this for safety, just in case the previous owner left pointers to\r\n       * memory allocations.\r\n       */\r\n      png_ptr->zstream.next_in = NULL;\r\n      png_ptr->zstream.avail_in = 0;\r\n      png_ptr->zstream.next_out = NULL;\r\n      png_ptr->zstream.avail_out = 0;\r\n\r\n      if (png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED)\r\n      {\r\n#        if PNG_ZLIB_VERNUM < 0x1240\r\n            ret = inflateReset(&png_ptr->zstream);\r\n#        else\r\n            ret = inflateReset2(&png_ptr->zstream, window_bits);\r\n#        endif\r\n      }\r\n\r\n      else\r\n      {\r\n#        if PNG_ZLIB_VERNUM < 0x1240\r\n            ret = inflateInit(&png_ptr->zstream);\r\n#        else\r\n            ret = inflateInit2(&png_ptr->zstream, window_bits);\r\n#        endif\r\n\r\n         if (ret == Z_OK)\r\n            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;\r\n      }\r\n\r\n      if (ret == Z_OK)\r\n         png_ptr->zowner = owner;\r\n\r\n      else\r\n         png_zstream_error(png_ptr, ret);\r\n\r\n      return ret;\r\n   }\r\n\r\n#  ifdef window_bits\r\n#     undef window_bits\r\n#  endif\r\n}\r\n\r\n#ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED\r\n/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to\r\n * allow the caller to do multiple calls if required.  If the 'finish' flag is\r\n * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must\r\n * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and\r\n * Z_OK or Z_STREAM_END will be returned on success.\r\n *\r\n * The input and output sizes are updated to the actual amounts of data consumed\r\n * or written, not the amount available (as in a z_stream).  The data pointers\r\n * are not changed, so the next input is (data+input_size) and the next\r\n * available output is (output+output_size).\r\n */\r\nstatic int\r\npng_inflate(png_structrp png_ptr, png_uint_32 owner, int finish,\r\n    /* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,\r\n    /* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)\r\n{\r\n   if (png_ptr->zowner == owner) /* Else not claimed */\r\n   {\r\n      int ret;\r\n      png_alloc_size_t avail_out = *output_size_ptr;\r\n      png_uint_32 avail_in = *input_size_ptr;\r\n\r\n      /* zlib can't necessarily handle more than 65535 bytes at once (i.e. it\r\n       * can't even necessarily handle 65536 bytes) because the type uInt is\r\n       * \"16 bits or more\".  Consequently it is necessary to chunk the input to\r\n       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the\r\n       * maximum value that can be stored in a uInt.)  It is possible to set\r\n       * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have\r\n       * a performance advantage, because it reduces the amount of data accessed\r\n       * at each step and that may give the OS more time to page it in.\r\n       */\r\n      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);\r\n      /* avail_in and avail_out are set below from 'size' */\r\n      png_ptr->zstream.avail_in = 0;\r\n      png_ptr->zstream.avail_out = 0;\r\n\r\n      /* Read directly into the output if it is available (this is set to\r\n       * a local buffer below if output is NULL).\r\n       */\r\n      if (output != NULL)\r\n         png_ptr->zstream.next_out = output;\r\n\r\n      do\r\n      {\r\n         uInt avail;\r\n         Byte local_buffer[PNG_INFLATE_BUF_SIZE];\r\n\r\n         /* zlib INPUT BUFFER */\r\n         /* The setting of 'avail_in' used to be outside the loop; by setting it\r\n          * inside it is possible to chunk the input to zlib and simply rely on\r\n          * zlib to advance the 'next_in' pointer.  This allows arbitrary\r\n          * amounts of data to be passed through zlib at the unavoidable cost of\r\n          * requiring a window save (memcpy of up to 32768 output bytes)\r\n          * every ZLIB_IO_MAX input bytes.\r\n          */\r\n         avail_in += png_ptr->zstream.avail_in; /* not consumed last time */\r\n\r\n         avail = ZLIB_IO_MAX;\r\n\r\n         if (avail_in < avail)\r\n            avail = (uInt)avail_in; /* safe: < than ZLIB_IO_MAX */\r\n\r\n         avail_in -= avail;\r\n         png_ptr->zstream.avail_in = avail;\r\n\r\n         /* zlib OUTPUT BUFFER */\r\n         avail_out += png_ptr->zstream.avail_out; /* not written last time */\r\n\r\n         avail = ZLIB_IO_MAX; /* maximum zlib can process */\r\n\r\n         if (output == NULL)\r\n         {\r\n            /* Reset the output buffer each time round if output is NULL and\r\n             * make available the full buffer, up to 'remaining_space'\r\n             */\r\n            png_ptr->zstream.next_out = local_buffer;\r\n            if ((sizeof local_buffer) < avail)\r\n               avail = (sizeof local_buffer);\r\n         }\r\n\r\n         if (avail_out < avail)\r\n            avail = (uInt)avail_out; /* safe: < ZLIB_IO_MAX */\r\n\r\n         png_ptr->zstream.avail_out = avail;\r\n         avail_out -= avail;\r\n\r\n         /* zlib inflate call */\r\n         /* In fact 'avail_out' may be 0 at this point, that happens at the end\r\n          * of the read when the final LZ end code was not passed at the end of\r\n          * the previous chunk of input data.  Tell zlib if we have reached the\r\n          * end of the output buffer.\r\n          */\r\n         ret = inflate(&png_ptr->zstream, avail_out > 0 ? Z_NO_FLUSH :\r\n            (finish ? Z_FINISH : Z_SYNC_FLUSH));\r\n      } while (ret == Z_OK);\r\n\r\n      /* For safety kill the local buffer pointer now */\r\n      if (output == NULL)\r\n         png_ptr->zstream.next_out = NULL;\r\n\r\n      /* Claw back the 'size' and 'remaining_space' byte counts. */\r\n      avail_in += png_ptr->zstream.avail_in;\r\n      avail_out += png_ptr->zstream.avail_out;\r\n\r\n      /* Update the input and output sizes; the updated values are the amount\r\n       * consumed or written, effectively the inverse of what zlib uses.\r\n       */\r\n      if (avail_out > 0)\r\n         *output_size_ptr -= avail_out;\r\n\r\n      if (avail_in > 0)\r\n         *input_size_ptr -= avail_in;\r\n\r\n      /* Ensure png_ptr->zstream.msg is set (even in the success case!) */\r\n      png_zstream_error(png_ptr, ret);\r\n      return ret;\r\n   }\r\n\r\n   else\r\n   {\r\n      /* This is a bad internal error.  The recovery assigns to the zstream msg\r\n       * pointer, which is not owned by the caller, but this is safe; it's only\r\n       * used on errors!\r\n       */\r\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\r\n      return Z_STREAM_ERROR;\r\n   }\r\n}\r\n\r\n/*\r\n * Decompress trailing data in a chunk.  The assumption is that read_buffer\r\n * points at an allocated area holding the contents of a chunk with a\r\n * trailing compressed part.  What we get back is an allocated area\r\n * holding the original prefix part and an uncompressed version of the\r\n * trailing part (the malloc area passed in is freed).\r\n */\r\nstatic int\r\npng_decompress_chunk(png_structrp png_ptr,\r\n   png_uint_32 chunklength, png_uint_32 prefix_size,\r\n   png_alloc_size_t *newlength /* must be initialized to the maximum! */,\r\n   int terminate /*add a '\\0' to the end of the uncompressed data*/)\r\n{\r\n   /* TODO: implement different limits for different types of chunk.\r\n    *\r\n    * The caller supplies *newlength set to the maximum length of the\r\n    * uncompressed data, but this routine allocates space for the prefix and\r\n    * maybe a '\\0' terminator too.  We have to assume that 'prefix_size' is\r\n    * limited only by the maximum chunk size.\r\n    */\r\n   png_alloc_size_t limit = PNG_SIZE_MAX;\r\n\r\n#  ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED\r\n      if (png_ptr->user_chunk_malloc_max > 0 &&\r\n         png_ptr->user_chunk_malloc_max < limit)\r\n         limit = png_ptr->user_chunk_malloc_max;\r\n#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\r\n      if (PNG_USER_CHUNK_MALLOC_MAX < limit)\r\n         limit = PNG_USER_CHUNK_MALLOC_MAX;\r\n#  endif\r\n\r\n   if (limit >= prefix_size + (terminate != 0))\r\n   {\r\n      int ret;\r\n\r\n      limit -= prefix_size + (terminate != 0);\r\n\r\n      if (limit < *newlength)\r\n         *newlength = limit;\r\n\r\n      /* Now try to claim the stream. */\r\n      ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);\r\n\r\n      if (ret == Z_OK)\r\n      {\r\n         png_uint_32 lzsize = chunklength - prefix_size;\r\n\r\n         ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\r\n            /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,\r\n            /* output: */ NULL, newlength);\r\n\r\n         if (ret == Z_STREAM_END)\r\n         {\r\n            /* Use 'inflateReset' here, not 'inflateReset2' because this\r\n             * preserves the previously decided window size (otherwise it would\r\n             * be necessary to store the previous window size.)  In practice\r\n             * this doesn't matter anyway, because png_inflate will call inflate\r\n             * with Z_FINISH in almost all cases, so the window will not be\r\n             * maintained.\r\n             */\r\n            if (inflateReset(&png_ptr->zstream) == Z_OK)\r\n            {\r\n               /* Because of the limit checks above we know that the new,\r\n                * expanded, size will fit in a size_t (let alone an\r\n                * png_alloc_size_t).  Use png_malloc_base here to avoid an\r\n                * extra OOM message.\r\n                */\r\n               png_alloc_size_t new_size = *newlength;\r\n               png_alloc_size_t buffer_size = prefix_size + new_size +\r\n                  (terminate != 0);\r\n               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,\r\n                  buffer_size));\r\n\r\n               if (text != NULL)\r\n               {\r\n                  ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\r\n                     png_ptr->read_buffer + prefix_size, &lzsize,\r\n                     text + prefix_size, newlength);\r\n\r\n                  if (ret == Z_STREAM_END)\r\n                  {\r\n                     if (new_size == *newlength)\r\n                     {\r\n                        if (terminate)\r\n                           text[prefix_size + *newlength] = 0;\r\n\r\n                        if (prefix_size > 0)\r\n                           memcpy(text, png_ptr->read_buffer, prefix_size);\r\n\r\n                        {\r\n                           png_bytep old_ptr = png_ptr->read_buffer;\r\n\r\n                           png_ptr->read_buffer = text;\r\n                           png_ptr->read_buffer_size = buffer_size;\r\n                           text = old_ptr; /* freed below */\r\n                        }\r\n                     }\r\n\r\n                     else\r\n                     {\r\n                        /* The size changed on the second read, there can be no\r\n                         * guarantee that anything is correct at this point.\r\n                         * The 'msg' pointer has been set to \"unexpected end of\r\n                         * LZ stream\", which is fine, but return an error code\r\n                         * that the caller won't accept.\r\n                         */\r\n                        ret = PNG_UNEXPECTED_ZLIB_RETURN;\r\n                     }\r\n                  }\r\n\r\n                  else if (ret == Z_OK)\r\n                     ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */\r\n\r\n                  /* Free the text pointer (this is the old read_buffer on\r\n                   * success)\r\n                   */\r\n                  png_free(png_ptr, text);\r\n\r\n                  /* This really is very benign, but it's still an error because\r\n                   * the extra space may otherwise be used as a Trojan Horse.\r\n                   */\r\n                  if (ret == Z_STREAM_END &&\r\n                     chunklength - prefix_size != lzsize)\r\n                     png_chunk_benign_error(png_ptr, \"extra compressed data\");\r\n               }\r\n\r\n               else\r\n               {\r\n                  /* Out of memory allocating the buffer */\r\n                  ret = Z_MEM_ERROR;\r\n                  png_zstream_error(png_ptr, Z_MEM_ERROR);\r\n               }\r\n            }\r\n\r\n            else\r\n            {\r\n               /* inflateReset failed, store the error message */\r\n               png_zstream_error(png_ptr, ret);\r\n\r\n               if (ret == Z_STREAM_END)\r\n                  ret = PNG_UNEXPECTED_ZLIB_RETURN;\r\n            }\r\n         }\r\n\r\n         else if (ret == Z_OK)\r\n            ret = PNG_UNEXPECTED_ZLIB_RETURN;\r\n\r\n         /* Release the claimed stream */\r\n         png_ptr->zowner = 0;\r\n      }\r\n\r\n      else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */\r\n         ret = PNG_UNEXPECTED_ZLIB_RETURN;\r\n\r\n      return ret;\r\n   }\r\n\r\n   else\r\n   {\r\n      /* Application/configuration limits exceeded */\r\n      png_zstream_error(png_ptr, Z_MEM_ERROR);\r\n      return Z_MEM_ERROR;\r\n   }\r\n}\r\n#endif /* PNG_READ_COMPRESSED_TEXT_SUPPORTED */\r\n\r\n#ifdef PNG_READ_iCCP_SUPPORTED\r\n/* Perform a partial read and decompress, producing 'avail_out' bytes and\r\n * reading from the current chunk as required.\r\n */\r\nstatic int\r\npng_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,\r\n   png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,\r\n   int finish)\r\n{\r\n   if (png_ptr->zowner == png_ptr->chunk_name)\r\n   {\r\n      int ret;\r\n\r\n      /* next_in and avail_in must have been initialized by the caller. */\r\n      png_ptr->zstream.next_out = next_out;\r\n      png_ptr->zstream.avail_out = 0; /* set in the loop */\r\n\r\n      do\r\n      {\r\n         if (png_ptr->zstream.avail_in == 0)\r\n         {\r\n            if (read_size > *chunk_bytes)\r\n               read_size = (uInt)*chunk_bytes;\r\n            *chunk_bytes -= read_size;\r\n\r\n            if (read_size > 0)\r\n               png_crc_read(png_ptr, read_buffer, read_size);\r\n\r\n            png_ptr->zstream.next_in = read_buffer;\r\n            png_ptr->zstream.avail_in = read_size;\r\n         }\r\n\r\n         if (png_ptr->zstream.avail_out == 0)\r\n         {\r\n            uInt avail = ZLIB_IO_MAX;\r\n            if (avail > *out_size)\r\n               avail = (uInt)*out_size;\r\n            *out_size -= avail;\r\n\r\n            png_ptr->zstream.avail_out = avail;\r\n         }\r\n\r\n         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all\r\n          * the available output is produced; this allows reading of truncated\r\n          * streams.\r\n          */\r\n         ret = inflate(&png_ptr->zstream,\r\n            *chunk_bytes > 0 ? Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));\r\n      }\r\n      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));\r\n\r\n      *out_size += png_ptr->zstream.avail_out;\r\n      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */\r\n\r\n      /* Ensure the error message pointer is always set: */\r\n      png_zstream_error(png_ptr, ret);\r\n      return ret;\r\n   }\r\n\r\n   else\r\n   {\r\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\r\n      return Z_STREAM_ERROR;\r\n   }\r\n}\r\n#endif\r\n\r\n/* Read and check the IDHR chunk */\r\nvoid /* PRIVATE */\r\npng_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte buf[13];\r\n   png_uint_32 width, height;\r\n   int bit_depth, color_type, compression_type, filter_type;\r\n   int interlace_type;\r\n\r\n   png_debug(1, \"in png_handle_IHDR\");\r\n\r\n   if (png_ptr->mode & PNG_HAVE_IHDR)\r\n      png_chunk_error(png_ptr, \"out of place\");\r\n\r\n   /* Check the length */\r\n   if (length != 13)\r\n      png_chunk_error(png_ptr, \"invalid\");\r\n\r\n   png_ptr->mode |= PNG_HAVE_IHDR;\r\n\r\n   png_crc_read(png_ptr, buf, 13);\r\n   png_crc_finish(png_ptr, 0);\r\n\r\n   width = png_get_uint_31(png_ptr, buf);\r\n   height = png_get_uint_31(png_ptr, buf + 4);\r\n   bit_depth = buf[8];\r\n   color_type = buf[9];\r\n   compression_type = buf[10];\r\n   filter_type = buf[11];\r\n   interlace_type = buf[12];\r\n\r\n   /* Set internal variables */\r\n   png_ptr->width = width;\r\n   png_ptr->height = height;\r\n   png_ptr->bit_depth = (png_byte)bit_depth;\r\n   png_ptr->interlaced = (png_byte)interlace_type;\r\n   png_ptr->color_type = (png_byte)color_type;\r\n#ifdef PNG_MNG_FEATURES_SUPPORTED\r\n   png_ptr->filter_type = (png_byte)filter_type;\r\n#endif\r\n   png_ptr->compression_type = (png_byte)compression_type;\r\n\r\n   /* Find number of channels */\r\n   switch (png_ptr->color_type)\r\n   {\r\n      default: /* invalid, png_set_IHDR calls png_error */\r\n      case PNG_COLOR_TYPE_GRAY:\r\n      case PNG_COLOR_TYPE_PALETTE:\r\n         png_ptr->channels = 1;\r\n         break;\r\n\r\n      case PNG_COLOR_TYPE_RGB:\r\n         png_ptr->channels = 3;\r\n         break;\r\n\r\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\r\n         png_ptr->channels = 2;\r\n         break;\r\n\r\n      case PNG_COLOR_TYPE_RGB_ALPHA:\r\n         png_ptr->channels = 4;\r\n         break;\r\n   }\r\n\r\n   /* Set up other useful info */\r\n   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *\r\n   png_ptr->channels);\r\n   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);\r\n   png_debug1(3, \"bit_depth = %d\", png_ptr->bit_depth);\r\n   png_debug1(3, \"channels = %d\", png_ptr->channels);\r\n   png_debug1(3, \"rowbytes = %lu\", (unsigned long)png_ptr->rowbytes);\r\n   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,\r\n       color_type, interlace_type, compression_type, filter_type);\r\n}\r\n\r\n/* Read and check the palette */\r\nvoid /* PRIVATE */\r\npng_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_color palette[PNG_MAX_PALETTE_LENGTH];\r\n   int num, i;\r\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\r\n   png_colorp pal_ptr;\r\n#endif\r\n\r\n   png_debug(1, \"in png_handle_PLTE\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   /* Moved to before the 'after IDAT' check below because otherwise duplicate\r\n    * PLTE chunks are potentially ignored (the spec says there shall not be more\r\n    * than one PLTE, the error is not treated as benign, so this check trumps\r\n    * the requirement that PLTE appears before IDAT.)\r\n    */\r\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\r\n      png_chunk_error(png_ptr, \"duplicate\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      /* This is benign because the non-benign error happened before, when an\r\n       * IDAT was encountered in a color-mapped image with no PLTE.\r\n       */\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   png_ptr->mode |= PNG_HAVE_PLTE;\r\n\r\n   if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"ignored in grayscale PNG\");\r\n      return;\r\n   }\r\n\r\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\r\n   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      return;\r\n   }\r\n#endif\r\n\r\n   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n\r\n      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\r\n         png_chunk_benign_error(png_ptr, \"invalid\");\r\n\r\n      else\r\n         png_chunk_error(png_ptr, \"invalid\");\r\n\r\n      return;\r\n   }\r\n\r\n   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */\r\n   num = (int)length / 3;\r\n\r\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\r\n   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)\r\n   {\r\n      png_byte buf[3];\r\n\r\n      png_crc_read(png_ptr, buf, 3);\r\n      pal_ptr->red = buf[0];\r\n      pal_ptr->green = buf[1];\r\n      pal_ptr->blue = buf[2];\r\n   }\r\n#else\r\n   for (i = 0; i < num; i++)\r\n   {\r\n      png_byte buf[3];\r\n\r\n      png_crc_read(png_ptr, buf, 3);\r\n      /* Don't depend upon png_color being any order */\r\n      palette[i].red = buf[0];\r\n      palette[i].green = buf[1];\r\n      palette[i].blue = buf[2];\r\n   }\r\n#endif\r\n\r\n   /* If we actually need the PLTE chunk (ie for a paletted image), we do\r\n    * whatever the normal CRC configuration tells us.  However, if we\r\n    * have an RGB image, the PLTE can be considered ancillary, so\r\n    * we will act as though it is.\r\n    */\r\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n#endif\r\n   {\r\n      png_crc_finish(png_ptr, 0);\r\n   }\r\n\r\n#ifndef PNG_READ_OPT_PLTE_SUPPORTED\r\n   else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */\r\n   {\r\n      /* If we don't want to use the data from an ancillary chunk,\r\n       * we have two options: an error abort, or a warning and we\r\n       * ignore the data in this chunk (which should be OK, since\r\n       * it's considered ancillary for a RGB or RGBA image).\r\n       *\r\n       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the\r\n       * chunk type to determine whether to check the ancillary or the critical\r\n       * flags.\r\n       */\r\n      if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))\r\n      {\r\n         if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)\r\n            return;\r\n\r\n         else\r\n            png_chunk_error(png_ptr, \"CRC error\");\r\n      }\r\n\r\n      /* Otherwise, we (optionally) emit a warning and use the chunk. */\r\n      else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))\r\n         png_chunk_warning(png_ptr, \"CRC error\");\r\n   }\r\n#endif\r\n\r\n   /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its\r\n    * own copy of the palette.  This has the side effect that when png_start_row\r\n    * is called (this happens after any call to png_read_update_info) the\r\n    * info_ptr palette gets changed.  This is extremely unexpected and\r\n    * confusing.\r\n    *\r\n    * Fix this by not sharing the palette in this way.\r\n    */\r\n   png_set_PLTE(png_ptr, info_ptr, palette, num);\r\n\r\n   /* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before\r\n    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely\r\n    * checked the apparent validity of a tRNS chunk inserted before PLTE on a\r\n    * palette PNG.  1.6.0 attempts to rigorously follow the standard and\r\n    * therefore does a benign error if the erroneous condition is detected *and*\r\n    * cancels the tRNS if the benign error returns.  The alternative is to\r\n    * amend the standard since it would be rather hypocritical of the standards\r\n    * maintainers to ignore it.\r\n    */\r\n#ifdef PNG_READ_tRNS_SUPPORTED\r\n   if (png_ptr->num_trans > 0 ||\r\n      (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0))\r\n   {\r\n      /* Cancel this because otherwise it would be used if the transforms\r\n       * require it.  Don't cancel the 'valid' flag because this would prevent\r\n       * detection of duplicate chunks.\r\n       */\r\n      png_ptr->num_trans = 0;\r\n\r\n      if (info_ptr != NULL)\r\n         info_ptr->num_trans = 0;\r\n\r\n      png_chunk_benign_error(png_ptr, \"tRNS must be after\");\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_hIST_SUPPORTED\r\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\r\n      png_chunk_benign_error(png_ptr, \"hIST must be after\");\r\n#endif\r\n\r\n#ifdef PNG_READ_bKGD_SUPPORTED\r\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\r\n      png_chunk_benign_error(png_ptr, \"bKGD must be after\");\r\n#endif\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_handle_IEND(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_debug(1, \"in png_handle_IEND\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))\r\n      png_chunk_error(png_ptr, \"out of place\");\r\n\r\n   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);\r\n\r\n   png_crc_finish(png_ptr, length);\r\n\r\n   if (length != 0)\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n\r\n   PNG_UNUSED(info_ptr)\r\n}\r\n\r\n#ifdef PNG_READ_gAMA_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_gAMA(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_fixed_point igamma;\r\n   png_byte buf[4];\r\n\r\n   png_debug(1, \"in png_handle_gAMA\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   if (length != 4)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buf, 4);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   igamma = png_get_fixed_point(NULL, buf);\r\n\r\n   png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, igamma);\r\n   png_colorspace_sync(png_ptr, info_ptr);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_sBIT_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_sBIT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   unsigned int truelen, i;\r\n   png_byte sample_depth;\r\n   png_byte buf[4];\r\n\r\n   png_debug(1, \"in png_handle_sBIT\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      truelen = 3;\r\n      sample_depth = 8;\r\n   }\r\n\r\n   else\r\n   {\r\n      truelen = png_ptr->channels;\r\n      sample_depth = png_ptr->bit_depth;\r\n   }\r\n\r\n   if (length != truelen || length > 4)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      png_crc_finish(png_ptr, length);\r\n      return;\r\n   }\r\n\r\n   buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;\r\n   png_crc_read(png_ptr, buf, truelen);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   for (i=0; i<truelen; ++i)\r\n      if (buf[i] == 0 || buf[i] > sample_depth)\r\n      {\r\n         png_chunk_benign_error(png_ptr, \"invalid\");\r\n         return;\r\n      }\r\n\r\n   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n   {\r\n      png_ptr->sig_bit.red = buf[0];\r\n      png_ptr->sig_bit.green = buf[1];\r\n      png_ptr->sig_bit.blue = buf[2];\r\n      png_ptr->sig_bit.alpha = buf[3];\r\n   }\r\n\r\n   else\r\n   {\r\n      png_ptr->sig_bit.gray = buf[0];\r\n      png_ptr->sig_bit.red = buf[0];\r\n      png_ptr->sig_bit.green = buf[0];\r\n      png_ptr->sig_bit.blue = buf[0];\r\n      png_ptr->sig_bit.alpha = buf[1];\r\n   }\r\n\r\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_cHRM_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte buf[32];\r\n   png_xy xy;\r\n\r\n   png_debug(1, \"in png_handle_cHRM\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   if (length != 32)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buf, 32);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   xy.whitex = png_get_fixed_point(NULL, buf);\r\n   xy.whitey = png_get_fixed_point(NULL, buf + 4);\r\n   xy.redx   = png_get_fixed_point(NULL, buf + 8);\r\n   xy.redy   = png_get_fixed_point(NULL, buf + 12);\r\n   xy.greenx = png_get_fixed_point(NULL, buf + 16);\r\n   xy.greeny = png_get_fixed_point(NULL, buf + 20);\r\n   xy.bluex  = png_get_fixed_point(NULL, buf + 24);\r\n   xy.bluey  = png_get_fixed_point(NULL, buf + 28);\r\n\r\n   if (xy.whitex == PNG_FIXED_ERROR ||\r\n       xy.whitey == PNG_FIXED_ERROR ||\r\n       xy.redx   == PNG_FIXED_ERROR ||\r\n       xy.redy   == PNG_FIXED_ERROR ||\r\n       xy.greenx == PNG_FIXED_ERROR ||\r\n       xy.greeny == PNG_FIXED_ERROR ||\r\n       xy.bluex  == PNG_FIXED_ERROR ||\r\n       xy.bluey  == PNG_FIXED_ERROR)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"invalid values\");\r\n      return;\r\n   }\r\n\r\n   /* If a colorspace error has already been output skip this chunk */\r\n   if (png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID)\r\n      return;\r\n\r\n   if (png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM)\r\n   {\r\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\r\n      png_colorspace_sync(png_ptr, info_ptr);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\r\n   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,\r\n      1/*prefer cHRM values*/);\r\n   png_colorspace_sync(png_ptr, info_ptr);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_sRGB_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_sRGB(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte intent;\r\n\r\n   png_debug(1, \"in png_handle_sRGB\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   if (length != 1)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, &intent, 1);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   /* If a colorspace error has already been output skip this chunk */\r\n   if (png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID)\r\n      return;\r\n\r\n   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\r\n    * this.\r\n    */\r\n   if (png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT)\r\n   {\r\n      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\r\n      png_colorspace_sync(png_ptr, info_ptr);\r\n      png_chunk_benign_error(png_ptr, \"too many profiles\");\r\n      return;\r\n   }\r\n\r\n   (void)png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, intent);\r\n   png_colorspace_sync(png_ptr, info_ptr);\r\n}\r\n#endif /* PNG_READ_sRGB_SUPPORTED */\r\n\r\n#ifdef PNG_READ_iCCP_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n/* Note: this does not properly handle profiles that are > 64K under DOS */\r\n{\r\n   png_const_charp errmsg = NULL; /* error message output, or no error */\r\n   int finished = 0; /* crc checked */\r\n\r\n   png_debug(1, \"in png_handle_iCCP\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   /* Consistent with all the above colorspace handling an obviously *invalid*\r\n    * chunk is just ignored, so does not invalidate the color space.  An\r\n    * alternative is to set the 'invalid' flags at the start of this routine\r\n    * and only clear them in they were not set before and all the tests pass.\r\n    * The minimum 'deflate' stream is assumed to be just the 2 byte header and 4\r\n    * byte checksum.  The keyword must be one character and there is a\r\n    * terminator (0) byte and the compression method.\r\n    */\r\n   if (length < 9)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"too short\");\r\n      return;\r\n   }\r\n\r\n   /* If a colorspace error has already been output skip this chunk */\r\n   if (png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      return;\r\n   }\r\n\r\n   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\r\n    * this.\r\n    */\r\n   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)\r\n   {\r\n      uInt read_length, keyword_length;\r\n      char keyword[81];\r\n\r\n      /* Find the keyword; the keyword plus separator and compression method\r\n       * bytes can be at most 81 characters long.\r\n       */\r\n      read_length = 81; /* maximum */\r\n      if (read_length > length)\r\n         read_length = (uInt)length;\r\n\r\n      png_crc_read(png_ptr, (png_bytep)keyword, read_length);\r\n      length -= read_length;\r\n\r\n      keyword_length = 0;\r\n      while (keyword_length < 80 && keyword_length < read_length &&\r\n         keyword[keyword_length] != 0)\r\n         ++keyword_length;\r\n\r\n      /* TODO: make the keyword checking common */\r\n      if (keyword_length >= 1 && keyword_length <= 79)\r\n      {\r\n         /* We only understand '0' compression - deflate - so if we get a\r\n          * different value we can't safely decode the chunk.\r\n          */\r\n         if (keyword_length+1 < read_length &&\r\n            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)\r\n         {\r\n            read_length -= keyword_length+2;\r\n\r\n            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)\r\n            {\r\n               Byte profile_header[132];\r\n               Byte local_buffer[PNG_INFLATE_BUF_SIZE];\r\n               png_alloc_size_t size = (sizeof profile_header);\r\n\r\n               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);\r\n               png_ptr->zstream.avail_in = read_length;\r\n               (void)png_inflate_read(png_ptr, local_buffer,\r\n                  (sizeof local_buffer), &length, profile_header, &size,\r\n                  0/*finish: don't, because the output is too small*/);\r\n\r\n               if (size == 0)\r\n               {\r\n                  /* We have the ICC profile header; do the basic header checks.\r\n                   */\r\n                  const png_uint_32 profile_length =\r\n                     png_get_uint_32(profile_header);\r\n\r\n                  if (png_icc_check_length(png_ptr, &png_ptr->colorspace,\r\n                     keyword, profile_length))\r\n                  {\r\n                     /* The length is apparently ok, so we can check the 132\r\n                      * byte header.\r\n                      */\r\n                     if (png_icc_check_header(png_ptr, &png_ptr->colorspace,\r\n                        keyword, profile_length, profile_header,\r\n                        png_ptr->color_type))\r\n                     {\r\n                        /* Now read the tag table; a variable size buffer is\r\n                         * needed at this point, allocate one for the whole\r\n                         * profile.  The header check has already validated\r\n                         * that none of these stuff will overflow.\r\n                         */\r\n                        const png_uint_32 tag_count = png_get_uint_32(\r\n                           profile_header+128);\r\n                        png_bytep profile = png_read_buffer(png_ptr,\r\n                           profile_length, 2/*silent*/);\r\n\r\n                        if (profile != NULL)\r\n                        {\r\n                           memcpy(profile, profile_header,\r\n                              (sizeof profile_header));\r\n\r\n                           size = 12 * tag_count;\r\n\r\n                           (void)png_inflate_read(png_ptr, local_buffer,\r\n                              (sizeof local_buffer), &length,\r\n                              profile + (sizeof profile_header), &size, 0);\r\n\r\n                           /* Still expect a buffer error because we expect\r\n                            * there to be some tag data!\r\n                            */\r\n                           if (size == 0)\r\n                           {\r\n                              if (png_icc_check_tag_table(png_ptr,\r\n                                 &png_ptr->colorspace, keyword, profile_length,\r\n                                 profile))\r\n                              {\r\n                                 /* The profile has been validated for basic\r\n                                  * security issues, so read the whole thing in.\r\n                                  */\r\n                                 size = profile_length - (sizeof profile_header)\r\n                                    - 12 * tag_count;\r\n\r\n                                 (void)png_inflate_read(png_ptr, local_buffer,\r\n                                    (sizeof local_buffer), &length,\r\n                                    profile + (sizeof profile_header) +\r\n                                    12 * tag_count, &size, 1/*finish*/);\r\n\r\n                                 if (length > 0 && !(png_ptr->flags &\r\n                                       PNG_FLAG_BENIGN_ERRORS_WARN))\r\n                                    errmsg = \"extra compressed data\";\r\n\r\n                                 /* But otherwise allow extra data: */\r\n                                 else if (size == 0)\r\n                                 {\r\n                                    if (length > 0)\r\n                                    {\r\n                                       /* This can be handled completely, so\r\n                                        * keep going.\r\n                                        */\r\n                                       png_chunk_warning(png_ptr,\r\n                                          \"extra compressed data\");\r\n                                    }\r\n\r\n                                    png_crc_finish(png_ptr, length);\r\n                                    finished = 1;\r\n\r\n#                                   ifdef PNG_sRGB_SUPPORTED\r\n                                       /* Check for a match against sRGB */\r\n                                       png_icc_set_sRGB(png_ptr,\r\n                                          &png_ptr->colorspace, profile,\r\n                                          png_ptr->zstream.adler);\r\n#                                   endif\r\n\r\n                                    /* Steal the profile for info_ptr. */\r\n                                    if (info_ptr != NULL)\r\n                                    {\r\n                                       png_free_data(png_ptr, info_ptr,\r\n                                          PNG_FREE_ICCP, 0);\r\n\r\n                                       info_ptr->iccp_name = png_voidcast(char*,\r\n                                          png_malloc_base(png_ptr,\r\n                                          keyword_length+1));\r\n                                       if (info_ptr->iccp_name != NULL)\r\n                                       {\r\n                                          memcpy(info_ptr->iccp_name, keyword,\r\n                                             keyword_length+1);\r\n                                          info_ptr->iccp_proflen =\r\n                                             profile_length;\r\n                                          info_ptr->iccp_profile = profile;\r\n                                          png_ptr->read_buffer = NULL; /*steal*/\r\n                                          info_ptr->free_me |= PNG_FREE_ICCP;\r\n                                          info_ptr->valid |= PNG_INFO_iCCP;\r\n                                       }\r\n\r\n                                       else\r\n                                       {\r\n                                          png_ptr->colorspace.flags |=\r\n                                             PNG_COLORSPACE_INVALID;\r\n                                          errmsg = \"out of memory\";\r\n                                       }\r\n                                    }\r\n\r\n                                    /* else the profile remains in the read\r\n                                     * buffer which gets reused for subsequent\r\n                                     * chunks.\r\n                                     */\r\n\r\n                                    if (info_ptr != NULL)\r\n                                       png_colorspace_sync(png_ptr, info_ptr);\r\n\r\n                                    if (errmsg == NULL)\r\n                                    {\r\n                                       png_ptr->zowner = 0;\r\n                                       return;\r\n                                    }\r\n                                 }\r\n\r\n                                 else if (size > 0)\r\n                                    errmsg = \"truncated\";\r\n\r\n                                 else\r\n                                    errmsg = png_ptr->zstream.msg;\r\n                              }\r\n\r\n                              /* else png_icc_check_tag_table output an error */\r\n                           }\r\n\r\n                           else /* profile truncated */\r\n                              errmsg = png_ptr->zstream.msg;\r\n                        }\r\n\r\n                        else\r\n                           errmsg = \"out of memory\";\r\n                     }\r\n\r\n                     /* else png_icc_check_header output an error */\r\n                  }\r\n\r\n                  /* else png_icc_check_length output an error */\r\n               }\r\n\r\n               else /* profile truncated */\r\n                  errmsg = png_ptr->zstream.msg;\r\n\r\n               /* Release the stream */\r\n               png_ptr->zowner = 0;\r\n            }\r\n\r\n            else /* png_inflate_claim failed */\r\n               errmsg = png_ptr->zstream.msg;\r\n         }\r\n\r\n         else\r\n            errmsg = \"bad compression method\"; /* or missing */\r\n      }\r\n\r\n      else\r\n         errmsg = \"bad keyword\";\r\n   }\r\n\r\n   else\r\n      errmsg = \"too many profiles\";\r\n\r\n   /* Failure: the reason is in 'errmsg' */\r\n   if (!finished)\r\n      png_crc_finish(png_ptr, length);\r\n\r\n   png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\r\n   png_colorspace_sync(png_ptr, info_ptr);\r\n   if (errmsg != NULL) /* else already output */\r\n      png_chunk_benign_error(png_ptr, errmsg);\r\n}\r\n#endif /* PNG_READ_iCCP_SUPPORTED */\r\n\r\n#ifdef PNG_READ_sPLT_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n/* Note: this does not properly handle chunks that are > 64K under DOS */\r\n{\r\n   png_bytep entry_start, buffer;\r\n   png_sPLT_t new_palette;\r\n   png_sPLT_entryp pp;\r\n   png_uint_32 data_length;\r\n   int entry_size, i;\r\n   png_uint_32 skip = 0;\r\n   png_uint_32 dl;\r\n   png_size_t max_dl;\r\n\r\n   png_debug(1, \"in png_handle_sPLT\");\r\n\r\n#ifdef PNG_USER_LIMITS_SUPPORTED\r\n   if (png_ptr->user_chunk_cache_max != 0)\r\n   {\r\n      if (png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         return;\r\n      }\r\n\r\n      if (--png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_warning(png_ptr, \"No space in chunk cache for sPLT\");\r\n         png_crc_finish(png_ptr, length);\r\n         return;\r\n      }\r\n   }\r\n#endif\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n#ifdef PNG_MAX_MALLOC_64K\r\n   if (length > 65535U)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\r\n      return;\r\n   }\r\n#endif\r\n\r\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\r\n   if (buffer == NULL)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of memory\");\r\n      return;\r\n   }\r\n\r\n\r\n   /* WARNING: this may break if size_t is less than 32 bits; it is assumed\r\n    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a\r\n    * potential breakage point if the types in pngconf.h aren't exactly right.\r\n    */\r\n   png_crc_read(png_ptr, buffer, length);\r\n\r\n   if (png_crc_finish(png_ptr, skip))\r\n      return;\r\n\r\n   buffer[length] = 0;\r\n\r\n   for (entry_start = buffer; *entry_start; entry_start++)\r\n      /* Empty loop to find end of name */ ;\r\n\r\n   ++entry_start;\r\n\r\n   /* A sample depth should follow the separator, and we should be on it  */\r\n   if (entry_start > buffer + length - 2)\r\n   {\r\n      png_warning(png_ptr, \"malformed sPLT chunk\");\r\n      return;\r\n   }\r\n\r\n   new_palette.depth = *entry_start++;\r\n   entry_size = (new_palette.depth == 8 ? 6 : 10);\r\n   /* This must fit in a png_uint_32 because it is derived from the original\r\n    * chunk data length.\r\n    */\r\n   data_length = length - (png_uint_32)(entry_start - buffer);\r\n\r\n   /* Integrity-check the data length */\r\n   if (data_length % entry_size)\r\n   {\r\n      png_warning(png_ptr, \"sPLT chunk has bad length\");\r\n      return;\r\n   }\r\n\r\n   dl = (png_int_32)(data_length / entry_size);\r\n   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));\r\n\r\n   if (dl > max_dl)\r\n   {\r\n       png_warning(png_ptr, \"sPLT chunk too long\");\r\n       return;\r\n   }\r\n\r\n   new_palette.nentries = (png_int_32)(data_length / entry_size);\r\n\r\n   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(\r\n       png_ptr, new_palette.nentries * (sizeof (png_sPLT_entry)));\r\n\r\n   if (new_palette.entries == NULL)\r\n   {\r\n       png_warning(png_ptr, \"sPLT chunk requires too much memory\");\r\n       return;\r\n   }\r\n\r\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\r\n   for (i = 0; i < new_palette.nentries; i++)\r\n   {\r\n      pp = new_palette.entries + i;\r\n\r\n      if (new_palette.depth == 8)\r\n      {\r\n         pp->red = *entry_start++;\r\n         pp->green = *entry_start++;\r\n         pp->blue = *entry_start++;\r\n         pp->alpha = *entry_start++;\r\n      }\r\n\r\n      else\r\n      {\r\n         pp->red   = png_get_uint_16(entry_start); entry_start += 2;\r\n         pp->green = png_get_uint_16(entry_start); entry_start += 2;\r\n         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;\r\n         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;\r\n      }\r\n\r\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\r\n   }\r\n#else\r\n   pp = new_palette.entries;\r\n\r\n   for (i = 0; i < new_palette.nentries; i++)\r\n   {\r\n\r\n      if (new_palette.depth == 8)\r\n      {\r\n         pp[i].red   = *entry_start++;\r\n         pp[i].green = *entry_start++;\r\n         pp[i].blue  = *entry_start++;\r\n         pp[i].alpha = *entry_start++;\r\n      }\r\n\r\n      else\r\n      {\r\n         pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;\r\n         pp[i].green = png_get_uint_16(entry_start); entry_start += 2;\r\n         pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;\r\n         pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;\r\n      }\r\n\r\n      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;\r\n   }\r\n#endif\r\n\r\n   /* Discard all chunk data except the name and stash that */\r\n   new_palette.name = (png_charp)buffer;\r\n\r\n   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);\r\n\r\n   png_free(png_ptr, new_palette.entries);\r\n}\r\n#endif /* PNG_READ_sPLT_SUPPORTED */\r\n\r\n#ifdef PNG_READ_tRNS_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\r\n\r\n   png_debug(1, \"in png_handle_tRNS\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\r\n   {\r\n      png_byte buf[2];\r\n\r\n      if (length != 2)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"invalid\");\r\n         return;\r\n      }\r\n\r\n      png_crc_read(png_ptr, buf, 2);\r\n      png_ptr->num_trans = 1;\r\n      png_ptr->trans_color.gray = png_get_uint_16(buf);\r\n   }\r\n\r\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\r\n   {\r\n      png_byte buf[6];\r\n\r\n      if (length != 6)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"invalid\");\r\n         return;\r\n      }\r\n\r\n      png_crc_read(png_ptr, buf, length);\r\n      png_ptr->num_trans = 1;\r\n      png_ptr->trans_color.red = png_get_uint_16(buf);\r\n      png_ptr->trans_color.green = png_get_uint_16(buf + 2);\r\n      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);\r\n   }\r\n\r\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      if (!(png_ptr->mode & PNG_HAVE_PLTE))\r\n      {\r\n         /* TODO: is this actually an error in the ISO spec? */\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"out of place\");\r\n         return;\r\n      }\r\n\r\n      if (length > png_ptr->num_palette || length > PNG_MAX_PALETTE_LENGTH ||\r\n         length == 0)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"invalid\");\r\n         return;\r\n      }\r\n\r\n      png_crc_read(png_ptr, readbuf, length);\r\n      png_ptr->num_trans = (png_uint_16)length;\r\n   }\r\n\r\n   else\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid with alpha channel\");\r\n      return;\r\n   }\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n   {\r\n      png_ptr->num_trans = 0;\r\n      return;\r\n   }\r\n\r\n   /* TODO: this is a horrible side effect in the palette case because the\r\n    * png_struct ends up with a pointer to the tRNS buffer owned by the\r\n    * png_info.  Fix this.\r\n    */\r\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\r\n       &(png_ptr->trans_color));\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_bKGD_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_bKGD(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   unsigned int truelen;\r\n   png_byte buf[6];\r\n   png_color_16 background;\r\n\r\n   png_debug(1, \"in png_handle_bKGD\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) ||\r\n      (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\r\n       !(png_ptr->mode & PNG_HAVE_PLTE)))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      truelen = 1;\r\n\r\n   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n      truelen = 6;\r\n\r\n   else\r\n      truelen = 2;\r\n\r\n   if (length != truelen)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buf, truelen);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   /* We convert the index value into RGB components so that we can allow\r\n    * arbitrary RGB values for background when we have transparency, and\r\n    * so it is easy to determine the RGB values of the background color\r\n    * from the info_ptr struct.\r\n    */\r\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n   {\r\n      background.index = buf[0];\r\n\r\n      if (info_ptr && info_ptr->num_palette)\r\n      {\r\n         if (buf[0] >= info_ptr->num_palette)\r\n         {\r\n            png_chunk_benign_error(png_ptr, \"invalid index\");\r\n            return;\r\n         }\r\n\r\n         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;\r\n         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;\r\n         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;\r\n      }\r\n\r\n      else\r\n         background.red = background.green = background.blue = 0;\r\n\r\n      background.gray = 0;\r\n   }\r\n\r\n   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */\r\n   {\r\n      background.index = 0;\r\n      background.red =\r\n      background.green =\r\n      background.blue =\r\n      background.gray = png_get_uint_16(buf);\r\n   }\r\n\r\n   else\r\n   {\r\n      background.index = 0;\r\n      background.red = png_get_uint_16(buf);\r\n      background.green = png_get_uint_16(buf + 2);\r\n      background.blue = png_get_uint_16(buf + 4);\r\n      background.gray = 0;\r\n   }\r\n\r\n   png_set_bKGD(png_ptr, info_ptr, &background);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_hIST_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   unsigned int num, i;\r\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\r\n\r\n   png_debug(1, \"in png_handle_hIST\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) || !(png_ptr->mode & PNG_HAVE_PLTE))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   num = length / 2 ;\r\n\r\n   if (num != png_ptr->num_palette || num > PNG_MAX_PALETTE_LENGTH)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   for (i = 0; i < num; i++)\r\n   {\r\n      png_byte buf[2];\r\n\r\n      png_crc_read(png_ptr, buf, 2);\r\n      readbuf[i] = png_get_uint_16(buf);\r\n   }\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   png_set_hIST(png_ptr, info_ptr, readbuf);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_pHYs_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_pHYs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte buf[9];\r\n   png_uint_32 res_x, res_y;\r\n   int unit_type;\r\n\r\n   png_debug(1, \"in png_handle_pHYs\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   if (length != 9)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buf, 9);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   res_x = png_get_uint_32(buf);\r\n   res_y = png_get_uint_32(buf + 4);\r\n   unit_type = buf[8];\r\n   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_oFFs_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_oFFs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte buf[9];\r\n   png_int_32 offset_x, offset_y;\r\n   int unit_type;\r\n\r\n   png_debug(1, \"in png_handle_oFFs\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   if (length != 9)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buf, 9);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   offset_x = png_get_int_32(buf);\r\n   offset_y = png_get_int_32(buf + 4);\r\n   unit_type = buf[8];\r\n   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_pCAL_SUPPORTED\r\n/* Read the pCAL chunk (described in the PNG Extensions document) */\r\nvoid /* PRIVATE */\r\npng_handle_pCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_int_32 X0, X1;\r\n   png_byte type, nparams;\r\n   png_bytep buffer, buf, units, endptr;\r\n   png_charpp params;\r\n   int i;\r\n\r\n   png_debug(1, \"in png_handle_pCAL\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   png_debug1(2, \"Allocating and reading pCAL chunk data (%u bytes)\",\r\n       length + 1);\r\n\r\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\r\n\r\n   if (buffer == NULL)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of memory\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buffer, length);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   buffer[length] = 0; /* Null terminate the last string */\r\n\r\n   png_debug(3, \"Finding end of pCAL purpose string\");\r\n   for (buf = buffer; *buf; buf++)\r\n      /* Empty loop */ ;\r\n\r\n   endptr = buffer + length;\r\n\r\n   /* We need to have at least 12 bytes after the purpose string\r\n    * in order to get the parameter information.\r\n    */\r\n   if (endptr <= buf + 12)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\");\r\n   X0 = png_get_int_32((png_bytep)buf+1);\r\n   X1 = png_get_int_32((png_bytep)buf+5);\r\n   type = buf[9];\r\n   nparams = buf[10];\r\n   units = buf + 11;\r\n\r\n   png_debug(3, \"Checking pCAL equation type and number of parameters\");\r\n   /* Check that we have the right number of parameters for known\r\n    * equation types.\r\n    */\r\n   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||\r\n       (type == PNG_EQUATION_BASE_E && nparams != 3) ||\r\n       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||\r\n       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"invalid parameter count\");\r\n      return;\r\n   }\r\n\r\n   else if (type >= PNG_EQUATION_LAST)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"unrecognized equation type\");\r\n   }\r\n\r\n   for (buf = units; *buf; buf++)\r\n      /* Empty loop to move past the units string. */ ;\r\n\r\n   png_debug(3, \"Allocating pCAL parameters array\");\r\n\r\n   params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,\r\n       nparams * (sizeof (png_charp))));\r\n\r\n   if (params == NULL)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"out of memory\");\r\n      return;\r\n   }\r\n\r\n   /* Get pointers to the start of each parameter string. */\r\n   for (i = 0; i < nparams; i++)\r\n   {\r\n      buf++; /* Skip the null string terminator from previous parameter. */\r\n\r\n      png_debug1(3, \"Reading pCAL parameter %d\", i);\r\n\r\n      for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)\r\n         /* Empty loop to move past each parameter string */ ;\r\n\r\n      /* Make sure we haven't run out of data yet */\r\n      if (buf > endptr)\r\n      {\r\n         png_free(png_ptr, params);\r\n         png_chunk_benign_error(png_ptr, \"invalid data\");\r\n         return;\r\n      }\r\n   }\r\n\r\n   png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,\r\n      (png_charp)units, params);\r\n\r\n   png_free(png_ptr, params);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_sCAL_SUPPORTED\r\n/* Read the sCAL chunk */\r\nvoid /* PRIVATE */\r\npng_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_bytep buffer;\r\n   png_size_t i;\r\n   int state;\r\n\r\n   png_debug(1, \"in png_handle_sCAL\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of place\");\r\n      return;\r\n   }\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   /* Need unit type, width, \\0, height: minimum 4 bytes */\r\n   else if (length < 4)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_debug1(2, \"Allocating and reading sCAL chunk data (%u bytes)\",\r\n      length + 1);\r\n\r\n   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);\r\n\r\n   if (buffer == NULL)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"out of memory\");\r\n      png_crc_finish(png_ptr, length);\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buffer, length);\r\n   buffer[length] = 0; /* Null terminate the last string */\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   /* Validate the unit. */\r\n   if (buffer[0] != 1 && buffer[0] != 2)\r\n   {\r\n      png_chunk_benign_error(png_ptr, \"invalid unit\");\r\n      return;\r\n   }\r\n\r\n   /* Validate the ASCII numbers, need two ASCII numbers separated by\r\n    * a '\\0' and they need to fit exactly in the chunk data.\r\n    */\r\n   i = 1;\r\n   state = 0;\r\n\r\n   if (!png_check_fp_number((png_const_charp)buffer, length, &state, &i) ||\r\n       i >= length || buffer[i++] != 0)\r\n      png_chunk_benign_error(png_ptr, \"bad width format\");\r\n\r\n   else if (!PNG_FP_IS_POSITIVE(state))\r\n      png_chunk_benign_error(png_ptr, \"non-positive width\");\r\n\r\n   else\r\n   {\r\n      png_size_t heighti = i;\r\n\r\n      state = 0;\r\n      if (!png_check_fp_number((png_const_charp)buffer, length, &state, &i) ||\r\n         i != length)\r\n         png_chunk_benign_error(png_ptr, \"bad height format\");\r\n\r\n      else if (!PNG_FP_IS_POSITIVE(state))\r\n         png_chunk_benign_error(png_ptr, \"non-positive height\");\r\n\r\n      else\r\n         /* This is the (only) success case. */\r\n         png_set_sCAL_s(png_ptr, info_ptr, buffer[0],\r\n            (png_charp)buffer+1, (png_charp)buffer+heighti);\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_tIME_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_handle_tIME(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_byte buf[7];\r\n   png_time mod_time;\r\n\r\n   png_debug(1, \"in png_handle_tIME\");\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"duplicate\");\r\n      return;\r\n   }\r\n\r\n   if (png_ptr->mode & PNG_HAVE_IDAT)\r\n      png_ptr->mode |= PNG_AFTER_IDAT;\r\n\r\n   if (length != 7)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"invalid\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buf, 7);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   mod_time.second = buf[6];\r\n   mod_time.minute = buf[5];\r\n   mod_time.hour = buf[4];\r\n   mod_time.day = buf[3];\r\n   mod_time.month = buf[2];\r\n   mod_time.year = png_get_uint_16(buf);\r\n\r\n   png_set_tIME(png_ptr, info_ptr, &mod_time);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_tEXt_SUPPORTED\r\n/* Note: this does not properly handle chunks that are > 64K under DOS */\r\nvoid /* PRIVATE */\r\npng_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_text  text_info;\r\n   png_bytep buffer;\r\n   png_charp key;\r\n   png_charp text;\r\n   png_uint_32 skip = 0;\r\n\r\n   png_debug(1, \"in png_handle_tEXt\");\r\n\r\n#ifdef PNG_USER_LIMITS_SUPPORTED\r\n   if (png_ptr->user_chunk_cache_max != 0)\r\n   {\r\n      if (png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         return;\r\n      }\r\n\r\n      if (--png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\r\n         return;\r\n      }\r\n   }\r\n#endif\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   if (png_ptr->mode & PNG_HAVE_IDAT)\r\n      png_ptr->mode |= PNG_AFTER_IDAT;\r\n\r\n#ifdef PNG_MAX_MALLOC_64K\r\n   if (length > 65535U)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\r\n      return;\r\n   }\r\n#endif\r\n\r\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\r\n\r\n   if (buffer == NULL)\r\n   {\r\n     png_chunk_benign_error(png_ptr, \"out of memory\");\r\n     return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buffer, length);\r\n\r\n   if (png_crc_finish(png_ptr, skip))\r\n      return;\r\n\r\n   key = (png_charp)buffer;\r\n   key[length] = 0;\r\n\r\n   for (text = key; *text; text++)\r\n      /* Empty loop to find end of key */ ;\r\n\r\n   if (text != key + length)\r\n      text++;\r\n\r\n   text_info.compression = PNG_TEXT_COMPRESSION_NONE;\r\n   text_info.key = key;\r\n   text_info.lang = NULL;\r\n   text_info.lang_key = NULL;\r\n   text_info.itxt_length = 0;\r\n   text_info.text = text;\r\n   text_info.text_length = strlen(text);\r\n\r\n   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1))\r\n      png_warning(png_ptr, \"Insufficient memory to process text chunk\");\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_zTXt_SUPPORTED\r\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\r\nvoid /* PRIVATE */\r\npng_handle_zTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_const_charp errmsg = NULL;\r\n   png_bytep       buffer;\r\n   png_uint_32     keyword_length;\r\n\r\n   png_debug(1, \"in png_handle_zTXt\");\r\n\r\n#ifdef PNG_USER_LIMITS_SUPPORTED\r\n   if (png_ptr->user_chunk_cache_max != 0)\r\n   {\r\n      if (png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         return;\r\n      }\r\n\r\n      if (--png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\r\n         return;\r\n      }\r\n   }\r\n#endif\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   if (png_ptr->mode & PNG_HAVE_IDAT)\r\n      png_ptr->mode |= PNG_AFTER_IDAT;\r\n\r\n   buffer = png_read_buffer(png_ptr, length, 2/*silent*/);\r\n\r\n   if (buffer == NULL)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of memory\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buffer, length);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   /* TODO: also check that the keyword contents match the spec! */\r\n   for (keyword_length = 0;\r\n      keyword_length < length && buffer[keyword_length] != 0;\r\n      ++keyword_length)\r\n      /* Empty loop to find end of name */ ;\r\n\r\n   if (keyword_length > 79 || keyword_length < 1)\r\n      errmsg = \"bad keyword\";\r\n\r\n   /* zTXt must have some LZ data after the keyword, although it may expand to\r\n    * zero bytes; we need a '\\0' at the end of the keyword, the compression type\r\n    * then the LZ data:\r\n    */\r\n   else if (keyword_length + 3 > length)\r\n      errmsg = \"truncated\";\r\n\r\n   else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)\r\n      errmsg = \"unknown compression type\";\r\n\r\n   else\r\n   {\r\n      png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;\r\n\r\n      /* TODO: at present png_decompress_chunk imposes a single application\r\n       * level memory limit, this should be split to different values for iCCP\r\n       * and text chunks.\r\n       */\r\n      if (png_decompress_chunk(png_ptr, length, keyword_length+2,\r\n         &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\r\n      {\r\n         png_text text;\r\n\r\n         /* It worked; png_ptr->read_buffer now looks like a tEXt chunk except\r\n          * for the extra compression type byte and the fact that it isn't\r\n          * necessarily '\\0' terminated.\r\n          */\r\n         buffer = png_ptr->read_buffer;\r\n         buffer[uncompressed_length+(keyword_length+2)] = 0;\r\n\r\n         text.compression = PNG_TEXT_COMPRESSION_zTXt;\r\n         text.key = (png_charp)buffer;\r\n         text.text = (png_charp)(buffer + keyword_length+2);\r\n         text.text_length = uncompressed_length;\r\n         text.itxt_length = 0;\r\n         text.lang = NULL;\r\n         text.lang_key = NULL;\r\n\r\n         if (png_set_text_2(png_ptr, info_ptr, &text, 1))\r\n            errmsg = \"insufficient memory\";\r\n      }\r\n\r\n      else\r\n         errmsg = png_ptr->zstream.msg;\r\n   }\r\n\r\n   if (errmsg != NULL)\r\n      png_chunk_benign_error(png_ptr, errmsg);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_iTXt_SUPPORTED\r\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\r\nvoid /* PRIVATE */\r\npng_handle_iTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\r\n{\r\n   png_const_charp errmsg = NULL;\r\n   png_bytep buffer;\r\n   png_uint_32 prefix_length;\r\n\r\n   png_debug(1, \"in png_handle_iTXt\");\r\n\r\n#ifdef PNG_USER_LIMITS_SUPPORTED\r\n   if (png_ptr->user_chunk_cache_max != 0)\r\n   {\r\n      if (png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         return;\r\n      }\r\n\r\n      if (--png_ptr->user_chunk_cache_max == 1)\r\n      {\r\n         png_crc_finish(png_ptr, length);\r\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\r\n         return;\r\n      }\r\n   }\r\n#endif\r\n\r\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\r\n      png_chunk_error(png_ptr, \"missing IHDR\");\r\n\r\n   if (png_ptr->mode & PNG_HAVE_IDAT)\r\n      png_ptr->mode |= PNG_AFTER_IDAT;\r\n\r\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\r\n\r\n   if (buffer == NULL)\r\n   {\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"out of memory\");\r\n      return;\r\n   }\r\n\r\n   png_crc_read(png_ptr, buffer, length);\r\n\r\n   if (png_crc_finish(png_ptr, 0))\r\n      return;\r\n\r\n   /* First the keyword. */\r\n   for (prefix_length=0;\r\n      prefix_length < length && buffer[prefix_length] != 0;\r\n      ++prefix_length)\r\n      /* Empty loop */ ;\r\n\r\n   /* Perform a basic check on the keyword length here. */\r\n   if (prefix_length > 79 || prefix_length < 1)\r\n      errmsg = \"bad keyword\";\r\n\r\n   /* Expect keyword, compression flag, compression type, language, translated\r\n    * keyword (both may be empty but are 0 terminated) then the text, which may\r\n    * be empty.\r\n    */\r\n   else if (prefix_length + 5 > length)\r\n      errmsg = \"truncated\";\r\n\r\n   else if (buffer[prefix_length+1] == 0 ||\r\n      (buffer[prefix_length+1] == 1 &&\r\n      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))\r\n   {\r\n      int compressed = buffer[prefix_length+1] != 0;\r\n      png_uint_32 language_offset, translated_keyword_offset;\r\n      png_alloc_size_t uncompressed_length = 0;\r\n\r\n      /* Now the language tag */\r\n      prefix_length += 3;\r\n      language_offset = prefix_length;\r\n\r\n      for (; prefix_length < length && buffer[prefix_length] != 0;\r\n         ++prefix_length)\r\n         /* Empty loop */ ;\r\n\r\n      /* WARNING: the length may be invalid here, this is checked below. */\r\n      translated_keyword_offset = ++prefix_length;\r\n\r\n      for (; prefix_length < length && buffer[prefix_length] != 0;\r\n         ++prefix_length)\r\n         /* Empty loop */ ;\r\n\r\n      /* prefix_length should now be at the trailing '\\0' of the translated\r\n       * keyword, but it may already be over the end.  None of this arithmetic\r\n       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit\r\n       * systems the available allocaton may overflow.\r\n       */\r\n      ++prefix_length;\r\n\r\n      if (!compressed && prefix_length <= length)\r\n         uncompressed_length = length - prefix_length;\r\n\r\n      else if (compressed && prefix_length < length)\r\n      {\r\n         uncompressed_length = PNG_SIZE_MAX;\r\n\r\n         /* TODO: at present png_decompress_chunk imposes a single application\r\n          * level memory limit, this should be split to different values for\r\n          * iCCP and text chunks.\r\n          */\r\n         if (png_decompress_chunk(png_ptr, length, prefix_length,\r\n            &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\r\n            buffer = png_ptr->read_buffer;\r\n\r\n         else\r\n            errmsg = png_ptr->zstream.msg;\r\n      }\r\n\r\n      else\r\n         errmsg = \"truncated\";\r\n\r\n      if (errmsg == NULL)\r\n      {\r\n         png_text text;\r\n\r\n         buffer[uncompressed_length+prefix_length] = 0;\r\n\r\n         if (compressed)\r\n            text.compression = PNG_ITXT_COMPRESSION_NONE;\r\n\r\n         else\r\n            text.compression = PNG_ITXT_COMPRESSION_zTXt;\r\n\r\n         text.key = (png_charp)buffer;\r\n         text.lang = (png_charp)buffer + language_offset;\r\n         text.lang_key = (png_charp)buffer + translated_keyword_offset;\r\n         text.text = (png_charp)buffer + prefix_length;\r\n         text.text_length = 0;\r\n         text.itxt_length = uncompressed_length;\r\n\r\n         if (png_set_text_2(png_ptr, info_ptr, &text, 1))\r\n            errmsg = \"insufficient memory\";\r\n      }\r\n   }\r\n\r\n   else\r\n      errmsg = \"bad compression info\";\r\n\r\n   if (errmsg != NULL)\r\n      png_chunk_benign_error(png_ptr, errmsg);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\r\n/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */\r\nstatic int\r\npng_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)\r\n{\r\n   png_alloc_size_t limit = PNG_SIZE_MAX;\r\n\r\n   if (png_ptr->unknown_chunk.data != NULL)\r\n   {\r\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\r\n      png_ptr->unknown_chunk.data = NULL;\r\n   }\r\n\r\n#  ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED\r\n      if (png_ptr->user_chunk_malloc_max > 0 &&\r\n         png_ptr->user_chunk_malloc_max < limit)\r\n         limit = png_ptr->user_chunk_malloc_max;\r\n\r\n#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\r\n      if (PNG_USER_CHUNK_MALLOC_MAX < limit)\r\n         limit = PNG_USER_CHUNK_MALLOC_MAX;\r\n#  endif\r\n\r\n   if (length <= limit)\r\n   {\r\n      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);\r\n      /* The following is safe because of the PNG_SIZE_MAX init above */\r\n      png_ptr->unknown_chunk.size = (png_size_t)length/*SAFE*/;\r\n      /* 'mode' is a flag array, only the bottom four bits matter here */\r\n      png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;\r\n\r\n      if (length == 0)\r\n         png_ptr->unknown_chunk.data = NULL;\r\n\r\n      else\r\n      {\r\n         /* Do a 'warn' here - it is handled below. */\r\n         png_ptr->unknown_chunk.data = png_voidcast(png_bytep,\r\n            png_malloc_warn(png_ptr, length));\r\n      }\r\n   }\r\n\r\n   if (png_ptr->unknown_chunk.data == NULL && length > 0)\r\n   {\r\n      /* This is benign because we clean up correctly */\r\n      png_crc_finish(png_ptr, length);\r\n      png_chunk_benign_error(png_ptr, \"unknown chunk exceeds memory limits\");\r\n      return 0;\r\n   }\r\n\r\n   else\r\n   {\r\n      if (length > 0)\r\n         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);\r\n      png_crc_finish(png_ptr, 0);\r\n      return 1;\r\n   }\r\n}\r\n#endif /* PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */\r\n\r\n/* Handle an unknown, or known but disabled, chunk */\r\nvoid /* PRIVATE */\r\npng_handle_unknown(png_structrp png_ptr, png_inforp info_ptr,\r\n   png_uint_32 length, int keep)\r\n{\r\n   int handled = 0; /* the chunk was handled */\r\n\r\n   png_debug(1, \"in png_handle_unknown\");\r\n\r\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\r\n   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing\r\n    * the bug which meant that setting a non-default behavior for a specific\r\n    * chunk would be ignored (the default was always used unless a user\r\n    * callback was installed).\r\n    *\r\n    * 'keep' is the value from the png_chunk_unknown_handling, the setting for\r\n    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it\r\n    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.\r\n    * This is just an optimization to avoid multiple calls to the lookup\r\n    * function.\r\n    */\r\n#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\n#     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\r\n         keep = png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name);\r\n#     endif\r\n#  endif\r\n\r\n   /* One of the following methods will read the chunk or skip it (at least one\r\n    * of these is always defined because this is the only way to switch on\r\n    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\r\n    */\r\n#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED\r\n      /* The user callback takes precedence over the chunk keep value, but the\r\n       * keep value is still required to validate a save of a critical chunk.\r\n       */\r\n      if (png_ptr->read_user_chunk_fn != NULL)\r\n      {\r\n         if (png_cache_unknown_chunk(png_ptr, length))\r\n         {\r\n            /* Callback to user unknown chunk handler */\r\n            int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,\r\n               &png_ptr->unknown_chunk);\r\n\r\n            /* ret is:\r\n             * negative: An error occured, png_chunk_error will be called.\r\n             *     zero: The chunk was not handled, the chunk will be discarded\r\n             *           unless png_set_keep_unknown_chunks has been used to set\r\n             *           a 'keep' behavior for this particular chunk, in which\r\n             *           case that will be used.  A critical chunk will cause an\r\n             *           error at this point unless it is to be saved.\r\n             * positive: The chunk was handled, libpng will ignore/discard it.\r\n             */\r\n            if (ret < 0)\r\n               png_chunk_error(png_ptr, \"error in user chunk\");\r\n\r\n            else if (ret == 0)\r\n            {\r\n               /* If the keep value is 'default' or 'never' override it, but\r\n                * still error out on critical chunks unless the keep value is\r\n                * 'always'  While this is weird it is the behavior in 1.4.12.\r\n                * A possible improvement would be to obey the value set for the\r\n                * chunk, but this would be an API change that would probably\r\n                * damage some applications.\r\n                *\r\n                * The png_app_warning below catches the case that matters, where\r\n                * the application has not set specific save or ignore for this\r\n                * chunk or global save or ignore.\r\n                */\r\n               if (keep < PNG_HANDLE_CHUNK_IF_SAFE)\r\n               {\r\n#                 ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\r\n                     if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)\r\n                     {\r\n                        png_chunk_warning(png_ptr, \"Saving unknown chunk:\");\r\n                        png_app_warning(png_ptr,\r\n                           \"forcing save of an unhandled chunk;\"\r\n                           \" please call png_set_keep_unknown_chunks\");\r\n                           /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */\r\n                     }\r\n#                 endif\r\n                  keep = PNG_HANDLE_CHUNK_IF_SAFE;\r\n               }\r\n            }\r\n\r\n            else /* chunk was handled */\r\n            {\r\n               handled = 1;\r\n               /* Critical chunks can be safely discarded at this point. */\r\n               keep = PNG_HANDLE_CHUNK_NEVER;\r\n            }\r\n         }\r\n\r\n         else\r\n            keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */\r\n      }\r\n\r\n      else\r\n         /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */\r\n#  endif /* PNG_READ_USER_CHUNKS_SUPPORTED */\r\n\r\n#  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED\r\n      {\r\n         /* keep is currently just the per-chunk setting, if there was no\r\n          * setting change it to the global default now (not that this may\r\n          * still be AS_DEFAULT) then obtain the cache of the chunk if required,\r\n          * if not simply skip the chunk.\r\n          */\r\n         if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\r\n            keep = png_ptr->unknown_default;\r\n\r\n         if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\r\n            (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\r\n             PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\r\n         {\r\n            if (!png_cache_unknown_chunk(png_ptr, length))\r\n               keep = PNG_HANDLE_CHUNK_NEVER;\r\n         }\r\n\r\n         else\r\n            png_crc_finish(png_ptr, length);\r\n      }\r\n#  else\r\n#     ifndef PNG_READ_USER_CHUNKS_SUPPORTED\r\n#        error no method to support READ_UNKNOWN_CHUNKS\r\n#     endif\r\n\r\n      {\r\n         /* If here there is no read callback pointer set and no support is\r\n          * compiled in to just save the unknown chunks, so simply skip this\r\n          * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then\r\n          * the app has erroneously asked for unknown chunk saving when there\r\n          * is no support.\r\n          */\r\n         if (keep > PNG_HANDLE_CHUNK_NEVER)\r\n            png_app_error(png_ptr, \"no unknown chunk support available\");\r\n\r\n         png_crc_finish(png_ptr, length);\r\n      }\r\n#  endif\r\n\r\n#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\r\n      /* Now store the chunk in the chunk list if appropriate, and if the limits\r\n       * permit it.\r\n       */\r\n      if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\r\n         (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\r\n          PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\r\n      {\r\n#     ifdef PNG_USER_LIMITS_SUPPORTED\r\n         switch (png_ptr->user_chunk_cache_max)\r\n         {\r\n            case 2:\r\n               png_ptr->user_chunk_cache_max = 1;\r\n               png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\r\n               /* FALL THROUGH */\r\n            case 1:\r\n               /* NOTE: prior to 1.6.0 this case resulted in an unknown critical\r\n                * chunk being skipped, now there will be a hard error below.\r\n                */\r\n               break;\r\n\r\n            default: /* not at limit */\r\n               --(png_ptr->user_chunk_cache_max);\r\n               /* FALL THROUGH */\r\n            case 0: /* no limit */\r\n#     endif /* PNG_USER_LIMITS_SUPPORTED */\r\n               /* Here when the limit isn't reached or when limits are compiled\r\n                * out; store the chunk.\r\n                */\r\n               png_set_unknown_chunks(png_ptr, info_ptr,\r\n                  &png_ptr->unknown_chunk, 1);\r\n               handled = 1;\r\n#     ifdef PNG_USER_LIMITS_SUPPORTED\r\n               break;\r\n         }\r\n#     endif\r\n      }\r\n#  else /* no store support: the chunk must be handled by the user callback */\r\n      PNG_UNUSED(info_ptr)\r\n#  endif\r\n\r\n   /* Regardless of the error handling below the cached data (if any) can be\r\n    * freed now.  Notice that the data is not freed if there is a png_error, but\r\n    * it will be freed by destroy_read_struct.\r\n    */\r\n   if (png_ptr->unknown_chunk.data != NULL)\r\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\r\n   png_ptr->unknown_chunk.data = NULL;\r\n\r\n#else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */\r\n   /* There is no support to read an unknown chunk, so just skip it. */\r\n   png_crc_finish(png_ptr, length);\r\n   PNG_UNUSED(info_ptr)\r\n   PNG_UNUSED(keep)\r\n#endif /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */\r\n\r\n   /* Check for unhandled critical chunks */\r\n   if (!handled && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\r\n      png_chunk_error(png_ptr, \"unhandled critical chunk\");\r\n}\r\n\r\n/* This function is called to verify that a chunk name is valid.\r\n * This function can't have the \"critical chunk check\" incorporated\r\n * into it, since in the future we will need to be able to call user\r\n * functions to handle unknown critical chunks after we check that\r\n * the chunk name itself is valid.\r\n */\r\n\r\n/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:\r\n *\r\n * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\r\n */\r\n\r\nvoid /* PRIVATE */\r\npng_check_chunk_name(png_structrp png_ptr, png_uint_32 chunk_name)\r\n{\r\n   int i;\r\n\r\n   png_debug(1, \"in png_check_chunk_name\");\r\n\r\n   for (i=1; i<=4; ++i)\r\n   {\r\n      int c = chunk_name & 0xff;\r\n\r\n      if (c < 65 || c > 122 || (c > 90 && c < 97))\r\n         png_chunk_error(png_ptr, \"invalid chunk type\");\r\n\r\n      chunk_name >>= 8;\r\n   }\r\n}\r\n\r\n/* Combines the row recently read in with the existing pixels in the row.  This\r\n * routine takes care of alpha and transparency if requested.  This routine also\r\n * handles the two methods of progressive display of interlaced images,\r\n * depending on the 'display' value; if 'display' is true then the whole row\r\n * (dp) is filled from the start by replicating the available pixels.  If\r\n * 'display' is false only those pixels present in the pass are filled in.\r\n */\r\nvoid /* PRIVATE */\r\npng_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)\r\n{\r\n   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;\r\n   png_const_bytep sp = png_ptr->row_buf + 1;\r\n   png_uint_32 row_width = png_ptr->width;\r\n   unsigned int pass = png_ptr->pass;\r\n   png_bytep end_ptr = 0;\r\n   png_byte end_byte = 0;\r\n   unsigned int end_mask;\r\n\r\n   png_debug(1, \"in png_combine_row\");\r\n\r\n   /* Added in 1.5.6: it should not be possible to enter this routine until at\r\n    * least one row has been read from the PNG data and transformed.\r\n    */\r\n   if (pixel_depth == 0)\r\n      png_error(png_ptr, \"internal row logic error\");\r\n\r\n   /* Added in 1.5.4: the pixel depth should match the information returned by\r\n    * any call to png_read_update_info at this point.  Do not continue if we got\r\n    * this wrong.\r\n    */\r\n   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=\r\n          PNG_ROWBYTES(pixel_depth, row_width))\r\n      png_error(png_ptr, \"internal row size calculation error\");\r\n\r\n   /* Don't expect this to ever happen: */\r\n   if (row_width == 0)\r\n      png_error(png_ptr, \"internal row width error\");\r\n\r\n   /* Preserve the last byte in cases where only part of it will be overwritten,\r\n    * the multiply below may overflow, we don't care because ANSI-C guarantees\r\n    * we get the low bits.\r\n    */\r\n   end_mask = (pixel_depth * row_width) & 7;\r\n   if (end_mask != 0)\r\n   {\r\n      /* end_ptr == NULL is a flag to say do nothing */\r\n      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;\r\n      end_byte = *end_ptr;\r\n#     ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n         if (png_ptr->transformations & PNG_PACKSWAP) /* little-endian byte */\r\n            end_mask = 0xff << end_mask;\r\n\r\n         else /* big-endian byte */\r\n#     endif\r\n         end_mask = 0xff >> end_mask;\r\n      /* end_mask is now the bits to *keep* from the destination row */\r\n   }\r\n\r\n   /* For non-interlaced images this reduces to a memcpy(). A memcpy()\r\n    * will also happen if interlacing isn't supported or if the application\r\n    * does not call png_set_interlace_handling().  In the latter cases the\r\n    * caller just gets a sequence of the unexpanded rows from each interlace\r\n    * pass.\r\n    */\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE) &&\r\n      pass < 6 && (display == 0 ||\r\n      /* The following copies everything for 'display' on passes 0, 2 and 4. */\r\n      (display == 1 && (pass & 1) != 0)))\r\n   {\r\n      /* Narrow images may have no bits in a pass; the caller should handle\r\n       * this, but this test is cheap:\r\n       */\r\n      if (row_width <= PNG_PASS_START_COL(pass))\r\n         return;\r\n\r\n      if (pixel_depth < 8)\r\n      {\r\n         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit\r\n          * into 32 bits, then a single loop over the bytes using the four byte\r\n          * values in the 32-bit mask can be used.  For the 'display' option the\r\n          * expanded mask may also not require any masking within a byte.  To\r\n          * make this work the PACKSWAP option must be taken into account - it\r\n          * simply requires the pixels to be reversed in each byte.\r\n          *\r\n          * The 'regular' case requires a mask for each of the first 6 passes,\r\n          * the 'display' case does a copy for the even passes in the range\r\n          * 0..6.  This has already been handled in the test above.\r\n          *\r\n          * The masks are arranged as four bytes with the first byte to use in\r\n          * the lowest bits (little-endian) regardless of the order (PACKSWAP or\r\n          * not) of the pixels in each byte.\r\n          *\r\n          * NOTE: the whole of this logic depends on the caller of this function\r\n          * only calling it on rows appropriate to the pass.  This function only\r\n          * understands the 'x' logic; the 'y' logic is handled by the caller.\r\n          *\r\n          * The following defines allow generation of compile time constant bit\r\n          * masks for each pixel depth and each possibility of swapped or not\r\n          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,\r\n          * is in the range 0..7; and the result is 1 if the pixel is to be\r\n          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'\r\n          * for the block method.\r\n          *\r\n          * With some compilers a compile time expression of the general form:\r\n          *\r\n          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)\r\n          *\r\n          * Produces warnings with values of 'shift' in the range 33 to 63\r\n          * because the right hand side of the ?: expression is evaluated by\r\n          * the compiler even though it isn't used.  Microsoft Visual C (various\r\n          * versions) and the Intel C compiler are known to do this.  To avoid\r\n          * this the following macros are used in 1.5.6.  This is a temporary\r\n          * solution to avoid destabilizing the code during the release process.\r\n          */\r\n#        if PNG_USE_COMPILE_TIME_MASKS\r\n#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))\r\n#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))\r\n#        else\r\n#           define PNG_LSR(x,s) ((x)>>(s))\r\n#           define PNG_LSL(x,s) ((x)<<(s))\r\n#        endif\r\n#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\\\r\n           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)\r\n#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\\\r\n           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)\r\n\r\n         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is\r\n          * little endian - the first pixel is at bit 0 - however the extra\r\n          * parameter 's' can be set to cause the mask position to be swapped\r\n          * within each byte, to match the PNG format.  This is done by XOR of\r\n          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.\r\n          */\r\n#        define PIXEL_MASK(p,x,d,s) \\\r\n            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))\r\n\r\n         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.\r\n          */\r\n#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\r\n#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\r\n\r\n         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp\r\n          * cases the result needs replicating, for the 4-bpp case the above\r\n          * generates a full 32 bits.\r\n          */\r\n#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))\r\n\r\n#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\\\r\n            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\\\r\n            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)\r\n\r\n#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\\\r\n            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\\\r\n            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)\r\n\r\n#if PNG_USE_COMPILE_TIME_MASKS\r\n         /* Utility macros to construct all the masks for a depth/swap\r\n          * combination.  The 's' parameter says whether the format is PNG\r\n          * (big endian bytes) or not.  Only the three odd-numbered passes are\r\n          * required for the display/block algorithm.\r\n          */\r\n#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\\\r\n            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }\r\n\r\n#        define B_MASKS(d,s) { B_MASK(1,d,s), S_MASK(3,d,s), S_MASK(5,d,s) }\r\n\r\n#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))\r\n\r\n         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and\r\n          * then pass:\r\n          */\r\n         static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =\r\n         {\r\n            /* Little-endian byte masks for PACKSWAP */\r\n            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },\r\n            /* Normal (big-endian byte) masks - PNG format */\r\n            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }\r\n         };\r\n\r\n         /* display_mask has only three entries for the odd passes, so index by\r\n          * pass>>1.\r\n          */\r\n         static PNG_CONST png_uint_32 display_mask[2][3][3] =\r\n         {\r\n            /* Little-endian byte masks for PACKSWAP */\r\n            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },\r\n            /* Normal (big-endian byte) masks - PNG format */\r\n            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }\r\n         };\r\n\r\n#        define MASK(pass,depth,display,png)\\\r\n            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\\\r\n               row_mask[png][DEPTH_INDEX(depth)][pass])\r\n\r\n#else /* !PNG_USE_COMPILE_TIME_MASKS */\r\n         /* This is the runtime alternative: it seems unlikely that this will\r\n          * ever be either smaller or faster than the compile time approach.\r\n          */\r\n#        define MASK(pass,depth,display,png)\\\r\n            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))\r\n#endif /* !PNG_USE_COMPILE_TIME_MASKS */\r\n\r\n         /* Use the appropriate mask to copy the required bits.  In some cases\r\n          * the byte mask will be 0 or 0xff, optimize these cases.  row_width is\r\n          * the number of pixels, but the code copies bytes, so it is necessary\r\n          * to special case the end.\r\n          */\r\n         png_uint_32 pixels_per_byte = 8 / pixel_depth;\r\n         png_uint_32 mask;\r\n\r\n#        ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n            if (png_ptr->transformations & PNG_PACKSWAP)\r\n               mask = MASK(pass, pixel_depth, display, 0);\r\n\r\n            else\r\n#        endif\r\n            mask = MASK(pass, pixel_depth, display, 1);\r\n\r\n         for (;;)\r\n         {\r\n            png_uint_32 m;\r\n\r\n            /* It doesn't matter in the following if png_uint_32 has more than\r\n             * 32 bits because the high bits always match those in m<<24; it is,\r\n             * however, essential to use OR here, not +, because of this.\r\n             */\r\n            m = mask;\r\n            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */\r\n            m &= 0xff;\r\n\r\n            if (m != 0) /* something to copy */\r\n            {\r\n               if (m != 0xff)\r\n                  *dp = (png_byte)((*dp & ~m) | (*sp & m));\r\n               else\r\n                  *dp = *sp;\r\n            }\r\n\r\n            /* NOTE: this may overwrite the last byte with garbage if the image\r\n             * is not an exact number of bytes wide; libpng has always done\r\n             * this.\r\n             */\r\n            if (row_width <= pixels_per_byte)\r\n               break; /* May need to restore part of the last byte */\r\n\r\n            row_width -= pixels_per_byte;\r\n            ++dp;\r\n            ++sp;\r\n         }\r\n      }\r\n\r\n      else /* pixel_depth >= 8 */\r\n      {\r\n         unsigned int bytes_to_copy, bytes_to_jump;\r\n\r\n         /* Validate the depth - it must be a multiple of 8 */\r\n         if (pixel_depth & 7)\r\n            png_error(png_ptr, \"invalid user transform pixel depth\");\r\n\r\n         pixel_depth >>= 3; /* now in bytes */\r\n         row_width *= pixel_depth;\r\n\r\n         /* Regardless of pass number the Adam 7 interlace always results in a\r\n          * fixed number of pixels to copy then to skip.  There may be a\r\n          * different number of pixels to skip at the start though.\r\n          */\r\n         {\r\n            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;\r\n\r\n            row_width -= offset;\r\n            dp += offset;\r\n            sp += offset;\r\n         }\r\n\r\n         /* Work out the bytes to copy. */\r\n         if (display)\r\n         {\r\n            /* When doing the 'block' algorithm the pixel in the pass gets\r\n             * replicated to adjacent pixels.  This is why the even (0,2,4,6)\r\n             * passes are skipped above - the entire expanded row is copied.\r\n             */\r\n            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;\r\n\r\n            /* But don't allow this number to exceed the actual row width. */\r\n            if (bytes_to_copy > row_width)\r\n               bytes_to_copy = row_width;\r\n         }\r\n\r\n         else /* normal row; Adam7 only ever gives us one pixel to copy. */\r\n            bytes_to_copy = pixel_depth;\r\n\r\n         /* In Adam7 there is a constant offset between where the pixels go. */\r\n         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;\r\n\r\n         /* And simply copy these bytes.  Some optimization is possible here,\r\n          * depending on the value of 'bytes_to_copy'.  Special case the low\r\n          * byte counts, which we know to be frequent.\r\n          *\r\n          * Notice that these cases all 'return' rather than 'break' - this\r\n          * avoids an unnecessary test on whether to restore the last byte\r\n          * below.\r\n          */\r\n         switch (bytes_to_copy)\r\n         {\r\n            case 1:\r\n               for (;;)\r\n               {\r\n                  *dp = *sp;\r\n\r\n                  if (row_width <= bytes_to_jump)\r\n                     return;\r\n\r\n                  dp += bytes_to_jump;\r\n                  sp += bytes_to_jump;\r\n                  row_width -= bytes_to_jump;\r\n               }\r\n\r\n            case 2:\r\n               /* There is a possibility of a partial copy at the end here; this\r\n                * slows the code down somewhat.\r\n                */\r\n               do\r\n               {\r\n                  dp[0] = sp[0], dp[1] = sp[1];\r\n\r\n                  if (row_width <= bytes_to_jump)\r\n                     return;\r\n\r\n                  sp += bytes_to_jump;\r\n                  dp += bytes_to_jump;\r\n                  row_width -= bytes_to_jump;\r\n               }\r\n               while (row_width > 1);\r\n\r\n               /* And there can only be one byte left at this point: */\r\n               *dp = *sp;\r\n               return;\r\n\r\n            case 3:\r\n               /* This can only be the RGB case, so each copy is exactly one\r\n                * pixel and it is not necessary to check for a partial copy.\r\n                */\r\n               for(;;)\r\n               {\r\n                  dp[0] = sp[0], dp[1] = sp[1], dp[2] = sp[2];\r\n\r\n                  if (row_width <= bytes_to_jump)\r\n                     return;\r\n\r\n                  sp += bytes_to_jump;\r\n                  dp += bytes_to_jump;\r\n                  row_width -= bytes_to_jump;\r\n               }\r\n\r\n            default:\r\n#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE\r\n               /* Check for double byte alignment and, if possible, use a\r\n                * 16-bit copy.  Don't attempt this for narrow images - ones that\r\n                * are less than an interlace panel wide.  Don't attempt it for\r\n                * wide bytes_to_copy either - use the memcpy there.\r\n                */\r\n               if (bytes_to_copy < 16 /*else use memcpy*/ &&\r\n                  png_isaligned(dp, png_uint_16) &&\r\n                  png_isaligned(sp, png_uint_16) &&\r\n                  bytes_to_copy % (sizeof (png_uint_16)) == 0 &&\r\n                  bytes_to_jump % (sizeof (png_uint_16)) == 0)\r\n               {\r\n                  /* Everything is aligned for png_uint_16 copies, but try for\r\n                   * png_uint_32 first.\r\n                   */\r\n                  if (png_isaligned(dp, png_uint_32) &&\r\n                     png_isaligned(sp, png_uint_32) &&\r\n                     bytes_to_copy % (sizeof (png_uint_32)) == 0 &&\r\n                     bytes_to_jump % (sizeof (png_uint_32)) == 0)\r\n                  {\r\n                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);\r\n                     png_const_uint_32p sp32 = png_aligncastconst(\r\n                        png_const_uint_32p, sp);\r\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\r\n                        (sizeof (png_uint_32));\r\n\r\n                     do\r\n                     {\r\n                        size_t c = bytes_to_copy;\r\n                        do\r\n                        {\r\n                           *dp32++ = *sp32++;\r\n                           c -= (sizeof (png_uint_32));\r\n                        }\r\n                        while (c > 0);\r\n\r\n                        if (row_width <= bytes_to_jump)\r\n                           return;\r\n\r\n                        dp32 += skip;\r\n                        sp32 += skip;\r\n                        row_width -= bytes_to_jump;\r\n                     }\r\n                     while (bytes_to_copy <= row_width);\r\n\r\n                     /* Get to here when the row_width truncates the final copy.\r\n                      * There will be 1-3 bytes left to copy, so don't try the\r\n                      * 16-bit loop below.\r\n                      */\r\n                     dp = (png_bytep)dp32;\r\n                     sp = (png_const_bytep)sp32;\r\n                     do\r\n                        *dp++ = *sp++;\r\n                     while (--row_width > 0);\r\n                     return;\r\n                  }\r\n\r\n                  /* Else do it in 16-bit quantities, but only if the size is\r\n                   * not too large.\r\n                   */\r\n                  else\r\n                  {\r\n                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);\r\n                     png_const_uint_16p sp16 = png_aligncastconst(\r\n                        png_const_uint_16p, sp);\r\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\r\n                        (sizeof (png_uint_16));\r\n\r\n                     do\r\n                     {\r\n                        size_t c = bytes_to_copy;\r\n                        do\r\n                        {\r\n                           *dp16++ = *sp16++;\r\n                           c -= (sizeof (png_uint_16));\r\n                        }\r\n                        while (c > 0);\r\n\r\n                        if (row_width <= bytes_to_jump)\r\n                           return;\r\n\r\n                        dp16 += skip;\r\n                        sp16 += skip;\r\n                        row_width -= bytes_to_jump;\r\n                     }\r\n                     while (bytes_to_copy <= row_width);\r\n\r\n                     /* End of row - 1 byte left, bytes_to_copy > row_width: */\r\n                     dp = (png_bytep)dp16;\r\n                     sp = (png_const_bytep)sp16;\r\n                     do\r\n                        *dp++ = *sp++;\r\n                     while (--row_width > 0);\r\n                     return;\r\n                  }\r\n               }\r\n#endif /* PNG_ALIGN_ code */\r\n\r\n               /* The true default - use a memcpy: */\r\n               for (;;)\r\n               {\r\n                  memcpy(dp, sp, bytes_to_copy);\r\n\r\n                  if (row_width <= bytes_to_jump)\r\n                     return;\r\n\r\n                  sp += bytes_to_jump;\r\n                  dp += bytes_to_jump;\r\n                  row_width -= bytes_to_jump;\r\n                  if (bytes_to_copy > row_width)\r\n                     bytes_to_copy = row_width;\r\n               }\r\n         }\r\n\r\n         /* NOT REACHED*/\r\n      } /* pixel_depth >= 8 */\r\n\r\n      /* Here if pixel_depth < 8 to check 'end_ptr' below. */\r\n   }\r\n   else\r\n#endif\r\n\r\n   /* If here then the switch above wasn't used so just memcpy the whole row\r\n    * from the temporary row buffer (notice that this overwrites the end of the\r\n    * destination row if it is a partial byte.)\r\n    */\r\n   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));\r\n\r\n   /* Restore the overwritten bits from the last byte if necessary. */\r\n   if (end_ptr != NULL)\r\n      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\r\n}\r\n\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,\r\n   png_uint_32 transformations /* Because these may affect the byte layout */)\r\n{\r\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\r\n   /* Offset to next interlace block */\r\n   static PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\r\n\r\n   png_debug(1, \"in png_do_read_interlace\");\r\n   if (row != NULL && row_info != NULL)\r\n   {\r\n      png_uint_32 final_width;\r\n\r\n      final_width = row_info->width * png_pass_inc[pass];\r\n\r\n      switch (row_info->pixel_depth)\r\n      {\r\n         case 1:\r\n         {\r\n            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);\r\n            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);\r\n            int sshift, dshift;\r\n            int s_start, s_end, s_inc;\r\n            int jstop = png_pass_inc[pass];\r\n            png_byte v;\r\n            png_uint_32 i;\r\n            int j;\r\n\r\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n            if (transformations & PNG_PACKSWAP)\r\n            {\r\n                sshift = (int)((row_info->width + 7) & 0x07);\r\n                dshift = (int)((final_width + 7) & 0x07);\r\n                s_start = 7;\r\n                s_end = 0;\r\n                s_inc = -1;\r\n            }\r\n\r\n            else\r\n#endif\r\n            {\r\n                sshift = 7 - (int)((row_info->width + 7) & 0x07);\r\n                dshift = 7 - (int)((final_width + 7) & 0x07);\r\n                s_start = 0;\r\n                s_end = 7;\r\n                s_inc = 1;\r\n            }\r\n\r\n            for (i = 0; i < row_info->width; i++)\r\n            {\r\n               v = (png_byte)((*sp >> sshift) & 0x01);\r\n               for (j = 0; j < jstop; j++)\r\n               {\r\n                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));\r\n                  tmp |= v << dshift;\r\n                  *dp = (png_byte)(tmp & 0xff);\r\n\r\n                  if (dshift == s_end)\r\n                  {\r\n                     dshift = s_start;\r\n                     dp--;\r\n                  }\r\n\r\n                  else\r\n                     dshift += s_inc;\r\n               }\r\n\r\n               if (sshift == s_end)\r\n               {\r\n                  sshift = s_start;\r\n                  sp--;\r\n               }\r\n\r\n               else\r\n                  sshift += s_inc;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case 2:\r\n         {\r\n            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);\r\n            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);\r\n            int sshift, dshift;\r\n            int s_start, s_end, s_inc;\r\n            int jstop = png_pass_inc[pass];\r\n            png_uint_32 i;\r\n\r\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n            if (transformations & PNG_PACKSWAP)\r\n            {\r\n               sshift = (int)(((row_info->width + 3) & 0x03) << 1);\r\n               dshift = (int)(((final_width + 3) & 0x03) << 1);\r\n               s_start = 6;\r\n               s_end = 0;\r\n               s_inc = -2;\r\n            }\r\n\r\n            else\r\n#endif\r\n            {\r\n               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);\r\n               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);\r\n               s_start = 0;\r\n               s_end = 6;\r\n               s_inc = 2;\r\n            }\r\n\r\n            for (i = 0; i < row_info->width; i++)\r\n            {\r\n               png_byte v;\r\n               int j;\r\n\r\n               v = (png_byte)((*sp >> sshift) & 0x03);\r\n               for (j = 0; j < jstop; j++)\r\n               {\r\n                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));\r\n                  tmp |= v << dshift;\r\n                  *dp = (png_byte)(tmp & 0xff);\r\n\r\n                  if (dshift == s_end)\r\n                  {\r\n                     dshift = s_start;\r\n                     dp--;\r\n                  }\r\n\r\n                  else\r\n                     dshift += s_inc;\r\n               }\r\n\r\n               if (sshift == s_end)\r\n               {\r\n                  sshift = s_start;\r\n                  sp--;\r\n               }\r\n\r\n               else\r\n                  sshift += s_inc;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case 4:\r\n         {\r\n            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);\r\n            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);\r\n            int sshift, dshift;\r\n            int s_start, s_end, s_inc;\r\n            png_uint_32 i;\r\n            int jstop = png_pass_inc[pass];\r\n\r\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\r\n            if (transformations & PNG_PACKSWAP)\r\n            {\r\n               sshift = (int)(((row_info->width + 1) & 0x01) << 2);\r\n               dshift = (int)(((final_width + 1) & 0x01) << 2);\r\n               s_start = 4;\r\n               s_end = 0;\r\n               s_inc = -4;\r\n            }\r\n\r\n            else\r\n#endif\r\n            {\r\n               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);\r\n               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);\r\n               s_start = 0;\r\n               s_end = 4;\r\n               s_inc = 4;\r\n            }\r\n\r\n            for (i = 0; i < row_info->width; i++)\r\n            {\r\n               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);\r\n               int j;\r\n\r\n               for (j = 0; j < jstop; j++)\r\n               {\r\n                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));\r\n                  tmp |= v << dshift;\r\n                  *dp = (png_byte)(tmp & 0xff);\r\n\r\n                  if (dshift == s_end)\r\n                  {\r\n                     dshift = s_start;\r\n                     dp--;\r\n                  }\r\n\r\n                  else\r\n                     dshift += s_inc;\r\n               }\r\n\r\n               if (sshift == s_end)\r\n               {\r\n                  sshift = s_start;\r\n                  sp--;\r\n               }\r\n\r\n               else\r\n                  sshift += s_inc;\r\n            }\r\n            break;\r\n         }\r\n\r\n         default:\r\n         {\r\n            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);\r\n\r\n            png_bytep sp = row + (png_size_t)(row_info->width - 1)\r\n                * pixel_bytes;\r\n\r\n            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;\r\n\r\n            int jstop = png_pass_inc[pass];\r\n            png_uint_32 i;\r\n\r\n            for (i = 0; i < row_info->width; i++)\r\n            {\r\n               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */\r\n               int j;\r\n\r\n               memcpy(v, sp, pixel_bytes);\r\n\r\n               for (j = 0; j < jstop; j++)\r\n               {\r\n                  memcpy(dp, v, pixel_bytes);\r\n                  dp -= pixel_bytes;\r\n               }\r\n\r\n               sp -= pixel_bytes;\r\n            }\r\n            break;\r\n         }\r\n      }\r\n\r\n      row_info->width = final_width;\r\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);\r\n   }\r\n#ifndef PNG_READ_PACKSWAP_SUPPORTED\r\n   PNG_UNUSED(transformations)  /* Silence compiler warning */\r\n#endif\r\n}\r\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\r\n\r\nstatic void\r\npng_read_filter_row_sub(png_row_infop row_info, png_bytep row,\r\n   png_const_bytep prev_row)\r\n{\r\n   png_size_t i;\r\n   png_size_t istop = row_info->rowbytes;\r\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\r\n   png_bytep rp = row + bpp;\r\n\r\n   PNG_UNUSED(prev_row)\r\n\r\n   for (i = bpp; i < istop; i++)\r\n   {\r\n      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);\r\n      rp++;\r\n   }\r\n}\r\n\r\nstatic void\r\npng_read_filter_row_up(png_row_infop row_info, png_bytep row,\r\n   png_const_bytep prev_row)\r\n{\r\n   png_size_t i;\r\n   png_size_t istop = row_info->rowbytes;\r\n   png_bytep rp = row;\r\n   png_const_bytep pp = prev_row;\r\n\r\n   for (i = 0; i < istop; i++)\r\n   {\r\n      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);\r\n      rp++;\r\n   }\r\n}\r\n\r\nstatic void\r\npng_read_filter_row_avg(png_row_infop row_info, png_bytep row,\r\n   png_const_bytep prev_row)\r\n{\r\n   png_size_t i;\r\n   png_bytep rp = row;\r\n   png_const_bytep pp = prev_row;\r\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\r\n   png_size_t istop = row_info->rowbytes - bpp;\r\n\r\n   for (i = 0; i < bpp; i++)\r\n   {\r\n      *rp = (png_byte)(((int)(*rp) +\r\n         ((int)(*pp++) / 2 )) & 0xff);\r\n\r\n      rp++;\r\n   }\r\n\r\n   for (i = 0; i < istop; i++)\r\n   {\r\n      *rp = (png_byte)(((int)(*rp) +\r\n         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);\r\n\r\n      rp++;\r\n   }\r\n}\r\n\r\nstatic void\r\npng_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,\r\n   png_const_bytep prev_row)\r\n{\r\n   png_bytep rp_end = row + row_info->rowbytes;\r\n   int a, c;\r\n\r\n   /* First pixel/byte */\r\n   c = *prev_row++;\r\n   a = *row + c;\r\n   *row++ = (png_byte)a;\r\n\r\n   /* Remainder */\r\n   while (row < rp_end)\r\n   {\r\n      int b, pa, pb, pc, p;\r\n\r\n      a &= 0xff; /* From previous iteration or start */\r\n      b = *prev_row++;\r\n\r\n      p = b - c;\r\n      pc = a - c;\r\n\r\n#     ifdef PNG_USE_ABS\r\n         pa = abs(p);\r\n         pb = abs(pc);\r\n         pc = abs(p + pc);\r\n#     else\r\n         pa = p < 0 ? -p : p;\r\n         pb = pc < 0 ? -pc : pc;\r\n         pc = (p + pc) < 0 ? -(p + pc) : p + pc;\r\n#     endif\r\n\r\n      /* Find the best predictor, the least of pa, pb, pc favoring the earlier\r\n       * ones in the case of a tie.\r\n       */\r\n      if (pb < pa) pa = pb, a = b;\r\n      if (pc < pa) a = c;\r\n\r\n      /* Calculate the current pixel in a, and move the previous row pixel to c\r\n       * for the next time round the loop\r\n       */\r\n      c = b;\r\n      a += *row;\r\n      *row++ = (png_byte)a;\r\n   }\r\n}\r\n\r\nstatic void\r\npng_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,\r\n   png_const_bytep prev_row)\r\n{\r\n   int bpp = (row_info->pixel_depth + 7) >> 3;\r\n   png_bytep rp_end = row + bpp;\r\n\r\n   /* Process the first pixel in the row completely (this is the same as 'up'\r\n    * because there is only one candidate predictor for the first row).\r\n    */\r\n   while (row < rp_end)\r\n   {\r\n      int a = *row + *prev_row++;\r\n      *row++ = (png_byte)a;\r\n   }\r\n\r\n   /* Remainder */\r\n   rp_end += row_info->rowbytes - bpp;\r\n\r\n   while (row < rp_end)\r\n   {\r\n      int a, b, c, pa, pb, pc, p;\r\n\r\n      c = *(prev_row - bpp);\r\n      a = *(row - bpp);\r\n      b = *prev_row++;\r\n\r\n      p = b - c;\r\n      pc = a - c;\r\n\r\n#     ifdef PNG_USE_ABS\r\n         pa = abs(p);\r\n         pb = abs(pc);\r\n         pc = abs(p + pc);\r\n#     else\r\n         pa = p < 0 ? -p : p;\r\n         pb = pc < 0 ? -pc : pc;\r\n         pc = (p + pc) < 0 ? -(p + pc) : p + pc;\r\n#     endif\r\n\r\n      if (pb < pa) pa = pb, a = b;\r\n      if (pc < pa) a = c;\r\n\r\n      a += *row;\r\n      *row++ = (png_byte)a;\r\n   }\r\n}\r\n\r\nstatic void\r\npng_init_filter_functions(png_structrp pp)\r\n   /* This function is called once for every PNG image (except for PNG images\r\n    * that only use PNG_FILTER_VALUE_NONE for all rows) to set the\r\n    * implementations required to reverse the filtering of PNG rows.  Reversing\r\n    * the filter is the first transformation performed on the row data.  It is\r\n    * performed in place, therefore an implementation can be selected based on\r\n    * the image pixel format.  If the implementation depends on image width then\r\n    * take care to ensure that it works correctly if the image is interlaced -\r\n    * interlacing causes the actual row width to vary.\r\n    */\r\n{\r\n   unsigned int bpp = (pp->pixel_depth + 7) >> 3;\r\n\r\n   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;\r\n   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;\r\n   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;\r\n   if (bpp == 1)\r\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\r\n         png_read_filter_row_paeth_1byte_pixel;\r\n   else\r\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\r\n         png_read_filter_row_paeth_multibyte_pixel;\r\n\r\n#ifdef PNG_FILTER_OPTIMIZATIONS\r\n   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to\r\n    * call to install hardware optimizations for the above functions; simply\r\n    * replace whatever elements of the pp->read_filter[] array with a hardware\r\n    * specific (or, for that matter, generic) optimization.\r\n    *\r\n    * To see an example of this examine what configure.ac does when\r\n    * --enable-arm-neon is specified on the command line.\r\n    */\r\n   PNG_FILTER_OPTIMIZATIONS(pp, bpp);\r\n#endif\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,\r\n   png_const_bytep prev_row, int filter)\r\n{\r\n   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define\r\n    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic\r\n    * implementations.  See png_init_filter_functions above.\r\n    */\r\n   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)\r\n   {\r\n      if (pp->read_filter[0] == NULL)\r\n         png_init_filter_functions(pp);\r\n\r\n      pp->read_filter[filter-1](row_info, row, prev_row);\r\n   }\r\n}\r\n\r\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\nvoid /* PRIVATE */\r\npng_read_IDAT_data(png_structrp png_ptr, png_bytep output,\r\n   png_alloc_size_t avail_out)\r\n{\r\n   /* Loop reading IDATs and decompressing the result into output[avail_out] */\r\n   png_ptr->zstream.next_out = output;\r\n   png_ptr->zstream.avail_out = 0; /* safety: set below */\r\n\r\n   if (output == NULL)\r\n      avail_out = 0;\r\n\r\n   do\r\n   {\r\n      int ret;\r\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\r\n\r\n      if (png_ptr->zstream.avail_in == 0)\r\n      {\r\n         uInt avail_in;\r\n         png_bytep buffer;\r\n\r\n         while (png_ptr->idat_size == 0)\r\n         {\r\n            png_crc_finish(png_ptr, 0);\r\n\r\n            png_ptr->idat_size = png_read_chunk_header(png_ptr);\r\n            /* This is an error even in the 'check' case because the code just\r\n             * consumed a non-IDAT header.\r\n             */\r\n            if (png_ptr->chunk_name != png_IDAT)\r\n               png_error(png_ptr, \"Not enough image data\");\r\n         }\r\n\r\n         avail_in = png_ptr->IDAT_read_size;\r\n\r\n         if (avail_in > png_ptr->idat_size)\r\n            avail_in = (uInt)png_ptr->idat_size;\r\n\r\n         /* A PNG with a gradually increasing IDAT size will defeat this attempt\r\n          * to minimize memory usage by causing lots of re-allocs, but\r\n          * realistically doing IDAT_read_size re-allocs is not likely to be a\r\n          * big problem.\r\n          */\r\n         buffer = png_read_buffer(png_ptr, avail_in, 0/*error*/);\r\n\r\n         png_crc_read(png_ptr, buffer, avail_in);\r\n         png_ptr->idat_size -= avail_in;\r\n\r\n         png_ptr->zstream.next_in = buffer;\r\n         png_ptr->zstream.avail_in = avail_in;\r\n      }\r\n\r\n      /* And set up the output side. */\r\n      if (output != NULL) /* standard read */\r\n      {\r\n         uInt out = ZLIB_IO_MAX;\r\n\r\n         if (out > avail_out)\r\n            out = (uInt)avail_out;\r\n\r\n         avail_out -= out;\r\n         png_ptr->zstream.avail_out = out;\r\n      }\r\n\r\n      else /* after last row, checking for end */\r\n      {\r\n         png_ptr->zstream.next_out = tmpbuf;\r\n         png_ptr->zstream.avail_out = (sizeof tmpbuf);\r\n      }\r\n\r\n      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the\r\n       * process.  If the LZ stream is truncated the sequential reader will\r\n       * terminally damage the stream, above, by reading the chunk header of the\r\n       * following chunk (it then exits with png_error).\r\n       *\r\n       * TODO: deal more elegantly with truncated IDAT lists.\r\n       */\r\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\r\n\r\n      /* Take the unconsumed output back. */\r\n      if (output != NULL)\r\n         avail_out += png_ptr->zstream.avail_out;\r\n\r\n      else /* avail_out counts the extra bytes */\r\n         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;\r\n\r\n      png_ptr->zstream.avail_out = 0;\r\n\r\n      if (ret == Z_STREAM_END)\r\n      {\r\n         /* Do this for safety; we won't read any more into this row. */\r\n         png_ptr->zstream.next_out = NULL;\r\n\r\n         png_ptr->mode |= PNG_AFTER_IDAT;\r\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\r\n\r\n         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)\r\n            png_chunk_benign_error(png_ptr, \"Extra compressed data\");\r\n         break;\r\n      }\r\n\r\n      if (ret != Z_OK)\r\n      {\r\n         png_zstream_error(png_ptr, ret);\r\n\r\n         if (output != NULL)\r\n            png_chunk_error(png_ptr, png_ptr->zstream.msg);\r\n\r\n         else /* checking */\r\n         {\r\n            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);\r\n            return;\r\n         }\r\n      }\r\n   } while (avail_out > 0);\r\n\r\n   if (avail_out > 0)\r\n   {\r\n      /* The stream ended before the image; this is the same as too few IDATs so\r\n       * should be handled the same way.\r\n       */\r\n      if (output != NULL)\r\n         png_error(png_ptr, \"Not enough image data\");\r\n\r\n      else /* the deflate stream contained extra data */\r\n         png_chunk_benign_error(png_ptr, \"Too much image data\");\r\n   }\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_read_finish_IDAT(png_structrp png_ptr)\r\n{\r\n   /* We don't need any more data and the stream should have ended, however the\r\n    * LZ end code may actually not have been processed.  In this case we must\r\n    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk\r\n    * may still remain to be consumed.\r\n    */\r\n   if (!(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))\r\n   {\r\n      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in\r\n       * the compressed stream, but the stream may be damaged too, so even after\r\n       * this call we may need to terminate the zstream ownership.\r\n       */\r\n      png_read_IDAT_data(png_ptr, NULL, 0);\r\n      png_ptr->zstream.next_out = NULL; /* safety */\r\n\r\n      /* Now clear everything out for safety; the following may not have been\r\n       * done.\r\n       */\r\n      if (!(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))\r\n      {\r\n         png_ptr->mode |= PNG_AFTER_IDAT;\r\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\r\n      }\r\n   }\r\n\r\n   /* If the zstream has not been released do it now *and* terminate the reading\r\n    * of the final IDAT chunk.\r\n    */\r\n   if (png_ptr->zowner == png_IDAT)\r\n   {\r\n      /* Always do this; the pointers otherwise point into the read buffer. */\r\n      png_ptr->zstream.next_in = NULL;\r\n      png_ptr->zstream.avail_in = 0;\r\n\r\n      /* Now we no longer own the zstream. */\r\n      png_ptr->zowner = 0;\r\n\r\n      /* The slightly weird semantics of the sequential IDAT reading is that we\r\n       * are always in or at the end of an IDAT chunk, so we always need to do a\r\n       * crc_finish here.  If idat_size is non-zero we also need to read the\r\n       * spurious bytes at the end of the chunk now.\r\n       */\r\n      (void)png_crc_finish(png_ptr, png_ptr->idat_size);\r\n   }\r\n}\r\n\r\nvoid /* PRIVATE */\r\npng_read_finish_row(png_structrp png_ptr)\r\n{\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\r\n\r\n   /* Start of interlace block */\r\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\r\n\r\n   /* Offset to next interlace block */\r\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\r\n\r\n   /* Start of interlace block in the y direction */\r\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\r\n\r\n   /* Offset to next interlace block in the y direction */\r\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\r\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\r\n\r\n   png_debug(1, \"in png_read_finish_row\");\r\n   png_ptr->row_number++;\r\n   if (png_ptr->row_number < png_ptr->num_rows)\r\n      return;\r\n\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   if (png_ptr->interlaced)\r\n   {\r\n      png_ptr->row_number = 0;\r\n\r\n      /* TO DO: don't do this if prev_row isn't needed (requires\r\n       * read-ahead of the next row's filter byte.\r\n       */\r\n      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\r\n\r\n      do\r\n      {\r\n         png_ptr->pass++;\r\n\r\n         if (png_ptr->pass >= 7)\r\n            break;\r\n\r\n         png_ptr->iwidth = (png_ptr->width +\r\n            png_pass_inc[png_ptr->pass] - 1 -\r\n            png_pass_start[png_ptr->pass]) /\r\n            png_pass_inc[png_ptr->pass];\r\n\r\n         if (!(png_ptr->transformations & PNG_INTERLACE))\r\n         {\r\n            png_ptr->num_rows = (png_ptr->height +\r\n                png_pass_yinc[png_ptr->pass] - 1 -\r\n                png_pass_ystart[png_ptr->pass]) /\r\n                png_pass_yinc[png_ptr->pass];\r\n         }\r\n\r\n         else  /* if (png_ptr->transformations & PNG_INTERLACE) */\r\n            break; /* libpng deinterlacing sees every row */\r\n\r\n      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);\r\n\r\n      if (png_ptr->pass < 7)\r\n         return;\r\n   }\r\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\r\n\r\n   /* Here after at the end of the last row of the last pass. */\r\n   png_read_finish_IDAT(png_ptr);\r\n}\r\n#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */\r\n\r\nvoid /* PRIVATE */\r\npng_read_start_row(png_structrp png_ptr)\r\n{\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\r\n\r\n   /* Start of interlace block */\r\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\r\n\r\n   /* Offset to next interlace block */\r\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\r\n\r\n   /* Start of interlace block in the y direction */\r\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\r\n\r\n   /* Offset to next interlace block in the y direction */\r\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\r\n#endif\r\n\r\n   int max_pixel_depth;\r\n   png_size_t row_bytes;\r\n\r\n   png_debug(1, \"in png_read_start_row\");\r\n\r\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\r\n   png_init_read_transformations(png_ptr);\r\n#endif\r\n#ifdef PNG_READ_INTERLACING_SUPPORTED\r\n   if (png_ptr->interlaced)\r\n   {\r\n      if (!(png_ptr->transformations & PNG_INTERLACE))\r\n         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -\r\n             png_pass_ystart[0]) / png_pass_yinc[0];\r\n\r\n      else\r\n         png_ptr->num_rows = png_ptr->height;\r\n\r\n      png_ptr->iwidth = (png_ptr->width +\r\n          png_pass_inc[png_ptr->pass] - 1 -\r\n          png_pass_start[png_ptr->pass]) /\r\n          png_pass_inc[png_ptr->pass];\r\n   }\r\n\r\n   else\r\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\r\n   {\r\n      png_ptr->num_rows = png_ptr->height;\r\n      png_ptr->iwidth = png_ptr->width;\r\n   }\r\n\r\n   max_pixel_depth = png_ptr->pixel_depth;\r\n\r\n   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpliar set of\r\n    * calculations to calculate the final pixel depth, then\r\n    * png_do_read_transforms actually does the transforms.  This means that the\r\n    * code which effectively calculates this value is actually repeated in three\r\n    * separate places.  They must all match.  Innocent changes to the order of\r\n    * transformations can and will break libpng in a way that causes memory\r\n    * overwrites.\r\n    *\r\n    * TODO: fix this.\r\n    */\r\n#ifdef PNG_READ_PACK_SUPPORTED\r\n   if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)\r\n      max_pixel_depth = 8;\r\n#endif\r\n\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n   if (png_ptr->transformations & PNG_EXPAND)\r\n   {\r\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      {\r\n         if (png_ptr->num_trans)\r\n            max_pixel_depth = 32;\r\n\r\n         else\r\n            max_pixel_depth = 24;\r\n      }\r\n\r\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\r\n      {\r\n         if (max_pixel_depth < 8)\r\n            max_pixel_depth = 8;\r\n\r\n         if (png_ptr->num_trans)\r\n            max_pixel_depth *= 2;\r\n      }\r\n\r\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\r\n      {\r\n         if (png_ptr->num_trans)\r\n         {\r\n            max_pixel_depth *= 4;\r\n            max_pixel_depth /= 3;\r\n         }\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\r\n   if (png_ptr->transformations & PNG_EXPAND_16)\r\n   {\r\n#     ifdef PNG_READ_EXPAND_SUPPORTED\r\n         /* In fact it is an error if it isn't supported, but checking is\r\n          * the safe way.\r\n          */\r\n         if (png_ptr->transformations & PNG_EXPAND)\r\n         {\r\n            if (png_ptr->bit_depth < 16)\r\n               max_pixel_depth *= 2;\r\n         }\r\n         else\r\n#     endif\r\n         png_ptr->transformations &= ~PNG_EXPAND_16;\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_FILLER_SUPPORTED\r\n   if (png_ptr->transformations & (PNG_FILLER))\r\n   {\r\n      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\r\n      {\r\n         if (max_pixel_depth <= 8)\r\n            max_pixel_depth = 16;\r\n\r\n         else\r\n            max_pixel_depth = 32;\r\n      }\r\n\r\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||\r\n         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      {\r\n         if (max_pixel_depth <= 32)\r\n            max_pixel_depth = 32;\r\n\r\n         else\r\n            max_pixel_depth = 64;\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\r\n   if (png_ptr->transformations & PNG_GRAY_TO_RGB)\r\n   {\r\n      if (\r\n#ifdef PNG_READ_EXPAND_SUPPORTED\r\n          (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||\r\n#endif\r\n#ifdef PNG_READ_FILLER_SUPPORTED\r\n          (png_ptr->transformations & (PNG_FILLER)) ||\r\n#endif\r\n          png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\n      {\r\n         if (max_pixel_depth <= 16)\r\n            max_pixel_depth = 32;\r\n\r\n         else\r\n            max_pixel_depth = 64;\r\n      }\r\n\r\n      else\r\n      {\r\n         if (max_pixel_depth <= 8)\r\n         {\r\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n               max_pixel_depth = 32;\r\n\r\n            else\r\n               max_pixel_depth = 24;\r\n         }\r\n\r\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n            max_pixel_depth = 64;\r\n\r\n         else\r\n            max_pixel_depth = 48;\r\n      }\r\n   }\r\n#endif\r\n\r\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \\\r\ndefined(PNG_USER_TRANSFORM_PTR_SUPPORTED)\r\n   if (png_ptr->transformations & PNG_USER_TRANSFORM)\r\n   {\r\n      int user_pixel_depth = png_ptr->user_transform_depth *\r\n         png_ptr->user_transform_channels;\r\n\r\n      if (user_pixel_depth > max_pixel_depth)\r\n         max_pixel_depth = user_pixel_depth;\r\n   }\r\n#endif\r\n\r\n   /* This value is stored in png_struct and double checked in the row read\r\n    * code.\r\n    */\r\n   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;\r\n   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */\r\n\r\n   /* Align the width on the next larger 8 pixels.  Mainly used\r\n    * for interlacing\r\n    */\r\n   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));\r\n   /* Calculate the maximum bytes needed, adding a byte and a pixel\r\n    * for safety's sake\r\n    */\r\n   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +\r\n       1 + ((max_pixel_depth + 7) >> 3);\r\n\r\n#ifdef PNG_MAX_MALLOC_64K\r\n   if (row_bytes > (png_uint_32)65536L)\r\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\r\n#endif\r\n\r\n   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)\r\n   {\r\n     png_free(png_ptr, png_ptr->big_row_buf);\r\n     png_free(png_ptr, png_ptr->big_prev_row);\r\n\r\n     if (png_ptr->interlaced)\r\n        png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,\r\n            row_bytes + 48);\r\n\r\n     else\r\n        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\r\n\r\n     png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\r\n\r\n#ifdef PNG_ALIGNED_MEMORY_SUPPORTED\r\n     /* Use 16-byte aligned memory for row_buf with at least 16 bytes\r\n      * of padding before and after row_buf; treat prev_row similarly.\r\n      * NOTE: the alignment is to the start of the pixels, one beyond the start\r\n      * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this\r\n      * was incorrect; the filter byte was aligned, which had the exact\r\n      * opposite effect of that intended.\r\n      */\r\n     {\r\n        png_bytep temp = png_ptr->big_row_buf + 32;\r\n        int extra = (int)((temp - (png_bytep)0) & 0x0f);\r\n        png_ptr->row_buf = temp - extra - 1/*filter byte*/;\r\n\r\n        temp = png_ptr->big_prev_row + 32;\r\n        extra = (int)((temp - (png_bytep)0) & 0x0f);\r\n        png_ptr->prev_row = temp - extra - 1/*filter byte*/;\r\n     }\r\n\r\n#else\r\n     /* Use 31 bytes of padding before and 17 bytes after row_buf. */\r\n     png_ptr->row_buf = png_ptr->big_row_buf + 31;\r\n     png_ptr->prev_row = png_ptr->big_prev_row + 31;\r\n#endif\r\n     png_ptr->old_big_row_buf_size = row_bytes + 48;\r\n   }\r\n\r\n#ifdef PNG_MAX_MALLOC_64K\r\n   if (png_ptr->rowbytes > 65535)\r\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\r\n\r\n#endif\r\n   if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))\r\n      png_error(png_ptr, \"Row has too many bytes to allocate in memory\");\r\n\r\n   memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\r\n\r\n   png_debug1(3, \"width = %u,\", png_ptr->width);\r\n   png_debug1(3, \"height = %u,\", png_ptr->height);\r\n   png_debug1(3, \"iwidth = %u,\", png_ptr->iwidth);\r\n   png_debug1(3, \"num_rows = %u,\", png_ptr->num_rows);\r\n   png_debug1(3, \"rowbytes = %lu,\", (unsigned long)png_ptr->rowbytes);\r\n   png_debug1(3, \"irowbytes = %lu\",\r\n       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);\r\n\r\n   /* The sequential reader needs a buffer for IDAT, but the progressive reader\r\n    * does not, so free the read buffer now regardless; the sequential reader\r\n    * reallocates it on demand.\r\n    */\r\n   if (png_ptr->read_buffer)\r\n   {\r\n      png_bytep buffer = png_ptr->read_buffer;\r\n\r\n      png_ptr->read_buffer_size = 0;\r\n      png_ptr->read_buffer = NULL;\r\n      png_free(png_ptr, buffer);\r\n   }\r\n\r\n   /* Finally claim the zstream for the inflate of the IDAT data, use the bits\r\n    * value from the stream (note that this will result in a fatal error if the\r\n    * IDAT stream has a bogus deflate header window_bits value, but this should\r\n    * not be happening any longer!)\r\n    */\r\n   if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)\r\n      png_error(png_ptr, png_ptr->zstream.msg);\r\n\r\n   png_ptr->flags |= PNG_FLAG_ROW_INIT;\r\n}\r\n#endif /* PNG_READ_SUPPORTED */\r\n","\r\n/* pngset.c - storage of image information into info struct\r\n *\r\n * Last changed in libpng 1.6.8 [December 19, 2013]\r\n * Copyright (c) 1998-2013 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n *\r\n * The functions here are used during reads to store data from the file\r\n * into the info struct, and during writes to store application data\r\n * into the info struct for writing into the file.  This abstracts the\r\n * info struct and allows us to change the structure in the future.\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n\r\n#ifdef PNG_bKGD_SUPPORTED\r\nvoid PNGAPI\r\npng_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_color_16p background)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"bKGD\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || background == NULL)\r\n      return;\r\n\r\n   info_ptr->background = *background;\r\n   info_ptr->valid |= PNG_INFO_bKGD;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_cHRM_SUPPORTED\r\nvoid PNGFAPI\r\npng_set_cHRM_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,\r\n    png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,\r\n    png_fixed_point blue_x, png_fixed_point blue_y)\r\n{\r\n   png_xy xy;\r\n\r\n   png_debug1(1, \"in %s storage function\", \"cHRM fixed\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   xy.redx = red_x;\r\n   xy.redy = red_y;\r\n   xy.greenx = green_x;\r\n   xy.greeny = green_y;\r\n   xy.bluex = blue_x;\r\n   xy.bluey = blue_y;\r\n   xy.whitex = white_x;\r\n   xy.whitey = white_y;\r\n\r\n   if (png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &xy,\r\n      2/* override with app values*/))\r\n      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\r\n\r\n   png_colorspace_sync_info(png_ptr, info_ptr);\r\n}\r\n\r\nvoid PNGFAPI\r\npng_set_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_fixed_point int_red_X, png_fixed_point int_red_Y,\r\n    png_fixed_point int_red_Z, png_fixed_point int_green_X,\r\n    png_fixed_point int_green_Y, png_fixed_point int_green_Z,\r\n    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,\r\n    png_fixed_point int_blue_Z)\r\n{\r\n   png_XYZ XYZ;\r\n\r\n   png_debug1(1, \"in %s storage function\", \"cHRM XYZ fixed\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   XYZ.red_X = int_red_X;\r\n   XYZ.red_Y = int_red_Y;\r\n   XYZ.red_Z = int_red_Z;\r\n   XYZ.green_X = int_green_X;\r\n   XYZ.green_Y = int_green_Y;\r\n   XYZ.green_Z = int_green_Z;\r\n   XYZ.blue_X = int_blue_X;\r\n   XYZ.blue_Y = int_blue_Y;\r\n   XYZ.blue_Z = int_blue_Z;\r\n\r\n   if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace, &XYZ, 2))\r\n      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\r\n\r\n   png_colorspace_sync_info(png_ptr, info_ptr);\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    double white_x, double white_y, double red_x, double red_y,\r\n    double green_x, double green_y, double blue_x, double blue_y)\r\n{\r\n   png_set_cHRM_fixed(png_ptr, info_ptr,\r\n      png_fixed(png_ptr, white_x, \"cHRM White X\"),\r\n      png_fixed(png_ptr, white_y, \"cHRM White Y\"),\r\n      png_fixed(png_ptr, red_x, \"cHRM Red X\"),\r\n      png_fixed(png_ptr, red_y, \"cHRM Red Y\"),\r\n      png_fixed(png_ptr, green_x, \"cHRM Green X\"),\r\n      png_fixed(png_ptr, green_y, \"cHRM Green Y\"),\r\n      png_fixed(png_ptr, blue_x, \"cHRM Blue X\"),\r\n      png_fixed(png_ptr, blue_y, \"cHRM Blue Y\"));\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_cHRM_XYZ(png_const_structrp png_ptr, png_inforp info_ptr, double red_X,\r\n    double red_Y, double red_Z, double green_X, double green_Y, double green_Z,\r\n    double blue_X, double blue_Y, double blue_Z)\r\n{\r\n   png_set_cHRM_XYZ_fixed(png_ptr, info_ptr,\r\n      png_fixed(png_ptr, red_X, \"cHRM Red X\"),\r\n      png_fixed(png_ptr, red_Y, \"cHRM Red Y\"),\r\n      png_fixed(png_ptr, red_Z, \"cHRM Red Z\"),\r\n      png_fixed(png_ptr, green_X, \"cHRM Red X\"),\r\n      png_fixed(png_ptr, green_Y, \"cHRM Red Y\"),\r\n      png_fixed(png_ptr, green_Z, \"cHRM Red Z\"),\r\n      png_fixed(png_ptr, blue_X, \"cHRM Red X\"),\r\n      png_fixed(png_ptr, blue_Y, \"cHRM Red Y\"),\r\n      png_fixed(png_ptr, blue_Z, \"cHRM Red Z\"));\r\n}\r\n#  endif /* PNG_FLOATING_POINT_SUPPORTED */\r\n\r\n#endif /* PNG_cHRM_SUPPORTED */\r\n\r\n#ifdef PNG_gAMA_SUPPORTED\r\nvoid PNGFAPI\r\npng_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_fixed_point file_gamma)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"gAMA\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);\r\n   png_colorspace_sync_info(png_ptr, info_ptr);\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)\r\n{\r\n   png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,\r\n       \"png_set_gAMA\"));\r\n}\r\n#  endif\r\n#endif\r\n\r\n#ifdef PNG_hIST_SUPPORTED\r\nvoid PNGAPI\r\npng_set_hIST(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_uint_16p hist)\r\n{\r\n   int i;\r\n\r\n   png_debug1(1, \"in %s storage function\", \"hIST\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   if (info_ptr->num_palette == 0 || info_ptr->num_palette\r\n       > PNG_MAX_PALETTE_LENGTH)\r\n   {\r\n      png_warning(png_ptr,\r\n          \"Invalid palette size, hIST allocation skipped\");\r\n\r\n      return;\r\n   }\r\n\r\n   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);\r\n\r\n   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in\r\n    * version 1.2.1\r\n    */\r\n   info_ptr->hist = png_voidcast(png_uint_16p, png_malloc_warn(png_ptr,\r\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_uint_16))));\r\n\r\n   if (info_ptr->hist == NULL)\r\n   {\r\n      png_warning(png_ptr, \"Insufficient memory for hIST chunk data\");\r\n      return;\r\n   }\r\n\r\n   info_ptr->free_me |= PNG_FREE_HIST;\r\n\r\n   for (i = 0; i < info_ptr->num_palette; i++)\r\n      info_ptr->hist[i] = hist[i];\r\n\r\n   info_ptr->valid |= PNG_INFO_hIST;\r\n}\r\n#endif\r\n\r\nvoid PNGAPI\r\npng_set_IHDR(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_uint_32 width, png_uint_32 height, int bit_depth,\r\n    int color_type, int interlace_type, int compression_type,\r\n    int filter_type)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"IHDR\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   info_ptr->width = width;\r\n   info_ptr->height = height;\r\n   info_ptr->bit_depth = (png_byte)bit_depth;\r\n   info_ptr->color_type = (png_byte)color_type;\r\n   info_ptr->compression_type = (png_byte)compression_type;\r\n   info_ptr->filter_type = (png_byte)filter_type;\r\n   info_ptr->interlace_type = (png_byte)interlace_type;\r\n\r\n   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,\r\n       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,\r\n       info_ptr->compression_type, info_ptr->filter_type);\r\n\r\n   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n      info_ptr->channels = 1;\r\n\r\n   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)\r\n      info_ptr->channels = 3;\r\n\r\n   else\r\n      info_ptr->channels = 1;\r\n\r\n   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)\r\n      info_ptr->channels++;\r\n\r\n   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);\r\n\r\n   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);\r\n}\r\n\r\n#ifdef PNG_oFFs_SUPPORTED\r\nvoid PNGAPI\r\npng_set_oFFs(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_int_32 offset_x, png_int_32 offset_y, int unit_type)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"oFFs\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   info_ptr->x_offset = offset_x;\r\n   info_ptr->y_offset = offset_y;\r\n   info_ptr->offset_unit_type = (png_byte)unit_type;\r\n   info_ptr->valid |= PNG_INFO_oFFs;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_pCAL_SUPPORTED\r\nvoid PNGAPI\r\npng_set_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type,\r\n    int nparams, png_const_charp units, png_charpp params)\r\n{\r\n   png_size_t length;\r\n   int i;\r\n\r\n   png_debug1(1, \"in %s storage function\", \"pCAL\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || purpose == NULL || units == NULL\r\n      || (nparams > 0 && params == NULL))\r\n      return;\r\n\r\n   length = strlen(purpose) + 1;\r\n   png_debug1(3, \"allocating purpose for info (%lu bytes)\",\r\n       (unsigned long)length);\r\n\r\n   /* TODO: validate format of calibration name and unit name */\r\n\r\n   /* Check that the type matches the specification. */\r\n   if (type < 0 || type > 3)\r\n      png_error(png_ptr, \"Invalid pCAL equation type\");\r\n\r\n   if (nparams < 0 || nparams > 255)\r\n      png_error(png_ptr, \"Invalid pCAL parameter count\");\r\n\r\n   /* Validate params[nparams] */\r\n   for (i=0; i<nparams; ++i)\r\n      if (params[i] == NULL ||\r\n         !png_check_fp_string(params[i], strlen(params[i])))\r\n         png_error(png_ptr, \"Invalid format for pCAL parameter\");\r\n\r\n   info_ptr->pcal_purpose = png_voidcast(png_charp,\r\n      png_malloc_warn(png_ptr, length));\r\n\r\n   if (info_ptr->pcal_purpose == NULL)\r\n   {\r\n      png_warning(png_ptr, \"Insufficient memory for pCAL purpose\");\r\n      return;\r\n   }\r\n\r\n   memcpy(info_ptr->pcal_purpose, purpose, length);\r\n\r\n   png_debug(3, \"storing X0, X1, type, and nparams in info\");\r\n   info_ptr->pcal_X0 = X0;\r\n   info_ptr->pcal_X1 = X1;\r\n   info_ptr->pcal_type = (png_byte)type;\r\n   info_ptr->pcal_nparams = (png_byte)nparams;\r\n\r\n   length = strlen(units) + 1;\r\n   png_debug1(3, \"allocating units for info (%lu bytes)\",\r\n     (unsigned long)length);\r\n\r\n   info_ptr->pcal_units = png_voidcast(png_charp,\r\n      png_malloc_warn(png_ptr, length));\r\n\r\n   if (info_ptr->pcal_units == NULL)\r\n   {\r\n      png_warning(png_ptr, \"Insufficient memory for pCAL units\");\r\n      return;\r\n   }\r\n\r\n   memcpy(info_ptr->pcal_units, units, length);\r\n\r\n   info_ptr->pcal_params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,\r\n       (png_size_t)((nparams + 1) * (sizeof (png_charp)))));\r\n\r\n   if (info_ptr->pcal_params == NULL)\r\n   {\r\n      png_warning(png_ptr, \"Insufficient memory for pCAL params\");\r\n      return;\r\n   }\r\n\r\n   memset(info_ptr->pcal_params, 0, (nparams + 1) * (sizeof (png_charp)));\r\n\r\n   for (i = 0; i < nparams; i++)\r\n   {\r\n      length = strlen(params[i]) + 1;\r\n      png_debug2(3, \"allocating parameter %d for info (%lu bytes)\", i,\r\n          (unsigned long)length);\r\n\r\n      info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);\r\n\r\n      if (info_ptr->pcal_params[i] == NULL)\r\n      {\r\n         png_warning(png_ptr, \"Insufficient memory for pCAL parameter\");\r\n         return;\r\n      }\r\n\r\n      memcpy(info_ptr->pcal_params[i], params[i], length);\r\n   }\r\n\r\n   info_ptr->valid |= PNG_INFO_pCAL;\r\n   info_ptr->free_me |= PNG_FREE_PCAL;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_sCAL_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sCAL_s(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    int unit, png_const_charp swidth, png_const_charp sheight)\r\n{\r\n   png_size_t lengthw = 0, lengthh = 0;\r\n\r\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   /* Double check the unit (should never get here with an invalid\r\n    * unit unless this is an API call.)\r\n    */\r\n   if (unit != 1 && unit != 2)\r\n      png_error(png_ptr, \"Invalid sCAL unit\");\r\n\r\n   if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||\r\n       swidth[0] == 45 /* '-' */ || !png_check_fp_string(swidth, lengthw))\r\n      png_error(png_ptr, \"Invalid sCAL width\");\r\n\r\n   if (sheight == NULL || (lengthh = strlen(sheight)) == 0 ||\r\n       sheight[0] == 45 /* '-' */ || !png_check_fp_string(sheight, lengthh))\r\n      png_error(png_ptr, \"Invalid sCAL height\");\r\n\r\n   info_ptr->scal_unit = (png_byte)unit;\r\n\r\n   ++lengthw;\r\n\r\n   png_debug1(3, \"allocating unit for info (%u bytes)\", (unsigned int)lengthw);\r\n\r\n   info_ptr->scal_s_width = png_voidcast(png_charp,\r\n      png_malloc_warn(png_ptr, lengthw));\r\n\r\n   if (info_ptr->scal_s_width == NULL)\r\n   {\r\n      png_warning(png_ptr, \"Memory allocation failed while processing sCAL\");\r\n      return;\r\n   }\r\n\r\n   memcpy(info_ptr->scal_s_width, swidth, lengthw);\r\n\r\n   ++lengthh;\r\n\r\n   png_debug1(3, \"allocating unit for info (%u bytes)\", (unsigned int)lengthh);\r\n\r\n   info_ptr->scal_s_height = png_voidcast(png_charp,\r\n      png_malloc_warn(png_ptr, lengthh));\r\n\r\n   if (info_ptr->scal_s_height == NULL)\r\n   {\r\n      png_free (png_ptr, info_ptr->scal_s_width);\r\n      info_ptr->scal_s_width = NULL;\r\n\r\n      png_warning(png_ptr, \"Memory allocation failed while processing sCAL\");\r\n      return;\r\n   }\r\n\r\n   memcpy(info_ptr->scal_s_height, sheight, lengthh);\r\n\r\n   info_ptr->valid |= PNG_INFO_sCAL;\r\n   info_ptr->free_me |= PNG_FREE_SCAL;\r\n}\r\n\r\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sCAL(png_const_structrp png_ptr, png_inforp info_ptr, int unit,\r\n    double width, double height)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\r\n\r\n   /* Check the arguments. */\r\n   if (width <= 0)\r\n      png_warning(png_ptr, \"Invalid sCAL width ignored\");\r\n\r\n   else if (height <= 0)\r\n      png_warning(png_ptr, \"Invalid sCAL height ignored\");\r\n\r\n   else\r\n   {\r\n      /* Convert 'width' and 'height' to ASCII. */\r\n      char swidth[PNG_sCAL_MAX_DIGITS+1];\r\n      char sheight[PNG_sCAL_MAX_DIGITS+1];\r\n\r\n      png_ascii_from_fp(png_ptr, swidth, (sizeof swidth), width,\r\n         PNG_sCAL_PRECISION);\r\n      png_ascii_from_fp(png_ptr, sheight, (sizeof sheight), height,\r\n         PNG_sCAL_PRECISION);\r\n\r\n      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);\r\n   }\r\n}\r\n#  endif\r\n\r\n#  ifdef PNG_FIXED_POINT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sCAL_fixed(png_const_structrp png_ptr, png_inforp info_ptr, int unit,\r\n    png_fixed_point width, png_fixed_point height)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\r\n\r\n   /* Check the arguments. */\r\n   if (width <= 0)\r\n      png_warning(png_ptr, \"Invalid sCAL width ignored\");\r\n\r\n   else if (height <= 0)\r\n      png_warning(png_ptr, \"Invalid sCAL height ignored\");\r\n\r\n   else\r\n   {\r\n      /* Convert 'width' and 'height' to ASCII. */\r\n      char swidth[PNG_sCAL_MAX_DIGITS+1];\r\n      char sheight[PNG_sCAL_MAX_DIGITS+1];\r\n\r\n      png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);\r\n      png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);\r\n\r\n      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);\r\n   }\r\n}\r\n#  endif\r\n#endif\r\n\r\n#ifdef PNG_pHYs_SUPPORTED\r\nvoid PNGAPI\r\npng_set_pHYs(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_uint_32 res_x, png_uint_32 res_y, int unit_type)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"pHYs\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   info_ptr->x_pixels_per_unit = res_x;\r\n   info_ptr->y_pixels_per_unit = res_y;\r\n   info_ptr->phys_unit_type = (png_byte)unit_type;\r\n   info_ptr->valid |= PNG_INFO_pHYs;\r\n}\r\n#endif\r\n\r\nvoid PNGAPI\r\npng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_colorp palette, int num_palette)\r\n{\r\n\r\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\r\n   {\r\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\r\n         png_error(png_ptr, \"Invalid palette length\");\r\n\r\n      else\r\n      {\r\n         png_warning(png_ptr, \"Invalid palette length\");\r\n         return;\r\n      }\r\n   }\r\n\r\n   if ((num_palette > 0 && palette == NULL) ||\r\n      (num_palette == 0\r\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\r\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\r\n#        endif\r\n      ))\r\n   {\r\n      png_error(png_ptr, \"Invalid palette\");\r\n      return;\r\n   }\r\n\r\n   /* It may not actually be necessary to set png_ptr->palette here;\r\n    * we do it for backward compatibility with the way the png_handle_tRNS\r\n    * function used to do the allocation.\r\n    *\r\n    * 1.6.0: the above statement appears to be incorrect; something has to set\r\n    * the palette inside png_struct on read.\r\n    */\r\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\r\n\r\n   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead\r\n    * of num_palette entries, in case of an invalid PNG file that has\r\n    * too-large sample values.\r\n    */\r\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\r\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\r\n\r\n   if (num_palette > 0)\r\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\r\n   info_ptr->palette = png_ptr->palette;\r\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\r\n\r\n   info_ptr->free_me |= PNG_FREE_PLTE;\r\n\r\n   info_ptr->valid |= PNG_INFO_PLTE;\r\n}\r\n\r\n#ifdef PNG_sBIT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_color_8p sig_bit)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"sBIT\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)\r\n      return;\r\n\r\n   info_ptr->sig_bit = *sig_bit;\r\n   info_ptr->valid |= PNG_INFO_sBIT;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_sRGB_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sRGB(png_const_structrp png_ptr, png_inforp info_ptr, int srgb_intent)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"sRGB\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   (void)png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);\r\n   png_colorspace_sync_info(png_ptr, info_ptr);\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    int srgb_intent)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"sRGB_gAMA_and_cHRM\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   if (png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent))\r\n   {\r\n      /* This causes the gAMA and cHRM to be written too */\r\n      info_ptr->colorspace.flags |=\r\n         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;\r\n   }\r\n\r\n   png_colorspace_sync_info(png_ptr, info_ptr);\r\n}\r\n#endif /* sRGB */\r\n\r\n\r\n#ifdef PNG_iCCP_SUPPORTED\r\nvoid PNGAPI\r\npng_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_charp name, int compression_type,\r\n    png_const_bytep profile, png_uint_32 proflen)\r\n{\r\n   png_charp new_iccp_name;\r\n   png_bytep new_iccp_profile;\r\n   png_size_t length;\r\n\r\n   png_debug1(1, \"in %s storage function\", \"iCCP\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)\r\n      return;\r\n\r\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\r\n      png_app_error(png_ptr, \"Invalid iCCP compression method\");\r\n\r\n   /* Set the colorspace first because this validates the profile; do not\r\n    * override previously set app cHRM or gAMA here (because likely as not the\r\n    * application knows better than libpng what the correct values are.)  Pass\r\n    * the info_ptr color_type field to png_colorspace_set_ICC because in the\r\n    * write case it has not yet been stored in png_ptr.\r\n    */\r\n   {\r\n      int result = png_colorspace_set_ICC(png_ptr, &info_ptr->colorspace, name,\r\n         proflen, profile, info_ptr->color_type);\r\n\r\n      png_colorspace_sync_info(png_ptr, info_ptr);\r\n\r\n      /* Don't do any of the copying if the profile was bad, or inconsistent. */\r\n      if (!result)\r\n         return;\r\n\r\n      /* But do write the gAMA and cHRM chunks from the profile. */\r\n      info_ptr->colorspace.flags |=\r\n         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;\r\n   }\r\n\r\n   length = strlen(name)+1;\r\n   new_iccp_name = png_voidcast(png_charp, png_malloc_warn(png_ptr, length));\r\n\r\n   if (new_iccp_name == NULL)\r\n   {\r\n      png_benign_error(png_ptr, \"Insufficient memory to process iCCP chunk\");\r\n      return;\r\n   }\r\n\r\n   memcpy(new_iccp_name, name, length);\r\n   new_iccp_profile = png_voidcast(png_bytep,\r\n      png_malloc_warn(png_ptr, proflen));\r\n\r\n   if (new_iccp_profile == NULL)\r\n   {\r\n      png_free(png_ptr, new_iccp_name);\r\n      png_benign_error(png_ptr,\r\n          \"Insufficient memory to process iCCP profile\");\r\n      return;\r\n   }\r\n\r\n   memcpy(new_iccp_profile, profile, proflen);\r\n\r\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);\r\n\r\n   info_ptr->iccp_proflen = proflen;\r\n   info_ptr->iccp_name = new_iccp_name;\r\n   info_ptr->iccp_profile = new_iccp_profile;\r\n   info_ptr->free_me |= PNG_FREE_ICCP;\r\n   info_ptr->valid |= PNG_INFO_iCCP;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_TEXT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_text(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_textp text_ptr, int num_text)\r\n{\r\n   int ret;\r\n   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);\r\n\r\n   if (ret)\r\n      png_error(png_ptr, \"Insufficient memory to store text\");\r\n}\r\n\r\nint /* PRIVATE */\r\npng_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_textp text_ptr, int num_text)\r\n{\r\n   int i;\r\n\r\n   png_debug1(1, \"in %lx storage function\", png_ptr == NULL ? \"unexpected\" :\r\n      (unsigned long)png_ptr->chunk_name);\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)\r\n      return(0);\r\n\r\n   /* Make sure we have enough space in the \"text\" array in info_struct\r\n    * to hold all of the incoming text_ptr objects.  This compare can't overflow\r\n    * because max_text >= num_text (anyway, subtract of two positive integers\r\n    * can't overflow in any case.)\r\n    */\r\n   if (num_text > info_ptr->max_text - info_ptr->num_text)\r\n   {\r\n      int old_num_text = info_ptr->num_text;\r\n      int max_text;\r\n      png_textp new_text = NULL;\r\n\r\n      /* Calculate an appropriate max_text, checking for overflow. */\r\n      max_text = old_num_text;\r\n      if (num_text <= INT_MAX - max_text)\r\n      {\r\n         max_text += num_text;\r\n\r\n         /* Round up to a multiple of 8 */\r\n         if (max_text < INT_MAX-8)\r\n            max_text = (max_text + 8) & ~0x7;\r\n\r\n         else\r\n            max_text = INT_MAX;\r\n\r\n         /* Now allocate a new array and copy the old members in, this does all\r\n          * the overflow checks.\r\n          */\r\n         new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,\r\n            info_ptr->text, old_num_text, max_text-old_num_text,\r\n            sizeof *new_text));\r\n      }\r\n\r\n      if (new_text == NULL)\r\n      {\r\n         png_chunk_report(png_ptr, \"too many text chunks\",\r\n            PNG_CHUNK_WRITE_ERROR);\r\n         return 1;\r\n      }\r\n\r\n      png_free(png_ptr, info_ptr->text);\r\n\r\n      info_ptr->text = new_text;\r\n      info_ptr->free_me |= PNG_FREE_TEXT;\r\n      info_ptr->max_text = max_text;\r\n      /* num_text is adjusted below as the entries are copied in */\r\n\r\n      png_debug1(3, \"allocated %d entries for info_ptr->text\", max_text);\r\n   }\r\n\r\n   for (i = 0; i < num_text; i++)\r\n   {\r\n      size_t text_length, key_len;\r\n      size_t lang_len, lang_key_len;\r\n      png_textp textp = &(info_ptr->text[info_ptr->num_text]);\r\n\r\n      if (text_ptr[i].key == NULL)\r\n          continue;\r\n\r\n      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||\r\n          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)\r\n      {\r\n         png_chunk_report(png_ptr, \"text compression mode is out of range\",\r\n            PNG_CHUNK_WRITE_ERROR);\r\n         continue;\r\n      }\r\n\r\n      key_len = strlen(text_ptr[i].key);\r\n\r\n      if (text_ptr[i].compression <= 0)\r\n      {\r\n         lang_len = 0;\r\n         lang_key_len = 0;\r\n      }\r\n\r\n      else\r\n#  ifdef PNG_iTXt_SUPPORTED\r\n      {\r\n         /* Set iTXt data */\r\n\r\n         if (text_ptr[i].lang != NULL)\r\n            lang_len = strlen(text_ptr[i].lang);\r\n\r\n         else\r\n            lang_len = 0;\r\n\r\n         if (text_ptr[i].lang_key != NULL)\r\n            lang_key_len = strlen(text_ptr[i].lang_key);\r\n\r\n         else\r\n            lang_key_len = 0;\r\n      }\r\n#  else /* PNG_iTXt_SUPPORTED */\r\n      {\r\n         png_chunk_report(png_ptr, \"iTXt chunk not supported\",\r\n            PNG_CHUNK_WRITE_ERROR);\r\n         continue;\r\n      }\r\n#  endif\r\n\r\n      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')\r\n      {\r\n         text_length = 0;\r\n#  ifdef PNG_iTXt_SUPPORTED\r\n         if (text_ptr[i].compression > 0)\r\n            textp->compression = PNG_ITXT_COMPRESSION_NONE;\r\n\r\n         else\r\n#  endif\r\n            textp->compression = PNG_TEXT_COMPRESSION_NONE;\r\n      }\r\n\r\n      else\r\n      {\r\n         text_length = strlen(text_ptr[i].text);\r\n         textp->compression = text_ptr[i].compression;\r\n      }\r\n\r\n      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,\r\n          key_len + text_length + lang_len + lang_key_len + 4));\r\n\r\n      if (textp->key == NULL)\r\n      {\r\n         png_chunk_report(png_ptr, \"text chunk: out of memory\",\r\n               PNG_CHUNK_WRITE_ERROR);\r\n         return 1;\r\n      }\r\n\r\n      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",\r\n          (unsigned long)(png_uint_32)\r\n          (key_len + lang_len + lang_key_len + text_length + 4),\r\n          textp->key);\r\n\r\n      memcpy(textp->key, text_ptr[i].key, key_len);\r\n      *(textp->key + key_len) = '\\0';\r\n\r\n      if (text_ptr[i].compression > 0)\r\n      {\r\n         textp->lang = textp->key + key_len + 1;\r\n         memcpy(textp->lang, text_ptr[i].lang, lang_len);\r\n         *(textp->lang + lang_len) = '\\0';\r\n         textp->lang_key = textp->lang + lang_len + 1;\r\n         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);\r\n         *(textp->lang_key + lang_key_len) = '\\0';\r\n         textp->text = textp->lang_key + lang_key_len + 1;\r\n      }\r\n\r\n      else\r\n      {\r\n         textp->lang=NULL;\r\n         textp->lang_key=NULL;\r\n         textp->text = textp->key + key_len + 1;\r\n      }\r\n\r\n      if (text_length)\r\n         memcpy(textp->text, text_ptr[i].text, text_length);\r\n\r\n      *(textp->text + text_length) = '\\0';\r\n\r\n#  ifdef PNG_iTXt_SUPPORTED\r\n      if (textp->compression > 0)\r\n      {\r\n         textp->text_length = 0;\r\n         textp->itxt_length = text_length;\r\n      }\r\n\r\n      else\r\n#  endif\r\n      {\r\n         textp->text_length = text_length;\r\n         textp->itxt_length = 0;\r\n      }\r\n\r\n      info_ptr->num_text++;\r\n      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);\r\n   }\r\n\r\n   return(0);\r\n}\r\n#endif\r\n\r\n#ifdef PNG_tIME_SUPPORTED\r\nvoid PNGAPI\r\npng_set_tIME(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_timep mod_time)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"tIME\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || mod_time == NULL ||\r\n       (png_ptr->mode & PNG_WROTE_tIME))\r\n      return;\r\n\r\n   if (mod_time->month == 0   || mod_time->month > 12  ||\r\n       mod_time->day   == 0   || mod_time->day   > 31  ||\r\n       mod_time->hour  > 23   || mod_time->minute > 59 ||\r\n       mod_time->second > 60)\r\n   {\r\n      png_warning(png_ptr, \"Ignoring invalid time value\");\r\n      return;\r\n   }\r\n\r\n   info_ptr->mod_time = *mod_time;\r\n   info_ptr->valid |= PNG_INFO_tIME;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_tRNS_SUPPORTED\r\nvoid PNGAPI\r\npng_set_tRNS(png_structrp png_ptr, png_inforp info_ptr,\r\n    png_const_bytep trans_alpha, int num_trans, png_const_color_16p trans_color)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"tRNS\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   if (trans_alpha != NULL)\r\n   {\r\n       /* It may not actually be necessary to set png_ptr->trans_alpha here;\r\n        * we do it for backward compatibility with the way the png_handle_tRNS\r\n        * function used to do the allocation.\r\n        *\r\n        * 1.6.0: The above statement is incorrect; png_handle_tRNS effectively\r\n        * relies on png_set_tRNS storing the information in png_struct\r\n        * (otherwise it won't be there for the code in pngrtran.c).\r\n        */\r\n\r\n       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);\r\n\r\n       /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */\r\n       png_ptr->trans_alpha = info_ptr->trans_alpha = png_voidcast(png_bytep,\r\n         png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH));\r\n\r\n       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)\r\n          memcpy(info_ptr->trans_alpha, trans_alpha, (png_size_t)num_trans);\r\n   }\r\n\r\n   if (trans_color != NULL)\r\n   {\r\n      int sample_max = (1 << info_ptr->bit_depth);\r\n\r\n      if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&\r\n          trans_color->gray > sample_max) ||\r\n          (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&\r\n          (trans_color->red > sample_max ||\r\n          trans_color->green > sample_max ||\r\n          trans_color->blue > sample_max)))\r\n         png_warning(png_ptr,\r\n            \"tRNS chunk has out-of-range samples for bit_depth\");\r\n\r\n      info_ptr->trans_color = *trans_color;\r\n\r\n      if (num_trans == 0)\r\n         num_trans = 1;\r\n   }\r\n\r\n   info_ptr->num_trans = (png_uint_16)num_trans;\r\n\r\n   if (num_trans != 0)\r\n   {\r\n      info_ptr->valid |= PNG_INFO_tRNS;\r\n      info_ptr->free_me |= PNG_FREE_TRNS;\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_sPLT_SUPPORTED\r\nvoid PNGAPI\r\npng_set_sPLT(png_const_structrp png_ptr,\r\n    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries)\r\n/*\r\n *  entries        - array of png_sPLT_t structures\r\n *                   to be added to the list of palettes\r\n *                   in the info structure.\r\n *\r\n *  nentries       - number of palette structures to be\r\n *                   added.\r\n */\r\n{\r\n   png_sPLT_tp np;\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || nentries <= 0 || entries == NULL)\r\n      return;\r\n\r\n   /* Use the internal realloc function, which checks for all the possible\r\n    * overflows.  Notice that the parameters are (int) and (size_t)\r\n    */\r\n   np = png_voidcast(png_sPLT_tp,png_realloc_array(png_ptr,\r\n      info_ptr->splt_palettes, info_ptr->splt_palettes_num, nentries,\r\n      sizeof *np));\r\n\r\n   if (np == NULL)\r\n   {\r\n      /* Out of memory or too many chunks */\r\n      png_chunk_report(png_ptr, \"too many sPLT chunks\", PNG_CHUNK_WRITE_ERROR);\r\n      return;\r\n   }\r\n\r\n   png_free(png_ptr, info_ptr->splt_palettes);\r\n   info_ptr->splt_palettes = np;\r\n   info_ptr->free_me |= PNG_FREE_SPLT;\r\n\r\n   np += info_ptr->splt_palettes_num;\r\n\r\n   do\r\n   {\r\n      png_size_t length;\r\n\r\n      /* Skip invalid input entries */\r\n      if (entries->name == NULL || entries->entries == NULL)\r\n      {\r\n         /* png_handle_sPLT doesn't do this, so this is an app error */\r\n         png_app_error(png_ptr, \"png_set_sPLT: invalid sPLT\");\r\n         /* Just skip the invalid entry */\r\n         continue;\r\n      }\r\n\r\n      np->depth = entries->depth;\r\n\r\n      /* In the even of out-of-memory just return - there's no point keeping on\r\n       * trying to add sPLT chunks.\r\n       */\r\n      length = strlen(entries->name) + 1;\r\n      np->name = png_voidcast(png_charp, png_malloc_base(png_ptr, length));\r\n\r\n      if (np->name == NULL)\r\n         break;\r\n\r\n      memcpy(np->name, entries->name, length);\r\n\r\n      /* IMPORTANT: we have memory now that won't get freed if something else\r\n       * goes wrong, this code must free it.  png_malloc_array produces no\r\n       * warnings, use a png_chunk_report (below) if there is an error.\r\n       */\r\n      np->entries = png_voidcast(png_sPLT_entryp, png_malloc_array(png_ptr,\r\n          entries->nentries, sizeof (png_sPLT_entry)));\r\n\r\n      if (np->entries == NULL)\r\n      {\r\n         png_free(png_ptr, np->name);\r\n         break;\r\n      }\r\n\r\n      np->nentries = entries->nentries;\r\n      /* This multiply can't overflow because png_malloc_array has already\r\n       * checked it when doing the allocation.\r\n       */\r\n      memcpy(np->entries, entries->entries,\r\n         entries->nentries * sizeof (png_sPLT_entry));\r\n\r\n      /* Note that 'continue' skips the advance of the out pointer and out\r\n       * count, so an invalid entry is not added.\r\n       */\r\n      info_ptr->valid |= PNG_INFO_sPLT;\r\n      ++(info_ptr->splt_palettes_num);\r\n      ++np;\r\n   }\r\n   while (++entries, --nentries);\r\n\r\n   if (nentries > 0)\r\n      png_chunk_report(png_ptr, \"sPLT out of memory\", PNG_CHUNK_WRITE_ERROR);\r\n}\r\n#endif /* PNG_sPLT_SUPPORTED */\r\n\r\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\r\nstatic png_byte\r\ncheck_location(png_const_structrp png_ptr, int location)\r\n{\r\n   location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);\r\n\r\n   /* New in 1.6.0; copy the location and check it.  This is an API\r\n    * change, previously the app had to use the\r\n    * png_set_unknown_chunk_location API below for each chunk.\r\n    */\r\n   if (location == 0 && !(png_ptr->mode & PNG_IS_READ_STRUCT))\r\n   {\r\n      /* Write struct, so unknown chunks come from the app */\r\n      png_app_warning(png_ptr,\r\n         \"png_set_unknown_chunks now expects a valid location\");\r\n      /* Use the old behavior */\r\n      location = (png_byte)(png_ptr->mode &\r\n         (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));\r\n   }\r\n\r\n   /* This need not be an internal error - if the app calls\r\n    * png_set_unknown_chunks on a read pointer it must get the location right.\r\n    */\r\n   if (location == 0)\r\n      png_error(png_ptr, \"invalid location in png_set_unknown_chunks\");\r\n\r\n   /* Now reduce the location to the top-most set bit by removing each least\r\n    * significant bit in turn.\r\n    */\r\n   while (location != (location & -location))\r\n      location &= ~(location & -location);\r\n\r\n   /* The cast is safe because 'location' is a bit mask and only the low four\r\n    * bits are significant.\r\n    */\r\n   return (png_byte)location;\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_unknown_chunks(png_const_structrp png_ptr,\r\n   png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)\r\n{\r\n   png_unknown_chunkp np;\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL || num_unknowns <= 0 ||\r\n      unknowns == NULL)\r\n      return;\r\n\r\n   /* Check for the failure cases where support has been disabled at compile\r\n    * time.  This code is hardly ever compiled - it's here because\r\n    * STORE_UNKNOWN_CHUNKS is set by both read and write code (compiling in this\r\n    * code) but may be meaningless if the read or write handling of unknown\r\n    * chunks is not compiled in.\r\n    */\r\n#  if !defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) && \\\r\n      defined(PNG_READ_SUPPORTED)\r\n      if (png_ptr->mode & PNG_IS_READ_STRUCT)\r\n      {\r\n         png_app_error(png_ptr, \"no unknown chunk support on read\");\r\n         return;\r\n      }\r\n#  endif\r\n#  if !defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED) && \\\r\n      defined(PNG_WRITE_SUPPORTED)\r\n      if (!(png_ptr->mode & PNG_IS_READ_STRUCT))\r\n      {\r\n         png_app_error(png_ptr, \"no unknown chunk support on write\");\r\n         return;\r\n      }\r\n#  endif\r\n\r\n   /* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that\r\n    * unknown critical chunks could be lost with just a warning resulting in\r\n    * undefined behavior.  Now png_chunk_report is used to provide behavior\r\n    * appropriate to read or write.\r\n    */\r\n   np = png_voidcast(png_unknown_chunkp, png_realloc_array(png_ptr,\r\n         info_ptr->unknown_chunks, info_ptr->unknown_chunks_num, num_unknowns,\r\n         sizeof *np));\r\n\r\n   if (np == NULL)\r\n   {\r\n      png_chunk_report(png_ptr, \"too many unknown chunks\",\r\n         PNG_CHUNK_WRITE_ERROR);\r\n      return;\r\n   }\r\n\r\n   png_free(png_ptr, info_ptr->unknown_chunks);\r\n   info_ptr->unknown_chunks = np; /* safe because it is initialized */\r\n   info_ptr->free_me |= PNG_FREE_UNKN;\r\n\r\n   np += info_ptr->unknown_chunks_num;\r\n\r\n   /* Increment unknown_chunks_num each time round the loop to protect the\r\n    * just-allocated chunk data.\r\n    */\r\n   for (; num_unknowns > 0; --num_unknowns, ++unknowns)\r\n   {\r\n      memcpy(np->name, unknowns->name, (sizeof np->name));\r\n      np->name[(sizeof np->name)-1] = '\\0';\r\n      np->location = check_location(png_ptr, unknowns->location);\r\n\r\n      if (unknowns->size == 0)\r\n      {\r\n         np->data = NULL;\r\n         np->size = 0;\r\n      }\r\n\r\n      else\r\n      {\r\n         np->data = png_voidcast(png_bytep,\r\n            png_malloc_base(png_ptr, unknowns->size));\r\n\r\n         if (np->data == NULL)\r\n         {\r\n            png_chunk_report(png_ptr, \"unknown chunk: out of memory\",\r\n               PNG_CHUNK_WRITE_ERROR);\r\n            /* But just skip storing the unknown chunk */\r\n            continue;\r\n         }\r\n\r\n         memcpy(np->data, unknowns->data, unknowns->size);\r\n         np->size = unknowns->size;\r\n      }\r\n\r\n      /* These increments are skipped on out-of-memory for the data - the\r\n       * unknown chunk entry gets overwritten if the png_chunk_report returns.\r\n       * This is correct in the read case (the chunk is just dropped.)\r\n       */\r\n      ++np;\r\n      ++(info_ptr->unknown_chunks_num);\r\n   }\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_unknown_chunk_location(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    int chunk, int location)\r\n{\r\n   /* This API is pretty pointless in 1.6.0 because the location can be set\r\n    * before the call to png_set_unknown_chunks.\r\n    *\r\n    * TODO: add a png_app_warning in 1.7\r\n    */\r\n   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&\r\n      chunk < info_ptr->unknown_chunks_num)\r\n   {\r\n      if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT)) == 0)\r\n      {\r\n         png_app_error(png_ptr, \"invalid unknown chunk location\");\r\n         /* Fake out the pre 1.6.0 behavior: */\r\n         if ((location & PNG_HAVE_IDAT)) /* undocumented! */\r\n            location = PNG_AFTER_IDAT;\r\n\r\n         else\r\n            location = PNG_HAVE_IHDR; /* also undocumented */\r\n      }\r\n\r\n      info_ptr->unknown_chunks[chunk].location =\r\n         check_location(png_ptr, location);\r\n   }\r\n}\r\n#endif\r\n\r\n\r\n#ifdef PNG_MNG_FEATURES_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_permit_mng_features (png_structrp png_ptr, png_uint_32 mng_features)\r\n{\r\n   png_debug(1, \"in png_permit_mng_features\");\r\n\r\n   if (png_ptr == NULL)\r\n      return 0;\r\n\r\n   png_ptr->mng_features_permitted = mng_features & PNG_ALL_MNG_FEATURES;\r\n\r\n   return png_ptr->mng_features_permitted;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\r\nstatic unsigned int\r\nadd_one_chunk(png_bytep list, unsigned int count, png_const_bytep add, int keep)\r\n{\r\n   unsigned int i;\r\n\r\n   /* Utility function: update the 'keep' state of a chunk if it is already in\r\n    * the list, otherwise add it to the list.\r\n    */\r\n   for (i=0; i<count; ++i, list += 5) if (memcmp(list, add, 4) == 0)\r\n   {\r\n      list[4] = (png_byte)keep;\r\n      return count;\r\n   }\r\n\r\n   if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)\r\n   {\r\n      ++count;\r\n      memcpy(list, add, 4);\r\n      list[4] = (png_byte)keep;\r\n   }\r\n\r\n   return count;\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_keep_unknown_chunks(png_structrp png_ptr, int keep,\r\n    png_const_bytep chunk_list, int num_chunks_in)\r\n{\r\n   png_bytep new_list;\r\n   unsigned int num_chunks, old_num_chunks;\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   if (keep < 0 || keep >= PNG_HANDLE_CHUNK_LAST)\r\n   {\r\n      png_app_error(png_ptr, \"png_set_keep_unknown_chunks: invalid keep\");\r\n      return;\r\n   }\r\n\r\n   if (num_chunks_in <= 0)\r\n   {\r\n      png_ptr->unknown_default = keep;\r\n\r\n      /* '0' means just set the flags, so stop here */\r\n      if (num_chunks_in == 0)\r\n        return;\r\n   }\r\n\r\n   if (num_chunks_in < 0)\r\n   {\r\n      /* Ignore all unknown chunks and all chunks recognized by\r\n       * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND\r\n       */\r\n      static PNG_CONST png_byte chunks_to_ignore[] = {\r\n         98,  75,  71,  68, '\\0',  /* bKGD */\r\n         99,  72,  82,  77, '\\0',  /* cHRM */\r\n        103,  65,  77,  65, '\\0',  /* gAMA */\r\n        104,  73,  83,  84, '\\0',  /* hIST */\r\n        105,  67,  67,  80, '\\0',  /* iCCP */\r\n        105,  84,  88, 116, '\\0',  /* iTXt */\r\n        111,  70,  70, 115, '\\0',  /* oFFs */\r\n        112,  67,  65,  76, '\\0',  /* pCAL */\r\n        112,  72,  89, 115, '\\0',  /* pHYs */\r\n        115,  66,  73,  84, '\\0',  /* sBIT */\r\n        115,  67,  65,  76, '\\0',  /* sCAL */\r\n        115,  80,  76,  84, '\\0',  /* sPLT */\r\n        115,  84,  69,  82, '\\0',  /* sTER */\r\n        115,  82,  71,  66, '\\0',  /* sRGB */\r\n        116,  69,  88, 116, '\\0',  /* tEXt */\r\n        116,  73,  77,  69, '\\0',  /* tIME */\r\n        122,  84,  88, 116, '\\0'   /* zTXt */\r\n      };\r\n\r\n      chunk_list = chunks_to_ignore;\r\n      num_chunks = (sizeof chunks_to_ignore)/5;\r\n   }\r\n\r\n   else /* num_chunks_in > 0 */\r\n   {\r\n      if (chunk_list == NULL)\r\n      {\r\n         /* Prior to 1.6.0 this was silently ignored, now it is an app_error\r\n          * which can be switched off.\r\n          */\r\n         png_app_error(png_ptr, \"png_set_keep_unknown_chunks: no chunk list\");\r\n         return;\r\n      }\r\n\r\n      num_chunks = num_chunks_in;\r\n   }\r\n\r\n   old_num_chunks = png_ptr->num_chunk_list;\r\n   if (png_ptr->chunk_list == NULL)\r\n      old_num_chunks = 0;\r\n\r\n   /* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.\r\n    */\r\n   if (num_chunks + old_num_chunks > UINT_MAX/5)\r\n   {\r\n      png_app_error(png_ptr, \"png_set_keep_unknown_chunks: too many chunks\");\r\n      return;\r\n   }\r\n\r\n   /* If these chunks are being reset to the default then no more memory is\r\n    * required because add_one_chunk above doesn't extend the list if the 'keep'\r\n    * parameter is the default.\r\n    */\r\n   if (keep)\r\n   {\r\n      new_list = png_voidcast(png_bytep, png_malloc(png_ptr,\r\n          5 * (num_chunks + old_num_chunks)));\r\n\r\n      if (old_num_chunks > 0)\r\n         memcpy(new_list, png_ptr->chunk_list, 5*old_num_chunks);\r\n   }\r\n\r\n   else if (old_num_chunks > 0)\r\n      new_list = png_ptr->chunk_list;\r\n\r\n   else\r\n      new_list = NULL;\r\n\r\n   /* Add the new chunks together with each one's handling code.  If the chunk\r\n    * already exists the code is updated, otherwise the chunk is added to the\r\n    * end.  (In libpng 1.6.0 order no longer matters because this code enforces\r\n    * the earlier convention that the last setting is the one that is used.)\r\n    */\r\n   if (new_list != NULL)\r\n   {\r\n      png_const_bytep inlist;\r\n      png_bytep outlist;\r\n      unsigned int i;\r\n\r\n      for (i=0; i<num_chunks; ++i)\r\n         old_num_chunks = add_one_chunk(new_list, old_num_chunks,\r\n            chunk_list+5*i, keep);\r\n\r\n      /* Now remove any spurious 'default' entries. */\r\n      num_chunks = 0;\r\n      for (i=0, inlist=outlist=new_list; i<old_num_chunks; ++i, inlist += 5)\r\n         if (inlist[4])\r\n         {\r\n            if (outlist != inlist)\r\n               memcpy(outlist, inlist, 5);\r\n            outlist += 5;\r\n            ++num_chunks;\r\n         }\r\n\r\n      /* This means the application has removed all the specialized handling. */\r\n      if (num_chunks == 0)\r\n      {\r\n         if (png_ptr->chunk_list != new_list)\r\n            png_free(png_ptr, new_list);\r\n\r\n         new_list = NULL;\r\n      }\r\n   }\r\n\r\n   else\r\n      num_chunks = 0;\r\n\r\n   png_ptr->num_chunk_list = num_chunks;\r\n\r\n   if (png_ptr->chunk_list != new_list)\r\n   {\r\n      if (png_ptr->chunk_list != NULL)\r\n         png_free(png_ptr, png_ptr->chunk_list);\r\n\r\n      png_ptr->chunk_list = new_list;\r\n   }\r\n}\r\n#endif\r\n\r\n#ifdef PNG_READ_USER_CHUNKS_SUPPORTED\r\nvoid PNGAPI\r\npng_set_read_user_chunk_fn(png_structrp png_ptr, png_voidp user_chunk_ptr,\r\n    png_user_chunk_ptr read_user_chunk_fn)\r\n{\r\n   png_debug(1, \"in png_set_read_user_chunk_fn\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->read_user_chunk_fn = read_user_chunk_fn;\r\n   png_ptr->user_chunk_ptr = user_chunk_ptr;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_INFO_IMAGE_SUPPORTED\r\nvoid PNGAPI\r\npng_set_rows(png_const_structrp png_ptr, png_inforp info_ptr,\r\n    png_bytepp row_pointers)\r\n{\r\n   png_debug1(1, \"in %s storage function\", \"rows\");\r\n\r\n   if (png_ptr == NULL || info_ptr == NULL)\r\n      return;\r\n\r\n   if (info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))\r\n      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\r\n\r\n   info_ptr->row_pointers = row_pointers;\r\n\r\n   if (row_pointers)\r\n      info_ptr->valid |= PNG_INFO_IDAT;\r\n}\r\n#endif\r\n\r\nvoid PNGAPI\r\npng_set_compression_buffer_size(png_structrp png_ptr, png_size_t size)\r\n{\r\n    if (png_ptr == NULL)\r\n       return;\r\n\r\n    if (size == 0 || size > PNG_UINT_31_MAX)\r\n       png_error(png_ptr, \"invalid compression buffer size\");\r\n\r\n#  ifdef PNG_SEQUENTIAL_READ_SUPPORTED\r\n      if (png_ptr->mode & PNG_IS_READ_STRUCT)\r\n      {\r\n         png_ptr->IDAT_read_size = (png_uint_32)size; /* checked above */\r\n         return;\r\n      }\r\n#  endif\r\n\r\n#  ifdef PNG_WRITE_SUPPORTED\r\n      if (!(png_ptr->mode & PNG_IS_READ_STRUCT))\r\n      {\r\n         if (png_ptr->zowner != 0)\r\n         {\r\n            png_warning(png_ptr,\r\n              \"Compression buffer size cannot be changed because it is in use\");\r\n            return;\r\n         }\r\n\r\n         if (size > ZLIB_IO_MAX)\r\n         {\r\n            png_warning(png_ptr,\r\n               \"Compression buffer size limited to system maximum\");\r\n            size = ZLIB_IO_MAX; /* must fit */\r\n         }\r\n\r\n         else if (size < 6)\r\n         {\r\n            /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH\r\n             * if this is permitted.\r\n             */\r\n            png_warning(png_ptr,\r\n               \"Compression buffer size cannot be reduced below 6\");\r\n            return;\r\n         }\r\n\r\n         if (png_ptr->zbuffer_size != size)\r\n         {\r\n            png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);\r\n            png_ptr->zbuffer_size = (uInt)size;\r\n         }\r\n      }\r\n#  endif\r\n}\r\n\r\nvoid PNGAPI\r\npng_set_invalid(png_const_structrp png_ptr, png_inforp info_ptr, int mask)\r\n{\r\n   if (png_ptr && info_ptr)\r\n      info_ptr->valid &= ~mask;\r\n}\r\n\r\n\r\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\r\n/* This function was added to libpng 1.2.6 */\r\nvoid PNGAPI\r\npng_set_user_limits (png_structrp png_ptr, png_uint_32 user_width_max,\r\n    png_uint_32 user_height_max)\r\n{\r\n   /* Images with dimensions larger than these limits will be\r\n    * rejected by png_set_IHDR().  To accept any PNG datastream\r\n    * regardless of dimensions, set both limits to 0x7ffffffL.\r\n    */\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->user_width_max = user_width_max;\r\n   png_ptr->user_height_max = user_height_max;\r\n}\r\n\r\n/* This function was added to libpng 1.4.0 */\r\nvoid PNGAPI\r\npng_set_chunk_cache_max (png_structrp png_ptr, png_uint_32 user_chunk_cache_max)\r\n{\r\n    if (png_ptr)\r\n       png_ptr->user_chunk_cache_max = user_chunk_cache_max;\r\n}\r\n\r\n/* This function was added to libpng 1.4.1 */\r\nvoid PNGAPI\r\npng_set_chunk_malloc_max (png_structrp png_ptr,\r\n    png_alloc_size_t user_chunk_malloc_max)\r\n{\r\n   if (png_ptr)\r\n      png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\r\n}\r\n#endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */\r\n\r\n\r\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\r\nvoid PNGAPI\r\npng_set_benign_errors(png_structrp png_ptr, int allowed)\r\n{\r\n   png_debug(1, \"in png_set_benign_errors\");\r\n\r\n   /* If allowed is 1, png_benign_error() is treated as a warning.\r\n    *\r\n    * If allowed is 0, png_benign_error() is treated as an error (which\r\n    * is the default behavior if png_set_benign_errors() is not called).\r\n    */\r\n\r\n   if (allowed)\r\n      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN |\r\n         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN;\r\n\r\n   else\r\n      png_ptr->flags &= ~(PNG_FLAG_BENIGN_ERRORS_WARN |\r\n         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN);\r\n}\r\n#endif /* PNG_BENIGN_ERRORS_SUPPORTED */\r\n\r\n#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED\r\n   /* Whether to report invalid palette index; added at libng-1.5.10.\r\n    * It is possible for an indexed (color-type==3) PNG file to contain\r\n    * pixels with invalid (out-of-range) indexes if the PLTE chunk has\r\n    * fewer entries than the image's bit-depth would allow. We recover\r\n    * from this gracefully by filling any incomplete palette with zeroes\r\n    * (opaque black).  By default, when this occurs libpng will issue\r\n    * a benign error.  This API can be used to override that behavior.\r\n    */\r\nvoid PNGAPI\r\npng_set_check_for_invalid_index(png_structrp png_ptr, int allowed)\r\n{\r\n   png_debug(1, \"in png_set_check_for_invalid_index\");\r\n\r\n   if (allowed > 0)\r\n      png_ptr->num_palette_max = 0;\r\n\r\n   else\r\n      png_ptr->num_palette_max = -1;\r\n}\r\n#endif\r\n#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */\r\n","\r\n/* pngtrans.c - transforms the data in a row (used by both readers and writers)\r\n *\r\n * Last changed in libpng 1.6.9 [February 6, 2014]\r\n * Copyright (c) 1998-2014 Glenn Randers-Pehrson\r\n * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)\r\n * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)\r\n *\r\n * This code is released under the libpng license.\r\n * For conditions of distribution and use, see the disclaimer\r\n * and license in png.h\r\n */\r\n\r\n#include \"pngpriv.h\"\r\n\r\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\r\n\r\n#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)\r\n/* Turn on BGR-to-RGB mapping */\r\nvoid PNGAPI\r\npng_set_bgr(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_bgr\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_BGR;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)\r\n/* Turn on 16 bit byte swapping */\r\nvoid PNGAPI\r\npng_set_swap(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_swap\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   if (png_ptr->bit_depth == 16)\r\n      png_ptr->transformations |= PNG_SWAP_BYTES;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\r\n/* Turn on pixel packing */\r\nvoid PNGAPI\r\npng_set_packing(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_packing\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   if (png_ptr->bit_depth < 8)\r\n   {\r\n      png_ptr->transformations |= PNG_PACK;\r\n#     ifdef PNG_WRITE_SUPPORTED\r\n         png_ptr->usr_bit_depth = 8;\r\n#     endif\r\n   }\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)\r\n/* Turn on packed pixel swapping */\r\nvoid PNGAPI\r\npng_set_packswap(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_packswap\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   if (png_ptr->bit_depth < 8)\r\n      png_ptr->transformations |= PNG_PACKSWAP;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)\r\nvoid PNGAPI\r\npng_set_shift(png_structrp png_ptr, png_const_color_8p true_bits)\r\n{\r\n   png_debug(1, \"in png_set_shift\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_SHIFT;\r\n   png_ptr->shift = *true_bits;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_INTERLACING_SUPPORTED) || \\\r\n    defined(PNG_WRITE_INTERLACING_SUPPORTED)\r\nint PNGAPI\r\npng_set_interlace_handling(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_interlace handling\");\r\n\r\n   if (png_ptr && png_ptr->interlaced)\r\n   {\r\n      png_ptr->transformations |= PNG_INTERLACE;\r\n      return (7);\r\n   }\r\n\r\n   return (1);\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)\r\n/* Add a filler byte on read, or remove a filler or alpha byte on write.\r\n * The filler type has changed in v0.95 to allow future 2-byte fillers\r\n * for 48-bit input data, as well as to avoid problems with some compilers\r\n * that don't like bytes as parameters.\r\n */\r\nvoid PNGAPI\r\npng_set_filler(png_structrp png_ptr, png_uint_32 filler, int filler_loc)\r\n{\r\n   png_debug(1, \"in png_set_filler\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   /* In libpng 1.6 it is possible to determine whether this is a read or write\r\n    * operation and therefore to do more checking here for a valid call.\r\n    */\r\n   if (png_ptr->mode & PNG_IS_READ_STRUCT)\r\n   {\r\n#     ifdef PNG_READ_FILLER_SUPPORTED\r\n         /* On read png_set_filler is always valid, regardless of the base PNG\r\n          * format, because other transformations can give a format where the\r\n          * filler code can execute (basically an 8 or 16-bit component RGB or G\r\n          * format.)\r\n          *\r\n          * NOTE: usr_channels is not used by the read code!  (This has led to\r\n          * confusion in the past.)  The filler is only used in the read code.\r\n          */\r\n         png_ptr->filler = (png_uint_16)filler;\r\n#     else\r\n         png_app_error(png_ptr, \"png_set_filler not supported on read\");\r\n         PNG_UNUSED(filler) /* not used in the write case */\r\n         return;\r\n#     endif\r\n   }\r\n\r\n   else /* write */\r\n   {\r\n#     ifdef PNG_WRITE_FILLER_SUPPORTED\r\n         /* On write the usr_channels parameter must be set correctly at the\r\n          * start to record the number of channels in the app-supplied data.\r\n          */\r\n         switch (png_ptr->color_type)\r\n         {\r\n            case PNG_COLOR_TYPE_RGB:\r\n               png_ptr->usr_channels = 4;\r\n               break;\r\n\r\n            case PNG_COLOR_TYPE_GRAY:\r\n               if (png_ptr->bit_depth >= 8)\r\n               {\r\n                  png_ptr->usr_channels = 2;\r\n                  break;\r\n               }\r\n\r\n               else\r\n               {\r\n                  /* There simply isn't any code in libpng to strip out bits\r\n                   * from bytes when the components are less than a byte in\r\n                   * size!\r\n                   */\r\n                  png_app_error(png_ptr,\r\n                     \"png_set_filler is invalid for low bit depth gray output\");\r\n                  return;\r\n               }\r\n\r\n            default:\r\n               png_app_error(png_ptr,\r\n                  \"png_set_filler: inappropriate color type\");\r\n               return;\r\n         }\r\n#     else\r\n         png_app_error(png_ptr, \"png_set_filler not supported on write\");\r\n         return;\r\n#     endif\r\n   }\r\n\r\n   /* Here on success - libpng supports the operation, set the transformation\r\n    * and the flag to say where the filler channel is.\r\n    */\r\n   png_ptr->transformations |= PNG_FILLER;\r\n\r\n   if (filler_loc == PNG_FILLER_AFTER)\r\n      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;\r\n\r\n   else\r\n      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;\r\n}\r\n\r\n/* Added to libpng-1.2.7 */\r\nvoid PNGAPI\r\npng_set_add_alpha(png_structrp png_ptr, png_uint_32 filler, int filler_loc)\r\n{\r\n   png_debug(1, \"in png_set_add_alpha\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_set_filler(png_ptr, filler, filler_loc);\r\n   /* The above may fail to do anything. */\r\n   if (png_ptr->transformations & PNG_FILLER)\r\n      png_ptr->transformations |= PNG_ADD_ALPHA;\r\n}\r\n\r\n#endif\r\n\r\n#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \\\r\n    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)\r\nvoid PNGAPI\r\npng_set_swap_alpha(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_swap_alpha\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_SWAP_ALPHA;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \\\r\n    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)\r\nvoid PNGAPI\r\npng_set_invert_alpha(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_invert_alpha\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_INVERT_ALPHA;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)\r\nvoid PNGAPI\r\npng_set_invert_mono(png_structrp png_ptr)\r\n{\r\n   png_debug(1, \"in png_set_invert_mono\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n   png_ptr->transformations |= PNG_INVERT_MONO;\r\n}\r\n\r\n/* Invert monochrome grayscale data */\r\nvoid /* PRIVATE */\r\npng_do_invert(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_invert\");\r\n\r\n  /* This test removed from libpng version 1.0.13 and 1.2.0:\r\n   *   if (row_info->bit_depth == 1 &&\r\n   */\r\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\r\n   {\r\n      png_bytep rp = row;\r\n      png_size_t i;\r\n      png_size_t istop = row_info->rowbytes;\r\n\r\n      for (i = 0; i < istop; i++)\r\n      {\r\n         *rp = (png_byte)(~(*rp));\r\n         rp++;\r\n      }\r\n   }\r\n\r\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\r\n      row_info->bit_depth == 8)\r\n   {\r\n      png_bytep rp = row;\r\n      png_size_t i;\r\n      png_size_t istop = row_info->rowbytes;\r\n\r\n      for (i = 0; i < istop; i += 2)\r\n      {\r\n         *rp = (png_byte)(~(*rp));\r\n         rp += 2;\r\n      }\r\n   }\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\r\n      row_info->bit_depth == 16)\r\n   {\r\n      png_bytep rp = row;\r\n      png_size_t i;\r\n      png_size_t istop = row_info->rowbytes;\r\n\r\n      for (i = 0; i < istop; i += 4)\r\n      {\r\n         *rp = (png_byte)(~(*rp));\r\n         *(rp + 1) = (png_byte)(~(*(rp + 1)));\r\n         rp += 4;\r\n      }\r\n   }\r\n#endif\r\n}\r\n#endif\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)\r\n/* Swaps byte order on 16 bit depth images */\r\nvoid /* PRIVATE */\r\npng_do_swap(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_swap\");\r\n\r\n   if (row_info->bit_depth == 16)\r\n   {\r\n      png_bytep rp = row;\r\n      png_uint_32 i;\r\n      png_uint_32 istop= row_info->width * row_info->channels;\r\n\r\n      for (i = 0; i < istop; i++, rp += 2)\r\n      {\r\n         png_byte t = *rp;\r\n         *rp = *(rp + 1);\r\n         *(rp + 1) = t;\r\n      }\r\n   }\r\n}\r\n#endif\r\n#endif\r\n\r\n#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)\r\nstatic PNG_CONST png_byte onebppswaptable[256] = {\r\n   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,\r\n   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,\r\n   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,\r\n   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,\r\n   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,\r\n   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,\r\n   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,\r\n   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,\r\n   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,\r\n   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,\r\n   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,\r\n   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,\r\n   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,\r\n   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,\r\n   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,\r\n   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,\r\n   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,\r\n   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,\r\n   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,\r\n   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,\r\n   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,\r\n   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,\r\n   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,\r\n   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,\r\n   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,\r\n   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,\r\n   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,\r\n   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,\r\n   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,\r\n   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,\r\n   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,\r\n   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF\r\n};\r\n\r\nstatic PNG_CONST png_byte twobppswaptable[256] = {\r\n   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,\r\n   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,\r\n   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,\r\n   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,\r\n   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,\r\n   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,\r\n   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,\r\n   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,\r\n   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,\r\n   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,\r\n   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,\r\n   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,\r\n   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,\r\n   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,\r\n   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,\r\n   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,\r\n   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,\r\n   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,\r\n   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,\r\n   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,\r\n   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,\r\n   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,\r\n   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,\r\n   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,\r\n   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,\r\n   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,\r\n   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,\r\n   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,\r\n   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,\r\n   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,\r\n   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,\r\n   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF\r\n};\r\n\r\nstatic PNG_CONST png_byte fourbppswaptable[256] = {\r\n   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,\r\n   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,\r\n   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,\r\n   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,\r\n   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,\r\n   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,\r\n   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,\r\n   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,\r\n   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,\r\n   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,\r\n   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,\r\n   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,\r\n   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,\r\n   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,\r\n   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,\r\n   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,\r\n   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,\r\n   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,\r\n   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,\r\n   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,\r\n   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,\r\n   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,\r\n   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,\r\n   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,\r\n   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,\r\n   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,\r\n   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,\r\n   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,\r\n   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,\r\n   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,\r\n   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,\r\n   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF\r\n};\r\n\r\n/* Swaps pixel packing order within bytes */\r\nvoid /* PRIVATE */\r\npng_do_packswap(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_packswap\");\r\n\r\n   if (row_info->bit_depth < 8)\r\n   {\r\n      png_bytep rp;\r\n      png_const_bytep end, table;\r\n\r\n      end = row + row_info->rowbytes;\r\n\r\n      if (row_info->bit_depth == 1)\r\n         table = onebppswaptable;\r\n\r\n      else if (row_info->bit_depth == 2)\r\n         table = twobppswaptable;\r\n\r\n      else if (row_info->bit_depth == 4)\r\n         table = fourbppswaptable;\r\n\r\n      else\r\n         return;\r\n\r\n      for (rp = row; rp < end; rp++)\r\n         *rp = table[*rp];\r\n   }\r\n}\r\n#endif /* PNG_READ_PACKSWAP_SUPPORTED or PNG_WRITE_PACKSWAP_SUPPORTED */\r\n\r\n#if defined(PNG_WRITE_FILLER_SUPPORTED) || \\\r\n    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)\r\n/* Remove a channel - this used to be 'png_do_strip_filler' but it used a\r\n * somewhat weird combination of flags to determine what to do.  All the calls\r\n * to png_do_strip_filler are changed in 1.5.2 to call this instead with the\r\n * correct arguments.\r\n *\r\n * The routine isn't general - the channel must be the channel at the start or\r\n * end (not in the middle) of each pixel.\r\n */\r\nvoid /* PRIVATE */\r\npng_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)\r\n{\r\n   png_bytep sp = row; /* source pointer */\r\n   png_bytep dp = row; /* destination pointer */\r\n   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */\r\n\r\n   /* At the start sp will point to the first byte to copy and dp to where\r\n    * it is copied to.  ep always points just beyond the end of the row, so\r\n    * the loop simply copies (channels-1) channels until sp reaches ep.\r\n    *\r\n    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.\r\n    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.\r\n    */\r\n\r\n   /* GA, GX, XG cases */\r\n   if (row_info->channels == 2)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         if (at_start) /* Skip initial filler */\r\n            ++sp;\r\n         else          /* Skip initial channel and, for sp, the filler */\r\n            sp += 2, ++dp;\r\n\r\n         /* For a 1 pixel wide image there is nothing to do */\r\n         while (sp < ep)\r\n            *dp++ = *sp, sp += 2;\r\n\r\n         row_info->pixel_depth = 8;\r\n      }\r\n\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         if (at_start) /* Skip initial filler */\r\n            sp += 2;\r\n         else          /* Skip initial channel and, for sp, the filler */\r\n            sp += 4, dp += 2;\r\n\r\n         while (sp < ep)\r\n            *dp++ = *sp++, *dp++ = *sp, sp += 3;\r\n\r\n         row_info->pixel_depth = 16;\r\n      }\r\n\r\n      else\r\n         return; /* bad bit depth */\r\n\r\n      row_info->channels = 1;\r\n\r\n      /* Finally fix the color type if it records an alpha channel */\r\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\n         row_info->color_type = PNG_COLOR_TYPE_GRAY;\r\n   }\r\n\r\n   /* RGBA, RGBX, XRGB cases */\r\n   else if (row_info->channels == 4)\r\n   {\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         if (at_start) /* Skip initial filler */\r\n            ++sp;\r\n         else          /* Skip initial channels and, for sp, the filler */\r\n            sp += 4, dp += 3;\r\n\r\n         /* Note that the loop adds 3 to dp and 4 to sp each time. */\r\n         while (sp < ep)\r\n            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;\r\n\r\n         row_info->pixel_depth = 24;\r\n      }\r\n\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         if (at_start) /* Skip initial filler */\r\n            sp += 2;\r\n         else          /* Skip initial channels and, for sp, the filler */\r\n            sp += 8, dp += 6;\r\n\r\n         while (sp < ep)\r\n         {\r\n            /* Copy 6 bytes, skip 2 */\r\n            *dp++ = *sp++, *dp++ = *sp++;\r\n            *dp++ = *sp++, *dp++ = *sp++;\r\n            *dp++ = *sp++, *dp++ = *sp, sp += 3;\r\n         }\r\n\r\n         row_info->pixel_depth = 48;\r\n      }\r\n\r\n      else\r\n         return; /* bad bit depth */\r\n\r\n      row_info->channels = 3;\r\n\r\n      /* Finally fix the color type if it records an alpha channel */\r\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n         row_info->color_type = PNG_COLOR_TYPE_RGB;\r\n   }\r\n\r\n   else\r\n      return; /* The filler channel has gone already */\r\n\r\n   /* Fix the rowbytes value. */\r\n   row_info->rowbytes = dp-row;\r\n}\r\n#endif\r\n\r\n#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)\r\n/* Swaps red and blue bytes within a pixel */\r\nvoid /* PRIVATE */\r\npng_do_bgr(png_row_infop row_info, png_bytep row)\r\n{\r\n   png_debug(1, \"in png_do_bgr\");\r\n\r\n   if ((row_info->color_type & PNG_COLOR_MASK_COLOR))\r\n   {\r\n      png_uint_32 row_width = row_info->width;\r\n      if (row_info->bit_depth == 8)\r\n      {\r\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\r\n         {\r\n            png_bytep rp;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0, rp = row; i < row_width; i++, rp += 3)\r\n            {\r\n               png_byte save = *rp;\r\n               *rp = *(rp + 2);\r\n               *(rp + 2) = save;\r\n            }\r\n         }\r\n\r\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n         {\r\n            png_bytep rp;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0, rp = row; i < row_width; i++, rp += 4)\r\n            {\r\n               png_byte save = *rp;\r\n               *rp = *(rp + 2);\r\n               *(rp + 2) = save;\r\n            }\r\n         }\r\n      }\r\n\r\n#ifdef PNG_16BIT_SUPPORTED\r\n      else if (row_info->bit_depth == 16)\r\n      {\r\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\r\n         {\r\n            png_bytep rp;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0, rp = row; i < row_width; i++, rp += 6)\r\n            {\r\n               png_byte save = *rp;\r\n               *rp = *(rp + 4);\r\n               *(rp + 4) = save;\r\n               save = *(rp + 1);\r\n               *(rp + 1) = *(rp + 5);\r\n               *(rp + 5) = save;\r\n            }\r\n         }\r\n\r\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\n         {\r\n            png_bytep rp;\r\n            png_uint_32 i;\r\n\r\n            for (i = 0, rp = row; i < row_width; i++, rp += 8)\r\n            {\r\n               png_byte save = *rp;\r\n               *rp = *(rp + 4);\r\n               *(rp + 4) = save;\r\n               save = *(rp + 1);\r\n               *(rp + 1) = *(rp + 5);\r\n               *(rp + 5) = save;\r\n            }\r\n         }\r\n      }\r\n#endif\r\n   }\r\n}\r\n#endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */\r\n\r\n#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \\\r\n    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)\r\n/* Added at libpng-1.5.10 */\r\nvoid /* PRIVATE */\r\npng_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)\r\n{\r\n   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&\r\n      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */\r\n   {\r\n      /* Calculations moved outside switch in an attempt to stop different\r\n       * compiler warnings.  'padding' is in *bits* within the last byte, it is\r\n       * an 'int' because pixel_depth becomes an 'int' in the expression below,\r\n       * and this calculation is used because it avoids warnings that other\r\n       * forms produced on either GCC or MSVC.\r\n       */\r\n      int padding = (-row_info->pixel_depth * row_info->width) & 7;\r\n      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;\r\n\r\n      switch (row_info->bit_depth)\r\n      {\r\n         case 1:\r\n         {\r\n            /* in this case, all bytes must be 0 so we don't need\r\n             * to unpack the pixels except for the rightmost one.\r\n             */\r\n            for (; rp > png_ptr->row_buf; rp--)\r\n            {\r\n              if (*rp >> padding != 0)\r\n                 png_ptr->num_palette_max = 1;\r\n              padding = 0;\r\n            }\r\n\r\n            break;\r\n         }\r\n\r\n         case 2:\r\n         {\r\n            for (; rp > png_ptr->row_buf; rp--)\r\n            {\r\n              int i = ((*rp >> padding) & 0x03);\r\n\r\n              if (i > png_ptr->num_palette_max)\r\n                 png_ptr->num_palette_max = i;\r\n\r\n              i = (((*rp >> padding) >> 2) & 0x03);\r\n\r\n              if (i > png_ptr->num_palette_max)\r\n                 png_ptr->num_palette_max = i;\r\n\r\n              i = (((*rp >> padding) >> 4) & 0x03);\r\n\r\n              if (i > png_ptr->num_palette_max)\r\n                 png_ptr->num_palette_max = i;\r\n\r\n              i = (((*rp >> padding) >> 6) & 0x03);\r\n\r\n              if (i > png_ptr->num_palette_max)\r\n                 png_ptr->num_palette_max = i;\r\n\r\n              padding = 0;\r\n            }\r\n\r\n            break;\r\n         }\r\n\r\n         case 4:\r\n         {\r\n            for (; rp > png_ptr->row_buf; rp--)\r\n            {\r\n              int i = ((*rp >> padding) & 0x0f);\r\n\r\n              if (i > png_ptr->num_palette_max)\r\n                 png_ptr->num_palette_max = i;\r\n\r\n              i = (((*rp >> padding) >> 4) & 0x0f);\r\n\r\n              if (i > png_ptr->num_palette_max)\r\n                 png_ptr->num_palette_max = i;\r\n\r\n              padding = 0;\r\n            }\r\n\r\n            break;\r\n         }\r\n\r\n         case 8:\r\n         {\r\n            for (; rp > png_ptr->row_buf; rp--)\r\n            {\r\n               if (*rp > png_ptr->num_palette_max)\r\n                  png_ptr->num_palette_max = (int) *rp;\r\n            }\r\n\r\n            break;\r\n         }\r\n\r\n         default:\r\n            break;\r\n      }\r\n   }\r\n}\r\n#endif /* PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED */\r\n\r\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \\\r\n    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\r\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\r\nvoid PNGAPI\r\npng_set_user_transform_info(png_structrp png_ptr, png_voidp\r\n   user_transform_ptr, int user_transform_depth, int user_transform_channels)\r\n{\r\n   png_debug(1, \"in png_set_user_transform_info\");\r\n\r\n   if (png_ptr == NULL)\r\n      return;\r\n\r\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\r\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\r\n      (png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)\r\n   {\r\n      png_app_error(png_ptr,\r\n            \"info change after png_start_read_image or png_read_update_info\");\r\n      return;\r\n   }\r\n#endif\r\n\r\n   png_ptr->user_transform_ptr = user_transform_ptr;\r\n   png_ptr->user_transform_depth = (png_byte)user_transform_depth;\r\n   png_ptr->user_transform_channels = (png_byte)user_transform_channels;\r\n}\r\n#endif\r\n\r\n/* This function returns a pointer to the user_transform_ptr associated with\r\n * the user transform functions.  The application should free any memory\r\n * associated with this pointer before png_write_destroy and png_read_destroy\r\n * are called.\r\n */\r\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\r\npng_voidp PNGAPI\r\npng_get_user_transform_ptr(png_const_structrp png_ptr)\r\n{\r\n   if (png_ptr == NULL)\r\n      return (NULL);\r\n\r\n   return png_ptr->user_transform_ptr;\r\n}\r\n#endif\r\n\r\n#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED\r\npng_uint_32 PNGAPI\r\npng_get_current_row_number(png_const_structrp png_ptr)\r\n{\r\n   /* See the comments in png.h - this is the sub-image row when reading and\r\n    * interlaced image.\r\n    */\r\n   if (png_ptr != NULL)\r\n      return png_ptr->row_number;\r\n\r\n   return PNG_UINT_32_MAX; /* help the app not to fail silently */\r\n}\r\n\r\npng_byte PNGAPI\r\npng_get_current_pass_number(png_const_structrp png_ptr)\r\n{\r\n   if (png_ptr != NULL)\r\n      return png_ptr->pass;\r\n   return 8; /* invalid */\r\n}\r\n#endif /* PNG_USER_TRANSFORM_INFO_SUPPORTED */\r\n#endif /* PNG_READ_USER_TRANSFORM_SUPPORTED ||\r\n          PNG_WRITE_USER_TRANSFORM_SUPPORTED */\r\n#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */\r\n","/* adler32.c -- compute the Adler-32 checksum of a data stream\n * Copyright (C) 1995-2007 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zutil.h\"\n\n#define local static\n\nlocal uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2);\n\n#define BASE 65521UL    /* largest prime smaller than 65536 */\n#define NMAX 5552\n/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n\n#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}\n#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);\n#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);\n#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n#define DO16(buf)   DO8(buf,0); DO8(buf,8);\n\n/* use NO_DIVIDE if your processor does not do division in hardware */\n#ifdef NO_DIVIDE\n#  define MOD(a) \\\n    do { \\\n        if (a >= (BASE << 16)) a -= (BASE << 16); \\\n        if (a >= (BASE << 15)) a -= (BASE << 15); \\\n        if (a >= (BASE << 14)) a -= (BASE << 14); \\\n        if (a >= (BASE << 13)) a -= (BASE << 13); \\\n        if (a >= (BASE << 12)) a -= (BASE << 12); \\\n        if (a >= (BASE << 11)) a -= (BASE << 11); \\\n        if (a >= (BASE << 10)) a -= (BASE << 10); \\\n        if (a >= (BASE << 9)) a -= (BASE << 9); \\\n        if (a >= (BASE << 8)) a -= (BASE << 8); \\\n        if (a >= (BASE << 7)) a -= (BASE << 7); \\\n        if (a >= (BASE << 6)) a -= (BASE << 6); \\\n        if (a >= (BASE << 5)) a -= (BASE << 5); \\\n        if (a >= (BASE << 4)) a -= (BASE << 4); \\\n        if (a >= (BASE << 3)) a -= (BASE << 3); \\\n        if (a >= (BASE << 2)) a -= (BASE << 2); \\\n        if (a >= (BASE << 1)) a -= (BASE << 1); \\\n        if (a >= BASE) a -= BASE; \\\n    } while (0)\n#  define MOD4(a) \\\n    do { \\\n        if (a >= (BASE << 4)) a -= (BASE << 4); \\\n        if (a >= (BASE << 3)) a -= (BASE << 3); \\\n        if (a >= (BASE << 2)) a -= (BASE << 2); \\\n        if (a >= (BASE << 1)) a -= (BASE << 1); \\\n        if (a >= BASE) a -= BASE; \\\n    } while (0)\n#else\n#  define MOD(a) a %= BASE\n#  define MOD4(a) a %= BASE\n#endif\n\n/* ========================================================================= */\nuLong ZEXPORT adler32(adler, buf, len)\n    uLong adler;\n    const Bytef *buf;\n    uInt len;\n{\n    unsigned long sum2;\n    unsigned n;\n\n    /* split Adler-32 into component sums */\n    sum2 = (adler >> 16) & 0xffff;\n    adler &= 0xffff;\n\n    /* in case user likes doing a byte at a time, keep it fast */\n    if (len == 1) {\n        adler += buf[0];\n        if (adler >= BASE)\n            adler -= BASE;\n        sum2 += adler;\n        if (sum2 >= BASE)\n            sum2 -= BASE;\n        return adler | (sum2 << 16);\n    }\n\n    /* initial Adler-32 value (deferred check for len == 1 speed) */\n    if (buf == Z_NULL)\n        return 1L;\n\n    /* in case short lengths are provided, keep it somewhat fast */\n    if (len < 16) {\n        while (len--) {\n            adler += *buf++;\n            sum2 += adler;\n        }\n        if (adler >= BASE)\n            adler -= BASE;\n        MOD4(sum2);             /* only added so many BASE's */\n        return adler | (sum2 << 16);\n    }\n\n    /* do length NMAX blocks -- requires just one modulo operation */\n    while (len >= NMAX) {\n        len -= NMAX;\n        n = NMAX / 16;          /* NMAX is divisible by 16 */\n        do {\n            DO16(buf);          /* 16 sums unrolled */\n            buf += 16;\n        } while (--n);\n        MOD(adler);\n        MOD(sum2);\n    }\n\n    /* do remaining bytes (less than NMAX, still just one modulo) */\n    if (len) {                  /* avoid modulos if none remaining */\n        while (len >= 16) {\n            len -= 16;\n            DO16(buf);\n            buf += 16;\n        }\n        while (len--) {\n            adler += *buf++;\n            sum2 += adler;\n        }\n        MOD(adler);\n        MOD(sum2);\n    }\n\n    /* return recombined sums */\n    return adler | (sum2 << 16);\n}\n\n/* ========================================================================= */\nlocal uLong adler32_combine_(adler1, adler2, len2)\n    uLong adler1;\n    uLong adler2;\n    z_off64_t len2;\n{\n    unsigned long sum1;\n    unsigned long sum2;\n    unsigned rem;\n\n    /* the derivation of this formula is left as an exercise for the reader */\n    rem = (unsigned)(len2 % BASE);\n    sum1 = adler1 & 0xffff;\n    sum2 = rem * sum1;\n    MOD(sum2);\n    sum1 += (adler2 & 0xffff) + BASE - 1;\n    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);\n    if (sum2 >= BASE) sum2 -= BASE;\n    return sum1 | (sum2 << 16);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT adler32_combine(adler1, adler2, len2)\n    uLong adler1;\n    uLong adler2;\n    z_off_t len2;\n{\n    return adler32_combine_(adler1, adler2, len2);\n}\n\nuLong ZEXPORT adler32_combine64(adler1, adler2, len2)\n    uLong adler1;\n    uLong adler2;\n    z_off64_t len2;\n{\n    return adler32_combine_(adler1, adler2, len2);\n}\n","/* crc32.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2006, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster\n * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing\n * tables for updating the shift register in one step with three exclusive-ors\n * instead of four steps with four exclusive-ors.  This results in about a\n * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.\n */\n\n/* @(#) $Id$ */\n\n/*\n  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore\n  protection on the static variables used to control the first-use generation\n  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should\n  first call get_crc_table() to initialize the tables before allowing more than\n  one thread to use crc32().\n */\n\n#ifdef MAKECRCH\n#  include <stdio.h>\n#  ifndef DYNAMIC_CRC_TABLE\n#    define DYNAMIC_CRC_TABLE\n#  endif /* !DYNAMIC_CRC_TABLE */\n#endif /* MAKECRCH */\n\n#include \"zutil.h\"      /* for STDC and FAR definitions */\n\n#define local static\n\n/* Find a four-byte integer type for crc32_little() and crc32_big(). */\n#ifndef NOBYFOUR\n#  ifdef STDC           /* need ANSI C limits.h to determine sizes */\n#    include <limits.h>\n#    define BYFOUR\n#    if (UINT_MAX == 0xffffffffUL)\n       typedef unsigned int u4;\n#    else\n#      if (ULONG_MAX == 0xffffffffUL)\n         typedef unsigned long u4;\n#      else\n#        if (USHRT_MAX == 0xffffffffUL)\n           typedef unsigned short u4;\n#        else\n#          undef BYFOUR     /* can't find a four-byte integer type! */\n#        endif\n#      endif\n#    endif\n#  endif /* STDC */\n#endif /* !NOBYFOUR */\n\n/* Definitions for doing the crc four data bytes at a time. */\n#ifdef BYFOUR\n#  define REV(w) ((((w)>>24)&0xff)+(((w)>>8)&0xff00)+ \\\n                (((w)&0xff00)<<8)+(((w)&0xff)<<24))\n   local unsigned long crc32_little OF((unsigned long,\n                        const unsigned char FAR *, unsigned));\n   local unsigned long crc32_big OF((unsigned long,\n                        const unsigned char FAR *, unsigned));\n#  define TBLS 8\n#else\n#  define TBLS 1\n#endif /* BYFOUR */\n\n/* Local functions for crc concatenation */\nlocal unsigned long gf2_matrix_times OF((unsigned long *mat,\n                                         unsigned long vec));\nlocal void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));\nlocal uLong crc32_combine_(uLong crc1, uLong crc2, z_off64_t len2);\n\n\n#ifdef DYNAMIC_CRC_TABLE\n\nlocal volatile int crc_table_empty = 1;\nlocal unsigned long FAR crc_table[TBLS][256];\nlocal void make_crc_table OF((void));\n#ifdef MAKECRCH\n   local void write_table OF((FILE *, const unsigned long FAR *));\n#endif /* MAKECRCH */\n/*\n  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:\n  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n\n  Polynomials over GF(2) are represented in binary, one bit per coefficient,\n  with the lowest powers in the most significant bit.  Then adding polynomials\n  is just exclusive-or, and multiplying a polynomial by x is a right shift by\n  one.  If we call the above polynomial p, and represent a byte as the\n  polynomial q, also with the lowest power in the most significant bit (so the\n  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,\n  where a mod b means the remainder after dividing a by b.\n\n  This calculation is done using the shift-register method of multiplying and\n  taking the remainder.  The register is initialized to zero, and for each\n  incoming bit, x^32 is added mod p to the register if the bit is a one (where\n  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by\n  x (which is shifting right by one and adding x^32 mod p if the bit shifted\n  out is a one).  We start with the highest power (least significant bit) of\n  q and repeat for all eight bits of q.\n\n  The first table is simply the CRC of all possible eight bit values.  This is\n  all the information needed to generate CRCs on data a byte at a time for all\n  combinations of CRC register values and incoming bytes.  The remaining tables\n  allow for word-at-a-time CRC calculation for both big-endian and little-\n  endian machines, where a word is four bytes.\n*/\nlocal void make_crc_table()\n{\n    unsigned long c;\n    int n, k;\n    unsigned long poly;                 /* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n    static volatile int first = 1;      /* flag to limit concurrent making */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n    /* See if another task is already doing this (not thread-safe, but better\n       than nothing -- significantly reduces duration of vulnerability in\n       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n    if (first) {\n        first = 0;\n\n        /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n        poly = 0UL;\n        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n            poly |= 1UL << (31 - p[n]);\n\n        /* generate a crc for every 8-bit value */\n        for (n = 0; n < 256; n++) {\n            c = (unsigned long)n;\n            for (k = 0; k < 8; k++)\n                c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n            crc_table[0][n] = c;\n        }\n\n#ifdef BYFOUR\n        /* generate crc for each value followed by one, two, and three zeros,\n           and then the byte reversal of those as well as the first table */\n        for (n = 0; n < 256; n++) {\n            c = crc_table[0][n];\n            crc_table[4][n] = REV(c);\n            for (k = 1; k < 4; k++) {\n                c = crc_table[0][c & 0xff] ^ (c >> 8);\n                crc_table[k][n] = c;\n                crc_table[k + 4][n] = REV(c);\n            }\n        }\n#endif /* BYFOUR */\n\n        crc_table_empty = 0;\n    }\n    else {      /* not first */\n        /* wait for the other guy to finish (not efficient, but rare) */\n        while (crc_table_empty)\n            ;\n    }\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const unsigned long FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}\n\n#ifdef MAKECRCH\nlocal void write_table(out, table)\n    FILE *out;\n    const unsigned long FAR *table;\n{\n    int n;\n\n    for (n = 0; n < 256; n++)\n        fprintf(out, \"%s0x%08lxUL%s\", n % 5 ? \"\" : \"    \", table[n],\n                n == 255 ? \"\\n\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n}\n#endif /* MAKECRCH */\n\n#else /* !DYNAMIC_CRC_TABLE */\n/* ========================================================================\n * Tables of CRC-32s of all single-byte values, made by make_crc_table().\n */\n#include \"crc32.h\"\n#endif /* DYNAMIC_CRC_TABLE */\n\n/* =========================================================================\n * This function can be used by asm versions of crc32()\n */\nconst unsigned long FAR * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n        make_crc_table();\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const unsigned long FAR *)crc_table;\n}\n\n/* ========================================================================= */\n#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)\n#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1\n\n/* ========================================================================= */\nunsigned long ZEXPORT crc32(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    uInt len;\n{\n    if (buf == Z_NULL) return 0UL;\n\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n        make_crc_table();\n#endif /* DYNAMIC_CRC_TABLE */\n\n#ifdef BYFOUR\n    if (sizeof(void *) == sizeof(ptrdiff_t)) {\n        u4 endian;\n\n        endian = 1;\n        if (*((unsigned char *)(&endian)))\n            return crc32_little(crc, buf, len);\n        else\n            return crc32_big(crc, buf, len);\n    }\n#endif /* BYFOUR */\n    crc = crc ^ 0xffffffffUL;\n    while (len >= 8) {\n        DO8;\n        len -= 8;\n    }\n    if (len) do {\n        DO1;\n    } while (--len);\n    return crc ^ 0xffffffffUL;\n}\n\n#ifdef BYFOUR\n\n/* ========================================================================= */\n#define DOLIT4 c ^= *buf4++; \\\n        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \\\n            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]\n#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4\n\n/* ========================================================================= */\nlocal unsigned long crc32_little(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register u4 c;\n    register const u4 FAR *buf4;\n\n    c = (u4)crc;\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);\n        len--;\n    }\n\n    buf4 = (const u4 FAR *)(const void FAR *)buf;\n    while (len >= 32) {\n        DOLIT32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOLIT4;\n        len -= 4;\n    }\n    buf = (const unsigned char FAR *)buf4;\n\n    if (len) do {\n        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)c;\n}\n\n/* ========================================================================= */\n#define DOBIG4 c ^= *++buf4; \\\n        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \\\n            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]\n#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4\n\n/* ========================================================================= */\nlocal unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register u4 c;\n    register const u4 FAR *buf4;\n\n    c = REV((u4)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n    }\n\n    buf4 = (const u4 FAR *)(const void FAR *)buf;\n    buf4--;\n    while (len >= 32) {\n        DOBIG32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOBIG4;\n        len -= 4;\n    }\n    buf4++;\n    buf = (const unsigned char FAR *)buf4;\n\n    if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(REV(c));\n}\n\n#endif /* BYFOUR */\n\n#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */\n\n/* ========================================================================= */\nlocal unsigned long gf2_matrix_times(mat, vec)\n    unsigned long *mat;\n    unsigned long vec;\n{\n    unsigned long sum;\n\n    sum = 0;\n    while (vec) {\n        if (vec & 1)\n            sum ^= *mat;\n        vec >>= 1;\n        mat++;\n    }\n    return sum;\n}\n\n/* ========================================================================= */\nlocal void gf2_matrix_square(square, mat)\n    unsigned long *square;\n    unsigned long *mat;\n{\n    int n;\n\n    for (n = 0; n < GF2_DIM; n++)\n        square[n] = gf2_matrix_times(mat, mat[n]);\n}\n\n/* ========================================================================= */\nlocal uLong crc32_combine_(crc1, crc2, len2)\n    uLong crc1;\n    uLong crc2;\n    z_off64_t len2;\n{\n    int n;\n    unsigned long row;\n    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */\n    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */\n\n    /* degenerate case (also disallow negative lengths) */\n    if (len2 <= 0)\n        return crc1;\n\n    /* put operator for one zero bit in odd */\n    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */\n    row = 1;\n    for (n = 1; n < GF2_DIM; n++) {\n        odd[n] = row;\n        row <<= 1;\n    }\n\n    /* put operator for two zero bits in even */\n    gf2_matrix_square(even, odd);\n\n    /* put operator for four zero bits in odd */\n    gf2_matrix_square(odd, even);\n\n    /* apply len2 zeros to crc1 (first square will put the operator for one\n       zero byte, eight zero bits, in even) */\n    do {\n        /* apply zeros operator for this bit of len2 */\n        gf2_matrix_square(even, odd);\n        if (len2 & 1)\n            crc1 = gf2_matrix_times(even, crc1);\n        len2 >>= 1;\n\n        /* if no more bits set, then done */\n        if (len2 == 0)\n            break;\n\n        /* another iteration of the loop with odd and even swapped */\n        gf2_matrix_square(odd, even);\n        if (len2 & 1)\n            crc1 = gf2_matrix_times(odd, crc1);\n        len2 >>= 1;\n\n        /* if no more bits set, then done */\n    } while (len2 != 0);\n\n    /* return combined crc */\n    crc1 ^= crc2;\n    return crc1;\n}\n\n/* ========================================================================= */\nuLong ZEXPORT crc32_combine(crc1, crc2, len2)\n    uLong crc1;\n    uLong crc2;\n    z_off_t len2;\n{\n    return crc32_combine_(crc1, crc2, len2);\n}\n\nuLong ZEXPORT crc32_combine64(crc1, crc2, len2)\n    uLong crc1;\n    uLong crc2;\n    z_off64_t len2;\n{\n    return crc32_combine_(crc1, crc2, len2);\n}\n","/* inflate.c -- zlib decompression\n * Copyright (C) 1995-2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n * Change history:\n *\n * 1.2.beta0    24 Nov 2002\n * - First version -- complete rewrite of inflate to simplify code, avoid\n *   creation of window when not needed, minimize use of window when it is\n *   needed, make inffast.c even faster, implement gzip decoding, and to\n *   improve code readability and style over the previous zlib inflate code\n *\n * 1.2.beta1    25 Nov 2002\n * - Use pointers for available input and output checking in inffast.c\n * - Remove input and output counters in inffast.c\n * - Change inffast.c entry and loop from avail_in >= 7 to >= 6\n * - Remove unnecessary second byte pull from length extra in inffast.c\n * - Unroll direct copy to three copies per loop in inffast.c\n *\n * 1.2.beta2    4 Dec 2002\n * - Change external routine names to reduce potential conflicts\n * - Correct filename to inffixed.h for fixed tables in inflate.c\n * - Make hbuf[] unsigned char to match parameter type in inflate.c\n * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)\n *   to avoid negation problem on Alphas (64 bit) in inflate.c\n *\n * 1.2.beta3    22 Dec 2002\n * - Add comments on state->bits assertion in inffast.c\n * - Add comments on op field in inftrees.h\n * - Fix bug in reuse of allocated window after inflateReset()\n * - Remove bit fields--back to byte structure for speed\n * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths\n * - Change post-increments to pre-increments in inflate_fast(), PPC biased?\n * - Add compile time option, POSTINC, to use post-increments instead (Intel?)\n * - Make MATCH copy in inflate() much faster for when inflate_fast() not used\n * - Use local copies of stream next and avail values, as well as local bit\n *   buffer and bit count in inflate()--for speed when inflate_fast() not used\n *\n * 1.2.beta4    1 Jan 2003\n * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings\n * - Move a comment on output buffer sizes from inffast.c to inflate.c\n * - Add comments in inffast.c to introduce the inflate_fast() routine\n * - Rearrange window copies in inflate_fast() for speed and simplification\n * - Unroll last copy for window match in inflate_fast()\n * - Use local copies of window variables in inflate_fast() for speed\n * - Pull out common wnext == 0 case for speed in inflate_fast()\n * - Make op and len in inflate_fast() unsigned for consistency\n * - Add FAR to lcode and dcode declarations in inflate_fast()\n * - Simplified bad distance check in inflate_fast()\n * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new\n *   source file infback.c to provide a call-back interface to inflate for\n *   programs like gzip and unzip -- uses window as output buffer to avoid\n *   window copying\n *\n * 1.2.beta5    1 Jan 2003\n * - Improved inflateBack() interface to allow the caller to provide initial\n *   input in strm.\n * - Fixed stored blocks bug in inflateBack()\n *\n * 1.2.beta6    4 Jan 2003\n * - Added comments in inffast.c on effectiveness of POSTINC\n * - Typecasting all around to reduce compiler warnings\n * - Changed loops from while (1) or do {} while (1) to for (;;), again to\n *   make compilers happy\n * - Changed type of window in inflateBackInit() to unsigned char *\n *\n * 1.2.beta7    27 Jan 2003\n * - Changed many types to unsigned or unsigned short to avoid warnings\n * - Added inflateCopy() function\n *\n * 1.2.0        9 Mar 2003\n * - Changed inflateBack() interface to provide separate opaque descriptors\n *   for the in() and out() functions\n * - Changed inflateBack() argument and in_func typedef to swap the length\n *   and buffer address return values for the input function\n * - Check next_in and next_out for Z_NULL on entry to inflate()\n *\n * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n\n#ifdef MAKEFIXED\n#  ifndef BUILDFIXED\n#    define BUILDFIXED\n#  endif\n#endif\n\n/* function prototypes */\nlocal void fixedtables OF((struct inflate_state FAR *state));\nlocal int updatewindow OF((z_streamp strm, unsigned out));\n#ifdef BUILDFIXED\n   void makefixed OF((void));\n#endif\nlocal unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,\n                              unsigned len));\n\nint ZEXPORT inflateReset(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    strm->total_in = strm->total_out = state->total = 0;\n    strm->msg = Z_NULL;\n    strm->adler = 1;        /* to support ill-conceived Java test suite */\n    state->mode = HEAD;\n    state->last = 0;\n    state->havedict = 0;\n    state->dmax = 32768U;\n    state->head = Z_NULL;\n    state->wsize = 0;\n    state->whave = 0;\n    state->wnext = 0;\n    state->hold = 0;\n    state->bits = 0;\n    state->lencode = state->distcode = state->next = state->codes;\n    state->sane = 1;\n    state->back = -1;\n    Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\n\nint ZEXPORT inflateReset2(strm, windowBits)\nz_streamp strm;\nint windowBits;\n{\n    int wrap;\n    struct inflate_state FAR *state;\n\n    /* get the state */\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* extract wrap request from windowBits parameter */\n    if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    }\n    else {\n        wrap = (windowBits >> 4) + 1;\n#ifdef GUNZIP\n        if (windowBits < 48)\n            windowBits &= 15;\n#endif\n    }\n\n    /* set number of window bits, free window if different */\n    if (windowBits && (windowBits < 8 || windowBits > 15))\n        return Z_STREAM_ERROR;\n    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {\n        ZFREE(strm, state->window);\n        state->window = Z_NULL;\n    }\n\n    /* update state and reset the rest of it */\n    state->wrap = wrap;\n    state->wbits = (unsigned)windowBits;\n    return inflateReset(strm);\n}\n\nint ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)\nz_streamp strm;\nint windowBits;\nconst char *version;\nint stream_size;\n{\n    int ret;\n    struct inflate_state FAR *state;\n\n    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n        stream_size != (int)(sizeof(z_stream)))\n        return Z_VERSION_ERROR;\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n    strm->msg = Z_NULL;                 /* in case we return an error */\n    if (strm->zalloc == (alloc_func)0) {\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n    }\n    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n    state = (struct inflate_state FAR *)\n            ZALLOC(strm, 1, sizeof(struct inflate_state));\n    if (state == Z_NULL) return Z_MEM_ERROR;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n    strm->state = (struct internal_state FAR *)state;\n    state->window = Z_NULL;\n    ret = inflateReset2(strm, windowBits);\n    if (ret != Z_OK) {\n        ZFREE(strm, state);\n        strm->state = Z_NULL;\n    }\n    return ret;\n}\n\nint ZEXPORT inflateInit_(strm, version, stream_size)\nz_streamp strm;\nconst char *version;\nint stream_size;\n{\n    return inflateInit2_(strm, DEF_WBITS, version, stream_size);\n}\n\nint ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}\n\n/*\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n   If BUILDFIXED is defined, then instead this routine builds the tables the\n   first time it's called, and returns those tables the first time and\n   thereafter.  This reduces the size of the code by about 2K bytes, in\n   exchange for a little execution time.  However, BUILDFIXED should not be\n   used for threaded applications, since the rewriting of the tables and virgin\n   may not be thread-safe.\n */\nlocal void fixedtables(state)\nstruct inflate_state FAR *state;\n{\n#ifdef BUILDFIXED\n    static int virgin = 1;\n    static code *lenfix, *distfix;\n    static code fixed[544];\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        unsigned sym, bits;\n        static code *next;\n\n        /* literal/length table */\n        sym = 0;\n        while (sym < 144) state->lens[sym++] = 8;\n        while (sym < 256) state->lens[sym++] = 9;\n        while (sym < 280) state->lens[sym++] = 7;\n        while (sym < 288) state->lens[sym++] = 8;\n        next = fixed;\n        lenfix = next;\n        bits = 9;\n        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n\n        /* distance table */\n        sym = 0;\n        while (sym < 32) state->lens[sym++] = 5;\n        distfix = next;\n        bits = 5;\n        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n\n        /* do this just once */\n        virgin = 0;\n    }\n#else /* !BUILDFIXED */\n#   include \"inffixed.h\"\n#endif /* BUILDFIXED */\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}\n\n#ifdef MAKEFIXED\n#include <stdio.h>\n\n/*\n   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also\n   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes\n   those tables to stdout, which would be piped to inffixed.h.  A small program\n   can simply call makefixed to do this:\n\n    void makefixed(void);\n\n    int main(void)\n    {\n        makefixed();\n        return 0;\n    }\n\n   Then that can be linked with zlib built with MAKEFIXED defined and run:\n\n    a.out > inffixed.h\n */\nvoid makefixed()\n{\n    unsigned low, size;\n    struct inflate_state state;\n\n    fixedtables(&state);\n    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n    puts(\"     * Generated automatically by makefixed().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 7) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.lencode[low].op, state.lencode[low].bits,\n               state.lencode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n               state.distcode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}\n#endif /* MAKEFIXED */\n\n/*\n   Update the window with the last wsize (normally 32K) bytes written before\n   returning.  If window does not exist yet, create it.  This is only called\n   when a window is already in use, or when output has been written during this\n   inflate call, but the end of the deflate stream has not been reached yet.\n   It is also called to create a window for dictionary data when a dictionary\n   is loaded.\n\n   Providing output buffers larger than 32K to inflate() should provide a speed\n   advantage, since only the last 32K of output is copied to the sliding window\n   upon return from inflate(), and since all distances after the first 32K of\n   output will fall in the output data, making match copies simpler and faster.\n   The advantage may be dependent on the size of the processor's data caches.\n */\nlocal int updatewindow(strm, out)\nz_streamp strm;\nunsigned out;\n{\n    struct inflate_state FAR *state;\n    unsigned copy, dist;\n\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* if it hasn't been done already, allocate space for the window */\n    if (state->window == Z_NULL) {\n        state->window = (unsigned char FAR *)\n                        ZALLOC(strm, 1U << state->wbits,\n                               sizeof(unsigned char));\n        if (state->window == Z_NULL) return 1;\n    }\n\n    /* if window not in use yet, initialize */\n    if (state->wsize == 0) {\n        state->wsize = 1U << state->wbits;\n        state->wnext = 0;\n        state->whave = 0;\n    }\n\n    /* copy state->wsize or less output bytes into the circular window */\n    copy = out - strm->avail_out;\n    if (copy >= state->wsize) {\n        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);\n        state->wnext = 0;\n        state->whave = state->wsize;\n    }\n    else {\n        dist = state->wsize - state->wnext;\n        if (dist > copy) dist = copy;\n        zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);\n        copy -= dist;\n        if (copy) {\n            zmemcpy(state->window, strm->next_out - copy, copy);\n            state->wnext = copy;\n            state->whave = state->wsize;\n        }\n        else {\n            state->wnext += dist;\n            if (state->wnext == state->wsize) state->wnext = 0;\n            if (state->whave < state->wsize) state->whave += dist;\n        }\n    }\n    return 0;\n}\n\n/* Macros for inflate(): */\n\n/* check function to use adler32() for zlib or crc32() for gzip */\n#ifdef GUNZIP\n#  define UPDATE(check, buf, len) \\\n    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))\n#else\n#  define UPDATE(check, buf, len) adler32(check, buf, len)\n#endif\n\n/* check macros for header crc */\n#ifdef GUNZIP\n#  define CRC2(check, word) \\\n    do { \\\n        hbuf[0] = (unsigned char)(word); \\\n        hbuf[1] = (unsigned char)((word) >> 8); \\\n        check = crc32(check, hbuf, 2); \\\n    } while (0)\n\n#  define CRC4(check, word) \\\n    do { \\\n        hbuf[0] = (unsigned char)(word); \\\n        hbuf[1] = (unsigned char)((word) >> 8); \\\n        hbuf[2] = (unsigned char)((word) >> 16); \\\n        hbuf[3] = (unsigned char)((word) >> 24); \\\n        check = crc32(check, hbuf, 4); \\\n    } while (0)\n#endif\n\n/* Load registers with state in inflate() for speed */\n#define LOAD() \\\n    do { \\\n        put = strm->next_out; \\\n        left = strm->avail_out; \\\n        next = strm->next_in; \\\n        have = strm->avail_in; \\\n        hold = state->hold; \\\n        bits = state->bits; \\\n    } while (0)\n\n/* Restore state from registers in inflate() */\n#define RESTORE() \\\n    do { \\\n        strm->next_out = put; \\\n        strm->avail_out = left; \\\n        strm->next_in = next; \\\n        strm->avail_in = have; \\\n        state->hold = hold; \\\n        state->bits = bits; \\\n    } while (0)\n\n/* Clear the input bit accumulator */\n#define INITBITS() \\\n    do { \\\n        hold = 0; \\\n        bits = 0; \\\n    } while (0)\n\n/* Get a byte of input into the bit accumulator, or return from inflate()\n   if there is no input available. */\n#define PULLBYTE() \\\n    do { \\\n        if (have == 0) goto inf_leave; \\\n        have--; \\\n        hold += (unsigned long)(*next++) << bits; \\\n        bits += 8; \\\n    } while (0)\n\n/* Assure that there are at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflate(). */\n#define NEEDBITS(n) \\\n    do { \\\n        while (bits < (unsigned)(n)) \\\n            PULLBYTE(); \\\n    } while (0)\n\n/* Return the low n bits of the bit accumulator (n < 16) */\n#define BITS(n) \\\n    ((unsigned)hold & ((1U << (n)) - 1))\n\n/* Remove n bits from the bit accumulator */\n#define DROPBITS(n) \\\n    do { \\\n        hold >>= (n); \\\n        bits -= (unsigned)(n); \\\n    } while (0)\n\n/* Remove zero to seven bits as needed to go to a byte boundary */\n#define BYTEBITS() \\\n    do { \\\n        hold >>= bits & 7; \\\n        bits -= bits & 7; \\\n    } while (0)\n\n/* Reverse the bytes in a 32-bit value */\n#define REVERSE(q) \\\n    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \\\n     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))\n\n/*\n   inflate() uses a state machine to process as much input data and generate as\n   much output data as possible before returning.  The state machine is\n   structured roughly as follows:\n\n    for (;;) switch (state) {\n    ...\n    case STATEn:\n        if (not enough input data or output space to make progress)\n            return;\n        ... make progress ...\n        state = STATEm;\n        break;\n    ...\n    }\n\n   so when inflate() is called again, the same case is attempted again, and\n   if the appropriate resources are provided, the machine proceeds to the\n   next state.  The NEEDBITS() macro is usually the way the state evaluates\n   whether it can proceed or should return.  NEEDBITS() does the return if\n   the requested bits are not available.  The typical use of the BITS macros\n   is:\n\n        NEEDBITS(n);\n        ... do something with BITS(n) ...\n        DROPBITS(n);\n\n   where NEEDBITS(n) either returns from inflate() if there isn't enough\n   input left to load n bits into the accumulator, or it continues.  BITS(n)\n   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops\n   the low n bits off the accumulator.  INITBITS() clears the accumulator\n   and sets the number of available bits to zero.  BYTEBITS() discards just\n   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()\n   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.\n\n   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return\n   if there is no input available.  The decoding of variable length codes uses\n   PULLBYTE() directly in order to pull just enough bytes to decode the next\n   code, and no more.\n\n   Some states loop until they get enough input, making sure that enough\n   state information is maintained to continue the loop where it left off\n   if NEEDBITS() returns in the loop.  For example, want, need, and keep\n   would all have to actually be part of the saved state in case NEEDBITS()\n   returns:\n\n    case STATEw:\n        while (want < need) {\n            NEEDBITS(n);\n            keep[want++] = BITS(n);\n            DROPBITS(n);\n        }\n        state = STATEx;\n    case STATEx:\n\n   As shown above, if the next state is also the next case, then the break\n   is omitted.\n\n   A state may also return if there is not enough output space available to\n   complete that state.  Those states are copying stored data, writing a\n   literal byte, and copying a matching string.\n\n   When returning, a \"goto inf_leave\" is used to update the total counters,\n   update the check value, and determine whether any progress has been made\n   during that inflate() call in order to return the proper return code.\n   Progress is defined as a change in either strm->avail_in or strm->avail_out.\n   When there is a window, goto inf_leave will update the window with the last\n   output written.  If a goto inf_leave occurs in the middle of decompression\n   and there is no window currently, goto inf_leave will create one and copy\n   output to the window for the next call of inflate().\n\n   In this implementation, the flush parameter of inflate() only affects the\n   return code (per zlib.h).  inflate() always writes as much as possible to\n   strm->next_out, given the space available and the provided input--the effect\n   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers\n   the allocation of and copying into a sliding window until necessary, which\n   provides the effect documented in zlib.h for Z_FINISH when the entire input\n   stream available.  So the only thing the flush parameter actually does is:\n   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it\n   will return Z_BUF_ERROR if it has not reached the end of the stream.\n */\n\nint ZEXPORT inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            state->flags = 0;           /* expect zlib header */\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            else if (len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if (state->flags & 0x0200) CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if (state->flags & 0x0200) CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if (state->flags & 0x0200) CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if (state->flags & 0x0200) CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if (state->flags & 0x0200)\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = len;\n                } while (len && copy < have);\n                if (state->flags & 0x0200)\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = len;\n                } while (len && copy < have);\n                if (state->flags & 0x0200)\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if (hold != (state->check & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = REVERSE(hold);\n            INITBITS();\n            state->mode = DICT;\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n        case COPY_:\n            state->mode = COPY;\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (code const FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    NEEDBITS(here.bits);\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (code const FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (code const FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n        case LEN_:\n            state->mode = LEN;\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if (out)\n                    strm->adler = state->check =\n                        UPDATE(state->check, put - out, out);\n                out = left;\n                if ((\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     REVERSE(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if (hold != (state->total & 0xffffffffUL)) {\n                    strm->msg = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))\n        if (updatewindow(strm, out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if (state->wrap && out)\n        strm->adler = state->check =\n            UPDATE(state->check, strm->next_out - out, out);\n    strm->data_type = state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}\n\nint ZEXPORT inflateEnd(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->window != Z_NULL) ZFREE(strm, state->window);\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}\n\nint ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)\nz_streamp strm;\nconst Bytef *dictionary;\nuInt dictLength;\n{\n    struct inflate_state FAR *state;\n    unsigned long id;\n\n    /* check state */\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->wrap != 0 && state->mode != DICT)\n        return Z_STREAM_ERROR;\n\n    /* check for correct dictionary id */\n    if (state->mode == DICT) {\n        id = adler32(0L, Z_NULL, 0);\n        id = adler32(id, dictionary, dictLength);\n        if (id != state->check)\n            return Z_DATA_ERROR;\n    }\n\n    /* copy dictionary to window */\n    if (updatewindow(strm, strm->avail_out)) {\n        state->mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    if (dictLength > state->wsize) {\n        zmemcpy(state->window, dictionary + dictLength - state->wsize,\n                state->wsize);\n        state->whave = state->wsize;\n    }\n    else {\n        zmemcpy(state->window + state->wsize - dictLength, dictionary,\n                dictLength);\n        state->whave = dictLength;\n    }\n    state->havedict = 1;\n    Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\n\nint ZEXPORT inflateGetHeader(strm, head)\nz_streamp strm;\ngz_headerp head;\n{\n    struct inflate_state FAR *state;\n\n    /* check state */\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;\n\n    /* save header structure */\n    state->head = head;\n    head->done = 0;\n    return Z_OK;\n}\n\n/*\n   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n   or when out of input.  When called, *have is the number of pattern bytes\n   found in order so far, in 0..3.  On return *have is updated to the new\n   state.  If on return *have equals four, then the pattern was found and the\n   return value is how many bytes were read including the last byte of the\n   pattern.  If *have is less than four, then the pattern has not been found\n   yet and the return value is len.  In the latter case, syncsearch() can be\n   called again with more data and the *have state.  *have is initialized to\n   zero for the first call.\n */\nlocal unsigned syncsearch(have, buf, len)\nunsigned FAR *have;\nunsigned char FAR *buf;\nunsigned len;\n{\n    unsigned got;\n    unsigned next;\n\n    got = *have;\n    next = 0;\n    while (next < len && got < 4) {\n        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))\n            got++;\n        else if (buf[next])\n            got = 0;\n        else\n            got = 4 - got;\n        next++;\n    }\n    *have = got;\n    return next;\n}\n\nint ZEXPORT inflateSync(strm)\nz_streamp strm;\n{\n    unsigned len;               /* number of bytes to look at or looked at */\n    unsigned long in, out;      /* temporary to save total_in and total_out */\n    unsigned char buf[4];       /* to restore bit buffer to byte string */\n    struct inflate_state FAR *state;\n\n    /* check parameters */\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;\n\n    /* if first time, start search in bit buffer */\n    if (state->mode != SYNC) {\n        state->mode = SYNC;\n        state->hold <<= state->bits & 7;\n        state->bits -= state->bits & 7;\n        len = 0;\n        while (state->bits >= 8) {\n            buf[len++] = (unsigned char)(state->hold);\n            state->hold >>= 8;\n            state->bits -= 8;\n        }\n        state->have = 0;\n        syncsearch(&(state->have), buf, len);\n    }\n\n    /* search available input */\n    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);\n    strm->avail_in -= len;\n    strm->next_in += len;\n    strm->total_in += len;\n\n    /* return no joy or set up to restart inflate() on a new block */\n    if (state->have != 4) return Z_DATA_ERROR;\n    in = strm->total_in;  out = strm->total_out;\n    inflateReset(strm);\n    strm->total_in = in;  strm->total_out = out;\n    state->mode = TYPE;\n    return Z_OK;\n}\n\n/*\n   Returns true if inflate is currently at the end of a block generated by\n   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n   implementation to provide an additional safety check. PPP uses\n   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored\n   block. When decompressing, PPP checks that at the end of input packet,\n   inflate is waiting for these length bytes.\n */\nint ZEXPORT inflateSyncPoint(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    return state->mode == STORED && state->bits == 0;\n}\n\nint ZEXPORT inflateCopy(dest, source)\nz_streamp dest;\nz_streamp source;\n{\n    struct inflate_state FAR *state;\n    struct inflate_state FAR *copy;\n    unsigned char FAR *window;\n    unsigned wsize;\n\n    /* check input */\n    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||\n        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)source->state;\n\n    /* allocate space */\n    copy = (struct inflate_state FAR *)\n           ZALLOC(source, 1, sizeof(struct inflate_state));\n    if (copy == Z_NULL) return Z_MEM_ERROR;\n    window = Z_NULL;\n    if (state->window != Z_NULL) {\n        window = (unsigned char FAR *)\n                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));\n        if (window == Z_NULL) {\n            ZFREE(source, copy);\n            return Z_MEM_ERROR;\n        }\n    }\n\n    /* copy state */\n    zmemcpy(dest, source, sizeof(z_stream));\n    zmemcpy(copy, state, sizeof(struct inflate_state));\n    if (state->lencode >= state->codes &&\n        state->lencode <= state->codes + ENOUGH - 1) {\n        copy->lencode = copy->codes + (state->lencode - state->codes);\n        copy->distcode = copy->codes + (state->distcode - state->codes);\n    }\n    copy->next = copy->codes + (state->next - state->codes);\n    if (window != Z_NULL) {\n        wsize = 1U << state->wbits;\n        zmemcpy(window, state->window, wsize);\n    }\n    copy->window = window;\n    dest->state = (struct internal_state FAR *)copy;\n    return Z_OK;\n}\n\nint ZEXPORT inflateUndermine(strm, subvert)\nz_streamp strm;\nint subvert;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    state->sane = !subvert;\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    return Z_OK;\n#else\n    state->sane = 1;\n    return Z_DATA_ERROR;\n#endif\n}\n\nlong ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}\n","/* inftrees.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\n#define MAXBITS 15\n\nconst char inflate_copyright[] =\n   \" inflate 1.2.5 Copyright 1995-2010 Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\n/*\n   Build a set of tables to decode the provided canonical Huffman code.\n   The code lengths are lens[0..codes-1].  The result starts at *table,\n   whose indices are 0..2^bits-1.  work is a writable array of at least\n   lens shorts, which is used as a work area.  type is the type of code\n   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n   on return points to the next available entry's address.  bits is the\n   requested root table index bits, and on return it is the actual root\n   table index bits.  It will differ if the request is greater than the\n   longest code or if it is less than the shortest code.\n */\nint ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\ncodetype type;\nunsigned short FAR *lens;\nunsigned codes;\ncode FAR * FAR *table;\nunsigned FAR *bits;\nunsigned short FAR *work;\n{\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n    code FAR *next;             /* next available space in table */\n    const unsigned short FAR *base;     /* base value table to use */\n    const unsigned short FAR *extra;    /* extra bits table to use */\n    int end;                    /* use base and extra for symbol > end */\n    unsigned short count[MAXBITS+1];    /* number of codes of each length */\n    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n    static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n    switch (type) {\n    case CODES:\n        base = extra = work;    /* dummy value--not used */\n        end = 19;\n        break;\n    case LENS:\n        base = lbase;\n        base -= 257;\n        extra = lext;\n        extra -= 257;\n        end = 256;\n        break;\n    default:            /* DISTS */\n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n\n    /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used >= ENOUGH_LENS) ||\n        (type == DISTS && used >= ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n    for (;;) {\n        /* create table entry */\n        here.bits = (unsigned char)(len - drop);\n        if ((int)(work[sym]) < end) {\n            here.op = (unsigned char)0;\n            here.val = work[sym];\n        }\n        else if ((int)(work[sym]) > end) {\n            here.op = (unsigned char)(extra[work[sym]]);\n            here.val = base[work[sym]];\n        }\n        else {\n            here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used >= ENOUGH_LENS) ||\n                (type == DISTS && used >= ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /*\n       Fill in rest of table for incomplete codes.  This loop is similar to the\n       loop above in incrementing huff for table indices.  It is assumed that\n       len is equal to curr + drop, so there is no loop needed to increment\n       through high index bits.  When the current sub-table is filled, the loop\n       drops back to the root table to fill in any remaining entries there.\n     */\n    here.op = (unsigned char)64;                /* invalid code marker */\n    here.bits = (unsigned char)(len - drop);\n    here.val = (unsigned short)0;\n    while (huff != 0) {\n        /* when done with sub-table, drop back to root table */\n        if (drop != 0 && (huff & mask) != low) {\n            drop = 0;\n            len = root;\n            next = *table;\n            here.bits = (unsigned char)len;\n        }\n\n        /* put invalid code marker in table */\n        next[huff >> drop] = here;\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n","/* inffast.c -- fast decoding\n * Copyright (C) 1995-2008, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n\n#ifndef ASMINF\n\n/* Allow machine dependent optimization for post-increment or pre-increment.\n   Based on testing to date,\n   Pre-increment preferred for:\n   - PowerPC G3 (Adler)\n   - MIPS R5000 (Randers-Pehrson)\n   Post-increment preferred for:\n   - none\n   No measurable difference:\n   - Pentium III (Anderson)\n   - M68060 (Nikl)\n */\n#ifdef POSTINC\n#  define OFF 0\n#  define PUP(a) *(a)++\n#else\n#  define OFF 1\n#  define PUP(a) *++(a)\n#endif\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state->mode == LEN\n        strm->avail_in >= 6\n        strm->avail_out >= 258\n        start >= strm->avail_out\n        state->bits < 8\n\n   On return, state->mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm->avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvoid ZLIB_INTERNAL inflate_fast(strm, start)\nz_streamp strm;\nunsigned start;         /* inflate()'s starting value for strm->avail_out */\n{\n    struct inflate_state FAR *state;\n    unsigned char FAR *in;      /* local strm->next_in */\n    unsigned char FAR *last;    /* while in < last, enough input available */\n    unsigned char FAR *out;     /* local strm->next_out */\n    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n    unsigned char FAR *end;     /* while out < end, enough space available */\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* maximum distance from zlib header */\n#endif\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n    unsigned long hold;         /* local strm->hold */\n    unsigned bits;              /* local strm->bits */\n    code const FAR *lcode;      /* local strm->lencode */\n    code const FAR *dcode;      /* local strm->distcode */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code here;                  /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned dist;              /* match distance */\n    unsigned char FAR *from;    /* where to copy match from */\n\n    /* copy state to local variables */\n    state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in - OFF;\n    last = in + (strm->avail_in - 5);\n    out = strm->next_out - OFF;\n    beg = out - (start - strm->avail_out);\n    end = out + (strm->avail_out - 257);\n#ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* decode literals and length/distances until end-of-block or not enough\n       input data or output space */\n    do {\n        if (bits < 15) {\n            hold += (unsigned long)(PUP(in)) << bits;\n            bits += 8;\n            hold += (unsigned long)(PUP(in)) << bits;\n            bits += 8;\n        }\n        here = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(here.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here.op);\n        if (op == 0) {                          /* literal */\n            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                    \"inflate:         literal '%c'\\n\" :\n                    \"inflate:         literal 0x%02x\\n\", here.val));\n            PUP(out) = (unsigned char)(here.val);\n        }\n        else if (op & 16) {                     /* length base */\n            len = (unsigned)(here.val);\n            op &= 15;                           /* number of extra bits */\n            if (op) {\n                if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                    bits += 8;\n                }\n                len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", len));\n            if (bits < 15) {\n                hold += (unsigned long)(PUP(in)) << bits;\n                bits += 8;\n                hold += (unsigned long)(PUP(in)) << bits;\n                bits += 8;\n            }\n            here = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(here.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here.op);\n            if (op & 16) {                      /* distance base */\n                dist = (unsigned)(here.val);\n                op &= 15;                       /* number of extra bits */\n                if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                    bits += 8;\n                    if (bits < op) {\n                        hold += (unsigned long)(PUP(in)) << bits;\n                        bits += 8;\n                    }\n                }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        if (len <= op - whave) {\n                            do {\n                                PUP(out) = 0;\n                            } while (--len);\n                            continue;\n                        }\n                        len -= op - whave;\n                        do {\n                            PUP(out) = 0;\n                        } while (--op > whave);\n                        if (op == 0) {\n                            from = out - dist;\n                            do {\n                                PUP(out) = PUP(from);\n                            } while (--len);\n                            continue;\n                        }\n#endif\n                    }\n                    from = window - OFF;\n                    if (wnext == 0) {           /* very common case */\n                        from += wsize - op;\n                        if (op < len) {         /* some from window */\n                            len -= op;\n                            do {\n                                PUP(out) = PUP(from);\n                            } while (--op);\n                            from = out - dist;  /* rest from output */\n                        }\n                    }\n                    else if (wnext < op) {      /* wrap around window */\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                        if (op < len) {         /* some from end of window */\n                            len -= op;\n                            do {\n                                PUP(out) = PUP(from);\n                            } while (--op);\n                            from = window - OFF;\n                            if (wnext < len) {  /* some from start of window */\n                                op = wnext;\n                                len -= op;\n                                do {\n                                    PUP(out) = PUP(from);\n                                } while (--op);\n                                from = out - dist;      /* rest from output */\n                            }\n                        }\n                    }\n                    else {                      /* contiguous in window */\n                        from += wnext - op;\n                        if (op < len) {         /* some from window */\n                            len -= op;\n                            do {\n                                PUP(out) = PUP(from);\n                            } while (--op);\n                            from = out - dist;  /* rest from output */\n                        }\n                    }\n                    while (len > 2) {\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        len -= 3;\n                    }\n                    if (len) {\n                        PUP(out) = PUP(from);\n                        if (len > 1)\n                            PUP(out) = PUP(from);\n                    }\n                }\n                else {\n                    from = out - dist;          /* copy direct from output */\n                    do {                        /* minimum length is three */\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        len -= 3;\n                    } while (len > 2);\n                    if (len) {\n                        PUP(out) = PUP(from);\n                        if (len > 1)\n                            PUP(out) = PUP(from);\n                    }\n                }\n            }\n            else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode[here.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode[here.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n    hold &= (1U << bits) - 1;\n\n    /* update state and return */\n    strm->next_in = in + OFF;\n    strm->next_out = out + OFF;\n    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n    strm->avail_out = (unsigned)(out < end ?\n                                 257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n\n/*\n   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):\n   - Using bit fields for code structure\n   - Different op definition to avoid & for extra bits (do & for table bits)\n   - Three separate decoding do-loops for direct, window, and wnext == 0\n   - Special case for distance > 1 copies to do overlapped load and store copy\n   - Explicit branch predictions (based on measured branch probabilities)\n   - Deferring match copy and interspersed it with decoding subsequent codes\n   - Swapping literal/length else\n   - Swapping window/direct else\n   - Larger unrolled copy loops (three is about right)\n   - Moving len -= 3 statement into middle of loop\n */\n\n#endif /* !ASMINF */\n","/* zutil.c -- target dependent utility functions for the compression library\n * Copyright (C) 1995-2005, 2010 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zutil.h\"\n\n#ifndef NO_DUMMY_DECL\nstruct internal_state      {int dummy;}; /* for buggy compilers */\n#endif\n\nconst char * const z_errmsg[10] = {\n\"need dictionary\",     /* Z_NEED_DICT       2  */\n\"stream end\",          /* Z_STREAM_END      1  */\n\"\",                    /* Z_OK              0  */\n\"file error\",          /* Z_ERRNO         (-1) */\n\"stream error\",        /* Z_STREAM_ERROR  (-2) */\n\"data error\",          /* Z_DATA_ERROR    (-3) */\n\"insufficient memory\", /* Z_MEM_ERROR     (-4) */\n\"buffer error\",        /* Z_BUF_ERROR     (-5) */\n\"incompatible version\",/* Z_VERSION_ERROR (-6) */\n\"\"};\n\n\nconst char * ZEXPORT zlibVersion()\n{\n    return ZLIB_VERSION;\n}\n\nuLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#else\n        flags += 1L << 24;\n#  ifdef NO_snprintf\n        flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}\n\n#ifdef DEBUG\n\n#  ifndef verbose\n#    define verbose 0\n#  endif\nint ZLIB_INTERNAL z_verbose = verbose;\n\nvoid ZLIB_INTERNAL z_error (m)\n    char *m;\n{\n    fprintf(stderr, \"%s\\n\", m);\n    exit(1);\n}\n#endif\n\n/* exported to allow conversion of error code to string for compress() and\n * uncompress()\n */\nconst char * ZEXPORT zError(err)\n    int err;\n{\n    return ERR_MSG(err);\n}\n\n#if defined(_WIN32_WCE)\n    /* The Microsoft C Run-Time Library for Windows CE doesn't have\n     * errno.  We define it as a global variable to simplify porting.\n     * Its value is always 0 and should not be used.\n     */\n    int errno = 0;\n#endif\n\n#ifndef HAVE_MEMCPY\n\nvoid ZLIB_INTERNAL zmemcpy(dest, source, len)\n    Bytef* dest;\n    const Bytef* source;\n    uInt  len;\n{\n    if (len == 0) return;\n    do {\n        *dest++ = *source++; /* ??? to be unrolled */\n    } while (--len != 0);\n}\n\nint ZLIB_INTERNAL zmemcmp(s1, s2, len)\n    const Bytef* s1;\n    const Bytef* s2;\n    uInt  len;\n{\n    uInt j;\n\n    for (j = 0; j < len; j++) {\n        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;\n    }\n    return 0;\n}\n\nvoid ZLIB_INTERNAL zmemzero(dest, len)\n    Bytef* dest;\n    uInt  len;\n{\n    if (len == 0) return;\n    do {\n        *dest++ = 0;  /* ??? to be unrolled */\n    } while (--len != 0);\n}\n#endif\n\n\n#ifdef SYS16BIT\n\n#ifdef __TURBOC__\n/* Turbo C in 16-bit mode */\n\n#  define MY_ZCALLOC\n\n/* Turbo C malloc() does not allow dynamic allocation of 64K bytes\n * and farmalloc(64K) returns a pointer with an offset of 8, so we\n * must fix the pointer. Warning: the pointer must be put back to its\n * original form in order to free it, use zcfree().\n */\n\n#define MAX_PTR 10\n/* 10*64K = 640K */\n\nlocal int next_ptr = 0;\n\ntypedef struct ptr_table_s {\n    voidpf org_ptr;\n    voidpf new_ptr;\n} ptr_table;\n\nlocal ptr_table table[MAX_PTR];\n/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n\nvoidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}\n\nvoid ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    Assert(0, \"zcfree: ptr not found\");\n}\n\n#endif /* __TURBOC__ */\n\n\n#ifdef M_I86\n/* Microsoft C in 16-bit mode */\n\n#  define MY_ZCALLOC\n\n#if (!defined(_MSC_VER) || (_MSC_VER <= 600))\n#  define _halloc  halloc\n#  define _hfree   hfree\n#endif\n\nvoidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}\n\nvoid ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n}\n\n#endif /* M_I86 */\n\n#endif /* SYS16BIT */\n\n\n#ifndef MY_ZCALLOC /* Any system without a special alloc function */\n\n#ifndef STDC\nextern voidp  malloc OF((uInt size));\nextern voidp  calloc OF((uInt items, uInt size));\nextern void   free   OF((voidpf ptr));\n#endif\n\nvoidpf ZLIB_INTERNAL zcalloc (opaque, items, size)\n    voidpf opaque;\n    unsigned items;\n    unsigned size;\n{\n    if (opaque) items += size - size; /* make compiler happy */\n    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :\n                              (voidpf)calloc(items, size);\n}\n\nvoid ZLIB_INTERNAL zcfree (opaque, ptr)\n    voidpf opaque;\n    voidpf ptr;\n{\n    free(ptr);\n    if (opaque) return; /* make compiler happy */\n}\n\n#endif /* MY_ZCALLOC */\n"]}